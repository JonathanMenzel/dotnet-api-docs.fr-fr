<Type Name="Form" FullName="System.Windows.Forms.Form">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f3fc084a02f774d87fefe2646b5cb5ad6cc9733" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659940" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <TypeSignature Language="VB.NET" Value="Public Class Form&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Form : System::Windows::Forms::ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une fenêtre ou une boîte de dialogue qui compose l'interface utilisateur d'une application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.Form> est une représentation de n’importe quelle fenêtre affichée dans votre application. La <xref:System.Windows.Forms.Form> classe peut être utilisée pour créer des fenêtres standard, outil, sans bord et flottants. Vous pouvez également utiliser la <xref:System.Windows.Forms.Form> classe pour créer des fenêtres modales comme une boîte de dialogue. Un type spécial de formulaire, le formulaire de l’interface multidocument (MDI), peut contenir d’autres formulaires appelés formulaires enfants MDI. Un formulaire MDI est créé en définissant le <xref:System.Windows.Forms.Form.IsMdiContainer%2A> propriété `true`. Formulaires MDI enfants sont créés en définissant le <xref:System.Windows.Forms.Form.MdiParent%2A> propriété au formulaire parent MDI qui contiendra le formulaire enfant.  
  
 À l’aide des propriétés disponibles dans le <xref:System.Windows.Forms.Form> (classe), vous pouvez déterminer les fonctionnalités de gestion apparence, la taille, couleur et fenêtre de la boîte de dialogue ou fenêtre vous créez. Le <xref:System.Windows.Forms.Control.Text%2A> propriété permet de spécifier la légende de la fenêtre de la barre de titre. Le <xref:System.Windows.Forms.Form.Size%2A> et <xref:System.Windows.Forms.Form.DesktopLocation%2A> propriétés permettent de définir la taille et la position de la fenêtre lorsqu’elle est affichée. Vous pouvez utiliser le <xref:System.Windows.Forms.Control.ForeColor%2A> propriété de couleur pour modifier la couleur de premier plan par défaut de tous les contrôles placés sur le formulaire. Le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, et <xref:System.Windows.Forms.Form.MaximizeBox%2A> propriétés vous permettent de contrôler si le formulaire peut être réduit, agrandi ou redimensionné au moment de l’exécution.  
  
 Outre les propriétés, vous pouvez utiliser les méthodes de la classe pour manipuler un formulaire. Par exemple, vous pouvez utiliser la <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher un formulaire comme une boîte de dialogue modale. Vous pouvez utiliser la <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> méthode pour positionner le formulaire sur le bureau.  
  
 Les événements de la <xref:System.Windows.Forms.Form> classe permettent de répondre aux actions effectuées sur le formulaire. Vous pouvez utiliser la <xref:System.Windows.Forms.Form.Activated> événement pour effectuer des opérations telles que la mise à jour les données affichées dans les contrôles du formulaire lorsque le formulaire est activé.  
  
 Vous pouvez utiliser un formulaire comme classe initiale dans votre application en plaçant une méthode appelée `Main` dans la classe. Dans la `Main` méthode ajouter du code pour créer et afficher le formulaire. Vous devrez également ajouter la `STAThread` attribut le `Main` méthode dans l’ordre exécuter le formulaire. Lorsque le formulaire initial est fermé, l’application est également fermée.  
  
 Si vous définissez la <xref:System.Windows.Forms.Control.Enabled%2A> propriété `false` avant la <xref:System.Windows.Forms.Form> est visible (par exemple, si <xref:System.Windows.Forms.Control.Enabled%2A> avec la valeur false dans le [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)] concepteur), le boutons réduire, agrandir, fermer et système reste activé. Si vous définissez <xref:System.Windows.Forms.Control.Enabled%2A> à `false` après le <xref:System.Windows.Forms.Form> est visible (par exemple, lorsque l’événement de chargement se produit), les boutons sont désactivés.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Form();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille par défaut d’un formulaire est de 300 pixels en hauteur et 300 pixels en largeur.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple définit également utilise le <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ AcceptButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le bouton du formulaire qui est activé lorsque l'utilisateur appuie sur la touche Entrée.</summary>
        <value>
          <see cref="T:System.Windows.Forms.IButtonControl" /> qui représente le bouton à utiliser comme bouton d'acceptation du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet de désigner une action par défaut se produit lorsque l’utilisateur appuie sur la touche entrée dans votre application. Le bouton assigné à cette propriété doit être un <xref:System.Windows.Forms.IButtonControl> qui se trouve sur le formulaire en cours ou qui se trouve dans un conteneur sur le formulaire actuel.  
  
 Vous pouvez utiliser cette propriété pour permettre à l’utilisateur de naviguer rapidement un formulaire simple en les autorisant à appuyez simplement sur la touche ENTRÉE lorsqu’ils ont terminé au lieu de manuellement en cliquant sur le bouton d’acceptation avec la souris.  
  
 Le bouton d’acceptation ne soient pas activé si le contrôle actuellement sélectionné sur le formulaire intercepte la touche entrée et le traite. Par exemple, un contrôle de zone de texte multiligne permet la touche entrée pour être activé lorsqu’il est sélectionné pour insérer un caractère de nouvelle ligne dans le contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.CancelButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Activate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Active le formulaire et lui donne le focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Activation d’un formulaire remet en devant s’il s’agit de l’application active, ou il fait clignoter la légende de fenêtre s’il ne s’agit pas de l’application active. Le formulaire doit être visible pour cette méthode en vigueur. Pour déterminer le formulaire actif dans une application, utilisez le <xref:System.Windows.Forms.Form.ActiveForm%2A> propriété ou le <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> propriété si vos formulaires se trouvent dans une application d’interface (multidocument MDI) Multiple-document.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> et <xref:System.Windows.Forms.Form.Activate%2A> membres. Pour exécuter l’exemple, collez le code suivant dans un formulaire nommé `Form1` contenant un bouton nommé `Button1` et deux `Label` contrôles appelés `Label1` et `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour changer le focus. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un formulaire est activé dans le code ou par l'utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Lorsque l’application est active et a plusieurs formulaires, le formulaire actif est le formulaire avec le focus d’entrée. Un formulaire qui n’est pas visible ne peut pas être le formulaire actif. La façon la plus simple pour activer un formulaire visible est de cliquer dessus ou utiliser une combinaison de touches appropriée.  
  
 Pour activer un formulaire au moment de l’exécution à l’aide de code, appelez le <xref:System.Windows.Forms.Form.Activate%2A> (méthode). Vous pouvez utiliser cet événement pour des tâches telles que la mise à jour le contenu du formulaire en fonction des modifications apportées aux données du formulaire lorsque le formulaire n’a pas été activé.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, et <xref:System.Windows.Forms.Form.Activate%2A> membres. Pour exécuter l’exemple, collez le code suivant dans un formulaire nommé Form1 contenant un <xref:System.Windows.Forms.Button> appelé `Button1` et deux <xref:System.Windows.Forms.Label> contrôles appelés `Label1` et `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ActivateMdiChild(System::Windows::Forms::Form ^ form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">Formulaire enfant à activer.</param>
        <summary>Active l'enfant MDI d'un formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `form` paramètre est déjà le formulaire enfant MDI actif, puis la <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> méthode retourne simplement. Si `form` n’est pas `null`, il est défini pour le formulaire enfant MDI active.  
  
 Si le `form` paramètre est `null` ou non, <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> déclenche le <xref:System.Windows.Forms.Form.MdiChildActivate> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ActiveForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Form ^ ActiveForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le formulaire actuellement actif pour cette application.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> représentant le formulaire actuellement actif, ou <see langword="null" /> si aucun formulaire n'est actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour obtenir une référence au formulaire actuellement actif pour effectuer des actions sur le formulaire ou ses contrôles.  
  
 Si votre application est une application de l’interface multidocument (MDI), utilisez le <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> propriété pour obtenir le formulaire enfant MDI actuellement actif.  
  
   
  
## Examples  
 L’exemple de code suivant obtient le formulaire actif et désactive tous les contrôles du formulaire. L’exemple utilise le <xref:System.Windows.Forms.Control.Controls%2A> collection du formulaire pour parcourir chaque contrôle sur le formulaire et désactiver les contrôles.  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour demander un formulaire. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveMdiChild As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ActiveMdiChild { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la fenêtre enfant MDI active.</summary>
        <value>Retourne un <see cref="T:System.Windows.Forms.Form" /> représentant la fenêtre MDI enfant active ou <see langword="null" /> si aucune fenêtre enfant active n'est détectée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour déterminer si tous les formulaires enfants MDI sont ouverts dans votre application MDI. Vous pouvez également utiliser cette méthode pour effectuer des opérations sur une fenêtre enfant MDI à partir de son formulaire MDI parent ou d’un autre formulaire qui s’affiche dans votre application.  
  
 Si le formulaire actuellement actif n’est pas un formulaire enfant MDI, vous pouvez utiliser le <xref:System.Windows.Forms.Form.ActiveForm%2A> propriété pour obtenir une référence à celui-ci.  
  
   
  
## Examples  
 L’exemple de code suivant obtient une référence au formulaire enfant MDI actif et effectue une boucle sur tous les <xref:System.Windows.Forms.TextBox> contrôles du formulaire, la réinitialisation de leurs <xref:System.Windows.Forms.TextBoxBase.Text%2A> propriétés. Cet exemple nécessite qu’un formulaire MDI parent a été créé et que cet appel de méthode est fait à partir du formulaire parent MDI.  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">
          <see cref="T:System.Windows.Forms.Form" /> qui va appartenir à ce formulaire.</param>
        <summary>Ajoute à ce formulaire un formulaire qu'il détient.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le formulaire assigné au formulaire propriétaire appartiendra jusqu'à ce que le <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> méthode est appelée. Vous pouvez également rendre un formulaire détenu par un autre en définissant le <xref:System.Windows.Forms.Form.Owner%2A> propriété avec une référence à son formulaire propriétaire.  
  
 Lorsqu’un formulaire est détenu par un autre formulaire, il est fermé ou masqué le formulaire propriétaire. Par exemple, considérez un formulaire nommé `Form2` qui appartient à un formulaire nommé `Form1`. Si `Form1` est fermé ou réduit, `Form2` est également fermé ou masqué. L’appartenance n’est jamais affichés derrière son propriétaire. Vous pouvez utiliser des formulaires détenus pour les fenêtres Rechercher et remplacer, qui ne doit pas être affiché derrière le formulaire propriétaire lorsque le formulaire propriétaire est sélectionné.  
  
> [!NOTE]
>  Si le formulaire est un formulaire parent de l’interface multidocument (MDI), cette propriété retourne tous les formulaires qui sont affichés à l’exception des formulaires enfants MDI qui sont actuellement ouverts. Pour obtenir les formulaires enfants MDI ouverts dans un formulaire MDI parent, utilisez la <xref:System.Windows.Forms.Form.MdiChildren%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser la <xref:System.Windows.Forms.Form.AddOwnedForm%2A> méthode pour afficher un formulaire comme un formulaire détenu d’un autre formulaire. Une fois ce formulaire est affiché, vous réduisez son formulaire propriétaire, le formulaire détenu sera également réduit. L’exemple requiert que le code dans l’exemple est appelé à partir d’un autre événement ou une méthode d’un formulaire.  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          <see langword="true" /> pour afficher les barres de défilement ; sinon, <see langword="false" />.</param>
        <summary>Ajuste les barres de défilement sur le conteneur en fonction des positions actuelles des contrôles et du contrôle sélectionné actuellement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'opacité du formulaire peut être ajustée.</summary>
        <value>
          <see langword="true" /> si l'opacité du formulaire peut être modifiée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est automatiquement définie sur `true` si la `Opacity` est modifiée. Lorsque l’opacité d’un formulaire est définie à l’aide de la `Opacity` propriété, le formulaire superpose des objets sur le formulaire. Si vous définissez la <xref:System.Windows.Forms.Form.AllowTransparency%2A> propriété `false` le formulaire ne sera pas en mode de superposition, afin d’améliore les performances d’affichage du formulaire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ApplyAutoScaling ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ApplyAutoScaling();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redimensionne le formulaire en fonction de la valeur actuelle de la propriété <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> et de la taille de la police actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine la taille de formulaire à l’aide de la valeur de la <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> propriété et la <xref:System.Windows.Forms.Form.Size%2A> valeur retournée par le <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScale As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoScale { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la taille du formulaire est ajustée en fonction de la hauteur de la police utilisée dans le formulaire et si ses contrôles sont redimensionnés en conséquence.</summary>
        <value>
          <see langword="true" /> si le formulaire, de même que ses contrôles, sont automatiquement redimensionnés suivant la police qui leur est actuellement assignée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Windows.Forms.Form.AutoScale%2A> est obsolète et a été conservée pour la compatibilité descendante. L'alternative non obsolète est <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>. Pour plus d’informations sur la mise à l’échelle automatique, consultez [mise à l’échelle automatique dans les Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Vous pouvez utiliser cette propriété pour permettre au formulaire et ses contrôles pour ajuster automatiquement en fonction des modifications de la police. Cela peut être utile dans les applications où la police peut augmenter ou diminuer en fonction de la langue spécifiée pour une utilisation par Windows.  
  
 Pour obtenir la taille du formulaire sera automatiquement mise à l’échelle à utiliser le <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> propriété. Si vous souhaitez déterminer la taille de la forme est automatiquement mettre à l’échelle en fonction d’une police spécifique, utilisez le <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScaleBaseSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size AutoScaleBaseSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de base pour la mise à l'échelle automatique du formulaire.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> qui représente la taille de base utilisée par ce formulaire pour sa mise à l'échelle automatique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Ce membre a été conservé pour la compatibilité descendante. Pour plus d’informations sur la mise à l’échelle automatique, consultez [mise à l’échelle automatique dans les Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 La valeur de la <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> propriété est utilisée au moment de l’affichage du formulaire pour calculer le facteur d’échelle pour le formulaire. La taille de base de l’échelle automatique est utilisée par le formulaire comme une ligne de base pour une comparaison avec la taille de police système pour déterminer quelle mise à l’échelle de l’écran lors de l’échelle automatique est utilisé. Si vous souhaitez déterminer la taille de formulaire sera automatiquement mettre à l’échelle en fonction d’une police spécifique, utilisez le <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> (méthode).  
  
> [!NOTE]
>  La valeur de cette propriété est utilisée lorsque le formulaire est initialement créé. Une fois que la propriété est définie, il ne peut pas être modifié.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le formulaire permet le défilement automatique.</summary>
        <value>
          <see langword="true" /> pour activer le défilement automatique sur le formulaire ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est définie sur `true`, barres de défilement sont affichées sur le formulaire si des contrôles sont situés en dehors de la zone du client du formulaire. En outre, lorsque le défilement automatique est activée, la zone cliente du formulaire défile automatiquement pour afficher le contrôle avec le focus d’entrée.  
  
 Vous pouvez utiliser cette propriété pour empêcher les utilisateurs de perdre la possibilité d’afficher des contrôles lorsque leurs paramètres de résolution vidéo sont définies pour une faible résolution.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.AutoScroll%2A> propriété pour activer l’affichage des contrôles situés en dehors de la zone cliente d’un formulaire. L’exemple crée un formulaire et ajoute un <xref:System.Windows.Forms.Button> contrôle au formulaire. Le <xref:System.Windows.Forms.Button> contrôle est placé en dehors de la zone cliente du nouveau formulaire. Le <xref:System.Windows.Forms.Form.AutoScroll%2A> est définie sur true pour afficher les barres de défilement sur le formulaire pour permettre à l’utilisateur de faire défiler vers le contrôle. Cet exemple requiert que la méthode définie dans cet exemple est appelée à partir d’un autre formulaire dans un gestionnaire d’événements ou l’autre méthode.  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Redimensionner le formulaire en fonction du paramètre de <see cref="P:System.Windows.Forms.Form.AutoSizeMode" />.</summary>
        <value>
          <see langword="true" /> si le redimensionnement du formulaire s'effectue automatiquement ; <see langword="false" /> si le redimensionnement doit s'effectuer manuellement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Windows.Forms.Form.AutoSize%2A> pour forcer un formulaire doit être redimensionné pour s’adapter à son contenu.  
  
 Un formulaire ne se redimensionne pas automatiquement dans le Concepteur de formulaires de Visual Studio, indépendamment des valeurs de la <xref:System.Windows.Forms.Form.AutoSize%2A> et <xref:System.Windows.Forms.Form.AutoSizeMode%2A> propriétés. Le formulaire correctement redimensionné au moment de l’exécution en fonction des valeurs de ces deux propriétés. En revanche, une personnalisée <xref:System.Windows.Forms.UserControl> est automatiquement redimensionné à la fois au moment du design et au moment de l’exécution.  
  
 Lorsque vous utilisez <xref:System.Windows.Forms.Form.AutoSize%2A>, le <xref:System.Windows.Forms.Control.MinimumSize%2A> et <xref:System.Windows.Forms.Control.MaximumSize%2A> propriétés sont respectées, mais la valeur actuelle de la <xref:System.Windows.Forms.Control.Size%2A> propriété est ignorée. À l’aide de <xref:System.Windows.Forms.Form.AutoSize%2A> et <xref:System.Windows.Forms.Form.AutoSizeMode%2A> rend également le <xref:System.Windows.Forms.Form.AutoScroll%2A> superflue, car il n’existe aucun moyen de réduire le formulaire pour masquer les contrôles de vue de la propriété.  
  
 Consultez le <xref:System.Windows.Forms.AutoSizeMode> énumération pour plus d’informations sur la façon dont un formulaire comporte quand <xref:System.Windows.Forms.Form.AutoSize%2A> est `true`.  
  
   
  
## Examples  
 L’exemple de code suivant montre un formulaire créé à l’aide de code qui se redimensionne automatiquement pour s’ajuster à son contenu. Lors de l’exécution, le formulaire affiche une <xref:System.Windows.Forms.Label>, un <xref:System.Windows.Forms.TextBox> pour la saisie d’une URL et un <xref:System.Windows.Forms.Button> pour l’affichage de cette URL dans le navigateur par défaut de l’utilisateur. L’exemple de code utilise un <xref:System.Windows.Forms.FlowLayoutPanel> pour disposer les contrôles les uns après l’autre. Il définit également la <xref:System.Windows.Forms.Control.AutoSize%2A> et <xref:System.Windows.Forms.AutoSizeMode> pour augmenter ou diminuer pour s’adapter au contenu du formulaire.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la propriété <see cref="P:System.Windows.Forms.Form.AutoSize" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSizeMode As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoSizeMode AutoSizeMode { System::Windows::Forms::AutoSizeMode get(); void set(System::Windows::Forms::AutoSizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode qui permet de redimensionner le formulaire automatiquement.</summary>
        <value>Valeur énumérée <see cref="T:System.Windows.Forms.AutoSizeMode" />. La valeur par défaut est <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de la <xref:System.Windows.Forms.Form.AutoSizeMode%2A> à une nouvelle valeur de propriété, le formulaire à la disposition.  
  
 Un formulaire ne se redimensionne pas automatiquement dans le Concepteur de formulaires de Visual Studio, indépendamment des valeurs de la <xref:System.Windows.Forms.Form.AutoSize%2A> et <xref:System.Windows.Forms.Form.AutoSizeMode%2A> propriétés. Le formulaire correctement redimensionné au moment de l’exécution en fonction des valeurs de ces deux propriétés. En revanche, une personnalisée <xref:System.Windows.Forms.UserControl> est automatiquement redimensionné à la fois au moment du design et au moment de l’exécution.  
  
   
  
## Examples  
 L’exemple de code suivant montre un formulaire créé à l’aide de code qui se redimensionne automatiquement pour s’ajuster à son contenu. Lorsque exécuté, le formulaire affiche une <xref:System.Windows.Forms.Label>, un <xref:System.Windows.Forms.TextBox> pour la saisie d’une URL et un <xref:System.Windows.Forms.Button> pour l’affichage de cette URL dans le navigateur par défaut de l’utilisateur. L’exemple de code utilise un <xref:System.Windows.Forms.FlowLayoutPanel> pour disposer les contrôles les uns après l’autre. Il définit également la <xref:System.Windows.Forms.Control.AutoSize%2A> et <xref:System.Windows.Forms.AutoSizeMode> pour augmenter ou diminuer pour s’adapter au contenu du formulaire.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur n'est pas une valeur <see cref="T:System.Windows.Forms.AutoSizeMode" /> valide.</exception>
        <altmember cref="T:System.Windows.Forms.AutoSizeMode" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les contrôles dans ce conteneur seront validés automatiquement quand le focus changera.</summary>
        <value>Valeur d’énumération <see cref="T:System.Windows.Forms.AutoValidate" /> qui indique si les contrôles contenus sont validés implicitement lors du changement de focus. La valeur par défaut est Inherit (Hériter).</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la propriété <see cref="P:System.Windows.Forms.Form.AutoValidate" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur d'arrière-plan du contrôle.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> qui représente la couleur d'arrière-plan du contrôle. La valeur par défaut est la valeur de la propriété <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberSignature Language="VB.NET" Value="Public Property CancelButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ CancelButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contrôle bouton qui est activé lorsque l'utilisateur appuie sur la touche Échap.</summary>
        <value>
          <see cref="T:System.Windows.Forms.IButtonControl" /> représentant le bouton d'annulation du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le bouton Annuler pour un formulaire est le contrôle de bouton qui est activé chaque fois que l’utilisateur appuie sur la touche ÉCHAP. Le bouton assigné à cette propriété doit être un <xref:System.Windows.Forms.IButtonControl> qui se trouve sur le formulaire en cours ou qui se trouve dans un conteneur sur le formulaire actuel.  
  
 Cette propriété vous permet de désigner une action par défaut se produit lorsque l’utilisateur appuie sur la touche ÉCHAP dans votre application. Vous pouvez utiliser cette propriété pour permettre à l’utilisateur de naviguer rapidement un formulaire simple en les autorisant à appuyez simplement sur la touche ÉCHAP pour fermer une fenêtre sans validation des modifications à la place manuellement en cliquant sur le bouton Annuler avec la souris.  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A> peut ne pas fonctionner si un autre contrôle sur le formulaire intercepte la touche ÉCHAP. Par exemple, si vous avez un <xref:System.Windows.Forms.ComboBox> ouvert sur votre formulaire, la touche ÉCHAP ferme le <xref:System.Windows.Forms.ComboBox> au lieu de fermer le formulaire.  
  
 Le <xref:System.Windows.Forms.IButtonControl> objet assigné à <xref:System.Windows.Forms.Form.CancelButton%2A> doit être visible sur le formulaire, ou bien en appuyant sur la touche ÉCHAP clé n’a aucun effet.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToParent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToParent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Centre la position du formulaire dans les limites du formulaire parent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’appelez pas la <xref:System.Windows.Forms.Form.CenterToParent%2A> (méthode) directement à partir de votre code. Au lieu de cela, définissez la <xref:System.Windows.Forms.Form.StartPosition%2A> propriété <xref:System.Windows.Forms.FormStartPosition.CenterParent>.  
  
 Si le formulaire ou la boîte de dialogue est de niveau supérieur, puis <xref:System.Windows.Forms.Form.CenterToParent%2A> Centre le formulaire par rapport à l’écran ou du bureau.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterParent" />
        <altmember cref="M:System.Windows.Forms.Form.CenterToScreen" />
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToScreen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Centre le formulaire sur l'écran actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ne l’appelez pas directement à partir de votre code. Au lieu de cela, définissez la <xref:System.Windows.Forms.Form.StartPosition%2A> propriété <xref:System.Windows.Forms.FormStartPosition.CenterScreen>.  
  
 Le <xref:System.Windows.Forms.Form.CenterToScreen%2A> méthode utilise la liste de priorité suivant pour déterminer l’écran utilisé pour centrer le formulaire :  
  
1.  Le <xref:System.Windows.Forms.Form.Owner%2A> propriété du formulaire.  
  
2.  Propriétaire HWND du formulaire.  
  
3.  L’écran qui possède actuellement le curseur de souris.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterScreen" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la zone cliente du formulaire.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> représentant la taille de la zone cliente du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de la zone cliente du formulaire est la taille du formulaire, hormis les bordures et la barre de titre. La zone cliente d’un formulaire est la zone d’où les contrôles peuvent être placés dans un formulaire. Vous pouvez utiliser cette propriété pour obtenir les dimensions correctes lorsque vous effectuez des opérations graphiques ou lors du dimensionnement et de positionnement des contrôles sur le formulaire. Pour obtenir la taille de l’intégralité du formulaire, utilisez le <xref:System.Windows.Forms.Form.Size%2A> propriété ou utiliser les propriétés individuelles <xref:System.Windows.Forms.Control.Height%2A> et <xref:System.Windows.Forms.Control.Width%2A>.  
  
> [!NOTE]
>  Vous ne pouvez pas lier actuellement à cette propriété à l’aide des paramètres de l’application. Pour plus d’informations sur les paramètres de l’application, consultez [vue d’ensemble des paramètres d’Application](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un gestionnaire d’événements pour le <xref:System.Windows.Forms.Control.Resize> événement d’un formulaire. Le Gestionnaire d’événements utilise le <xref:System.Windows.Forms.Form.ClientSize%2A> propriété du formulaire afin de rendre un <xref:System.Windows.Forms.Button> contrôle nommé `button1` remplir la zone cliente du formulaire.  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un formulaire est fermé, toutes les ressources créées au sein de l’objet sont fermés, et le formulaire est supprimé. Vous pouvez empêcher la fermeture d’un formulaire au moment de l’exécution en gérant la <xref:System.Windows.Forms.Form.Closing> événement et en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> passé en tant que paramètre à votre gestionnaire d’événements. Si le formulaire que vous fermez est le formulaire de démarrage de votre application, votre application se termine.  
  
 Deux situations dans lesquelles un formulaire n’est pas supprimé sur `Close` est lorsque (1) il fait partie d’une application de l’interface multidocument (MDI) et le formulaire n’est pas visible ; et (2) vous avez affiché le formulaire à l’aide de <xref:System.Windows.Forms.Form.ShowDialog%2A>. Dans ce cas, vous devez appeler <xref:System.Windows.Forms.Form.Dispose%2A> manuellement pour marquer tous les contrôles du formulaire pour le garbage collection.  
  
> [!NOTE]
>  Lorsque le <xref:System.Windows.Forms.Form.Close%2A> méthode est appelée sur une <xref:System.Windows.Forms.Form> affichés sous la forme d’une fenêtre non modale, vous ne pouvez pas appeler la <xref:System.Windows.Forms.Control.Show%2A> méthode pour rendre le formulaire visible, car les ressources du formulaire ont déjà été libérées. Pour masquer un formulaire et la rendre visible, utilisez la <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> (méthode).  
  
> [!CAUTION]
>  Avant la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 2.0, le <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> et <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> événements ne sont pas déclenché quand la <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> méthode est appelée pour quitter l’application. Si vous avez un code de validation dans un de ces événements qui doivent être exécutés, vous devez appeler la <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> méthode pour chaque formulaire ouvert individuellement avant d’appeler le <xref:System.Windows.Forms.Application.Exit%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le formulaire a été fermé pendant la création d'un handle.</exception>
        <exception cref="T:System.ObjectDisposedException">Vous ne pouvez pas appeler cette méthode à partir de l'événement <see cref="E:System.Windows.Forms.Form.Activated" /> lorsque <see cref="P:System.Windows.Forms.Form.WindowState" /> a la valeur <see cref="F:System.Windows.Forms.FormWindowState.Maximized" />.</exception>
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le formulaire est fermé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.Closed> événement est obsolète dans le .NET Framework version 2.0 ; utilisez la <xref:System.Windows.Forms.Form.FormClosed> événement à la place.  
  
 Cet événement se produit une fois que le formulaire a été fermé par l’utilisateur ou par le <xref:System.Windows.Forms.Form.Close%2A> méthode du formulaire. Pour empêcher un formulaire de fermeture, gérer la <xref:System.Windows.Forms.Form.Closing> événement et définissez la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> passé à votre gestionnaire d’événements `true`.  
  
 Vous pouvez utiliser cet événement pour effectuer des tâches telles que la libération des ressources utilisées par le formulaire et pour enregistrer les informations entrées dans le formulaire ou à mettre à jour son formulaire parent.  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> et <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> événements ne sont pas déclenchés lorsque la <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> méthode est appelée pour quitter l’application. Si vous avez un code de validation dans un de ces événements qui doivent être exécutés, vous devez appeler la <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> méthode pour chaque formulaire ouvert individuellement avant d’appeler le <xref:System.Windows.Forms.Application.Exit%2A> (méthode).  
  
 Si le formulaire est un formulaire MDI parent, le <xref:System.Windows.Forms.Form.Closing> de tous les formulaires MDI enfants sont déclenchés avant le formulaire MDI parent <xref:System.Windows.Forms.Form.Closing> événement est déclenché. En outre, le <xref:System.Windows.Forms.Form.Closed> de tous les formulaires MDI enfants sont déclenchés avant la <xref:System.Windows.Forms.Form.Closed> du formulaire parent MDI est déclenché.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, et <xref:System.Windows.Forms.Form.Activate%2A> membres. Pour exécuter l’exemple, collez le code suivant dans un formulaire nommé `Form1` contenant un <xref:System.Windows.Forms.Button> appelé `Button1` et deux <xref:System.Windows.Forms.Label> contrôles appelés `Label1` et `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit pendant la fermeture du formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.Closing> événement est obsolète dans le .NET Framework version 2.0 ; utilisez la <xref:System.Windows.Forms.Form.FormClosing> événement à la place.  
  
 Le <xref:System.Windows.Forms.Form.Closing> événement se produit quand le formulaire est fermé. Lorsqu’un formulaire est fermé, toutes les ressources créées au sein de l’objet sont libérées et le formulaire est supprimé. Si vous annulez cet événement, le formulaire reste ouvert. Pour annuler la fermeture d’un formulaire, affectez la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> passé à votre gestionnaire d’événements `true`.  
  
 Lorsqu’un formulaire est affiché en tant que boîte de dialogue modale, en cliquant sur le **fermer** bouton (le bouton avec un X sur le coin supérieur droit du formulaire) entraîne le masquage du formulaire et la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété à définir `DialogResult.Cancel`. Vous pouvez remplacer la valeur affectée à la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété lorsque l’utilisateur clique sur le **fermer** bouton en définissant le <xref:System.Windows.Forms.Form.DialogResult%2A> propriété dans un gestionnaire d’événements pour le <xref:System.Windows.Forms.Form.Closing> événement sous la forme.  
  
> [!NOTE]
>  Lorsque le <xref:System.Windows.Forms.Form.Close%2A> méthode est appelée sur une <xref:System.Windows.Forms.Form> affichés sous la forme d’une fenêtre non modale, vous ne pouvez pas appeler la <xref:System.Windows.Forms.Control.Show%2A> méthode pour rendre le formulaire visible, car les ressources du formulaire ont déjà été libérées. Pour masquer un formulaire et la rendre visible, utilisez la <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> (méthode).  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> et <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> événements ne sont pas déclenchés lorsque la <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> méthode est appelée pour quitter l’application. Si vous avez un code de validation dans un de ces événements qui doivent être exécutés, vous devez appeler la <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> méthode pour chaque formulaire ouvert individuellement avant d’appeler le <xref:System.Windows.Forms.Application.Exit%2A> (méthode).  
  
 Si le formulaire est un formulaire MDI parent, le <xref:System.Windows.Forms.Form.Closing> de tous les formulaires MDI enfants sont déclenchés avant le formulaire MDI parent <xref:System.Windows.Forms.Form.Closing> événement est déclenché. En outre, le <xref:System.Windows.Forms.Form.Closed> de tous les formulaires MDI enfants sont déclenchés avant la <xref:System.Windows.Forms.Form.Closed> du formulaire parent MDI est déclenché. L’annulation de la <xref:System.Windows.Forms.Form.Closing> événement d’un formulaire enfant MDI n’empêche pas le <xref:System.Windows.Forms.Form.Closing> événement du formulaire parent MDI de se déclencher. Toutefois, l’annulation de l’événement sera définie sur `true` le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> qui est passé en tant que paramètre au formulaire parent. Pour forcer la fermeture de tous les formulaires parents et enfants MDI, définissez la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété `false` dans l’interface MDI formulaire parent.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Windows.Forms.Form.Closing> pour tester si le texte dans un <xref:System.Windows.Forms.TextBox> a changé. S’il a, l’utilisateur est invité s’il faut enregistrer les modifications dans un fichier.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberSignature Language="VB.NET" Value="Public Property ControlBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ControlBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si une zone de contrôle est affichée dans la barre de légende du formulaire.</summary>
        <value>
          <see langword="true" /> Si le formulaire affiche une zone de contrôle dans le coin supérieur droit du formulaire. dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Forms.Form.ControlBox%2A> est définie sur `true`, la zone de contrôle est affichée dans le coin supérieur droit de la barre de légende. La boîte de contrôle peut inclure des minimiser, optimiser et aide les boutons de plus à un bouton Fermer. Pour le `ControlBox` propriété en vigueur, vous devez également affecter du formulaire <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriété <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, ou <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  
  
 Si vous définissez <xref:System.Windows.Forms.Form.ControlBox%2A> à `false` et définissez également la <xref:System.Windows.Forms.Form.Location%2A> propriété, le <xref:System.Windows.Forms.Form.Size%2A> propriété du formulaire n’est pas mis à jour pour indiquer que la zone non cliente du formulaire a été masquée. Pour résoudre ce problème, placez le code qui modifie le <xref:System.Windows.Forms.Form.Location%2A> propriété dans le <xref:System.Windows.Forms.Control.HandleCreated> Gestionnaire d’événements.  
  
> [!NOTE]
>  Lorsque la valeur `false`, le <xref:System.Windows.Forms.Form.ControlBox%2A> propriété n’a aucun effet sur un formulaire enfant d’interface (multidocument MDI) Multiple-document qui est affiché agrandi lors de la création.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés afin de créer un formulaire qui n’a pas de toute zone de bordure ou une légende. Le formulaire créé dans cet exemple peut servir à créer un écran de démarrage pour une application. L’exemple requiert que la méthode est définie dans une classe de formulaire et appelée lorsque le formulaire est initialisé.  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une nouvelle instance de la collection de contrôles pour le contrôle.</summary>
        <returns>Nouvelle instance de <see cref="T:System.Windows.Forms.Control.ControlCollection" /> assignée au contrôle.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée le handle pour le formulaire. Si une classe dérivée substitue cette fonction, elle doit appeler l'implémentation de base.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Un handle a déjà été créé pour ce <see cref="T:System.Windows.Forms.Form" />.</exception>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le paramètre de création requis lors de la création du handle du contrôle.</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" /> qui contient les paramètres de création requis quand le handle du contrôle est créé.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le formulaire perd le focus et n'est plus le formulaire actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cet événement pour effectuer des tâches telles que la mise à jour d’une autre fenêtre de votre application avec des données issues du formulaire désactivé.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.Deactivate> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.Deactivate> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
        <altmember cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le mode de l'éditeur de méthode d'entrée (IME, Input Method Editor) par défaut pris en charge par le contrôle.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un éditeur de méthode d’entrée (IME) est un programme qui permet aux utilisateurs d’entrer des caractères complexes et des symboles, tels que des caractères japonais (Kanji), à l’aide d’un clavier standard.  
  
 Tel qu’implémenté dans le <xref:System.Windows.Forms.Form> classe, cette propriété retourne toujours la <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> valeur. La valeur de cette propriété est assignée à la <xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille par défaut du contrôle.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> par défaut du contrôle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> Windows à traiter.</param>
        <summary>Renvoie le message spécifié à la procédure de fenêtre par défaut.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle DesktopBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille et l'emplacement du formulaire sur le bureau Windows.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> représentant les limites du formulaire sur le bureau Windows à l'aide des coordonnées du bureau.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coordonnées du bureau sont basées sur l’espace de travail de l’écran, qui exclut la barre des tâches. Le système de coordonnées du bureau est basé sur les pixels. Si votre application s’exécute sur un système à plusieurs moniteurs, les coordonnées du formulaire sont les coordonnées du bureau combiné.  
  
 Vous pouvez utiliser cette propriété pour dimensionner et positionner un formulaire par rapport à d’autres formulaires ou applications sur le bureau Windows.  
  
   
  
## Examples  
 L’exemple de code suivant définit la taille et la position d’un formulaire afin que ce dernier se trouve à 50 pixels du bord gauche du bureau et à 50 pixels à partir du haut du bureau. Cet exemple requiert que la méthode est définie dans une classe de formulaire.  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopLocation" />
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopLocation As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point DesktopLocation { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du formulaire sur le bureau Windows.</summary>
        <value>
          <see cref="T:System.Drawing.Point" /> représentant la position du formulaire sur le bureau.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coordonnées du bureau sont basées sur l’espace de travail de l’écran, qui exclut la barre des tâches. Le système de coordonnées du bureau s’exprime en pixels. Si votre application s’exécute sur un système multi-écran, les coordonnées du formulaire sont les coordonnées du bureau combiné.  
  
 Vous pouvez utiliser cette propriété pour positionner un formulaire par rapport aux autres formes et les applications sur le bureau Windows.  
  
 Si vous appelez le <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> méthode avant d’appeler le <xref:System.Windows.Forms.Form.Show%2A> (méthode), votre formulaire sera positionné à son emplacement par défaut, qui est déterminée par le système d’exploitation. Pour plus d’informations sur le positionnement de la fenêtre, consultez la section « Taille et Position de la fenêtre » du document « Fonctionnalités de la fenêtre » dans MSDN library à http://msdn.microsoft.com/library.  
  
 Si vous appelez <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> après avoir appelé <xref:System.Windows.Forms.Form.Show%2A>, votre formulaire sera positionné à l’emplacement spécifié.  
  
   
  
## Examples  
 L’exemple de code suivant définit la position d’un formulaire afin que ce dernier se trouve à 100 pixels du bord gauche du bureau et à 100 pixels à partir du haut du bureau. Cet exemple requiert que la méthode a été définie dans une classe de formulaire.  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DialogResult DialogResult { System::Windows::Forms::DialogResult get(); void set(System::Windows::Forms::DialogResult value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le résultat de boîte de dialogue du formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.DialogResult" /> représentant le résultat du formulaire quand il est utilisé comme boîte de dialogue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat de la boîte de dialogue d’un formulaire est la valeur qui est retournée à partir du formulaire lorsqu’il est affiché en tant que boîte de dialogue modale. Si le formulaire est affiché comme une boîte de dialogue, définir cette propriété avec une valeur à partir de la <xref:System.Windows.Forms.DialogResult> énumération définit la valeur de résultat de la boîte de dialogue pour le formulaire, masque la boîte de dialogue modale et retourne le contrôle au formulaire appelant. Cette propriété est généralement définie par le <xref:System.Windows.Forms.Button.DialogResult%2A> propriété d’un <xref:System.Windows.Forms.Button> contrôle du formulaire. Lorsque l’utilisateur clique sur le <xref:System.Windows.Forms.Button> de contrôle, la valeur affectée à la <xref:System.Windows.Forms.Button.DialogResult%2A> propriété de la <xref:System.Windows.Forms.Button> est affectée à la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété sous la forme.  
  
 Lorsqu’un formulaire est affiché en tant que boîte de dialogue modale, en cliquant sur le **fermer** bouton (le bouton avec un X dans le coin supérieur droit du formulaire) entraîne le masquage du formulaire et la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété à définir `DialogResult.Cancel`. Le <xref:System.Windows.Forms.Form.Close%2A> (méthode) n’est pas appelée automatiquement lorsque l’utilisateur clique sur le **fermer** bouton de boîte de dialogue ou définit la valeur de la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété. Au lieu de cela, le formulaire est masqué et peut être affiché à nouveau sans créer une nouvelle instance de la boîte de dialogue. En raison de ce comportement, vous devez appeler la <xref:System.Windows.Forms.Control.Dispose%2A> méthode du formulaire lorsque le formulaire n’est plus nécessaire par votre application.  
  
 Vous pouvez utiliser cette propriété pour déterminer comment une boîte de dialogue est fermée afin de traiter correctement les actions effectuées dans la boîte de dialogue.  
  
> [!NOTE]
>  Vous pouvez remplacer la valeur affectée à la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété lorsque l’utilisateur clique sur le **fermer** bouton en définissant le <xref:System.Windows.Forms.Form.DialogResult%2A> propriété dans un gestionnaire d’événements pour le <xref:System.Windows.Forms.Form.Closing> événement sous la forme.  
  
> [!NOTE]
>  Si un <xref:System.Windows.Forms.Form> s’affiche comme une fenêtre non modale, la valeur retournée par la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété peut ne pas retourne une valeur assignée à l’écran, car les ressources du formulaire sont libérés automatiquement lorsque le formulaire est fermé.  
  
   
  
## Examples  
 L’exemple de code suivant affiche un formulaire sous la forme d’une boîte de dialogue et affiche un message indiquant si l’utilisateur a cliqué sur le bouton OK ou Annuler du formulaire en faisant référence à la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété du formulaire.  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée ne figure pas dans la plage des valeurs valides.</exception>
        <altmember cref="T:System.Windows.Forms.DialogResult" />
        <altmember cref="P:System.Windows.Forms.Button.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources (autres que la mémoire) utilisées par <see cref="T:System.Windows.Forms.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec la `disposing` paramètre la valeur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` la valeur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Windows.Forms.Form>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 <xref:System.Windows.Forms.Form.Dispose%2A> sera appelé automatiquement si le formulaire est affiché à l’aide de la <xref:System.Windows.Forms.Form.Show%2A> (méthode). Si une autre méthode telle que <xref:System.Windows.Forms.Form.ShowDialog%2A> est utilisé, ou le formulaire n’est jamais affiché, vous devez appeler <xref:System.Windows.Forms.Form.Dispose%2A> vous-même au sein de votre application.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lors des modifications aux paramètres de la résolution en DPI du périphérique d’affichage sur lequel le formulaire est actuellement affiché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FormBorderStyle As FormBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormBorderStyle FormBorderStyle { System::Windows::Forms::FormBorderStyle get(); void set(System::Windows::Forms::FormBorderStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style de bordure du formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormBorderStyle" /> qui représente le style de bordure à afficher pour le formulaire. La valeur par défaut est <see langword="FormBorderStyle.Sizable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le style de bordure du formulaire détermine la façon dont le contour de l’écran s’affiche. Outre la modification de l’affichage de la bordure d’un formulaire, le formulaire empêchent certains styles de bordure d’en cours de dimensionnement. Par exemple, le `FormBorderStyle.FixedDialog` style de bordure modifie la bordure du formulaire à celle d’une boîte de dialogue et empêche le redimensionnement du formulaire. Le style de bordure peut également affecter la taille ou la disponibilité de la section de la barre de légende d’un formulaire.  
  
> [!NOTE]
>  Avec la <xref:System.Windows.Forms.FormBorderStyle.Sizable> style, il est impossible de redimensionner la fenêtre au-dessous d’une certaine valeur minimale, même si vous avez défini <xref:System.Windows.Forms.Form.ControlBox%2A> à `false` et assigné à une chaîne de longueur nulle <xref:System.Windows.Forms.Form.Text%2A>. Pensez à utiliser contourner ce problème à l’aide de la <xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow> de style à la place.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée ne figure pas dans la plage des valeurs valides.</exception>
        <altmember cref="T:System.Windows.Forms.FormBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosed As FormClosedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosedEventHandler ^ FormClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une fois le formulaire fermé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.FormClosed> événement se produit une fois que le formulaire a été fermé par l’utilisateur ou par le <xref:System.Windows.Forms.Form.Close%2A> (méthode) ou le <xref:System.Windows.Forms.Application.Exit%2A> méthode de la <xref:System.Windows.Forms.Application> classe. Pour empêcher un formulaire de fermeture, gérer la <xref:System.Windows.Forms.Form.FormClosing> événement et définissez la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> passé à votre gestionnaire d’événements `true`.  
  
 Vous pouvez utiliser cet événement pour effectuer des tâches telles que la libération des ressources utilisées par le formulaire et pour enregistrer les informations entrées dans le formulaire ou à mettre à jour son formulaire parent.  
  
 Si le formulaire est un formulaire parent de l’interface multidocument (MDI), la <xref:System.Windows.Forms.Form.FormClosing> de tous les formulaires MDI enfants sont déclenchés avant le formulaire MDI parent <xref:System.Windows.Forms.Form.FormClosing> événement est déclenché. De même, la <xref:System.Windows.Forms.Form.FormClosed> de tous les formulaires MDI enfants sont déclenchés avant la <xref:System.Windows.Forms.Form.FormClosed> du formulaire parent MDI est déclenché.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.FormClosed> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.FormClosed> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosing As FormClosingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosingEventHandler ^ FormClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant la fermeture du formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.FormClosing> événement se produit quand le formulaire est fermé. Lorsqu’un formulaire est fermé, il est supprimé, libérant toutes les ressources associées à l’écran. Si vous annulez cet événement, le formulaire reste ouvert. Pour annuler la fermeture d’un formulaire, affectez la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.Windows.Forms.FormClosingEventArgs> passé à votre gestionnaire d’événements `true`.  
  
 Lorsqu’un formulaire est affiché en tant que boîte de dialogue modale, en cliquant sur le **fermer** bouton (le bouton avec un X sur le coin supérieur droit du formulaire) entraîne le masquage du formulaire et la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété à définir `DialogResult.Cancel`. Vous pouvez remplacer la valeur affectée à la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété lorsque l’utilisateur clique sur le **fermer** bouton en définissant le <xref:System.Windows.Forms.Form.DialogResult%2A> propriété dans un gestionnaire d’événements pour le <xref:System.Windows.Forms.Form.FormClosing> événement sous la forme.  
  
> [!NOTE]
>  Lorsque le <xref:System.Windows.Forms.Form.Close%2A> méthode est appelée sur une <xref:System.Windows.Forms.Form> affichés sous la forme d’une fenêtre non modale, vous ne pouvez pas appeler la <xref:System.Windows.Forms.Control.Show%2A> méthode pour rendre le formulaire visible, car les ressources du formulaire ont déjà été libérées. Pour masquer un formulaire et la rendre visible, utilisez la <xref:System.Windows.Forms.Control.Hide%2A> (méthode).  
  
 Si le formulaire est un formulaire parent de l’interface multidocument (MDI), la <xref:System.Windows.Forms.Form.FormClosing> de tous les formulaires MDI enfants sont déclenchés avant le formulaire MDI parent <xref:System.Windows.Forms.Form.FormClosing> événement est déclenché. De même, la <xref:System.Windows.Forms.Form.FormClosed> de tous les formulaires MDI enfants sont déclenchés avant la <xref:System.Windows.Forms.Form.FormClosed> du formulaire parent MDI est déclenché. L’annulation de la <xref:System.Windows.Forms.Form.FormClosing> événement d’un formulaire enfant MDI n’empêche pas le <xref:System.Windows.Forms.Form.FormClosing> événement du formulaire parent MDI de se déclencher. Toutefois, l’annulation de l’événement sera définie sur `true` le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.Windows.Forms.FormClosingEventArgs> classe qui est passé en tant que paramètre au formulaire parent. Pour forcer la fermeture de tous les formulaires parents et enfants MDI, définissez la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété `false` dans l’interface MDI formulaire parent.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.FormClosing> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.FormClosing> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::SizeF GetAutoScaleSize(System::Drawing::Font ^ font);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">
          <see cref="T:System.Drawing.Font" /> représentant la police sur la base de laquelle sera déterminée la taille du formulaire ajusté automatiquement.</param>
        <summary>Obtient la taille du formulaire lors de sa mise à l'échelle automatique en fonction d'une police spécifiée.</summary>
        <returns>
          <see cref="T:System.Drawing.SizeF" /> représentant la taille ajustée automatiquement du formulaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> méthode est obsolète dans le.NET Framework version 2.0. Ce membre a été conservé pour la compatibilité descendante. Pour plus d’informations sur la mise à l’échelle automatique, consultez [mise à l’échelle automatique dans les Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Vous pouvez utiliser cette méthode pour déterminer la taille de mise à l’échelle à une police spécifique avant d’appliquer la police à l’écran. Si vous souhaitez déterminer la taille du formulaire ajusté automatiquement est à en fonction de la police actuellement affectée au formulaire, utilisez le <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">
          <see cref="T:System.Drawing.Rectangle" /> qui spécifie la zone pour laquelle les limites d'affichage sont récupérées.</param>
        <param name="factor">Hauteur et largeur des limites du contrôle.</param>
        <param name="specified">Une des valeurs de <see cref="T:System.Windows.Forms.BoundsSpecified" /> qui spécifie les limites du contrôle à utiliser pendant la définition de sa taille et de sa position.</param>
        <summary>Récupère les limites dans lesquelles le contrôle est mis à l'échelle.</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" /> représentant les limites dans lesquelles le contrôle est mis à l'échelle.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberSignature Language="VB.NET" Value="Public Property HelpButton As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HelpButton { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si un bouton d'aide s'affiche dans la barre de légende du formulaire.</summary>
        <value>
          <see langword="true" /> pour afficher un bouton d'aide dans la barre de légende du formulaire ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette propriété a la valeur `true`, un petit bouton avec un point d’interrogation apparaît dans la barre de légende à gauche de la **fermer** bouton. Vous pouvez utiliser ce bouton pour afficher l’aide de votre application. Vous pouvez créer un gestionnaire d’événements pour le <xref:System.Windows.Forms.Control.HelpRequested> événement afin d’afficher des informations d’aide à l’utilisateur lorsque l’utilisateur clique sur le bouton aide de l’écran.  

Pour afficher un bouton d’aide, la valeur du formulaire <xref:System.Windows.Forms.Form.ControlBox> propriété doit être `true`, sa valeur par défaut. Le <xref:System.Windows.Forms.Form.ControlBox> propriété détermine si l’angle supérieur droit de la barre de légende contient des contrôles comme un bouton Agrandir, un bouton réduire, un bouton d’aide et un bouton Fermer. En outre, vous devez également définir du formulaire <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriété <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, ou <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  


> [!IMPORTANT]
>  La valeur de la <xref:System.Windows.Forms.Form.HelpButton%2A> propriété est ignorée si la **agrandir** ou **réduire** boutons sont affichés.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpButtonClicked As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ HelpButtonClicked;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit suite à un clic sur le bouton **Aide**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.HelpButtonClicked> événement se produit lorsque le **aide** bouton dans la barre de légende du formulaire. Le **aide** bouton s’affiche lorsque le <xref:System.Windows.Forms.Form.HelpButton%2A> est définie sur `true`. <xref:System.Windows.Forms.Form.HelpButtonClicked> peut être annulée.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.HelpButtonClicked> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.HelpButtonClicked> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.HelpButton" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As Icon" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Icon ^ Icon { System::Drawing::Icon ^ get(); void set(System::Drawing::Icon ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'icône du formulaire.</summary>
        <value>
          <see cref="T:System.Drawing.Icon" /> qui représente l'icône du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Icône d’un formulaire désigne l’image qui représente le formulaire dans la barre des tâches, ainsi que l’icône qui s’affiche pour la zone de contrôle du formulaire.  
  
 Cette propriété n’a aucun effet si <xref:System.Windows.Forms.Form.FormBorderStyle%2A> a la valeur <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>. Dans ce cas, l’écran n’affichera une icône.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanged As InputLanguageChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangedEventHandler ^ InputLanguageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après la modification du langage d'entrée du formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cet événement pour apporter des modifications à l’apparence et le texte en fonction des modifications apportées à la langue d’entrée du formulaire.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.InputLanguageChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.InputLanguageChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanging As InputLanguageChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangingEventHandler ^ InputLanguageChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'utilisateur tente de modifier le langage d'entrée du formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement se produit avant la modification du langage d’entrée du formulaire. Vous pouvez annuler le changement de langue en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.Windows.Forms.InputLanguageChangingEventArgs> passé à votre gestionnaire d’événements `false`. Si l’événement est annulé, la langue d’entrée n’est pas modifiée. Vous pouvez utiliser cet événement pour déterminer si la modification de la langue d’entrée demandée est appropriée pour votre application.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.InputLanguageChanging> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.InputLanguageChanging> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMdiChild As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiChild { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le formulaire est un formulaire enfant MDI.</summary>
        <value>
          <see langword="true" /> si le formulaire est un formulaire enfant MDI ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au moment de l’exécution, les formulaires MDI enfants sont affichés à l’intérieur de la zone cliente d’un formulaire MDI parent. Un formulaire MDI enfant peut être agrandi, réduit et déplacé dans un formulaire MDI parent. Pour créer un formulaire enfant MDI, assignez le <xref:System.Windows.Forms.Form> qui sera le formulaire MDI parent à le <xref:System.Windows.Forms.Form.MdiParent%2A> propriété du formulaire enfant. Vous pouvez utiliser la <xref:System.Windows.Forms.Form.IsMdiContainer%2A> formulaire de propriété pour déterminer si un formulaire est un formulaire MDI parent.  
  
 Vous pouvez utiliser le <xref:System.Windows.Forms.Form.IsMdiChild%2A> propriété pour déterminer si un formulaire retourné par une méthode ou propriété est un formulaire enfant MDI ou un formulaire standard de votre application comme une boîte de dialogue.  
  
> [!NOTE]
>  Tous les formulaires MDI enfants ont des bords redimensionnables, une zone de menu du contrôle et réduire et **agrandir** boutons, quels que soient les paramètres de la <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, et <xref:System.Windows.Forms.Form.MaximizeBox%2A> propriétés.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property IsMdiContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiContainer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le formulaire est un conteneur de formulaires enfants d'interface multidocument (MDI).</summary>
        <value>
          <see langword="true" /> si le formulaire est un conteneur de formulaires enfants MDI ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété modifie l’affichage et le comportement du formulaire à un formulaire MDI parent. Lorsque cette propriété a la valeur `true`, le formulaire affiche une zone cliente enfoncée avec une bordure en relief. Tous les formulaires MDI enfants affectés au formulaire parent sont affichés dans sa zone cliente.  
  
 Lorsqu’un formulaire MDI parent est fermé, la <xref:System.Windows.Forms.Form.Closing> de tous les formulaires MDI enfants sont déclenchés avant le formulaire MDI parent <xref:System.Windows.Forms.Form.Closing> événement est déclenché. En outre, le <xref:System.Windows.Forms.Form.Closed> de tous les formulaires MDI enfants sont déclenchés avant la <xref:System.Windows.Forms.Form.Closed> du formulaire parent MDI est déclenché.  
  
> [!NOTE]
>  S’il existe deux <xref:System.Windows.Forms.MenuStrip> contrôles sur un formulaire MDI enfant, en définissant <xref:System.Windows.Forms.Form.IsMdiContainer%2A> à `true` pour le parent formulaire fusionne le contenu du seul de le <xref:System.Windows.Forms.MenuStrip> contrôles. Utilisez <xref:System.Windows.Forms.ToolStripManager.Merge%2A> pour fusionner le contenu des enfants supplémentaires <xref:System.Windows.Forms.MenuStrip> contrôles sur le formulaire parent MDI.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.IsMdiContainer%2A> propriété ainsi qu’une modification du `BackColor` propriété d’un formulaire MDI. Pour exécuter cet exemple, collez le code suivant dans un nouveau formulaire.  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRestrictedWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRestrictedWindow { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le formulaire peut utiliser toutes les fenêtres et événements d'entrée d'utilisateur sans restriction.</summary>
        <value>
          <see langword="true" /> si le formulaire a des restrictions ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A> propriété détermine si le <xref:System.Security.Permissions.UIPermissionWindow.AllWindows> l’autorisation est accordée. Cette propriété est définie au moment de l’exécution dans le constructeur du formulaire et est mis en cache pour la durée de vie de l’écran. Les applications Windows Forms en cours d’exécution en confiance partielle ne peut pas contourner cette vérification, car le common language runtime garantit que le constructeur parent est toujours appelé avec une confiance partielle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPreview As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeyPreview { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le formulaire doit recevoir des événements de touche avant que l'événement ne soit passé au contrôle ayant le focus.</summary>
        <value>
          <see langword="true" /> si le formulaire reçoit tous les événements clés ; <see langword="false" /> si le contrôle actif du formulaire reçoit ces événements. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette propriété a la valeur `true`, le formulaire reçoit tous les <xref:System.Windows.Forms.Control.KeyPress>, <xref:System.Windows.Forms.Control.KeyDown>, et <xref:System.Windows.Forms.Control.KeyUp> événements. Une fois que les gestionnaires d’événements du formulaire ont terminé le traitement de la séquence de touches, la séquence de touches est ensuite assigné au contrôle qui a le focus. Par exemple, si le <xref:System.Windows.Forms.Form.KeyPreview%2A> est définie sur `true` et le contrôle actuellement sélectionné est un <xref:System.Windows.Forms.TextBox>, une fois que la séquence de touches est géré par les gestionnaires d’événements sous la forme la <xref:System.Windows.Forms.TextBox> contrôle reçoit la touche qui a été enfoncée. Pour gérer les événements de clavier uniquement au niveau du formulaire et n’autorise pas les contrôles de recevoir des événements de clavier, définissez la <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> propriété dans votre formulaire <xref:System.Windows.Forms.Control.KeyPress> Gestionnaire d’événements à `true`.  
  
 Vous pouvez utiliser cette propriété pour traiter la plupart des séquences de touches dans votre application et gérer la séquence de touches ou appeler le contrôle approprié pour gérer la séquence de touches. Par exemple, lorsqu’une application utilise des touches de fonction, vous souhaiterez traiter les séquences de touches au niveau du formulaire plutôt que d’écrire du code pour chaque contrôle qui peut recevoir des événements de séquence de touches.  
  
> [!NOTE]
>  Si un formulaire ne dispose d’aucun contrôle visible ou activé, il reçoit automatiquement tous les événements de clavier.  
  
> [!NOTE]
>  Un contrôle sur un formulaire peut être programmé pour annuler toutes les séquences de touches qu’il reçoit. Étant donné que le contrôle n’envoie jamais ces séquences de touches au formulaire, le formulaire ne verrez jamais les indépendamment du paramètre de <xref:System.Windows.Forms.Form.KeyPreview%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la définition d’un formulaire <xref:System.Windows.Forms.Form.KeyPreview%2A> propriété sur true et la gestion des événements clés au niveau du formulaire. Pour exécuter l’exemple, collez le code suivant dans un formulaire vierge.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LayoutMdi (value As MdiLayout)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LayoutMdi(System::Windows::Forms::MdiLayout value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">L'une des valeurs de <see cref="T:System.Windows.Forms.MdiLayout" /> définissant la disposition des formulaires enfants MDI.</param>
        <summary>Organise les formulaires enfants MDI au sein du formulaire parent MDI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour réorganiser les formulaires enfants MDI dans votre formulaire MDI parent permettant de faciliter la navigation et la manipulation des formulaires enfants MDI. Formulaires MDI enfants peuvent être affichée en mosaïque horizontalement et verticalement, en cascade, ou sous forme d’icônes dans le formulaire MDI parent.  
  
   
  
## Examples  
 L’exemple de code suivant montre les gestionnaires d’événements pour les éléments de menu d’un menu de la fenêtre sous forme de parent d’une application MDI. Chaque gestionnaire d’événements appelle la <xref:System.Windows.Forms.Form.LayoutMdi%2A> méthode pour réorganiser les formulaires enfants qui sont actuellement ouvertes dans l’application.  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MdiLayout" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant le premier affichage d'un formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cet événement pour effectuer des tâches telles que l’allocation de ressources utilisées par le formulaire.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, et <xref:System.Windows.Forms.Form.Activate%2A> membres. Pour exécuter l’exemple, collez le code suivant dans un formulaire nommé `Form1` contenant un <xref:System.Windows.Forms.Button> appelé `Button1` et deux <xref:System.Windows.Forms.Label> contrôles appelés `Label1` et `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Drawing.Point" /> qui représente l'angle supérieur gauche du <see cref="T:System.Windows.Forms.Form" /> dans les coordonnées d'écran.</summary>
        <value>
          <see cref="T:System.Drawing.Point" /> qui représente l'angle supérieur gauche du <see cref="T:System.Windows.Forms.Form" /> dans les coordonnées d'écran.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point> est une structure, ce qui signifie qu’il est un type valeur. Si vous accédez à une propriété dans <xref:System.Drawing.Point>, une copie de la propriété est retournée. Par conséquent, la modification la <xref:System.Drawing.Point.X%2A> ou <xref:System.Drawing.Point.Y%2A> propriétés de la <xref:System.Drawing.Point> retourné à partir de la <xref:System.Windows.Forms.Control.Location%2A> propriété n’affecte pas la <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, ou <xref:System.Windows.Forms.Control.Bottom%2A> valeurs de propriété de la <xref:System.Windows.Forms.Form>. Pour modifier ces propriétés, définissez la valeur de chaque propriété individuellement, ou définir le <xref:System.Windows.Forms.Form.Location%2A> propriété avec un nouveau <xref:System.Drawing.Point>.  
  
 Le <xref:System.Windows.Forms.Form.Location%2A> propriété obtient ou définit le <xref:System.Windows.Forms.Control.Location%2A> propriété de la <xref:System.Windows.Forms.Control> classe de base et définit le <xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Property MainMenuStrip As MenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuStrip ^ MainMenuStrip { System::Windows::Forms::MenuStrip ^ get(); void set(System::Windows::Forms::MenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le conteneur du menu principal du formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.MenuStrip" /> qui représente le conteneur de la structure de menus du formulaire. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En plus du paramètre de la <xref:System.Windows.Forms.Form.MainMenuStrip%2A> propriété, vous devez <xref:System.Windows.Forms.Control.ControlCollection.Add%2A> le <xref:System.Windows.Forms.MenuStrip> le contrôle à la <xref:System.Windows.Forms.Control.Controls%2A> collection du formulaire.  
  
 Le <xref:System.Windows.Forms.MenuStrip> classe remplace la <xref:System.Windows.Forms.MainMenu> classe dans les versions précédentes du .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'espace entre les contrôles.</summary>
        <value>Valeur qui représente l'espace entre les contrôles.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la propriété <see cref="P:System.Windows.Forms.Form.Margin" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaximizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le bouton **Agrandir** est affiché dans la barre de légende du formulaire.</summary>
        <value>
          <see langword="true" /> Pour afficher un **agrandir** bouton du formulaire ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 A **agrandir** bouton permet aux utilisateurs d’agrandir une fenêtre en plein écran. Pour afficher un **agrandir** bouton, la valeur du formulaire <xref:System.Windows.Forms.Form.ControlBox> propriété doit être `true`, sa valeur par défaut.  Le <xref:System.Windows.Forms.Form.ControlBox> propriété détermine si l’angle supérieur droit de la barre de légende contient des contrôles comme un bouton Agrandir, un bouton réduire, un bouton d’aide et un bouton Fermer. En outre, vous devez également définir du formulaire <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriété <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, ou <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  
  
 A **agrandir** bouton devient automatiquement un bouton de restauration lorsqu’une fenêtre est agrandie. Réduction ou la restauration automatique d’une fenêtre change le bouton Restaurer vers un **agrandir** bouton.  
  
> [!NOTE]
>  Agrandir un formulaire au moment de l’exécution génère un <xref:System.Windows.Forms.Control.Resize> événement. Le <xref:System.Windows.Forms.Form.WindowState%2A> propriété reflète l’état actuel de la fenêtre. Si vous définissez la <xref:System.Windows.Forms.Form.WindowState%2A> propriété `FormWindowState.Maximized`, le formulaire est agrandi, les paramètres sont en vigueur pour le <xref:System.Windows.Forms.Form.MaximizeBox%2A> et <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriétés.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Property MaximizedBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::Rectangle MaximizedBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient et définit la taille du formulaire une fois agrandi.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> représentant les limites du formulaire une fois celui-ci agrandi.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de la propriété <see cref="P:System.Drawing.Rectangle.Top" /> est supérieure à la hauteur du formulaire.  
  
 - ou -  
  
 La valeur de la propriété <see cref="P:System.Drawing.Rectangle.Left" /> est supérieure à la largeur du formulaire.</exception>
        <block subset="none" type="overrides">
          <para>Les classes qui héritent de <see cref="T:System.Windows.Forms.Form" /> peuvent substituer cette méthode pour fournir les nouvelles limites du formulaire lorsqu’elle est agrandie. La classe affecte à cette propriété en interne lorsque du formulaire **agrandir** bouton est activé.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximizedBoundsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximizedBoundsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.Form.MaximizedBounds" /> a changé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille maximale que peut prendre le formulaire lorsqu'il est redimensionné.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> qui représente la taille maximale du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet de limiter la taille d’un formulaire à une taille maximale spécifiée. Vous pouvez utiliser cette fonctionnalité lors de l’affichage de plusieurs fenêtres en même temps, pour garantir qu’une seule fenêtre ne provoque pas d’autres fenêtres. Si cette propriété est définie sur une <xref:System.Drawing.Size> objet 0 de hauteur et 0 dans la largeur, le formulaire aura une taille maximale au-delà des limites définies par Windows.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la définition du <xref:System.Windows.Forms.Form.MaximumSize%2A> propriété.  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Les valeurs de la hauteur ou de la largeur dans l'objet <see cref="T:System.Drawing.Size" /> sont inférieures à zéro.</exception>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MaxWindowTrackSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.Form.MaximumSize" /> a changé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.MaximumSizeChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.MaximumSizeChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MdiChildActivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MdiChildActivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un formulaire enfant MDI est activé ou fermé dans une application d'interface multidocument MDI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cet événement pour effectuer des tâches telles que la mise à jour le contenu du formulaire enfant MDI et modifier les options de menu disponibles dans le formulaire parent MDI en fonction de l’état du formulaire enfant MDI qui est activé.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.MdiChildActivate> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.MdiChildActivate> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiChildren As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ MdiChildren { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un tableau de formulaires représentant les formulaires enfants MDI qui sont apparentés à ce formulaire.</summary>
        <value>Tableau d'objets <see cref="T:System.Windows.Forms.Form" />, dont chaque objet identifie l'un des formulaires enfants MDI de ce formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’obtenir des références à tous les formulaires enfants MDI actuellement ouverts dans un formulaire MDI parent. Pour créer un formulaire enfant MDI, assignez le <xref:System.Windows.Forms.Form> qui sera le formulaire MDI parent à le <xref:System.Windows.Forms.Form.MdiParent%2A> propriété du formulaire enfant.  
  
 Vous pouvez utiliser cette propriété pour parcourir tous les MDI enfant pour effectuer des opérations telles que l’enregistrement de données à une base de données lors de la fermeture du formulaire MDI parent ou mettre à jour des champs sur les formulaires enfants en fonction des actions effectuées dans votre application.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.MdiChildren%2A> propriété pour une itération au sein de la liste des formulaires enfants MDI et ajouter un <xref:System.Windows.Forms.Button> chaque contrôle.  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiParent As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ MdiParent { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le formulaire parent MDI en cours de ce formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> représentant le formulaire parent MDI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer un formulaire enfant MDI, assignez le <xref:System.Windows.Forms.Form> qui sera le formulaire MDI parent à le <xref:System.Windows.Forms.Form.MdiParent%2A> propriété du formulaire enfant. Vous pouvez utiliser cette propriété à partir d’un formulaire enfant MDI pour obtenir des informations globales que vous avez besoin de tous les formulaires enfants ou appeler des méthodes qui effectuent des actions pour tous les formulaires enfants.  
  
> [!NOTE]
>  S’il existe deux <xref:System.Windows.Forms.MenuStrip> contrôles sur un formulaire MDI enfant, en définissant <xref:System.Windows.Forms.Form.IsMdiContainer%2A> à `true` pour le parent formulaire fusionne le contenu du seul de le <xref:System.Windows.Forms.MenuStrip> contrôles. Utilisez <xref:System.Windows.Forms.ToolStripManager.Merge%2A> pour fusionner le contenu des enfants supplémentaires <xref:System.Windows.Forms.MenuStrip> contrôles sur le formulaire parent MDI.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer des formulaires enfants dans une application MDI. L’exemple de code crée un formulaire avec un texte unique pour identifier le formulaire enfant. L’exemple utilise le <xref:System.Windows.Forms.Form.MdiParent%2A> propriété pour spécifier qu’un formulaire est un formulaire enfant. Cet exemple requiert que le code dans l’exemple est appelé à partir d’un formulaire qui a son <xref:System.Windows.Forms.Form.IsMdiContainer%2A> propriété `true` et que le formulaire possède une variable entière de niveau de classe privée nommée `childCount`.  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Le <see cref="T:System.Windows.Forms.Form" /> assigné à cette propriété n'est pas marqué comme un conteneur MDI.  
  
 - ou -  
  
 Le <see cref="T:System.Windows.Forms.Form" /> assigné à cette propriété est à la fois un formulaire conteneur MDI et un formulaire enfant MDI.  
  
 - ou -  
  
 Le <see cref="T:System.Windows.Forms.Form" /> assigné à cette propriété se trouve dans un thread différent.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour demander un formulaire. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberSignature Language="VB.NET" Value="Public Property Menu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ Menu { System::Windows::Forms::MainMenu ^ get(); void set(System::Windows::Forms::MainMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Forms.MainMenu" /> affiché dans le formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.MainMenu" /> qui représente le menu à afficher dans le formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour basculer entre les jeux de menus au moment de l’exécution. Par exemple, vous pouvez définir un <xref:System.Windows.Forms.MainMenu> à afficher lorsque votre formulaire de l’interface multidocument (MDI) a des formulaires enfants MDI aucun actives et l’autre <xref:System.Windows.Forms.MainMenu> à afficher lorsqu’une fenêtre enfant est affichée. Vous pouvez également utiliser un autre <xref:System.Windows.Forms.MainMenu> lorsque des conditions spécifiques existent dans votre application nécessitant un jeu de menus différent.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MainMenu>, assigne deux <xref:System.Windows.Forms.MenuItem> des objets sur le <xref:System.Windows.Forms.MainMenu> et le lie à un formulaire. Cet exemple suppose que vous avez un <xref:System.Windows.Forms.Form> créé qui est nommé `Form1`.  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le menu d'un formulaire perd le focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque vous cliquez sur n’importe quel élément de menu dans un menu qui résulte dans une commande en cours d’exécution et du perdre le focus menu. Vous pouvez utiliser cet événement pour effectuer des tâches telles que la mise à jour le texte d’un <xref:System.Windows.Forms.StatusBar> contrôle ou l’activation et désactivation des boutons sur un <xref:System.Windows.Forms.ToolBar>.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.MenuComplete> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.MenuComplete> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuStart As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuStart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le menu d'un formulaire reçoit le focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché lorsque l’utilisateur clique sur n’importe quel élément de menu dans le menu. Vous pouvez utiliser cet événement pour effectuer des tâches telles que l’activation et désactivation des contrôles sur le formulaire qui ne doivent pas être accessibles par l’utilisateur lorsque les menus sont en cours d’accès.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.MenuStart> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.MenuStart> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedMenu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ MergedMenu { System::Windows::Forms::MainMenu ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le menu fusionné du formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.MainMenu" /> qui représente le menu fusionné du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est principalement utilisée lorsque le formulaire est un formulaire enfant de l’interface multidocument (MDI) qui fusionne son menu avec de son formulaire parent. Vous pouvez utiliser cette propriété pour obtenir la structure actuelle de menu dans une application MDI à apporter des modifications ou ajouts apportés à la structure de menu. Pour obtenir la non fusionné <xref:System.Windows.Forms.MainMenu> assigné à un formulaire, utilisez le <xref:System.Windows.Forms.Form.Menu%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.Form.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MinimizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le bouton **Réduire** est affiché dans la barre de légende du formulaire.</summary>
        <value>
          <see langword="true" /> Pour afficher un **réduire** bouton du formulaire ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A **réduire** bouton permet aux utilisateurs de réduire une fenêtre à une icône. Pour afficher un **réduire** bouton, la valeur du formulaire <xref:System.Windows.Forms.Form.ControlBox> propriété doit être `true`, sa valeur par défaut.  Le <xref:System.Windows.Forms.Form.ControlBox> propriété détermine si l’angle supérieur droit de la barre de légende contient des contrôles comme un bouton Agrandir, un bouton réduire, un bouton d’aide et un bouton Fermer. En outre, vous devez également définir du formulaire <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriété <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, ou <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Réduction d’un formulaire au moment de l’exécution génère un <xref:System.Windows.Forms.Control.Resize> événement. Le <xref:System.Windows.Forms.Form.WindowState%2A> propriété reflète l’état actuel de la fenêtre. Si vous définissez la <xref:System.Windows.Forms.Form.WindowState%2A> propriété `FormWindowState.Minimized`, le formulaire est réduit, les paramètres sont en vigueur pour le <xref:System.Windows.Forms.Form.MinimizeBox%2A> et <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriétés.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de redimensionnement maximale du formulaire.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> qui représente la taille minimale du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet de limiter la taille d’un formulaire à une taille minimale spécifiée. Vous pouvez utiliser cette fonctionnalité pour empêcher un utilisateur de redimensionner une fenêtre à une taille non recommandée. Si cette propriété est définie sur une <xref:System.Drawing.Size> objet 0 de hauteur et 0 dans la largeur, le formulaire aura une taille minimale au-delà des limites définies par Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Les valeurs de la hauteur ou de la largeur dans l'objet <see cref="T:System.Drawing.Size" /> sont inférieures à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MinimumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MinimumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.Form.MinimumSize" /> a changé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.MinimumSizeChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.MinimumSizeChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si ce formulaire présente un affichage modal.</summary>
        <value>
          <see langword="true" /> si le formulaire présente un affichage modal ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un formulaire est affiché sous forme modale, aucune entrée (clavier ou la souris) ne peut se produire sauf aux objets sur le formulaire modal. Le programme doit masquer ou fermer le formulaire modal (généralement en réponse à une action de l’utilisateur) avant qu’une entrée à un autre formulaire peut se produire. Formulaires qui sont affichés sous forme modale sont généralement utilisés comme des boîtes de dialogue dans une application.  
  
 Vous pouvez utiliser cette propriété pour déterminer si un formulaire que vous avez obtenu à partir d’une méthode ou propriété a été un affichage modal.  
  
 Pour afficher un formulaire modal, utilisez la <xref:System.Windows.Forms.Form.ShowDialog%2A> (méthode).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.Form.Modal%2A> propriété pour déterminer si un formulaire est affiché comme un formulaire modal. Si elle n’est pas le <xref:System.Windows.Forms.Form.FormBorderStyle%2A> et <xref:System.Windows.Forms.Form.TopLevel%2A> propriétés sont modifiées pour rendre le formulaire un formulaire de niveau non top avec une bordure de fenêtre outil.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.ShowDialog" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnActivated%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Substitution de cette méthode est la méthode recommandée pour gérer l’événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.OnClosed%2A> méthode est obsolète dans le .NET Framework version 2.0 ; utilisez la <xref:System.Windows.Forms.Form.OnFormClosed%2A> méthode à la place.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnFormClosed%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Substitution de cette méthode est la méthode recommandée pour gérer l’événement dans une classe dérivée.  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.OnClosed%2A> et <xref:System.Windows.Forms.Form.OnClosing%2A> méthodes ne sont pas appelées lorsque la <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> méthode est appelée pour quitter l’application. Si vous avez un code de validation dans une de ces méthodes qui doivent être exécutés, vous devez appeler la <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> méthode pour chaque formulaire ouvert individuellement avant d’appeler le <xref:System.Windows.Forms.Application.Exit%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Windows.Forms.Form.OnClosed%2A> méthode dans une classe dérivée <xref:System.Windows.Forms.Form> .  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.ComponentModel.CancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.OnClosing%2A> méthode est obsolète dans le .NET Framework version 2.0 ; utilisez la <xref:System.Windows.Forms.Form.OnFormClosing%2A> méthode à la place.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnClosing%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Substitution de cette méthode est la méthode recommandée pour gérer l’événement dans une classe dérivée.  
  
> [!CAUTION]
>  Le <xref:System.Windows.Forms.Form.OnClosed%2A> et <xref:System.Windows.Forms.Form.OnClosing%2A> méthodes ne sont pas appelées lorsque la <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> méthode est appelée pour quitter l’application. Si vous avez un code de validation dans une de ces méthodes qui doivent être exécutés, vous devez appeler la <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> méthode pour chaque formulaire ouvert individuellement avant d’appeler le <xref:System.Windows.Forms.Application.Exit%2A> (méthode).  
  
   
  
## Examples  
 Le code suivant utilise des exemple <xref:System.Windows.Forms.Form.Closing> pour tester si le texte dans un <xref:System.Windows.Forms.TextBox> a changé. S’il a, l’utilisateur est invité s’il faut enregistrer les modifications dans un fichier.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.ComponentModel.CancelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclenche l'événement <see langword="CreateControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> (méthode).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.Deactivate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnDeactivate%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As DpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::Forms::DpiChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.DpiChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.Enter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnEnter%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosed (e As FormClosedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosed(System::Windows::Forms::FormClosedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.FormClosedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.FormClosed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.OnFormClosing%2A> méthode supprime le formulaire actuel à partir de la <xref:System.Windows.Forms.Application.OpenForms%2A> collection associé au <xref:System.Windows.Forms.Application>.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnFormClosed%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Substitution de cette méthode est la méthode recommandée pour gérer l’événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosing (e As FormClosingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosing(System::Windows::Forms::FormClosingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.FormClosingEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.FormClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnFormClosing%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGetDpiScaledSize (deviceDpiOld As Integer, deviceDpiNew As Integer, ByRef desiredSize As Size) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnGetDpiScaledSize(int deviceDpiOld, int deviceDpiNew, System::Drawing::Size % desiredSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">La valeur en DPI du périphérique d’affichage dans lequel le formulaire était précédemment affiché.</param>
        <param name="deviceDpiNew">La valeur en DPI du périphérique d’affichage dans lequel le formulaire sera affiché.</param>
        <param name="desiredSize">
          <see cref="T:System.Drawing.Size" /> représentant la nouvelle taille du formulaire en fonction de la nouvelle valeur en DPI.</param>
        <summary>Déclenche l’événement GetDpiScaledSize.</summary>
        <returns>
          <see langword="true" /> en cas de réussite ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpButtonClicked (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpButtonClicked(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.ComponentModel.CancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
        <altmember cref="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanged (e As InputLanguageChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanged(System::Windows::Forms::InputLanguageChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanging (e As InputLanguageChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanging(System::Windows::Forms::InputLanguageChangingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.Load" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnLoad%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximizedBoundsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximizedBoundsChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMdiChildActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMdiChildActivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.MdiChildActivate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.MenuComplete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnMenuComplete%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuComplete" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuStart (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuStart(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.MenuStart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnMenuStart%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuStart" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMinimumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMinimumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.PaintEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.Resize" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeBegin (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeBegin(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.ResizeBegin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ResizeBegin> événement est déclenché seulement si du formulaire <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> est définie sur `true`.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnResizeBegin%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeEnd (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeEnd(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.ResizeEnd" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ResizeEnd> événement est déclenché seulement si du formulaire <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> est définie sur `true`.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnResizeEnd%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le formulaire actuel ou l’un de ses parents dispose de ressources, le <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> méthode retournera sans exécuter d’action. Si le <xref:System.Windows.Forms.Control.RightToLeft%2A> propriété du formulaire a la valeur <xref:System.Windows.Forms.RightToLeft.Yes>, puis les handles du formulaire et ses contrôles enfants seront recréés via des appels à la <xref:System.Windows.Forms.Control.RecreateHandle%2A> (méthode).  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Form.Dispose" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShown (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShown(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Form.Shown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.Shown> événement se produit chaque fois que le formulaire est affiché en premier.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnShown%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.StyleChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution de <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le niveau d'opacité du formulaire.</summary>
        <value>Niveau d'opacité du formulaire. La valeur par défaut est 1,00.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.Opacity%2A> propriété vous permet de spécifier le niveau de transparence du formulaire et ses contrôles. Lorsque cette propriété est définie à une valeur inférieure à 100 pour cent (1,00), le formulaire entier, y compris les bordures, est effectué plus transparent. Définition de cette propriété sur la valeur 0 pour cent (0,00), le formulaire est complètement invisible. Vous pouvez utiliser cette propriété pour fournir différents niveaux de transparence ou pour fournir des effets tels que la suppression d’un formulaire dans ou hors de l’affichage. Par exemple, pour progressivement un formulaire dans l’affichage en définissant le <xref:System.Windows.Forms.Form.Opacity%2A> propriété à une valeur de 0 pour cent (0,00) et l’augmenter progressivement la valeur jusqu'à atteindre 100 pour cent (1,00).  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> diffère de la transparence fournie par le <xref:System.Windows.Forms.Form.TransparencyKey%2A>, ce qui permet uniquement d’un formulaire et ses si complètement transparent contrôles sont la même couleur que la valeur spécifiée dans le <xref:System.Windows.Forms.Form.TransparencyKey%2A> propriété.  
  
 Cette propriété n’est pas pris en charge lorsque <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> est `true`.  
  
 Le <xref:System.Windows.Forms.Form.Opacity%2A> propriété dépend de l’API Layered Windows qui a été introduit avec Windows 2000. Pour plus d’informations, consultez « En couche Windows : A New moyen pour utiliser la transparence et transparence effets dans Windows Applications » dans la documentation Platform SDK à [ http://msdn.microsoft.com ](http://msdn.microsoft.com/).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un formulaire qui s’affiche avec un niveau d’opacité de 75 pour cent. L’exemple de code crée un formulaire qui se trouve dans le centre de l’écran avec un <xref:System.Windows.Forms.Form.Opacity%2A> propriété définie pour modifier le niveau d’opacité du formulaire. L’exemple de code définit également la <xref:System.Windows.Forms.Form.Size%2A> propriété pour fournir une plus grande taille de formulaire à la taille par défaut du formulaire. Cet exemple de code a été écrit en supposant que la méthode définie dans cet exemple est appelée à partir d’un autre formulaire dans un gestionnaire d’événements ou l’autre méthode.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TransparencyKey" />
        <altmember cref="F:System.Windows.Forms.OSFeature.LayeredWindows" />
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedForms As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ OwnedForms { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un tableau d'objets <see cref="T:System.Windows.Forms.Form" /> représentant tous les formulaires appartenant à ce formulaire.</summary>
        <value>Tableau <see cref="T:System.Windows.Forms.Form" /> représentant les formulaires appartenant à ce formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne un tableau qui contient tous les formulaires appartenant à ce formulaire. Pour qu’un formulaire détenu par un autre formulaire, appelez le <xref:System.Windows.Forms.Form.AddOwnedForm%2A> (méthode). Le formulaire assigné au formulaire propriétaire lui appartiendra jusqu'à ce que le <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> méthode est appelée. Vous pouvez également rendre un formulaire détenu par un autre en définissant le <xref:System.Windows.Forms.Form.Owner%2A> propriété avec une référence à son formulaire propriétaire.  
  
 Lorsqu’un formulaire est détenu par un autre formulaire, il est fermé ou masqué le formulaire propriétaire. Par exemple, considérez un formulaire nommé `Form2` qui appartient à un formulaire nommé `Form1`. Si `Form1` est fermé ou réduit, `Form2` est également fermé ou masqué. L’appartenance n’est jamais affichés derrière son propriétaire. Vous pouvez utiliser des formulaires détenus pour les fenêtres Rechercher et remplacer, qui ne doit pas être affiché derrière le formulaire propriétaire lorsque le formulaire propriétaire est sélectionné.  
  
> [!NOTE]
>  Si le formulaire est un formulaire parent de l’interface multidocument (MDI), cette propriété retourne tous les formulaires qui sont affichés à l’exception des formulaires enfants MDI qui sont actuellement ouverts. Pour obtenir les formulaires enfants MDI ouverts dans un formulaire MDI parent, utilisez la <xref:System.Windows.Forms.Form.MdiChildren%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.OwnedForms%2A> propriété à modifier tous les formulaires appartenant au formulaire propriétaire. La première méthode dans l’exemple ajoute des formulaires au tableau de formulaires détenus associés à ce formulaire. La seconde méthode effectue une itération sur tous les formulaires détenus et modifie la légende. Cet exemple requiert que les deux méthodes sont appelées par un événement ou une autre méthode d’un formulaire.  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ Owner { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le formulaire propriétaire de ce formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> qui représente le formulaire auquel appartient ce formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour mettre un formulaire détenu par un autre formulaire, affectez son <xref:System.Windows.Forms.Form.Owner%2A> propriété une référence au formulaire qui sera le propriétaire.  
  
 Lorsqu’un formulaire est détenu par un autre formulaire, il est fermé ou masqué le formulaire propriétaire. Par exemple, considérez un formulaire nommé `Form2` qui appartient à un formulaire nommé `Form1`. Si `Form1` est fermé ou réduit, `Form2` est également fermé ou masqué. L’appartenance n’est jamais affichés derrière son propriétaire. Vous pouvez utiliser des formulaires détenus pour les fenêtres Rechercher et remplacer, qui ne doivent pas disparaître lorsque le formulaire propriétaire est sélectionné. Pour déterminer les formulaires appartenant à un formulaire parent, utilisez la <xref:System.Windows.Forms.Form.OwnedForms%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Une fenêtre de niveau supérieur ne peut pas avoir de propriétaire.</exception>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">
          <see cref="T:System.Windows.Forms.Message" />, passé par référence, qui représente le message Win32 à traiter.</param>
        <param name="keyData">Une des valeurs <see cref="T:System.Windows.Forms.Keys" /> qui représente la touche à traiter.</param>
        <summary>Traite une touche de commande.</summary>
        <returns>
          <see langword="true" /> si la séquence de touches a été traitée et utilisée par le contrôle ; sinon, <see langword="false" /> pour autoriser un traitement supplémentaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ProcessCmdKey%2A> substitue (méthode)  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType> implémentation pour fournir une gestion supplémentaire des touches de commande de menu principal et des accélérateurs MDI.  
  
 Pour plus d’informations sur les séquences de touches de recouvrement, consultez « Comment intercepter les séquences de touches dans les contrôles à l’aide de Visual c# » et « Comment intercepter les séquences de touches dans .NET contrôle à l’aide de Visual Basic .NET » dans la Base de connaissances Microsoft à http://support.microsoft.com.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Caractère à traiter.</param>
        <summary>Traite un caractère de boîte de dialogue.</summary>
        <returns>
          <see langword="true" /> si le caractère a été traité par le contrôle ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Une des valeurs <see cref="T:System.Windows.Forms.Keys" /> qui représente la touche à traiter.</param>
        <summary>Traite une touche de boîte de dialogue.</summary>
        <returns>
          <see langword="true" /> si la séquence de touches a été traitée et utilisée par le contrôle ; sinon, <see langword="false" /> pour autoriser un traitement supplémentaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ProcessDialogKey%2A> méthode substitue à la base de <xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType> l’implémentation pour fournir une gestion supplémentaire des touches retour et d’échappement dans les boîtes de dialogue. La méthode n’exécute aucun traitement sur les séquences de touches qui incluent les modificateurs ALT ou contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" />, passé par référence, qui représente le message de fenêtre à traiter.</param>
        <summary>Affiche un aperçu d'un message du clavier.</summary>
        <returns>
          <see langword="true" /> si le message a été traité par le contrôle ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Caractère à traiter.</param>
        <summary>Traite un caractère mnémonique.</summary>
        <returns>
          <see langword="true" /> si le caractère a été traité comme un mnémonique par le contrôle ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessTabKey(bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see langword="true" /> pour parcourir un à un les contrôles dans ContainerControl ; sinon, <see langword="false" />.</param>
        <summary>Sélectionne le contrôle suivant disponible et en fait le contrôle actif.</summary>
        <returns>
          <see langword="true" /> si un contrôle est sélectionné ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">
          <see cref="T:System.Windows.Forms.Form" /> représentant le formulaire à supprimer de la liste des formulaires détenus par ce formulaire.</param>
        <summary>Supprime de ce formulaire un formulaire qu'il détient.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le formulaire assigné au formulaire propriétaire appartiendra jusqu'à ce que le <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> méthode est appelée. En plus de la suppression de ce formulaire à partir de la liste de formulaire, cette méthode définit le formulaire propriétaire `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeBegin As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeBegin;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un formulaire passe en mode de redimensionnement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ResizeBegin> événement est déclenché lorsque l’utilisateur commence à redimensionner un formulaire, en général en faisant glisser les bordures ou la poignée de dimensionnement située dans le coin inférieur droit du formulaire. Cette action met le formulaire dans une boucle modale de redimensionnement jusqu'à ce que l’opération de redimensionnement est terminée. En règle générale, le jeu d’événements suivant se produit pendant une opération de redimensionnement :  
  
1.  Un seul <xref:System.Windows.Forms.Form.ResizeBegin> événement se produit lorsque le formulaire passe en mode de redimensionnement.  
  
2.  Zéro ou plusieurs paires de <xref:System.Windows.Forms.Control.Resize> et <xref:System.Windows.Forms.Control.SizeChanged> se produisent lorsque le formulaire <xref:System.Windows.Forms.Form.Size%2A> est modifiée.  
  
3.  Un seul <xref:System.Windows.Forms.Form.ResizeEnd> événement se produit lorsque le formulaire quitte le mode de redimensionnement.  
  
> [!NOTE]
>  Bouton sans faire glisser une bordure ou la poignée de redimensionnement générera le <xref:System.Windows.Forms.Form.ResizeBegin> et <xref:System.Windows.Forms.Form.ResizeEnd> événements sans les intermédiaires <xref:System.Windows.Forms.Control.Resize> et <xref:System.Windows.Forms.Control.SizeChanged> les paires d’événements.  
  
 Le <xref:System.Windows.Forms.Form.ResizeBegin> et <xref:System.Windows.Forms.Form.ResizeEnd> paire d’événements est également déclenché lorsque l’utilisateur déplace le formulaire, en général en faisant glisser la souris sur la barre de légende. Ces événements sont générés pas par manipulation de l’écran, par exemple en modifiant la <xref:System.Windows.Forms.Form.Size%2A> ou <xref:System.Windows.Forms.Control.Location%2A> propriétés.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.ResizeBegin> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.ResizeBegin> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeEnd As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeEnd;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un formulaire quitte le mode de redimensionnement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ResizeEnd> événement est déclenché lorsque l’utilisateur termine le redimensionnement d’un formulaire, en général en faisant glisser les bordures ou la poignée de dimensionnement située dans le coin inférieur droit du formulaire, puis en la relâchant. Pour plus d’informations sur l’opération de redimensionnement, consultez le <xref:System.Windows.Forms.Form.ResizeBegin> événement.  
  
 Le <xref:System.Windows.Forms.Form.ResizeEnd> événement est également généré une fois que l’utilisateur déplace un formulaire, en général en faisant glisser la souris sur la barre de légende. Cet événement n’est pas généré par manipulation de l’écran, par exemple en modifiant la <xref:System.Windows.Forms.Form.Size%2A> ou <xref:System.Windows.Forms.Control.Location%2A> propriétés.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.ResizeEnd> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.ResizeEnd> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle RestoreBounds { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'emplacement et la taille du formulaire dans son état de fenêtre normal.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> qui contient l'emplacement et la taille du formulaire dans l'état de fenêtre normal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En général, vous utilisez le <xref:System.Windows.Forms.Form.RestoreBounds%2A> propriété pour effectuer le suivi de la taille de la fenêtre de l’utilisateur et de position des préférences pour le formulaire dans son état de fenêtre normal. Vous devez suivre les deux la valeur de la <xref:System.Windows.Forms.Form.WindowState%2A> et <xref:System.Windows.Forms.Form.RestoreBounds%2A> lors du suivi des préférences de l’utilisateur de la fenêtre de propriétés.  
  
> [!NOTE]
>  La valeur de la <xref:System.Windows.Forms.Form.RestoreBounds%2A> propriété est valide uniquement lorsque le <xref:System.Windows.Forms.Form.WindowState%2A> propriété de la <xref:System.Windows.Forms.Form> classe n’est pas égal à <xref:System.Windows.Forms.FormWindowState.Normal>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeftLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RightToLeftLayout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'effet miroir de droite à gauche est activé.</summary>
        <value>
          <see langword="true" /> si l'effet miroir de droite à gauche est activé ; sinon, <see langword="false" /> pour obtenir un positionnement de contrôle enfant standard. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> propriété est surtout utile pour développer des formulaires mondialisables pour des audiences internationales. De nombreux formulaires sont conçus afin que la disposition des contrôles sur un formulaire dans une disposition de gauche à droite. Ces formes sont compatibles avec les langues qui écrivent dans ce sens. Toutefois, lorsque vous affichez les mêmes formes aux utilisateurs de langues de droite à gauche, il est souvent préférable d’inverser l’ordre des contrôles sur le formulaire. Si les deux le <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> et <xref:System.Windows.Forms.Control.RightToLeft%2A> propriétés sont `true`, la mise en miroir est activée pour le formulaire et un positionnement de contrôle et flux de texte seront de droite à gauche.  
  
 Contrairement aux <xref:System.Windows.Forms.Control.RightToLeft%2A>, <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> n’hérite pas. Si vous souhaitez qu’il prenne effet pour les contrôles enfants, vous devez le définir sur chaque contrôle enfant que vous souhaitez mettre en miroir.  
  
 En mode owner draw n’est pas pris en charge lorsque <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> a la valeur `Yes`. Les événements owner draw seront produisent toujours, mais le comportement de tout code que vous créez dans ces événements n’est pas défini. En outre, <xref:System.Windows.Forms.Control.BackgroundImage%2A>, <xref:System.Windows.Forms.Form.Opacity%2A>, <xref:System.Windows.Forms.Form.TransparencyKey%2A>, et les événements de peinture ne sont pas pris en charge.  
  
 Le <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> et <xref:System.Windows.Forms.Control.RightToLeft%2A> propriétés provoquent les styles de fenêtre d’API Win32 suivants à définir :  
  
-   Lorsque <xref:System.Windows.Forms.Control.RightToLeft%2A> a la valeur `Yes` et <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> a la valeur `true`, Windows Forms définit le `WS_EX_LAYOUTRTL` style de fenêtre et supprime la `WS_EX_RIGHT` et `WS_EX_RTLREADING` styles.  
  
-   Lorsque <xref:System.Windows.Forms.Control.RightToLeft%2A> a la valeur `Yes` mais <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> a la valeur `No`, Windows Forms définit le `WS_EX_RIGHT` et `WS_EX_RTLREADING` des styles de fenêtre.  
  
 La modification de la valeur de cette propriété déclenche le <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> événement.  
  
 Pour plus d’informations sur les problèmes de globalisation, consultez [meilleures pratiques pour développer des Applications mondialisables](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une fois que la valeur de la propriété <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" /> a changé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Control.RightToLeft%2A> et <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> propriétés sont généralement utilisées pour développer des applications mondialisables.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Facteur selon lequel la hauteur et la largeur du contrôle sont mises à l'échelle.</param>
        <param name="specified">Valeur <see cref="T:System.Windows.Forms.BoundsSpecified" /> qui spécifie les limites du contrôle à utiliser pendant la définition de sa taille et de sa position.</param>
        <summary>Met à l'échelle l'emplacement, la taille, la marge intérieure et la marge d'un contrôle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleCore (x As Single, y As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleCore(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Pourcentage pour mettre le formulaire à l'échelle horizontalement</param>
        <param name="y">Pourcentage pour mettre le formulaire à l'échelle verticalement</param>
        <summary>Exécute une mise à l'échelle du formulaire.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">Si la valeur est true, le contrôle actif est modifié</param>
        <param name="forward">Si directed a la valeur true, cela contrôle la direction dans laquelle le focus est déplacé. Si la valeur est <see langword="true" />, le contrôle suivant est sélectionné ; sinon, le contrôle précédent est sélectionné.</param>
        <summary>Sélectionne ce formulaire, et éventuellement sélectionne le contrôle suivant ou précédent.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour changer le focus. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nouvelle valeur de la propriété <see cref="P:System.Windows.Forms.Control.Left" /> du contrôle.</param>
        <param name="y">Nouvelle valeur de la propriété <see cref="P:System.Windows.Forms.Control.Top" /> du contrôle.</param>
        <param name="width">Nouvelle valeur de la propriété <see cref="P:System.Windows.Forms.Control.Width" /> du contrôle.</param>
        <param name="height">Nouvelle valeur de la propriété <see cref="P:System.Windows.Forms.Control.Height" /> du contrôle.</param>
        <param name="specified">Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Exécute le travail de définition des limites spécifiées de ce contrôle.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetClientSizeCore(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Largeur demandée de la zone du client.</param>
        <param name="y">Hauteur demandée de la zone du client.</param>
        <summary>Définit la taille du client du formulaire. Ainsi, les limites du formulaire sont ajustées pour dimensionner la taille du client à la taille demandée.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordonnée x de la position du formulaire.</param>
        <param name="y">Coordonnée y de la position du formulaire.</param>
        <param name="width">Largeur du formulaire.</param>
        <param name="height">Hauteur du formulaire.</param>
        <summary>Définit les limites du formulaire par rapport aux coordonnées du bureau.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coordonnées du bureau sont basées sur l’espace de travail de l’écran, qui exclut la barre des tâches. Vous pouvez utiliser cette méthode pour définir la position et la taille de votre formulaire sur le bureau. Étant donné que les coordonnées du bureau sont basées sur l’espace de travail de l’écran, vous pouvez utiliser cette méthode pour vous assurer que votre formulaire est complètement visible sur le bureau.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.SetDesktopBounds%2A> (méthode). Pour exécuter cet exemple, collez le code suivant dans un formulaire qui contient un bouton nommé `Button2`. Assurez-vous que tous les événements sont associés à leurs gestionnaires d’événements.  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopLocation (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopLocation(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordonnée x de la position du formulaire.</param>
        <param name="y">Coordonnée y de la position du formulaire.</param>
        <summary>Définit la position du formulaire dans les coordonnées du bureau.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coordonnées du bureau sont basées sur l’espace de travail de l’écran, qui exclut la barre des tâches. Vous pouvez utiliser cette méthode pour positionner le formulaire sur le bureau. Étant donné que les coordonnées du bureau sont basées sur l’espace de travail de l’écran, vous pouvez utiliser cette méthode pour vous assurer que votre formulaire est complètement visible sur le bureau. Cette méthode est destinée à être utilisée principalement pour les écrans de niveau supérieur ; Utilisez la <xref:System.Windows.Forms.Form.LayoutMdi%2A> méthode pour placer des formulaires enfants de l’interface multidocument (MDI).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> et <xref:System.Windows.Forms.Form.Activate%2A> membres. Pour exécuter l’exemple, collez le code suivant dans un formulaire nommé `Form1` contenant un bouton nommé `Button1` et deux `Label` contrôles appelés `Label1` et `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetVisibleCore(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" /> pour rendre le contrôle visible ; sinon, <see langword="false" />.</param>
        <summary>Définit le contrôle à l'état visible spécifié.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show (owner As IWin32Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Tout objet qui implémente <see cref="T:System.Windows.Forms.IWin32Window" /> et représente la fenêtre de niveau supérieur qui sera propriétaire de ce formulaire.</param>
        <summary>Affiche le formulaire avec le propriétaire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour afficher un formulaire non modal. Lorsque vous utilisez cette méthode, le <xref:System.Windows.Forms.Form.Owner%2A> du formulaire est définie sur `owner`. Le formulaire non modal peut utiliser le <xref:System.Windows.Forms.Form.Owner%2A> propriété à obtenir des informations sur le formulaire propriétaire.  Appel de cette méthode revient à affecter à la <xref:System.Windows.Forms.Form.Owner%2A> propriété de la non modale, puis en appelant le <xref:System.Windows.Forms.Control.Show> (méthode).  
  
 Affichage du formulaire revient à affecter la <xref:System.Windows.Forms.Control.Visible%2A> propriété `true`. Après le <xref:System.Windows.Forms.Form.Show%2A> méthode est appelée, le <xref:System.Windows.Forms.Control.Visible%2A> propriété retourne une valeur de `true` jusqu'à ce que le <xref:System.Windows.Forms.Control.Hide%2A> méthode est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le formulaire affiché est déjà visible.  
  
 - ou -  
  
 Le formulaire spécifié par le paramètre <paramref name="owner" /> est le même que le formulaire affiché.  
  
 - ou -  
  
 Le formulaire affiché est désactivé.  
  
 - ou -  
  
 Le formulaire affiché n'est pas une fenêtre de niveau supérieur.  
  
 - ou -  
  
 Le formulaire affiché comme une boîte de dialogue est déjà un formulaire modal.  
  
 - ou -  
  
 Le processus actuel ne s'exécute pas en mode interactif avec l'utilisateur (pour plus d'informations, consultez <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="Overload:System.Windows.Forms.Form.ShowDialog" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowDialog">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Affiche le formulaire comme une boîte de dialogue modale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Affiche le formulaire comme une boîte de dialogue modale.</summary>
        <returns>Une des valeurs de <see cref="T:System.Windows.Forms.DialogResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour afficher une boîte de dialogue modale dans votre application. Lorsque cette méthode est appelée, le code suivant n’est pas exécuté tant qu’après la fermeture de la boîte de dialogue. La boîte de dialogue peut avoir une des valeurs de la <xref:System.Windows.Forms.DialogResult> énumération en l’assignant à la <xref:System.Windows.Forms.Button.DialogResult%2A> propriété d’un <xref:System.Windows.Forms.Button> sur le formulaire ou en définissant le <xref:System.Windows.Forms.Form.DialogResult%2A> propriété du formulaire dans le code. Cette valeur est ensuite retournée par cette méthode. Vous pouvez utiliser cette valeur de retour pour déterminer comment traiter les actions qui s’est produite dans la boîte de dialogue. Par exemple, si la boîte de dialogue a été fermée et retournée le `DialogResult.Cancel` valeur via cette méthode, vous pouvez empêcher le code qui suit l’appel à <xref:System.Windows.Forms.Form.ShowDialog%2A> à partir de l’exécution.  
  
 Lorsqu’un formulaire est affiché en tant que boîte de dialogue modale, en cliquant sur le **fermer** bouton (le bouton avec un X sur le coin supérieur droit du formulaire) entraîne le masquage du formulaire et la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété à définir `DialogResult.Cancel`. Contrairement aux formulaires de non modale, la <xref:System.Windows.Forms.Form.Close%2A> méthode n’est pas appelée par le .NET Framework lorsque l’utilisateur clique sur le bouton de fermeture du formulaire de boîte de dialogue ou définit la valeur de la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété. Au lieu de cela, le formulaire est masqué et peut être affiché à nouveau sans créer une nouvelle instance de la boîte de dialogue. Car un formulaire est affiché comme une boîte de dialogue est masquée à la place de fermeture, vous devez appeler la <xref:System.Windows.Forms.Control.Dispose%2A> méthode du formulaire lorsque le formulaire n’est plus nécessaire par votre application.  
  
 Cette version de la <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode ne spécifie pas un formulaire ou un contrôle comme son propriétaire. Lorsque cette version est appelée, la fenêtre actuellement active devient propriétaire de la boîte de dialogue. Si vous souhaitez spécifier un propriétaire spécifique, utilisez l’autre version de cette méthode.  
  
   
  
## Examples  
 L’exemple de code suivant affiche un formulaire sous la forme d’une boîte de dialogue modale et évalue la valeur de retour de la boîte de dialogue avant de déterminer s’il faut lire la valeur d’un <xref:System.Windows.Forms.TextBox> contrôle sur le formulaire de boîte de dialogue. Cet exemple suppose qu’un <xref:System.Windows.Forms.Form> nommé `testDialog` est créé et qu’il contient un <xref:System.Windows.Forms.TextBox> contrôle nommé `TextBox1`. En outre, l’exemple requiert que le code dans cet exemple est contenu et appelé à partir d’une autre <xref:System.Windows.Forms.Form> afin d’afficher `testDialog` en tant que boîte de dialogue modale. L’exemple utilise la version de <xref:System.Windows.Forms.Form.ShowDialog%2A> qui spécifie un propriétaire pour la boîte de dialogue.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le formulaire affiché est déjà visible.  
  
 - ou -  
  
 Le formulaire affiché est désactivé.  
  
 - ou -  
  
 Le formulaire affiché n'est pas une fenêtre de niveau supérieur.  
  
 - ou -  
  
 Le formulaire affiché comme une boîte de dialogue est déjà un formulaire modal.  
  
 - ou -  
  
 Le processus actuel ne s'exécute pas en mode interactif avec l'utilisateur (pour plus d'informations, consultez <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog (owner As IWin32Window) As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Tout objet qui implémente <see cref="T:System.Windows.Forms.IWin32Window" /> et représente la fenêtre de niveau supérieur à laquelle va appartenir la boîte de dialogue modale.</param>
        <summary>Affiche le formulaire comme une boîte de dialogue modale avec le propriétaire spécifié.</summary>
        <returns>Une des valeurs de <see cref="T:System.Windows.Forms.DialogResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour afficher une boîte de dialogue modale dans votre application. Lorsque cette méthode est appelée, le code suivant n’est pas exécuté tant qu’après la fermeture de la boîte de dialogue. La boîte de dialogue peut avoir une des valeurs de <xref:System.Windows.Forms.DialogResult> en l’assignant à la <xref:System.Windows.Forms.Button.DialogResult%2A> propriété d’un <xref:System.Windows.Forms.Button> sur le formulaire ou en définissant le <xref:System.Windows.Forms.Form.DialogResult%2A> propriété du formulaire dans le code. Cette valeur est ensuite retournée par cette méthode. Vous pouvez utiliser cette valeur de retour pour déterminer comment traiter les actions qui s’est produite dans la boîte de dialogue. Par exemple, si la boîte de dialogue a été fermée et retournée le `DialogResult.Cancel` valeur via cette méthode, vous pouvez empêcher le code qui suit l’appel à <xref:System.Windows.Forms.Form.ShowDialog%2A> à partir de l’exécution.  
  
 Lorsqu’un formulaire est affiché en tant que boîte de dialogue modale, en cliquant sur le **fermer** bouton (le bouton avec un X sur le coin supérieur droit du formulaire) entraîne le masquage du formulaire et la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété à définir `DialogResult.Cancel`. Contrairement aux formulaires non modales, la <xref:System.Windows.Forms.Form.Close%2A> méthode n’est pas appelée par le .NET Framework lorsque l’utilisateur clique sur le bouton de fermeture du formulaire de boîte de dialogue ou définit la valeur de la <xref:System.Windows.Forms.Form.DialogResult%2A> propriété. Au lieu de cela, le formulaire est masqué et peut être affiché à nouveau sans créer une nouvelle instance de la boîte de dialogue. Car un formulaire est affiché comme une boîte de dialogue est masquée à la place de fermeture, vous devez appeler la <xref:System.Windows.Forms.Control.Dispose%2A> méthode du formulaire lorsque le formulaire n’est plus nécessaire par votre application.  
  
 Cette version de la <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode vous permet de spécifier un formulaire spécifique qui sera propriétaire de la boîte de dialogue qui s’affiche.  
  
   
  
## Examples  
 L’exemple de code suivant affiche un formulaire sous la forme d’une boîte de dialogue modale et évalue la valeur de retour de la boîte de dialogue avant de déterminer s’il faut lire la valeur d’un <xref:System.Windows.Forms.TextBox> contrôle sur le formulaire de boîte de dialogue. Cet exemple suppose qu’un <xref:System.Windows.Forms.Form> nommé `Form2` est créé et qu’il contient un <xref:System.Windows.Forms.TextBox> contrôle nommé `TextBox1`. L’exemple utilise la version de <xref:System.Windows.Forms.Form.ShowDialog%2A> qui spécifie un propriétaire pour la boîte de dialogue.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le formulaire spécifié par le paramètre <paramref name="owner" /> est le même que le formulaire affiché.</exception>
        <exception cref="T:System.InvalidOperationException">Le formulaire affiché est déjà visible.  
  
 - ou -  
  
 Le formulaire affiché est désactivé.  
  
 - ou -  
  
 Le formulaire affiché n'est pas une fenêtre de niveau supérieur.  
  
 - ou -  
  
 Le formulaire affiché comme une boîte de dialogue est déjà un formulaire modal.  
  
 - ou -  
  
 Le processus actuel ne s'exécute pas en mode interactif avec l'utilisateur (pour plus d'informations, consultez <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowIcon As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowIcon { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si une icône est affichée dans la barre de légende du formulaire.</summary>
        <value>
          <see langword="true" /> si le formulaire affiche une icône dans la barre de légende ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.ShowIcon%2A> propriété contient un <xref:System.Boolean> valeur qui indique si du formulaire <xref:System.Windows.Forms.Form.Icon%2A> s’affiche dans la barre de légende du formulaire. Si le <xref:System.Windows.Forms.Form.ControlBox%2A> propriété est `false`, l’icône et le contrôle de zone seront supprimées.  
  
 Si <xref:System.Windows.Forms.Form.ShowIcon%2A> est `false` lorsque le formulaire principal est affiché, une icône générique s’affichera dans le bouton de barre des tâches de l’application.  
  
 Cette propriété n’a aucun effet si <xref:System.Windows.Forms.Form.FormBorderStyle%2A> a la valeur <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>. Dans ce cas, le formulaire n’affiche pas d’icône.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Icon" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le formulaire est affiché dans la barre des tâches Windows.</summary>
        <value>
          <see langword="true" /> pour afficher le formulaire dans la barre des tâches Windows au moment de l'exécution ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un formulaire est apparenté à un autre formulaire, le formulaire apparenté n’est pas affiché dans la barre des tâches Windows.  
  
 Vous pouvez utiliser cette propriété pour empêcher les utilisateurs de sélectionner votre formulaire via la barre des tâches Windows. Par exemple, si vous affichez une fenêtre outil Rechercher et remplacer dans votre application, vous pouvez souhaiter empêcher cette fenêtre à partir de la sélection via la barre des tâches Windows, car vous devriez fenêtre principale de l’application et la fenêtre outil Rechercher et remplacer affichées afin de traiter efficacement les recherches.  
  
 Vous souhaiterez souvent utiliser cette propriété lors de la création d’un formulaire avec le <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> style. Définition de la <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> style ne garantit pas seul qu’une fenêtre n’apparaîtra pas dans la barre des tâches.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Form.ShowInTaskbar%2A> propriété pour qu’une boîte de dialogue zone qui n’est pas affichée dans la barre des tâches Windows.  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Shown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Shown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit à chaque fois que le formulaire est affiché en premier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.Shown> événement est déclenché uniquement la première fois qu’un formulaire est affiché ; par la suite en réduisant, optimiser, restauration, le masquage, afficher, ou invalider et repeindre ne génère pas cet événement. Pour plus d’informations sur l’ordre des événements d’un formulaire, consultez [ordre des événements dans les Windows Forms](~/docs/framework/winforms/order-of-events-in-windows-forms.md).  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements indique l’occurrence de le <xref:System.Windows.Forms.Form.Shown> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un élément <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.Form> nommé `Form1`. Vérifiez que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Form.Shown> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowWithoutActivation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowWithoutActivation { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la fenêtre sera activée lorsqu'elle sera affichée.</summary>
        <value>
          <see langword="True" /> si la fenêtre ne doit pas être activée lors de son affichage ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété si vous souhaitez afficher une fenêtre de niveau supérieur, mais ne souhaitez pas interrompre le travail de l’utilisateur en prenant le focus d’entrée en dehors de la fenêtre active. Il peut s’agir d’une fenêtre d’information ou une fenêtre flottante, comme une palette d’outils dans l’application de la peinture.  
  
 Étant donné que cette propriété est en lecture seule, vous pouvez uniquement modifier sa valeur en substituant <xref:System.Windows.Forms.Form.ShowWithoutActivation%2A> dans votre propre formulaire et la programmation de lui permettre de retourner `true`.  
  
 Si votre fenêtre non activée doit utiliser des contrôles d’interface utilisateur, vous devez envisager d’utiliser le <xref:System.Windows.Forms.ToolStrip> contrôles, tels que <xref:System.Windows.Forms.ToolStripDropDown>. Ces contrôles sont sans fenêtre et n’entraîne pas une fenêtre pour activer lorsqu’ils sont sélectionnés.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille du formulaire.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> qui représente la taille du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet de définir la hauteur et la largeur (en pixels) de l’écran en même temps au lieu de définir la <xref:System.Windows.Forms.Control.Height%2A> et <xref:System.Windows.Forms.Control.Width%2A> propriétés individuellement. Si vous souhaitez définir la taille et l’emplacement d’un formulaire, vous pouvez utiliser la <xref:System.Windows.Forms.Form.DesktopBounds%2A> à la taille et localisez le formulaire basé sur les coordonnées du bureau ou utilisez le <xref:System.Windows.Forms.Control.Bounds%2A> propriété de la <xref:System.Windows.Forms.Control> classe pour définir la taille et l’emplacement du formulaire basé sur les coordonnées d’écran inates.  
  
> [!NOTE]
>  La valeur maximale de cette propriété est limitée par la résolution de l’écran sur lequel s’exécute le formulaire. La valeur ne peut pas être supérieure à 12 pixels chaque dimension d’écran (horizontal + 12 et vertical + 12).  
  
> [!NOTE]
>  Sur les périphériques Pocket PC, vous pouvez créer une fenêtre redimensionnable en définissant <xref:System.Windows.Forms.Form.FormBorderStyle%2A> à `None` et en supprimant les <xref:System.Windows.Forms.MainMenu> contrôle. Sur les périphériques SmartPhone, vous ne pouvez jamais redimensionner un <xref:System.Windows.Forms.Form> -il occupe toujours la totalité de l’écran.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un formulaire qui s’affiche avec un niveau d’opacité de 75 pour cent. L’exemple de code crée un formulaire qui se trouve dans le centre de l’écran avec un <xref:System.Windows.Forms.Form.Opacity%2A> propriété définie pour modifier le niveau d’opacité du formulaire. L’exemple de code définit également la <xref:System.Windows.Forms.Form.Size%2A> propriété pour fournir une plus grande taille de formulaire à la taille par défaut du formulaire. Cet exemple requiert que la méthode définie dans cet exemple est appelée à partir d’un autre formulaire dans un gestionnaire d’événements ou l’autre méthode.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeGripStyle As SizeGripStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::SizeGripStyle SizeGripStyle { System::Windows::Forms::SizeGripStyle get(); void set(System::Windows::Forms::SizeGripStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style de la poignée de dimensionnement à afficher dans le coin inférieur droit du formulaire.</summary>
        <value>
          <see cref="T:System.Windows.Forms.SizeGripStyle" /> représentant le style de la poignée de dimensionnement à afficher. La valeur par défaut est <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet de déterminer quand la poignée de dimensionnement est affichée sur le formulaire. Vous pouvez définir cette propriété pour afficher la poignée de dimensionnement ou automatiquement en fonction du paramètre de la <xref:System.Windows.Forms.Form.FormBorderStyle%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment masquer la poignée de dimensionnement pour une <xref:System.Windows.Forms.Form> lorsque le <xref:System.Windows.Forms.Form> n’est pas redimensionnable.  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée ne figure pas dans la plage des valeurs valides.</exception>
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="T:System.Windows.Forms.SizeGripStyle" />
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property StartPosition As FormStartPosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormStartPosition StartPosition { System::Windows::Forms::FormStartPosition get(); void set(System::Windows::Forms::FormStartPosition value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position initiale du formulaire au moment de l'exécution.</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormStartPosition" /> représentant la position initiale du formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet de définir la position de départ du formulaire lorsqu’il est affiché au moment de l’exécution. La position du formulaire peut être spécifiée manuellement en définissant le <xref:System.Windows.Forms.Form.Location%2A> propriété ou utiliser l’emplacement par défaut spécifié par Windows. Vous pouvez également placer le formulaire à afficher dans le centre de l’écran ou dans le centre de son formulaire parent pour les formulaires tels que les formulaires enfants de l’interface multidocument (MDI).  
  
 Cette propriété doit être définie avant que le formulaire s’affiche.  Vous pouvez définir cette propriété avant d’appeler le <xref:System.Windows.Forms.Form.Show%2A> ou <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode ou dans le constructeur de votre formulaire.  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle instance d’un <xref:System.Windows.Forms.Form> et appelle le <xref:System.Windows.Forms.Form.ShowDialog%2A> méthode pour afficher le formulaire comme une boîte de dialogue. L’exemple définit le <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, et <xref:System.Windows.Forms.Form.StartPosition%2A> propriétés pour modifier l’apparence et les fonctionnalités du formulaire à une boîte de dialogue. L’exemple utilise également la <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> méthode du formulaire <xref:System.Windows.Forms.Control.Controls%2A> collection pour ajouter deux <xref:System.Windows.Forms.Button> contrôles. L’exemple utilise le <xref:System.Windows.Forms.Form.HelpButton%2A> propriété pour afficher un bouton d’aide dans la barre de légende de la boîte de dialogue.  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée ne figure pas dans la plage des valeurs valides.</exception>
        <altmember cref="T:System.Windows.Forms.FormStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'ordre de tabulation du contrôle dans son conteneur.</summary>
        <value>Objet <see cref="T:System.Int32" /> contenant l'index du contrôle dans le jeu de contrôles de son conteneur qui est inclus dans l'ordre de tabulation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formulaires ne sont pas inclus dans l’ordre de tabulation. Définition de la <xref:System.Windows.Forms.Form.TabIndex%2A> propriété n’a aucun effet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.Form.TabIndex" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'utilisateur peut donner le focus à ce contrôle à l'aide de la touche Tab.</summary>
        <value>
          <see langword="true" /> si l'utilisateur peut donner le focus au contrôle avec la touche TAB ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la propriété <see cref="P:System.Windows.Forms.Form.TabStop" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte associé à ce contrôle.</summary>
        <value>Texte associé à ce contrôle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TopLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopLevel { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le formulaire doit s'afficher comme une fenêtre de niveau supérieur.</summary>
        <value>
          <see langword="true" /> pour afficher le formulaire comme une fenêtre de niveau supérieur ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un formulaire de niveau supérieur est une fenêtre qui n’a pas de formulaire parent, ou dont le formulaire parent est la fenêtre du bureau. Fenêtres de niveau supérieur sont généralement utilisées en tant que le formulaire principal dans une application.  
  
   
  
## Examples  
 Le code suivant par exemple le <xref:System.Windows.Forms.Form.Modal%2A> propriété pour déterminer si un formulaire est affiché comme un formulaire modal. Si elle n’est pas le <xref:System.Windows.Forms.Form.FormBorderStyle%2A> et <xref:System.Windows.Forms.Form.TopLevel%2A> propriétés sont modifiées pour rendre le formulaire non--formulaire de niveau supérieur avec une bordure de fenêtre outil.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Un formulaire parent MDI doit être une fenêtre de niveau supérieur.</exception>
        <altmember cref="P:System.Windows.Forms.Form.TopMost" />
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberSignature Language="VB.NET" Value="Public Property TopMost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopMost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le formulaire doit être affiché comme un formulaire de premier plan.</summary>
        <value>
          <see langword="true" /> pour afficher le formulaire comme un formulaire de premier plan ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un formulaire de premier plan est un formulaire qui recouvre toutes les autres formes (non-le plus haut), même si elle n’est pas le formulaire actif ou de premier plan. Formulaires de premier plan sont toujours affichés au point plus élevé dans l’ordre de plan des fenêtres sur le bureau. Vous pouvez utiliser cette propriété pour créer un formulaire qui est toujours affiché dans votre application, comme une fenêtre outil Rechercher et remplacer.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un formulaire de premier plan. L’exemple crée deux formes, qui est optimisée et qui s’affichera sous la forme d’un formulaire de premier plan. La première forme, nommée `bottomForm`, s’affiche agrandi, à l’aide de la <xref:System.Windows.Forms.Form.WindowState%2A> propriété, pour mieux illustrer les possibilités du formulaire de premier plan. La deuxième forme, nommée `topMostForm`, définit le <xref:System.Windows.Forms.Form.TopMost%2A> propriété `true` pour afficher le formulaire comme un formulaire de premier plan. Lorsque ce code est exécuté, l’en cliquant sur le formulaire agrandi provoquera pas le formulaire de premier plan à afficher sous le formulaire agrandi. L’exemple requiert que la méthode définie dans l’exemple est appelée à partir d’une autre forme.  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TopLevel" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une chaîne qui représente l'instance actuelle du formulaire.</summary>
        <returns>Chaîne qui se compose du nom qualifié complet de la classe de l'objet de formulaire, avec la propriété <see cref="P:System.Windows.Forms.Form.Text" /> du formulaire ajoutée à la fin. Par exemple, si le formulaire est dérivé de la classe <c>MyForm</c> dans l’espace de noms <c>MyNamespace</c> et que la propriété <see cref="P:System.Windows.Forms.Form.Text" /> a la valeur <c>Hello, World</c>, cette méthode retourne <c>MyNamespace.MyForm, Text: Hello, World</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberSignature Language="VB.NET" Value="Public Property TransparencyKey As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color TransparencyKey { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur qui représentera les zones transparentes du formulaire.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> qui représente la couleur transparente à afficher sur le formulaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.Form.TransparencyKey%2A> est affectée à un <xref:System.Drawing.Color>, les zones de formulaire qui ont le même <xref:System.Windows.Forms.Control.BackColor%2A> s’affichera en toute transparence. Toutes les actions de la souris, telles que le clic de souris, qui sont effectuées sur les zones transparentes du formulaire seront transférées vers le windows sous la zone transparente. Par exemple, si la zone cliente d’un formulaire est effectuée transparente, clic de souris sur cette zone envoie la notification d’événement de clic à n’importe quelle fenêtre au-dessous. Si la couleur assignée à la <xref:System.Windows.Forms.Form.TransparencyKey%2A> propriété est identique à tous les contrôles sur le formulaire, ils seront affichent également en toute transparence. Par exemple, si vous avez un <xref:System.Windows.Forms.Button> contrôle dans un formulaire qui a son <xref:System.Windows.Forms.Form.TransparencyKey%2A> propriété la valeur `SystemColors.Control`, le contrôle s’affichera en toute transparence, sauf si le <xref:System.Windows.Forms.Control.BackColor%2A> propriété de la <xref:System.Windows.Forms.Button> contrôle est remplacée par une couleur différente.  
  
 Cette propriété n’est pas pris en charge lorsque <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> est `true`.  
  
   
  
## Examples  
 L’exemple de code suivant crée une fenêtre comportant une zone cliente transparente, quelle que soit la couleur d’arrière-plan du formulaire. Cet exemple requiert que l’exemple de méthode est défini dans une classe de formulaire.  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateDefaultButton();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met à jour du bouton par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A> méthode détermine quel bouton du formulaire déclenche son événement Click lorsque l’utilisateur appuie sur entrée, en fonction de l’ordre de priorité suivant :  
  
1.  Si le <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> propriété implémente la <xref:System.Windows.Forms.IButtonControl> de l’interface, que le contrôle est le bouton par défaut.  
  
2.  Le <xref:System.Windows.Forms.Form.AcceptButton%2A> propriété est le bouton par défaut.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valide tous les contrôles enfants pouvant être sélectionnés dans le formulaire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoque la validation des données de tous les contrôles enfants d’un contrôle qui prennent en charge la validation.</summary>
        <returns>
          <see langword="true" /> si la validation de tous les enfants est réussie ; sinon, <see langword="false" />. Si cette méthode est appelée à partir des gestionnaires d’événements <see cref="E:System.Windows.Forms.Control.Validating" /> ou <see cref="E:System.Windows.Forms.Control.Validated" />, elle retourne toujours <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">Place des restrictions sur les contrôles dont l’événement <see cref="E:System.Windows.Forms.Control.Validating" /> est déclenché.</param>
        <summary>Provoque la validation des données de tous les contrôles enfants d’un contrôle qui prennent en charge la validation.</summary>
        <returns>
          <see langword="true" /> si la validation de tous les enfants est réussie ; sinon, <see langword="false" />. Si cette méthode est appelée à partir des gestionnaires d’événements <see cref="E:System.Windows.Forms.Control.Validating" /> ou <see cref="E:System.Windows.Forms.Control.Validated" />, elle retourne toujours <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As FormWindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormWindowState WindowState { System::Windows::Forms::FormWindowState get(); void set(System::Windows::Forms::FormWindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si un formulaire est réduit, agrandi ou normal.</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormWindowState" /> qui indique si le formulaire est réduit, agrandi ou normal. La valeur par défaut est <see langword="FormWindowState.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant qu’un formulaire est affiché, le <xref:System.Windows.Forms.Form.WindowState%2A> est toujours définie sur `FormWindowState.Normal`, quelle que soit sa valeur initiale. Cela se reflète dans le <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Top%2A>, et <xref:System.Windows.Forms.Control.Width%2A> les paramètres de propriété. Si un formulaire est masqué après avoir été affiché, ces propriétés reflètent l’état précédent jusqu'à ce que le formulaire s’affiche à nouveau, indépendamment de toute modification apportée à la <xref:System.Windows.Forms.Form.WindowState%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir le <xref:System.Windows.Forms.Form.WindowState%2A> à agrandie. Le code est appelé à partir de la <xref:System.Windows.Forms.Form.Shown> Gestionnaire d’événements une fois que le formulaire a été créé.  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée ne figure pas dans la plage des valeurs valides.</exception>
        <altmember cref="T:System.Windows.Forms.FormWindowState" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> Windows à traiter.</param>
        <summary>Traite les messages Windows.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>