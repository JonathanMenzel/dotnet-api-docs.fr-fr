<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e96b9a562587ce1b84c0314819619ffe1f760d2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55340283" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un élément affiché dans <see cref="T:System.Windows.Forms.MainMenu" /> ou dans <see cref="T:System.Windows.Forms.ContextMenu" />. Bien que <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> remplace et ajoute des fonctionnalités au contrôle <see cref="T:System.Windows.Forms.MenuItem" /> des versions antérieures, <see cref="T:System.Windows.Forms.MenuItem" /> est conservé pour la compatibilité descendante et l'utilisation future si tel est votre choix.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans l’ordre pour un <xref:System.Windows.Forms.MenuItem> s’affiche, vous devez l’ajouter à un <xref:System.Windows.Forms.MainMenu> ou <xref:System.Windows.Forms.ContextMenu>. Pour créer des sous-menus, vous pouvez ajouter <xref:System.Windows.Forms.MenuItem> des objets sur le <xref:System.Windows.Forms.Menu.MenuItems%2A> propriété du parent <xref:System.Windows.Forms.MenuItem>.  
  
 Le <xref:System.Windows.Forms.MenuItem> classe fournit des propriétés qui vous permettent de configurer l’apparence et les fonctionnalités d’un élément de menu. Pour afficher une case à cocher en regard d’un élément de menu, utilisez le <xref:System.Windows.Forms.MenuItem.Checked%2A> propriété. Vous pouvez utiliser cette fonctionnalité pour identifier un élément de menu est sélectionné dans une liste d’éléments de menu qui s’excluent mutuellement. Par exemple, si vous avez un ensemble d’éléments de menu permettant de définir la couleur du texte dans un <xref:System.Windows.Forms.TextBox> contrôle, vous pouvez utiliser le <xref:System.Windows.Forms.MenuItem.Checked%2A> propriété pour identifier la couleur actuellement sélectionnée. Le <xref:System.Windows.Forms.MenuItem.Shortcut%2A> propriété peut être utilisée pour définir une combinaison de touches qui peut être enfoncée pour sélectionner l’élément de menu.  
  
 Pour <xref:System.Windows.Forms.MenuItem> objets affichés dans une application d’Interface multidocument (MDI, Multiple Document Interface), vous pouvez utiliser la <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> méthode pour fusionner les menus d’un formulaire MDI parent avec ceux des formulaires enfants pour créer une structure de menus consolidée. Étant donné qu’un <xref:System.Windows.Forms.MenuItem> ne peuvent pas être réutilisés dans plusieurs emplacements en même temps, comme dans un <xref:System.Windows.Forms.MainMenu> et un <xref:System.Windows.Forms.ContextMenu>, vous pouvez utiliser la <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> méthode pour créer une copie d’un <xref:System.Windows.Forms.MenuItem> pour une utilisation dans un autre emplacement.  
  
 Le <xref:System.Windows.Forms.MenuItem.Popup> événement vous permet d’effectuer des tâches avant un menu s’affiche. Par exemple, vous pouvez créer un gestionnaire d’événements pour cet événement afficher ou masquer des éléments de menu en fonction de l’état de votre code. Le <xref:System.Windows.Forms.MenuItem.Select> événement vous permet d’effectuer des tâches telles que de fournir une aide détaillée pour les éléments de menu de votre application lorsque l’utilisateur place le pointeur de la souris sur un élément de menu.  
  
   
  
## Examples  
 L’exemple de code suivant crée une structure de menu pour un formulaire. L’exemple de code ajoute un <xref:System.Windows.Forms.MenuItem> pour représenter l’élément de menu de niveau supérieur, lui ajoute un élément de sous-menu qui permet de sélectionner une taille de police, puis ajoute deux éléments de sous-menu à cet élément de menu qui représentent les options de police de grands et petits dans une application. L’exemple requiert qu’un <xref:System.Windows.Forms.MainMenu> objet nommé `mainMenu1` et quatre <xref:System.Windows.Forms.MenuItem> objets nommés `menuItem1`, `menuItem2`, `menuItem3`, et `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise <see cref="T:System.Windows.Forms.MenuItem" /> avec une légende vide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois que vous avez créé un espace <xref:System.Windows.Forms.MenuItem> à l’aide de ce constructeur, vous pouvez utiliser les propriétés et méthodes de la <xref:System.Windows.Forms.MenuItem> classe pour spécifier l’apparence et le comportement de votre <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MenuItem> à l’aide de cette version du constructeur.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Légende de l'élément de menu.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.MenuItem" /> avec une légende spécifiée pour l'élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez une légende pour votre élément de menu avec le `text` paramètre, vous pouvez également spécifier une clé d’accès en plaçant un caractère « & » avant le caractère à utiliser comme touche d’accès. Par exemple, pour spécifier le « F » dans « Fichier » comme une clé d’accès, vous devez spécifier la légende pour l’élément de menu en tant que « & fichier ». Vous pouvez utiliser cette fonctionnalité pour fournir une navigation de clavier pour des menus.  
  
 Définition de la `text` paramètre pour «`-`» provoque votre élément de menu à afficher en tant que séparateur (une ligne horizontale) au lieu d’un élément de menu standard.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MenuItem> qui spécifie la légende de l’élément de menu au moment où il est construit.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Légende de l'élément de menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> qui gère l'événement <see cref="E:System.Windows.Forms.MenuItem.Click" /> pour cet élément de menu.</param>
        <summary>Initialise une nouvelle instance de la classe avec une légende spécifiée et un gestionnaire d'événements pour l'événement <see cref="E:System.Windows.Forms.MenuItem.Click" /> de l'élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez une légende pour votre élément de menu avec le `text` paramètre, vous pouvez également spécifier une clé d’accès en plaçant un « & » avant le caractère à utiliser comme touche d’accès. Par exemple, pour spécifier le « F » dans « Fichier » comme une clé d’accès, vous devez spécifier la légende pour l’élément de menu en tant que « & fichier ». Vous pouvez utiliser cette fonctionnalité pour fournir une navigation de clavier pour des menus.  
  
 Définition de la `text` paramètre pour «`-`» provoque votre élément de menu à afficher en tant que séparateur (une ligne horizontale) au lieu d’un élément de menu standard.  
  
 En outre, vous pouvez utiliser ce constructeur pour spécifier le délégué qui gère le <xref:System.Windows.Forms.MenuItem.Click> événement pour l’élément de menu en cours de création. Le <xref:System.EventHandler> que vous passez à ce constructeur doit être configuré pour appeler un gestionnaire d’événements qui peut gérer le <xref:System.Windows.Forms.MenuItem.Click> événement. Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MenuItem> objet avec une légende spécifiée et un <xref:System.EventHandler> délégué connecté à un gestionnaire d’événements qui gère la <xref:System.Windows.Forms.MenuItem.Click> événement pour l’élément de menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Légende de l'élément de menu.</param>
        <param name="items">Tableau d'objets <see cref="T:System.Windows.Forms.MenuItem" /> qui contient les éléments de sous-menu de cet élément de menu.</param>
        <summary>Initialise une nouvelle instance de la classe avec une légende spécifiée et un tableau d'éléments de sous-menu définis pour l'élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez une légende pour votre élément de menu avec le `text` paramètre, vous pouvez également spécifier une clé d’accès en plaçant un « & » avant le caractère à utiliser comme touche d’accès. Par exemple, pour spécifier le « F » dans « Fichier » comme une clé d’accès, vous devez spécifier la légende pour l’élément de menu en tant que « & fichier ». Vous pouvez utiliser cette fonctionnalité pour fournir une navigation de clavier pour des menus.  
  
 Définition de la `text` paramètre pour «`-`» provoque votre élément de menu à afficher en tant que séparateur (une ligne horizontale) au lieu d’un élément de menu standard.  
  
 Le `items` paramètre vous permet d’assigner un tableau d’éléments de menu pour définir un sous-menu de cet élément de menu. Chaque élément du tableau peut avoir également un tableau d’éléments de menu qui lui est assignée. Cela vous permet de créer des structures de menu complètes et les assigner au constructeur pour l’élément de menu.  
  
 Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un objet avec une légende spécifiée, un gestionnaire d’événements connecté à une méthode qui gérera l’événement de chaque élément de menu dans un tableau d’éléments de sous-menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Légende de l'élément de menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> qui gère l'événement <see cref="E:System.Windows.Forms.MenuItem.Click" /> pour cet élément de menu.</param>
        <param name="shortcut">Une des valeurs de <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <summary>Initialise une nouvelle instance de la classe avec une légende spécifiée, un gestionnaire d'événements et une touche de raccourci pour l'élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez une légende pour votre élément de menu avec le `text` paramètre, vous pouvez également spécifier une clé d’accès en plaçant un « & » avant le caractère à utiliser comme touche d’accès. Par exemple, pour spécifier le « F » dans « Fichier » comme une clé d’accès, vous devez spécifier la légende pour l’élément de menu en tant que « & fichier ». Vous pouvez utiliser cette fonctionnalité pour fournir une navigation de clavier pour des menus. Ce constructeur vous permet également de spécifier une touche de raccourci en plus d’une clé d’accès pour fournir la navigation au clavier. Touches de raccourci vous permettent de spécifier une combinaison de touches qui peuvent être utilisées pour activer l’élément de menu.  
  
 Définition de la `text` paramètre pour «`-`» provoque votre élément de menu à afficher en tant que séparateur (une ligne horizontale) au lieu d’un élément de menu standard.  
  
 En outre, vous pouvez utiliser ce constructeur pour spécifier le délégué qui gère le <xref:System.Windows.Forms.MenuItem.Click> événement pour l’élément de menu en cours de création. Le <xref:System.EventHandler> que vous passez à ce constructeur doit être configuré pour appeler un gestionnaire d’événements qui peut gérer le <xref:System.Windows.Forms.MenuItem.Click> événement. Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un objet avec une légende spécifiée, touche de raccourci et un gestionnaire d’événements connecté à une méthode qui gérera l’événement pour l’élément de menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Une des valeurs de <see cref="T:System.Windows.Forms.MenuMerge" />.</param>
        <param name="mergeOrder">Position relative occupée par cet élément de menu dans un menu fusionné.</param>
        <param name="shortcut">Une des valeurs de <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <param name="text">Légende de l'élément de menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> qui gère l'événement <see cref="E:System.Windows.Forms.MenuItem.Click" /> pour cet élément de menu.</param>
        <param name="onPopup"><see cref="T:System.EventHandler" /> qui gère l'événement <see cref="E:System.Windows.Forms.MenuItem.Popup" /> pour cet élément de menu.</param>
        <param name="onSelect"><see cref="T:System.EventHandler" /> qui gère l'événement <see cref="E:System.Windows.Forms.MenuItem.Select" /> pour cet élément de menu.</param>
        <param name="items">Tableau d'objets <see cref="T:System.Windows.Forms.MenuItem" /> qui contient les éléments de sous-menu de cet élément de menu.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.MenuItem" /> avec une légende spécifiée, des gestionnaires d'événements pour <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> et <see cref="E:System.Windows.Forms.MenuItem.Popup" />, une touche de raccourci, un type de fusion et un ordre de fusion pour l'élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez une légende pour votre élément de menu avec le `text` paramètre, vous pouvez également spécifier une clé d’accès en plaçant un « & » avant le caractère à utiliser comme touche d’accès. Par exemple, pour spécifier le « F » dans « Fichier » comme une clé d’accès, vous devez spécifier la légende pour l’élément de menu en tant que « & fichier ». Vous pouvez utiliser cette fonctionnalité pour fournir une navigation de clavier pour des menus.  
  
 Définition de la `text` paramètre pour «`-`» provoque votre élément de menu à afficher en tant que séparateur (une ligne horizontale) au lieu d’un élément de menu standard.  
  
 Le `items` paramètre vous permet d’assigner un tableau d’éléments de menu pour définir un sous-menu de cet élément de menu. Chaque élément du tableau peut avoir également un tableau d’éléments de menu qui lui est assignée. Cela vous permet de créer des structures de menu complètes et les assigner au constructeur pour l’élément de menu.  
  
 Le `mergeType` et `mergeOrder` vous permettent de déterminer le comporte de cet élément de menu lorsque l’élément de menu est fusionné avec un autre menu. Selon la valeur que vous spécifiez pour le `mergeType` paramètre, vous pouvez ajouter, supprimer, remplacer ou fusionner l’élément de menu et ses éléments de sous-menu avec l’autre menu. Le `mergeOrder` paramètre détermine où l’élément de menu en cours de création sera positionné lorsque le menu est fusionné.  
  
 En outre, vous pouvez utiliser ce constructeur pour créer un <xref:System.Windows.Forms.MenuItem> et vous connecter à un gestionnaire d’événements dans votre code qui traitera la, cliquez sur l’élément de menu. Le <xref:System.EventHandler> que vous passez à ce constructeur doit être configuré pour appeler un gestionnaire d’événements qui peut gérer le <xref:System.Windows.Forms.MenuItem.Click> événement. À l’aide de cette version du constructeur, vous pouvez également connecter le <xref:System.Windows.Forms.MenuItem.Popup> et <xref:System.Windows.Forms.MenuItem.Select> événements afin de déterminer quand cet élément de menu est sélectionné. Vous pouvez utiliser ces événements pour les tâches, par exemple déterminer s’il faut afficher une case à cocher en regard des éléments de sous-menu ou activer ou désactiver des éléments de menu en fonction de l’état de l’application. Le <xref:System.Windows.Forms.MenuItem.Select> et <xref:System.Windows.Forms.MenuItem.Click> événements sont déclenchés uniquement pour <xref:System.Windows.Forms.MenuItem> les objets qui sont ne parent pas les éléments de menu. Pour plus d’informations sur la gestion des événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un élément de menu qui a une clé de légende et de raccourci. L’élément de menu possède également des gestionnaires d’événements définis pour le <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, et <xref:System.Windows.Forms.MenuItem.Select> événements. Si cet élément de menu est fusionné, il ajoute l’élément de menu au menu avec l’ordre de fusion de zéro.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si <see cref="T:System.Windows.Forms.MenuItem" /> est placé sur une nouvelle ligne (pour un élément de menu ajouté à un objet <see cref="T:System.Windows.Forms.MainMenu" />) ou dans une nouvelle colonne (pour un élément de sous-menu ou un élément de menu affiché dans <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value><see langword="true" /> si l'élément de menu se trouve sur une nouvelle ligne ou dans une nouvelle colonne ; <see langword="false" /> si l'élément de menu reste à sa position par défaut. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Windows.Forms.MenuItem.BarBreak%2A> propriété pour créer un menu dans lequel chaque élément de menu est placé à côté des autres horizontalement au lieu de dans une liste verticale. Vous pouvez également utiliser cette propriété pour créer une barre de menus qui contient plusieurs lignes d’éléments de menu de niveau supérieur.  
  
 Cette propriété est différente de la <xref:System.Windows.Forms.MenuItem.Break%2A> propriété qu’une barre s’affiche sur le bord gauche de chaque élément de menu qui a le <xref:System.Windows.Forms.MenuItem.Break%2A> propriété définie sur `true`. La barre est affichée uniquement lorsque l’élément de menu n’est pas un élément de menu de niveau supérieur.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MenuItem> avec deux éléments de sous-menu. Les deux éléments de sous-menu sont affichent horizontalement au lieu d’utiliser verticalement le <xref:System.Windows.Forms.MenuItem.BarBreak%2A> propriété.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'élément est placé sur une nouvelle ligne (pour un élément de menu ajouté à un objet <see cref="T:System.Windows.Forms.MainMenu" />) ou dans une nouvelle colonne (pour un élément de menu ou un élément de sous-menu affiché dans <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value><see langword="true" /> si l'élément de menu se trouve sur une nouvelle ligne ou dans une nouvelle colonne ; <see langword="false" /> si l'élément de menu reste à sa position par défaut. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Windows.Forms.MenuItem.Break%2A> propriété pour créer un menu dans lequel chaque menu est placé à côté des autres horizontalement au lieu de dans une liste verticale. Vous pouvez également utiliser cette propriété pour créer une barre de menus qui contient plusieurs lignes d’éléments de menu de niveau supérieur.  
  
   
  
## Examples  
 L’exemple de code suivant crée un menu avec deux éléments de menu de niveau supérieur sur la ligne du haut et un élément de menu sur la ligne inférieure.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une coche apparaît en regard du texte de l'élément de menu.</summary>
        <value><see langword="true" /> si l'élément de menu possède une coche située en regard ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Windows.Forms.MenuItem.Checked%2A> propriété en combinaison avec d’autres éléments de menu dans un menu de fournir l’état d’une application. Par exemple, vous pouvez placer une coche sur un élément de menu dans un groupe d’éléments pour identifier la taille de la police à afficher pour le texte dans une application. Vous pouvez également utiliser le <xref:System.Windows.Forms.MenuItem.Checked%2A> propriété pour identifier l’élément de menu sélectionné dans un groupe d’éléments de menu qui s’excluent mutuellement.  
  
> [!NOTE]
>  Cette propriété ne peut pas être définie sur `true` pour les éléments de menu de niveau supérieur.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.MenuItem.Checked%2A> propriété afin de fournir l’état dans une application. Dans cet exemple, un groupe d’éléments de menu sont utilisés pour spécifier la couleur du texte dans un <xref:System.Windows.Forms.TextBox> contrôle. Le Gestionnaire d’événements fourni est utilisé par le <xref:System.Windows.Forms.MenuItem.Click> événement trois des éléments de menu. Chaque élément de menu spécifie une couleur de texte, `menuItemRed` (rouge), `menuItemGreen` (vert), ou `menuItemBlue` (bleu). Le Gestionnaire d’événements détermine quel élément de menu utilisateur a cliqué, place une coche en regard de l’élément de menu sélectionné et modifie la couleur du texte de la forme <xref:System.Windows.Forms.TextBox> contrôle. L’exemple exige que le <xref:System.Drawing> espace de noms a été ajouté au formulaire qui contient ce code. L’exemple exige également qu’un <xref:System.Windows.Forms.TextBox> a été ajouté à cet exemple de code se trouve dans le formulaire nommé `textBox1`.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Windows.Forms.MenuItem" /> est un menu du niveau supérieur ou a des enfants.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit suite à un clic sur l'élément de menu ou à la sélection de cet élément à l'aide d'une touche de raccourci ou d'une touche d'accès rapide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.MenuItem.Click> événement se produit lorsque cela <xref:System.Windows.Forms.MenuItem> l’utilisateur a cliqué. Également, cet événement se produit si l’utilisateur sélectionne l’élément de menu à l’aide du clavier et appuie sur la touche ENTRÉE. Il peut également se produire si l’utilisateur appuie sur une touche d’accès rapide ou une touche de raccourci qui est associé le <xref:System.Windows.Forms.MenuItem>. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.Menu.MenuItems%2A> propriété pour le <xref:System.Windows.Forms.MenuItem> contient des éléments, cet événement n’est pas déclenché. Cet événement n’est pas déclenché pour les éléments de menu parent.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Click> événement pour effectuer des tâches lorsque un <xref:System.Windows.Forms.MenuItem> est cliqué. L’exemple crée un <xref:System.Windows.Forms.MainMenu> appelé `mainMenu1` et ajoute deux <xref:System.Windows.Forms.MenuItem> objets, `topMenuItem` (`File`) et `menuItem1` (`Open`). Il se connecte ensuite le `Click` événement à la `menuItem1_Click` Gestionnaire d’événements. Lorsque l’utilisateur clique sur le `Open` élément de menu, un <xref:System.Windows.Forms.OpenFileDialog> est initialisé et affiché. L’exemple nécessite que vous avez créé un <xref:System.Windows.Forms.Form> nommé `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une copie de <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie de l'élément <see cref="T:System.Windows.Forms.MenuItem" /> actuel.</summary>
        <returns><see cref="T:System.Windows.Forms.MenuItem" /> qui représente l'élément de menu dupliqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> objets ne peuvent pas être utilisés dans plusieurs endroits, sauf si vous obtenez une copie de la <xref:System.Windows.Forms.MenuItem>. Vous pouvez appeler cette méthode pour créer une copie de cet élément de menu pour une utilisation dans un <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, ou d’autres <xref:System.Windows.Forms.MenuItem> au sein de votre application. Lorsqu’un élément de menu est cloné, les gestionnaires d’événements spécifiés dans l’élément de menu d’origine continuera à fonctionner dans la version clonée de l’élément de menu. Par exemple, si vous avez créé un <xref:System.Windows.Forms.MenuItem> et connecté son <xref:System.Windows.Forms.MenuItem.Click> événement à un gestionnaire d’événements. Lorsque l’élément de menu est cloné, l’élément de menu cloné appellera le même gestionnaire d’événements.  
  
   
  
## Examples  
 Le code suivant exemple clones un <xref:System.Windows.Forms.MenuItem> et l’affiche dans un <xref:System.Windows.Forms.ContextMenu>. L’exemple exige qu’un <xref:System.Windows.Forms.MenuItem> existe dans un <xref:System.Windows.Forms.MainMenu> sur un formulaire avec le nom de `menuItem1` et qu’un <xref:System.Windows.Forms.ContextMenu> objet nommé `contextMenu1` existe également sur le formulaire.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc"><see cref="T:System.Windows.Forms.MenuItem" /> qui représente l'élément de menu à copier.</param>
        <summary>Crée une copie du <see cref="T:System.Windows.Forms.MenuItem" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour créer des copies d’éléments de menu que vous avez déjà créé pour une utilisation dans un menu contextuel ou une autre structure de menu au sein de votre application. Cette version de <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> vous permet de spécifier un spécifique <xref:System.Windows.Forms.MenuItem> pour copier au lieu de l’élément de menu qui appelle la méthode. Vous pouvez utiliser cette méthode pour initialiser un nouveau <xref:System.Windows.Forms.MenuItem> objet avec une copie d’un autre <xref:System.Windows.Forms.MenuItem>. Lorsqu’un élément de menu est cloné, les gestionnaires d’événements spécifiés dans l’élément de menu d’origine continuera à fonctionner dans la version clonée de l’élément de menu. Par exemple, si vous avez créé un <xref:System.Windows.Forms.MenuItem> et connecté son <xref:System.Windows.Forms.MenuItem.Click> événement à un gestionnaire d’événements. Lorsque l’élément de menu est cloné, l’élément de menu cloné appellera le même gestionnaire d’événements.  
  
   
  
## Examples  
 L’exemple de code suivant initialise un nouveau <xref:System.Windows.Forms.MenuItem> avec une copie d’un existant <xref:System.Windows.Forms.MenuItem> qui est utilisé dans un <xref:System.Windows.Forms.MainMenu> sur un formulaire. Le code ajoute ensuite cloné <xref:System.Windows.Forms.MenuItem> à un <xref:System.Windows.Forms.ContextMenu> sur le formulaire. Cet exemple suppose qu’un <xref:System.Windows.Forms.MenuItem> est déjà créé et nommé `menuItem1` et qui un <xref:System.Windows.Forms.ContextMenu> contrôle a été créé et nommé `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'élément est l'élément de menu par défaut.</summary>
        <value><see langword="true" /> si l'élément de menu est l'élément par défaut dans un menu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’élément de menu par défaut pour un menu est affiché en gras. Lorsque l’utilisateur double-clique sur un sous-menu qui contient un élément par défaut, l’élément par défaut est sélectionné et le sous-menu est fermé. Vous pouvez utiliser le <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> propriété permettant d’indiquer, l’action par défaut qui est attendue dans un menu ou un menu contextuel.  
  
   
  
## Examples  
 L’exemple de code suivant crée un élément de menu avec deux éléments de sous-menu. L’exemple définit `menuItem2` en tant que l’élément de menu par défaut à l’aide du <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> propriété.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources (autres que la mémoire) utilisées par <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Windows.Forms.MenuItem.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Windows.Forms.MenuItem>. La méthode <xref:System.Windows.Forms.MenuItem.Dispose%2A> rend le <xref:System.Windows.Forms.MenuItem> inutilisable. Après avoir appelé <xref:System.Windows.Forms.MenuItem.Dispose%2A>, vous devez libérer toutes les références à la <xref:System.Windows.Forms.MenuItem> afin que la mémoire occupée peut être récupérée par le garbage collection.  
  
> [!NOTE]
>  Appelez toujours <xref:System.Windows.Forms.MenuItem.Dispose%2A> avant de libérer votre dernière référence à <xref:System.Windows.Forms.MenuItem>. Sinon, les ressources du <xref:System.Windows.Forms.MenuItem> est ne seront pas libérées jusqu'à ce que le garbage collection appelle le <xref:System.Windows.Forms.MenuItem> destructeur de l’objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la propriété <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> d'un élément de menu a la valeur <see langword="true" /> et qu'une demande visant à dessiner l'élément de menu est faite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.DrawItemEventArgs> argument passé à un <xref:System.Windows.Forms.MenuItem.DrawItem> Gestionnaire d’événements fournit une <xref:System.Drawing.Graphics> objet qui vous permet d’effectuer le dessin et autres opérations graphiques sur la surface de l’élément de menu. Vous pouvez utiliser ce gestionnaire d’événements pour créer des menus personnalisés répondant aux besoins de votre application. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment gérer les <xref:System.Windows.Forms.MenuItem.DrawItem> événement. Cet exemple dessine un menu en utilisant un <xref:System.Drawing.Brush> et un <xref:System.Drawing.Font>, puis dessine une <xref:System.Drawing.Rectangle> autour de l’élément de menu. Le dessin est effectué via le <xref:System.Drawing.Graphics> objet, qui est passé au gestionnaire d’événements dans le <xref:System.Windows.Forms.DrawItemEventArgs> paramètre. Cet exemple nécessite que vous avez initialisé le <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> propriété pour l’élément à `true`. Pour l’exemple c#, ajoutez le code suivant dans le constructeur du formulaire, après `InitializeComponent`, pour raccorder l’événement :  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'élément de menu est activé.</summary>
        <value><see langword="true" /> si l'élément de menu est activé ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Forms.MenuItem> qui est désactivé est affiché dans une couleur grise pour indiquer son état. Lorsqu’un élément de menu parent est désactivé, tous les éléments de sous-menu ne sont pas affichés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Popup> événement pour déterminer si <xref:System.Windows.Forms.MenuItem> objets qui prennent en charge couper, copier et les opérations de suppression sont activés avant le qu’ils sont affichés dans le menu. L’exemple détermine si `textBox1`, un <xref:System.Windows.Forms.TextBox> contrôler sur le formulaire est activé, a le focus d’entrée et a texte sélectionné avant d’activer la <xref:System.Windows.Forms.MenuItem> objets. Cet exemple requiert que trois <xref:System.Windows.Forms.MenuItem> objets sont créés avec les noms `menuCut`, `menuCopy`, et `menuDelete` ont été créés.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique la position de l'élément de menu dans son menu parent.</summary>
        <value>Index de base zéro qui représente la position de l'élément de menu dans son menu parent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété fournit la position d’index d’un élément de menu dans la collection d’éléments de menu de son menu parent. Vous pouvez utiliser cette propriété pour repositionner un élément de menu à un autre emplacement au sein de son menu. Vous pouvez également utiliser cette propriété lorsque vous créez un <xref:System.Windows.Forms.MenuItem> pour spécifier sa position dans une structure de menu au moment de la création.  
  
   
  
## Examples  
 L’exemple de code suivant passe la position de deux éléments de menu dans un menu. L’exemple de code suivant suppose que deux <xref:System.Windows.Forms.MenuItem> objets sont créés avec les noms `menuItem1` et `menuItem2`. Le `menuItem1` élément de menu descend d’une position dans le menu, tandis que `menuItem2` déplace vers le haut d’une position.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur assignée est inférieure à zéro ou supérieure au nombre d'éléments.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'élément de menu contient des éléments de menu enfants.</summary>
        <value><see langword="true" /> si l'élément de menu contient des éléments enfants ; <see langword="false" /> s'il s'agit d'un élément de menu autonome.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété avec le <xref:System.Windows.Forms.MenuItem.Parent%2A> propriété jusqu'à laquelle naviguer dans le code via une structure de menu entier.  
  
   
  
## Examples  
 L’exemple de code suivant détermine s’il existe des sous-menus associés un <xref:System.Windows.Forms.MenuItem> nommé `menuItem1`. S’il existe des sous-menus, il les désactive en définissant le <xref:System.Windows.Forms.MenuItem.Enabled%2A> propriété `false`. L’exemple requiert qu’un <xref:System.Windows.Forms.MenuItem> créé, appelé `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'élément de menu va être rempli avec la liste des fenêtres enfants MDI (interface multidocument) affichées dans le formulaire associé.</summary>
        <value><see langword="true" /> si une liste des fenêtres MDI enfants s'affiche dans cet élément de menu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un élément de menu est sélectionné pour afficher une liste des fenêtres MDI enfants, la liste s’affiche en tant que sous-menu de l’élément de menu. Seuls les formulaires qui sont définies comme des formulaires MDI enfants sont affichés dans la liste de la fenêtre. Seuls neuf fenêtres enfants peuvent être affichés à la fois. S’il existe plus de neuf fenêtres enfants affichées, un élément de menu « Plus Windows... » s’affiche à la fin de la liste de la fenêtre. Cliquer sur cet élément de menu affiche une boîte de dialogue avec une liste complète des fenêtres enfants qui sont actuellement actives.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MenuItem> qui est utilisé pour afficher la liste des formulaires MDI enfants actuellement ouverts dans un formulaire MDI.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le menu a besoin de connaître la taille d'un élément de menu avant de le dessiner.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour que cet événement soit déclenché, vous devez disposer du <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> la valeur de propriété de l’élément de menu `true`. Cet événement est déclenché avant que les menus owner-drawn sont dessinés pour permettre la taille de l’élément de menu extraits afin d’être spécifié. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.MenuItem.MeasureItem> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.MenuItem> nommé `MenuItem1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.MenuItem.MeasureItem> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique l'identificateur Windows pour cet élément de menu.</summary>
        <value>Identificateur Windows de cet élément de menu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fusionne ce <see cref="T:System.Windows.Forms.MenuItem" /> avec un autre <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fusionne ce <see cref="T:System.Windows.Forms.MenuItem" /> avec un autre <see cref="T:System.Windows.Forms.MenuItem" /> et retourne le <see cref="T:System.Windows.Forms.MenuItem" /> qui résulte de la fusion.</summary>
        <returns><see cref="T:System.Windows.Forms.MenuItem" /> qui représente l'élément de menu fusionné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez cette version de <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, le <xref:System.Windows.Forms.MenuItem> retourné est une copie de l’élément de menu actuel qui peut être fusionné avec un autre élément de menu sans affecter les fonctionnalités de l’élément actuel. Cette version de la <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> méthode ressemble à appeler le <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> méthode qui ne contient aucun paramètre.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc"><see cref="T:System.Windows.Forms.MenuItem" /> qui spécifie l'élément de menu à fusionner avec celui-ci.</param>
        <summary>Fusionne un autre élément de menu avec cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Éléments de menu sont fusionnées en fonction de la valeur de l’élément de menu <xref:System.Windows.Forms.MenuItem.MergeType%2A> et <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> propriétés. Cette version de la <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> méthode vous permet de fusionner deux <xref:System.Windows.Forms.MenuItem> objets (et leurs sous-menus) en un seul menu. Fusion de menus est gérée automatiquement lorsqu’un formulaire d’Interface multidocument (MDI, Multiple Document Interface) parent et enfant ont des menus. Vous pouvez utiliser cette version de la méthode pour fusionner deux <xref:System.Windows.Forms.MenuItem> objets (et leurs éléments de sous-menu) situés dans un <xref:System.Windows.Forms.MainMenu> contrôle en un seul menu au sein d’un <xref:System.Windows.Forms.ContextMenu>. Par exemple, vous pouvez appeler cette version de la <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> méthode pour fusionner les éléments de menu d’un menu fichier et Edition dans un seul <xref:System.Windows.Forms.MenuItem> qui peut être ajouté à et affiché par un <xref:System.Windows.Forms.ContextMenu>.  
  
   
  
## Examples  
 L’exemple de code suivant utilise cette version de la <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> méthode pour créer une copie d’un <xref:System.Windows.Forms.MenuItem> et les fusionner avec une autre. Les données fusionnées <xref:System.Windows.Forms.MenuItem> est ensuite ajoutée à un <xref:System.Windows.Forms.ContextMenu> contrôle. Cet exemple suppose qu’il n’y a deux éléments de menu appelés `menuItem1` et `menuItem2` qui contiennent des éléments de sous-menu et un <xref:System.Windows.Forms.ContextMenu> nommé `contextMenu1` pour afficher les éléments de menu. `menuItem1` et `menuItem2` ont différents éléments de menu qu’ils contiennent. Après l’appel à <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> est effectuée, un menu est créé.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique la position relative de l’élément de menu lorsqu’il est fusionné avec un autre.</summary>
        <value>Index de base zéro qui représente l’ordre de fusion de cet élément de menu. La valeur par défaut est 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre de fusion d’un élément de menu spécifie la position relative occupée par cet élément de menu si la structure de menu qui la <xref:System.Windows.Forms.MenuItem> est contenue dans est fusionné avec un autre.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> propriété pour contrôler le mode d’affichage d’un menu fusionné. Il s’agit d’un exemple complet, prêt à exécuter une fois que vous l’ajoutez à votre projet.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique le comportement de l’élément de menu lorsque son menu est fusionné avec un autre.</summary>
        <value>Valeur <see cref="T:System.Windows.Forms.MenuMerge" /> qui représente le type de fusion de l'élément de menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de fusion d’un élément de menu indique la façon dont l’élément de menu se comporte lorsqu’il a le même ordre de fusion en tant qu’un autre élément de menu fusionné. Vous pouvez utiliser les menus fusionnés pour créer un menu consolidé basé sur deux ou plusieurs des menus existants.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.MenuItem> avec la <xref:System.Windows.Forms.MenuItem.MergeType%2A> et <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> spécifié afin que l’élément de menu est ajouté à la première position du menu fusionné.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur assignée ne fait pas partie des valeurs <see cref="T:System.Windows.Forms.MenuMerge" />.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique le caractère mnémonique associé à cet élément de menu.</summary>
        <value>Caractère qui représente le caractère mnémonique associé à cet élément de menu. Retourne le caractère NUL (valeur ASCII 0) si aucun caractère mnémonique n'est spécifié dans le texte du <see cref="T:System.Windows.Forms.MenuItem" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le caractère mnémonique est le premier caractère après un caractère esperluette (&) dans le texte de la <xref:System.Windows.Forms.MenuItem>. Cette propriété ne retournera pas un caractère mnémonique si deux caractères « et commercial » sont positionnés ensemble car les signes & sont utilisées pour afficher une esperluette dans le texte de la <xref:System.Windows.Forms.MenuItem> au lieu de définir un caractère mnémonique.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Click> événement pour effectuer des tâches lorsque un <xref:System.Windows.Forms.MenuItem> est cliqué. L’exemple crée un <xref:System.Windows.Forms.MainMenu> appelé `mainMenu1` et ajoute deux <xref:System.Windows.Forms.MenuItem> objets, `topMenuItem` (`File`) et `menuItem1` (`Open`). Il se connecte ensuite le `Click` événement à la `menuItem1_Click` Gestionnaire d’événements. Lorsque l’utilisateur clique sur le `Open` élément de menu, un <xref:System.Windows.Forms.OpenFileDialog> est initialisé et affiché. L’exemple nécessite que vous avez créé un <xref:System.Windows.Forms.Form> nommé `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> (méthode).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.DrawItemEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.DrawItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> (méthode).</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.MeasureItemEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> (méthode).</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Popup> événement pour déterminer si <xref:System.Windows.Forms.MenuItem> objets qui prennent en charge couper, copier et les opérations de suppression sont activés avant le qu’ils sont affichés dans le menu. L’exemple détermine si `textBox1`, un <xref:System.Windows.Forms.TextBox> contrôler sur le formulaire est activé, a le focus d’entrée et a texte sélectionné avant d’activer la <xref:System.Windows.Forms.MenuItem> objets. Cet exemple requiert que trois <xref:System.Windows.Forms.MenuItem> objets sont créés avec les noms `menuCut`, `menuCopy`, et `menuDelete` ont été créés.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> (méthode).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.Select" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Select> événement de la <xref:System.Windows.Forms.MenuItem> classe pour affecter le texte d’aide à un <xref:System.Windows.Forms.StatusBarPanel> d’un <xref:System.Windows.Forms.StatusBar> contrôle. Cet exemple requiert que <xref:System.Windows.Forms.MenuItem> objets nommés `menuOpen`, `menuSave`, et `menuExit` sont ajoutés à un <xref:System.Windows.Forms.MainMenu> contrôle sur un formulaire. L’exemple exige également qu’un <xref:System.Windows.Forms.StatusBar> contrôle nommé `statusBar1` a été ajouté au formulaire. Le <xref:System.Windows.Forms.StatusBar> contrôle doit contenir un <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> (méthode).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'élément de menu est dessiné par le code que vous fournissez ou par Windows.</summary>
        <value><see langword="true" /> si l'élément de menu est dessiné par le code ; <see langword="false" /> si l'élément de menu est dessiné par Windows. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> propriété est définie sur `true`, vous devez gérer tout le dessin de l’élément de menu. Vous pouvez utiliser cette fonctionnalité pour créer votre propre menu spécial s’affiche.  
  
   
  
## Examples  
 L’exemple de code suivant montre un menu avec un élément de menu owner-drawn. Cet exemple de jeu la <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> propriété et utilise le `AddHandler` instruction et le `AddressOf` opérateur pour désigner un délégué pour gérer le <xref:System.Windows.Forms.MenuItem.DrawItem> événement. Pour exécuter l’exemple, collez-le dans un formulaire qui importe le <xref:System>, <xref:System.Windows.Forms>, et <xref:System.Drawing> espaces de noms. Appelez `InitializeMenu` à partir du constructeur du formulaire ou `Load` (méthode).  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant le menu qui contient cet élément de menu.</summary>
        <value><see cref="T:System.Windows.Forms.Menu" /> qui représente le menu qui contient l'élément de menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour obtenir le <xref:System.Windows.Forms.Menu> objet pour un sous-menu. Vous pouvez convertir le <xref:System.Windows.Forms.Menu> objet retourné par cette propriété pour un <xref:System.Windows.Forms.MenuItem> objet pour le manipuler.  
  
   
  
## Examples  
 Dans cet exemple, vous créez un menu principal et un élément de menu de niveau supérieur, `menuItem1` (`File`). Vous créez également deux éléments de menu, `menuItem2` (`New`) et `menuItem3` (`Open`) et les ajouter à la liste d’éléments de menu `menuItem1`. Puis vous vérifiez si `menuItem3` a un parent menu, qui est true et affichent les informations de ce menu parent dans la boîte de message. Cet exemple nécessite que vous avez créé un <xref:System.Windows.Forms.Form> nommé `Form1`.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Génère un événement <see cref="E:System.Windows.Forms.Control.Click" /> pour <see cref="T:System.Windows.Forms.MenuItem" />, ce qui simule un clic de l'utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser ce menu pour activer un élément de menu dans le code sans passer aucune information d’événement. Par exemple, si vous souhaitez activer un menu élément basé sur une action qui se produit dans votre application, vous pouvez appeler la <xref:System.Windows.Forms.MenuItem.PerformClick%2A> méthode pour que <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 Dans cet exemple, vous cliquez par programme sur un élément de menu à l’aide de la `PerformClick` (méthode). Tout d’abord, vous créez un menu principal (`mainMenu1`) et lui ajouter deux éléments de menu, `menuItem1` (`File`) et `menuItem2` (`Edit`). Vous utilisez également le <xref:System.Windows.Forms.MenuItem.Click> événement pour envoyer des données au gestionnaire d’événements lorsque l’utilisateur clique sur un élément de menu. Puis vous utilisez le `PerformClick` méthode cliquer sur le `File` élément de menu. Lorsque vous démarrez l’application, le `File` élément de menu est activé, et une boîte de message qui contient le texte « Le fichier utilisateur clique sur le menu ». s’affiche sur l’écran. L’exemple nécessite que vous avez créé un <xref:System.Windows.Forms.Form> nommé `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.MenuItem.Select" /> pour cet élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vous permet de déclencher le <xref:System.Windows.Forms.MenuItem.Select> événement sans passer les informations d’événement au gestionnaire d’événements.  
  
   
  
## Examples  
 Dans cet exemple vous sélectionnez par programme un élément de menu à l’aide de la `PerformSelect` (méthode). Tout d’abord, vous créez un menu principal (`mainMenu1`) et lui ajouter deux éléments de menu, `menuItem1` (`File`) et `menuItem2` (`Edit`). Vous utilisez également le <xref:System.Windows.Forms.MenuItem.Select> événement à envoyer des données au gestionnaire d’événements lorsqu’un élément de menu est sélectionné. Puis vous utilisez le `PerformSelect` méthode afin de sélectionner le `File` élément de menu. Lorsque vous démarrez l’application, le `File` élément de menu est sélectionné, et une boîte de message qui contient le texte « Le fichier menu est sélectionné. » s’affiche sur l’écran. L’exemple nécessite que vous avez créé un <xref:System.Windows.Forms.Form> nommé `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant l'affichage de la liste des éléments de menu d'un élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement se produit uniquement quand un élément de menu a des éléments de sous-menu à afficher. Vous pouvez utiliser ce gestionnaire d’événements pour ajouter, supprimer, activer, désactiver, sélectionner ou désélectionner des éléments de menu en fonction de l’état de votre application avant qu’elles sont affichées. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Popup> événement pour déterminer si <xref:System.Windows.Forms.MenuItem> objets qui prennent en charge couper, copier et les opérations de suppression sont activés avant le qu’ils sont affichés dans le menu. L’exemple détermine si `textBox1`, un <xref:System.Windows.Forms.TextBox> contrôler sur le formulaire est activé, a le focus d’entrée et a texte sélectionné avant d’activer la <xref:System.Windows.Forms.MenuItem> objets. Cet exemple requiert que trois <xref:System.Windows.Forms.MenuItem> objets sont créés avec les noms `menuCut`, `menuCopy`, et `menuDelete` ont été créés.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le <see cref="T:System.Windows.Forms.MenuItem" /> affiche une case d'option au lieu d'une coche lorsqu'il est activé.</summary>
        <value><see langword="true" /> si la coche standard est remplacée par une case d'option ; <see langword="false" /> si la coche standard s'affiche lorsque l'élément de menu est activé. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coches n’impliquent pas nécessairement un état mutuellement pour un groupe d’éléments de menu. Vous pouvez utiliser cette propriété pour indiquer à l’utilisateur que la case à cocher d’un élément de menu s’excluent mutuellement.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Windows.Forms.MenuItem.Checked%2A> propriété à modifier l’état d’une application. Dans l’exemple, un groupe d’éléments de menu est fourni sont utilisés pour spécifier la couleur du texte dans un <xref:System.Windows.Forms.TextBox> contrôle. Dans l’exemple, le Gestionnaire d’événements fourni est utilisé par le <xref:System.Windows.Forms.MenuItem.Click> événement de trois éléments de menu. Chaque élément de menu spécifie une couleur, `menuItemRed`, `menuItemGreen`, ou `menuItemBlue`. Le Gestionnaire d’événements détermine quel élément de menu utilisateur a cliqué, place une coche en regard de l’élément de menu sélectionné et modifie la couleur du texte de la forme <xref:System.Windows.Forms.TextBox> contrôle nommé `textBox1`. L’exemple utilise également le <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> propriété afin d’illustrer comment une case sert à afficher les éléments de menu qui s’excluent mutuellement. Cet exemple requiert que le <xref:System.Drawing?displayProperty=nameWithType> espace de noms a été ajouté au formulaire qui contient ce code.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur place le pointeur sur un élément de menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est généralement déclenché lorsque l’utilisateur place le pointeur de la souris sur l’élément de menu. Peut également être déclenché lorsque l’utilisateur met en surbrillance un élément de menu à l’aide du clavier en accédant à l’élément de menu avec les touches de direction. Vous pouvez utiliser cet événement pour afficher une chaîne d’aide détaillées relatives à cet élément de menu dans la barre d’état d’une application. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.Menu.MenuItems%2A> propriété pour le <xref:System.Windows.Forms.MenuItem> contient des éléments, cet événement n’est pas déclenché. Cet événement n’est pas déclenché pour les éléments de menu parent.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.MenuItem.Select> événement de la <xref:System.Windows.Forms.MenuItem> classe pour affecter le texte d’aide à un <xref:System.Windows.Forms.StatusBarPanel> d’un <xref:System.Windows.Forms.StatusBar> contrôle. Cet exemple requiert que <xref:System.Windows.Forms.MenuItem> objets nommés `menuOpen`, `menuSave`, et `menuExit` sont ajoutés à un <xref:System.Windows.Forms.MainMenu> contrôle sur un formulaire. L’exemple exige également qu’un <xref:System.Windows.Forms.StatusBar> contrôle nommé `statusBar1` a été ajouté au formulaire. Le <xref:System.Windows.Forms.StatusBar> contrôle doit contenir un <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique la touche de raccourci associée à l'élément de menu.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.Shortcut" />. La valeur par défaut est <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Touches de raccourci fournissent une méthode permettant aux utilisateurs d’activer fréquemment utilisé des éléments de menu dans votre système de menus et pour fournir un accès clavier à votre application pour les utilisateurs qui n’ont pas accès à une souris ou un autre périphérique de pointeur.  
  
   
  
## Examples  
 L’exemple de code suivant crée un élément de menu, définit la légende, assigne une touche de raccourci, rend l’élément de menu visible et montre l’affichage de touches de raccourci pour l’élément de menu. L’exemple requiert qu’un <xref:System.Windows.Forms.MenuItem> a été créé, qui est nommé `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur assignée ne fait pas partie des valeurs <see cref="T:System.Windows.Forms.Shortcut" />.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la touche de raccourci associée à l'élément de menu est affichée en regard de la légende de l'élément de menu.</summary>
        <value><see langword="true" /> si la combinaison de touches de raccourci s'affiche en regard de la légende de l'élément de menu ; <see langword="false" /> si la combinaison de touches de raccourci ne s'affiche pas. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour fournir l’option permettant aux utilisateurs de masquer les raccourcis pour économiser l’espace de menu ou de masquer une touche de raccourci s’affiche.  
  
   
  
## Examples  
 L’exemple de code suivant crée un élément de menu, définit la légende, assigne une touche de raccourci, rend l’élément de menu visible et montre l’affichage de touches de raccourci pour l’élément de menu. L’exemple requiert qu’un <xref:System.Windows.Forms.MenuItem> a été créé, qui est nommé `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique la légende de l'élément de menu.</summary>
        <value>Texte de légende de l'élément de menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez une légende pour votre élément de menu, vous pouvez également spécifier une clé d’accès en plaçant un « & » avant le caractère à utiliser comme touche d’accès. Par exemple, pour spécifier le « F » dans « Fichier » comme une clé d’accès, vous devez spécifier la légende pour l’élément de menu en tant que « & fichier ». Vous pouvez utiliser cette fonctionnalité pour fournir une navigation de clavier pour des menus.  
  
 Définition de cette propriété «`-`» provoque votre élément de menu à afficher en tant que séparateur (une ligne horizontale) au lieu d’un élément de menu standard.  
  
   
  
## Examples  
 L’exemple de code suivant crée un élément de menu, définit la légende, assigne une touche de raccourci, rend l’élément de menu visible et montre l’affichage de touches de raccourci pour l’élément de menu. L’exemple requiert qu’un <xref:System.Windows.Forms.MenuItem> a été créé, qui est nommé `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui représente <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Chaîne qui représente le <see cref="T:System.Windows.Forms.MenuItem" /> actuel. La chaîne inclut le type et la propriété <see cref="P:System.Windows.Forms.MenuItem.Text" /> du contrôle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'élément de menu est visible.</summary>
        <value><see langword="true" /> si l'élément est visible dans le menu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour modifier une structure de menu sans avoir à fusionner les menus ou de désactiver les menus. Par exemple, si vous souhaitez masquer une section complète de fonctionnalités dans les menus de votre application, vous pouvez les masquer à partir de l’utilisateur en définissant cette propriété sur `false`.  
  
   
  
## Examples  
 L’exemple de code suivant crée un élément de menu, définit la légende, assigne une touche de raccourci, rend l’élément de menu visible et montre l’affichage de touches de raccourci pour l’élément de menu. L’exemple requiert qu’un <xref:System.Windows.Forms.MenuItem> a été créé, qui est nommé `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>