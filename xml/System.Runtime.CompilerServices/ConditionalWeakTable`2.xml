<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75a1ca0bc007b584e93073f8cc318bd920092d8d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480163" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <typeparam name="TKey">Type référence auquel le champ est attaché.</typeparam>
    <typeparam name="TValue">Type du champ. Il doit s'agir d'un type référence.</typeparam>
    <summary>Permet aux compilateurs d'attacher dynamiquement des champs objet aux objets managés.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe permet aux compilateurs de langage de joindre des propriétés arbitraires aux objets managés au moment de l’exécution. A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objet est un dictionnaire qui lie un objet managé, qui est représenté par une clé, à sa propriété jointe, qui est représentée par une valeur. Les clés de l’objet sont les instances individuelles de la `TKey` classe à laquelle la propriété est jointe, et ses valeurs sont les valeurs de propriété qui sont affectées aux objets correspondants.  
  
 Clés doivent être uniques ; en d’autres termes, la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe prend en charge une valeur attachée par objet managé. Deux clés sont égales si leur transmission à le <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode renvoie `true`.  
  
> [!NOTE]
>  Vous ne pouvez pas contrôler les comparaisons d’égalité en substituant <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> pour définir explicitement le code de hachage pour une clé. Le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe n’utilise pas le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> méthode pour calculer les codes de hachage et par conséquent n’appelle pas <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> substitue.  
  
 Bien que la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe conserve une collection de paires clé/valeur, il est plus considéré comme une table plutôt qu’un objet de dictionnaire. La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe diffère d’un dictionnaire de plusieurs façons :  
  
-   Il n’est pas persistante des clés. Autrement dit, une clé n’est pas gardée active uniquement parce qu’il est un membre de la collection.  
  
-   Il n’inclut pas toutes les méthodes (tel que `GetEnumerator` ou `Contains`) qu’un dictionnaire possède généralement.  
  
-   Il n’implémente pas le <xref:System.Collections.Generic.IDictionary%602> interface.  
  
 La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe diffère d’autres objets de collection dans sa gestion de la durée de vie des clés stockées dans la collection. En général, lorsqu’un objet est stocké dans une collection, sa durée de vie dure jusqu'à ce qu’il est supprimé (et il n’existe aucune référence supplémentaire à l’objet) ou jusqu'à la destruction de l’objet collection lui-même. Toutefois, dans le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> (classe), ajout d’une paire clé/valeur à la table ne garantit pas que la clé sera persistante, même si elle est accessible directement à partir d’une valeur stockée dans la table (par exemple, si la table contient une clé, A, avec une valeur V1 et une deuxième clé, B, avec une valeur P2 qui contient une référence à A). Au lieu de cela, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> supprime automatiquement l’entrée de clé/valeur dès qu’aucune autre référence à une clé n’existe en dehors du tableau. Cet exemple en fournit une illustration.  
  
   
  
## Examples  
 L’exemple suivant illustre qu’une clé stockée dans le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table n’est pas persistante après les références à ce dernier à l’extérieur de la table sont détruits. L’exemple définit deux classes : `ManagedClass`, qui représente la clé dans la table, et `ClassData`, qui représente la valeur de clé. L’exemple instancie trois objets de chaque type. Il instancie également un <xref:System.WeakReference> objet qui représente la seconde `ManagedClass`et puis détruit la seconde `ManagedClass` instance. La tentative de récupération de la seconde `ManagedClass` de l’objet à partir de la <xref:System.WeakReference.Target%2A> propriété indique qu’aucune référence à l’objet ne reste.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Instances de la <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> classe sont thread-safe. Ils ne nécessitent pas les appelants à effectuer un verrouillage supplémentaire.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructeur instancie vide <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table ; autrement dit, la table ne contient aucun paires clé/valeur. Vous pouvez ajouter des paires clé/valeur en appelant le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, ou <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> (méthode).  
  
 Chaque clé dans un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objet doit être unique. Les clés ne sont pas uniques si elles font référence au même objet (autrement dit, si les passer en tant qu’arguments à la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> retourne de la méthode `true`).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Clé à ajouter. <c>key</c> représente l’objet auquel la propriété est jointe.</param>
        <param name="value">Valeur de la propriété de la clé.</param>
        <summary>Ajoute une clé à la table.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objet doit être unique. Les clés ne sont pas uniques si elles font référence au même objet (autrement dit, si les passer en tant qu’arguments à la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> retourne de la méthode `true`).  
  
 Si la clé est le garbage collection pendant l’opération d’addition, la paire clé/valeur existante est supprimée et la nouvelle paire clé/valeur est ajoutée sans une exception est levée.  
  
   
  
## Examples  
 L’exemple suivant définit un `MainClass` classe et un `MainInfo` (classe), qui fournit des informations sur la `MainClass` instance. L’exemple appelle ensuite la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> méthode pour ajouter un `MainClass` objet et son joint `MainInfo` de l’objet à un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table. L’exemple illustre également les appels à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> et <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> méthodes pour ajouter des paires clé/valeur à la table et à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> méthode pour récupérer la valeur d’une clé existante.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> existe déjà.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable`2 ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le garbage collector appelle <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> lorsque l’objet actuel est prêt à être finalisé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher. <c>key</c> représente l’objet auquel la propriété est jointe.</param>
        <summary>Effectue une recherche atomique de la clé spécifiée dans la table et retourne la valeur correspondante. Si la clé n'existe pas dans la table, la méthode appelle le constructeur par défaut de la classe qui représente la valeur de la table pour créer une valeur liée à la clé spécifiée.</summary>
        <returns>Valeur qui correspond à <paramref name="key" />, si <paramref name="key" /> existe déjà dans la table ; sinon, nouvelle valeur créée par le constructeur par défaut de la classe définie par le paramètre de type générique <paramref name="TValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `key` n’existe pas dans la table, la méthode ajoute, ainsi que l’objet est instancié en appelant le constructeur par défaut de la classe définie par le `TValue` paramètre de type générique. Si le `TValue` classe n’a aucun constructeur par défaut, un <xref:System.MissingMethodException> est levée.  
  
 C’est la méthode recommandée de la récupération d’une valeur existante ou l’ajout d’une nouvelle valeur à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> si la classe de valeur de la table définit un constructeur par défaut de la table. Si elle ne définit pas un constructeur par défaut, vous pouvez appeler à la place la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> (méthode), qui s’appuie sur une méthode de rappel fournie pour instancier l’objet qui représente la valeur de la table  
  
 Pour récupérer la valeur d’une clé existante sans ajouter la paire clé/valeur si la clé est introuvable dans la table, appelez le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un `MainClass` classe et un `MainInfo` (classe), qui fournit des informations sur la `MainClass` instance. L’exemple appelle la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> méthode pour ajouter un `MainClass` objet et son joint `MainInfo` de l’objet à un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table. L’exemple illustre également les appels à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> et <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> méthodes pour ajouter des paires clé/valeur à la table et à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> méthode pour récupérer la valeur d’une clé existante.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Dans [.NET pour les applications du Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou la [Bibliothèque de classes portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), interceptez l’exception de la classe de base, <see cref="T:System.MissingMemberException" />, à la place.  
  
</para>
          </block>  
  
 La classe qui représente la valeur de la table ne définit pas de constructeur par défaut.</exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher. <c>key</c> représente l’objet auquel la propriété est jointe.</param>
        <param name="createValueCallback">Délégué d’une méthode qui peut créer une valeur pour l’élément <c>key</c> donné. Il comporte un paramètre unique de type <c>TKey</c> et retourne une valeur de type <c>TValue</c>.</param>
        <summary>Effectue une recherche atomique de la clé spécifiée dans la table et retourne la valeur correspondante. Si la clé n'existe pas dans la table, la méthode appelle une méthode de rappel pour créer une valeur liée à la clé spécifiée.</summary>
        <returns>Valeur attachée à <paramref name="key" />, si <paramref name="key" /> existe déjà dans la table ; sinon, nouvelle valeur retournée par le délégué <paramref name="createValueCallback" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `key` n’existe pas dans la table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> appelle la méthode définie par le `createValueCallback` paramètre et lui passe la clé. Une nouvelle valeur est liée à la clé de la table et retournée comme résultat.  
  
 Utilisez cette méthode uniquement lorsque la classe qui représente la valeur de la table ne définit pas un constructeur par défaut. Si elle ne définit pas un constructeur par défaut, utilisez la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> méthode à la place. Pour récupérer la valeur d’une clé existante sans ajouter la paire clé/valeur si la clé est introuvable dans la table, appelez le <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> (méthode).  
  
 Si plusieurs threads essaient de créer la même clé, `createValueCallback` peut être appelée plusieurs fois avec la même clé. Seul de ces appels réussira, et sa valeur retournée sera ajoutée à la table. Thread qui réussit à créer de la valeur est indéterminé. Cette règle permet à la table d’appeler `createValueCallback` hors du verrou de table interne pour empêcher les interblocages.  
  
   
  
## Examples  
 L’exemple suivant définit un `MainClass` classe et un `MainInfo` (classe), qui fournit des informations sur la `MainClass` instance. Il définit également un statique (`Shared` en Visual Basic) `CreateAttachedValue` méthode qui peut être affectée à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> déléguer et passé à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> (méthode). L’exemple appelle la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> méthode pour ajouter un `MainClass` objet et son joint `MainInfo` de l’objet à un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table. L’exemple illustre également les appels à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> et <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> méthodes pour ajouter des paires clé/valeur à la table et à la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> méthode pour récupérer la valeur d’une clé existante.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ou <paramref name="createValueCallback" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé à supprimer.</param>
        <summary>Supprime une clé et sa valeur de la table.</summary>
        <returns>
          <see langword="true" /> si la recherche et la suppression de la clé réussissent ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé est le garbage collector pendant cette opération, la méthode ne lève pas d’exception et la valeur de retour n’est pas définie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Clé qui représente un objet avec une propriété jointe.</param>
        <param name="value">Quand cette méthode est retournée, contient la valeur de la propriété jointe. Si <c>key</c> est introuvable, <c>value</c> contient la valeur par défaut.</param>
        <summary>Obtient la valeur de la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si la valeur <paramref name="key" /> est trouvée, sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé est le garbage collector pendant cette opération, la méthode peut retourner `false` et `value` à la valeur par défaut (comme si la clé ne figuraient pas) la valeur.  
  
   
  
## Examples  
 L’exemple suivant définit un `MainClass` classe et un `MainInfo` (classe), qui fournit des informations sur la `MainClass` instance. L’exemple appelle la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, et <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> méthodes pour ajouter des paires clé/valeur à un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table. Dans chaque cas, l’exemple appelle la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> méthode pour vérifier que la paire clé/valeur a été ajoutée à la table.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>