<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RuntimeHelpers.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c39d8180904c9260ec3b7f679f09d3791b94ac31.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c39d8180904c9260ec3b7f679f09d3791b94ac31</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Provides a set of static methods and properties that provide support for compilers.</source>
          <target state="translated">Fournit un ensemble de méthodes et de propriétés statiques qui prennent en charge les compilateurs.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>This class cannot be inherited.</source>
          <target state="translated">Cette classe ne peut pas être héritée.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre comment définir de manière fiable des handles à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Pour définir de manière fiable un handle à un handle préexistant spécifié, vous devez vous assurer que l’allocation du handle natif et l’inscription ultérieure de ce handle dans un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> objet est atomique.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Tout échec entre ces opérations (par exemple, un abandon de thread ou une exception de mémoire insuffisante) provoquera la fuite du handle natif.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> méthode pour s’assurer que le descripteur n’est pas intégré.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</source>
          <target state="translated">Garantit que l'espace de pile restant est suffisant pour exécuter la fonction .NET Framework moyenne.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> Fournit des informations sur une pile limitée artificiellement qui conserve assez d’espace pour une exception à lever et une action de récupération à effectuer.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</source>
          <target state="translated">La limite de pile artificielle est choisie par le common language runtime pour garantir que suffisamment d’espace pour lever une exception en toute sécurité.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</source>
          <target state="translated">Cette méthode est utile dans les situations où un débordement de pile peut se produire suite à une récursivité illimitée.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</source>
          <target state="translated">Elle est destinée à utiliser dans les scénarios de services du compilateur, mais il peut également être utilisé en toute sécurité dans d’autres scénarios de développement.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</source>
          <target state="translated">Si l’espace de pile est suffisant, l’exception n’est levée, et la plupart des types .NET Framework et membres peuvent encore être appelées.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette méthode ne fait pas partie de la prise en charge de la région d’exécution limitée et ne doit pas être confondue avec le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The available stack space is insufficient to execute the average .NET Framework function.</source>
          <target state="translated">L'espace de pile disponible est insuffisant pour exécuter la fonction .NET Framework moyenne.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Premier objet à comparer.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">Deuxième objet à comparer.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are considered equal.</source>
          <target state="translated">Détermine si les instances <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> spécifiées sont considérées comme égales.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> parameter is the same instance as the <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> parameter, or if both are <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or if <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>; otherwise, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le paramètre <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> est la même instance que le paramètre <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> ou si les deux ont la valeur <ph id="ph4">&lt;see langword="null" /&gt;</ph>, ou si <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> retourne <ph id="ph5">&lt;see langword="true" /&gt;</ph> ; sinon <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The following example demonstrates how to compare two objects by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre comment comparer deux objets à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to try.</source>
          <target state="translated">Délégué du code à tester.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to run if an exception occurs.</source>
          <target state="translated">Délégué du code à exécuter si une exception se produit.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>The data to pass to <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Données à passer à <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> et <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>Executes code using a <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> while using another <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> to execute additional code in case of an exception.</source>
          <target state="translated">Exécute du code utilisant un <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> tout en utilisant un autre <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> pour exécuter du code supplémentaire en cas d'exception.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>An object to retrieve the hash code for.</source>
          <target state="translated">Objet pour lequel récupérer le code de hachage.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</source>
          <target state="translated">Sert de fonction de hachage pour un objet particulier et convient à une utilisation dans les algorithmes et les structures de données qui utilisent les codes de hachage, comme une table de hachage.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A hash code for the object identified by the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated">Code de hachage pour l'objet identifié par le paramètre <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method always calls the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> méthode appelle toujours la <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> méthode non virtuellement, même si le type d’objet a substitué la <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, using <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> might differ from calling <ph id="ph2">`GetHashCode`</ph> directly on the object with the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Par conséquent, à l’aide de <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> peuvent différer de l’appel <ph id="ph2">`GetHashCode`</ph> directement sur l’objet avec le <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</source>
          <target state="translated">Bien que le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> méthode retourne des codes de hachage identiques pour les références d’objet identiques, vous ne devez pas utiliser cette méthode pour tester l’identité de l’objet, car ce code de hachage n’identifie pas une référence d’objet.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour tester pour identifier les objets (autrement dit, pour tester les deux objets référence le même objet en mémoire), appelez le <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Nor should you use <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.</source>
          <target state="translated">Ni que vous devez utiliser <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> pour tester si deux chaînes représentent des références d’objet égal, car la chaîne est dans le pool interne.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for string interning, call the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour tester la centralisation des chaînes, appelez le <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that is based on the object's definition of equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Retourne un code de hachage qui est basé sur la définition de l’objet de l’égalité.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>For example, two strings with identical contents will return the same value for <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Par exemple, deux chaînes avec un contenu identique retournent la même valeur pour <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that indicates object identity.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Retourne un code de hachage qui indique l’identité de l’objet.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id="p1">[</bpt>String Interning<ept id="p1">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.</source>
          <target state="translated">Autrement dit, deux variables dont le contenu est identique et qui représentent une chaîne qui est dans le pool interne de chaîne (consultez la <bpt id="p1">[</bpt>centralisation des chaînes<ept id="p1">](#interning)</ept> section) ou les codes de hachage qui représentent une chaîne unique dans la mémoire de retour identiques.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Note that <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.</source>
          <target state="translated">Notez que <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> retourne toujours les codes de hachage identiques pour les références aux objets égales.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the reverse is not true: equal hash codes do not indicate equal object references.</source>
          <target state="translated">Toutefois, l’inverse n’est pas vrai : les codes de hachage égales n’indiquent pas les références aux objets égales.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</source>
          <target state="translated">Une valeur de code de hachage n’est pas propre à une référence d’objet particulier ; références d’objet différentes peuvent générer des codes de hachage identiques.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>String Interning</source>
          <target state="translated">Centralisation des chaînes</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</source>
          <target state="translated">Le common language runtime (CLR) conserve un pool interne de chaînes et stocke des littéraux dans le pool.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If two strings (for example, <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> to point to the same location on the managed heap to conserve memory.</source>
          <target state="translated">Si les deux chaînes (par exemple, <ph id="ph1">`str1`</ph> et <ph id="ph2">`str2`</ph>) sont créées à partir d’un même littéral de chaîne, le CLR définit <ph id="ph3">`str1`</ph> et <ph id="ph4">`str2`</ph> pour pointer vers le même emplacement sur le tas managé pour économiser la mémoire.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</source>
          <target state="translated">Appel de <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> sur la chaîne de ces deux objets génère le même code de hachage, contrairement au deuxième élément dans la section précédente.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The CLR adds only literals to the pool.</source>
          <target state="translated">Le CLR ajoute uniquement les littéraux au pool.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</source>
          <target state="translated">Résultats des opérations telles que la concaténation de chaînes ne sont pas ajoutés au pool, à moins que le compilateur résout la concaténation de chaîne comme un littéral de chaîne unique.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, if <ph id="ph1">`str2`</ph> was created as the result of a concatenation operation, and <ph id="ph2">`str2`</ph> is identical to <ph id="ph3">`str1`</ph>, using <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will not produce the same hash code.</source>
          <target state="translated">Par conséquent, si <ph id="ph1">`str2`</ph> a été créé à la suite d’une opération de concaténation, et <ph id="ph2">`str2`</ph> est identique à <ph id="ph3">`str1`</ph>, à l’aide <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> sur la chaîne de ces deux objets ne produisent pas le même code de hachage.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If you want to add a concatenated string to the pool explicitly, use the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous souhaitez ajouter une chaîne concaténée au pool explicitement, utilisez le <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method to check whether a string has an interned reference.</source>
          <target state="translated">Vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> méthode permettant de vérifier si une chaîne a une référence dans le pool interne.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The following example demonstrates the difference between the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">L’exemple suivant illustre la différence entre la <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The output from the example illustrates the following:</source>
          <target state="translated">La sortie de l’exemple illustre les éléments suivants :</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Both sets of hash codes for the first set of strings passed to the <ph id="ph1">`ShowHashCodes`</ph> method are different, because the strings are completely different.</source>
          <target state="translated">Les deux jeux de codes de hachage pour le premier ensemble de chaînes passé à la <ph id="ph1">`ShowHashCodes`</ph> méthode sont différents, car les chaînes sont complètement différentes.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> generates the same hash code for the second set of strings passed to the <ph id="ph2">`ShowHashCodes`</ph> method, because the strings are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> génère le même code de hachage pour le deuxième ensemble de chaînes passé à la <ph id="ph2">`ShowHashCodes`</ph> (méthode), étant donné que les chaînes sont égales.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method does not.</source>
          <target state="translated">Toutefois, le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> n’est pas le cas de méthode.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The first string is defined by using a string literal and so is interned.</source>
          <target state="translated">La première chaîne est définie à l’aide d’un littéral de chaîne et par conséquent, est dans le pool interne.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the value of the second string is the same, it is not interned, because it is returned by a call to the <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Bien que la valeur de la deuxième chaîne est le même, il n'est pas dans le pool interne, car il est retourné par un appel à la <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>In the case of the third string, the hash codes produced by <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> for both strings are identical, as are the hash codes produced by <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dans le cas de la troisième chaîne, les codes de hachage généré par <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> pour les deux chaînes sont identiques, comme le sont les codes de hachage générés par <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</source>
          <target state="translated">C’est parce que le compilateur a traité la valeur affectée à ces deux chaînes comme un littéral de chaîne unique et les variables de chaîne faire référence à la même chaîne dans le pool interne.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The value type to be boxed.</source>
          <target state="translated">Type valeur à convertir.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxes a value type.</source>
          <target state="translated">Convertit un type valeur.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>A boxed copy of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> if it is a value class; otherwise, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> itself.</source>
          <target state="translated">Copie convertie de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> s'il s'agit d'une classe de valeur ; sinon, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> lui-même.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</source>
          <target state="translated">Boxing d’un type valeur crée un objet et effectue une copie superficielle des champs du type valeur spécifié dans le nouvel objet.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</source>
          <target state="translated">Cette méthode permet à une classe value d’être manipulée comme un objet tout en conservant le comportement de l’alias d’une classe value.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The return value depends on whether the value class is mutable or immutable:</source>
          <target state="translated">La valeur de retour varie selon que la classe de valeur est mutable ou immuable :</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</source>
          <target state="translated">Si la valeur assignée est une classe de valeur mutable, la méthode retourne une copie superficielle de la classe, car les classes de valeur ont une sémantique de copie.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</source>
          <target state="translated">Si la valeur assignée est une classe de valeur immuable, la méthode retourne l’objet lui-même, au lieu d’une copie de la classe.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</source>
          <target state="translated">Compilateurs de langages dynamiquement typés peuvent utiliser cette méthode pour vous assurer que les types valeur boxed fonctionnent de façon identique pour les types valeur unboxed.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>That is, boxed value types get cloned when you pass them around, and they are always passed by value.</source>
          <target state="translated">Autrement dit, types valeur boxed sont multipliés lorsque vous les passez autour, et ils sont toujours passés par valeur.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The compiler can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.</source>
          <target state="translated">Le compilateur peut appeler <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> pour assigner un type valeur à un objet ou pour passer un type valeur en tant que paramètre d’un objet de type.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The following example demonstrates how to box a value class by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre comment la zone d’une classe de valeur à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>The array to be initialized.</source>
          <target state="translated">Tableau à initialiser.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>A field handle that specifies the location of the data used to initialize the array.</source>
          <target state="translated">Handle de champ qui spécifie l'emplacement des données utilisées pour l'initialisation du tableau.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>Provides a fast way to initialize an array from data that is stored in a module.</source>
          <target state="translated">Fournit un moyen rapide d'initialiser un tableau à partir de données stockées dans un module.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Gets the offset, in bytes, to the data in the given string.</source>
          <target state="translated">Obtient l'offset, en octets, jusqu'aux données figurant dans la chaîne donnée.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>The byte offset, from the start of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object to the first character in the string.</source>
          <target state="translated">Offset, en octets, à partir du début de l'objet <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> jusqu'au premier caractère de la chaîne.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</source>
          <target state="translated">Les compilateurs utilisent cette propriété pour les opérations de pointeur non sécurisé, mais elle est efficace, sur les caractères d’une chaîne managée.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers should pin the string against movement by the garbage collector before use.</source>
          <target state="translated">Ils doivent épingler la chaîne sur les mouvements par le garbage collector avant des utiliser.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</source>
          <target state="translated">Notez que les chaînes du Common language runtime sont immuables ; Autrement dit, leur contenu peut être lues mais pas modifié.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Designates a body of code as a constrained execution region (CER).</source>
          <target state="translated">Désigne une partie de code comme région d'exécution limitée.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Compilers use this method to mark <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, and <ph id="ph3">`fault`</ph> blocks as constrained execution regions (CERs).</source>
          <target state="translated">Les compilateurs utilisent cette méthode pour marquer <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, et <ph id="ph3">`fault`</ph> blocs comme régions d’exécution limitée (CER).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Code that is marked as a constrained region must only call other code with strong reliability contracts.</source>
          <target state="translated">Code qui est marqué comme région limitée doit uniquement appeler du code avec des contrats de fiabilité forts.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</source>
          <target state="translated">Il ne doit pas allouer ou effectuer des appels virtuels à des méthodes non préparées ou peu fiables, sauf si elle est prête à gérer les échecs.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Note that no intermediate language opcodes, except <ph id="ph1">`NOP`</ph>, are allowed between a call to the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">Notez que vous ne les intermédiaires opcodes de langage, à l’exception de <ph id="ph1">`NOP`</ph>, sont autorisés entre un appel à la <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> (méthode) et le <ph id="ph3">`try`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information about CERs, see the classes in the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</source>
          <target state="translated">Pour plus d’informations sur les régions d’exécution limitée, consultez les classes dans le <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> espace de noms.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>CERs that are marked using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">Cer qui sont marquées à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> méthode ne fonctionnent pas parfaitement lorsqu’un <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> est généré à partir la <ph id="ph3">`try`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.</source>
          <target state="translated">Pour plus d'informations, voir la méthode <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> appelle la méthode <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre comment définir de manière fiable des handles à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">Pour définir de manière fiable un handle à un handle préexistant spécifié, vous devez vous assurer que l’allocation du handle natif et l’inscription ultérieure de ce handle dans un <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> objet est atomique.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">Tout échec entre ces opérations (par exemple, un abandon de thread ou une exception de mémoire insuffisante) provoquera la fuite du handle natif.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> méthode pour s’assurer que le descripteur n’est pas intégré.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Designates a body of code as a constrained execution region (CER) without performing any probing.</source>
          <target state="translated">Désigne une partie de code comme région d'exécution limitée sans effectuer de détection.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Compilers should not call this method directly.</source>
          <target state="translated">Les compilateurs ne doivent pas appeler cette méthode directement.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Instead, define a CER by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu de cela, définissez une région d’exécution limitée en appelant le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>The event delegate to prepare.</source>
          <target state="translated">Délégué d'événement à préparer.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Provides a way for applications to dynamically prepare <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> event delegates.</source>
          <target state="translated">Offre aux applications un moyen de préparer des délégués d'événements <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> dynamiquement.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> délégués d’événement comme <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, et <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> ne sont pas préparés automatiquement au démarrage.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>You can use the following methods to prepare them:</source>
          <target state="translated">Vous pouvez utiliser les méthodes suivantes pour préparer les :</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.</source>
          <target state="translated">Attribut de la méthode à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribut.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.</source>
          <target state="translated">Attribut de la méthode à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribut.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> méthode pour préparer le délégué dynamiquement.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>For more information, see the article <bpt id="p1">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.</source>
          <target state="translated">Pour plus d’informations, consultez l’article <bpt id="p1">[</bpt>conserver votre Code en cours d’exécution avec les fonctionnalités de fiabilité du .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> dans MSDN Magazine.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>The delegate type to prepare.</source>
          <target state="translated">Type délégué à préparer.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Indique que le délégué spécifié doit être préparé pour être inclus dans une région d'exécution limitée.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</source>
          <target state="translated">Les compilateurs utilisent cette méthode pour préparer la méthode d’appel d’un délégué et pour préparer la cible de cet appel (ainsi que le graphique des appels pouvant être déterminé statiquement du délégué) comme une région d’exécution limitée (CER).</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Prépare une méthode en vue d'une intégration dans une région d'exécution limitée.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Handle vers la méthode à préparer.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">Prépare une méthode en vue d'une intégration dans une région d'exécution limitée.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Compilers use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).</source>
          <target state="translated">Les compilateurs utilisent le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> méthode pour gérer les appels virtuels qui sont effectués à l’intérieur d’une région d’exécution limitée (CER).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</source>
          <target state="translated">Au moment de la compilation JIT, le common language runtime n’a pas généralement suffisamment d’informations sur la cible d’un appel virtuel.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Therefore, the runtime does not initially prepare that segment of the call graph.</source>
          <target state="translated">Par conséquent, le runtime ne prépare pas initialement ce segment du graphique des appels.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</source>
          <target state="translated">Si le code qui est à l’aide de la région d’exécution limitée en sait assez pour déterminer la cible à n’importe quel point dans le temps avant la CER est entré en fait, il peut appeler <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> pour effectuer la même préparation du runtime normalement pour une région d’exécution limitée rattachée à la méthode spécifiée en tant qu’argument.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>A handle to the method to prepare.</source>
          <target state="translated">Handle vers la méthode à préparer.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The instantiation to pass to the method.</source>
          <target state="translated">Instanciation à passer à la méthode.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</source>
          <target state="translated">Prépare une méthode en vue d'une intégration dans une région d'exécution limitée avec l'instanciation spécifiée.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can provide generics support for compilers by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Vous pouvez fournir génériques prennent en charge pour les compilateurs à l’aide de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</source>
          <target state="translated">Le common language runtime ne peut pas préparer de régions d’exécution limitée (CER) associé à une méthode qui a des paramètres de type générique (soit un paramètre de type sur la classe contenant la méthode ou sur la méthode elle-même) lorsque ces paramètres de type sont instanciés comme les types référence.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</source>
          <target state="translated">Vous pouvez utiliser cette surcharge pour passer une instanciation spécifique (par exemple, un tableau de types), en spécifiant les paramètres de type classe tout d’abord (le cas échéant), suivi par les paramètres de type (méthode) (le cas échéant).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The runtime prepares that instantiation of the method.</source>
          <target state="translated">Le runtime prépare cette instanciation de la méthode.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id="ph1">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> or other value types.</source>
          <target state="translated">(Cela est nécessaire uniquement si les instanciations que vous utilisez contiennent au moins un paramètre de type de référence). Par conséquent, vous pouvez utiliser un style CER <ph id="ph1">`try`</ph> clause dans une méthode générique (ou une méthode non générique sur une classe générique) et elle fonctionnera parfaitement avec les instanciations de <ph id="ph2">&lt;xref:System.Int32&gt;</ph> ou d’autres types de valeur.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>To instantiate reference types such as <ph id="ph1">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.</source>
          <target state="translated">Pour instancier la référence des types tels que <ph id="ph1">&lt;xref:System.String&gt;</ph>, vous devez utiliser explicite <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> tout d’abord méthode méthode sur la région d’exécution limitée de racine.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</source>
          <target state="translated">Recherche une certaine quantité d'espace de pile, en vue de garantir l'impossibilité d'un dépassement de capacité de la pile dans un bloc de code suivant (en partant du principe que votre code utilise seulement une quantité limitée et modérée d'espace de pile).</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>We recommend that you use a constrained execution region (CER) instead of this method.</source>
          <target state="translated">Nous vous recommandons d'utiliser une région d'exécution limitée à la place de cette méthode.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</source>
          <target state="translated">Cette méthode est utilisée par l’infrastructure de la région d’exécution limitée lors de l’exécution dans des hôtes qui sont résilients à un débordement de pile tels que Microsoft SQL Server et Microsoft Exchange Server.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</source>
          <target state="translated">Cette méthode actuellement détecte 48 Ko d’espace de pile sur le x86 plateforme, mais la quantité exacte peut changer au fil du temps et peut varier sur d’autres plateformes.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is also used by compilers.</source>
          <target state="translated">Cette méthode est également utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.</source>
          <target state="translated">Au lieu d’utiliser le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> (méthode), vous devez utiliser une région d’exécution limitée standard.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>That is, if you are planning to use a moderate amount of stack space, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method immediately before your <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> or <ph id="ph5">`try`</ph><ph id="ph6">/</ph><ph id="ph7">`catch`</ph> block.</source>
          <target state="translated">Autrement dit, si vous envisagez d’utiliser une quantité modérée d’espace de pile, appelez le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> méthode immédiatement avant votre <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph> ou <ph id="ph5">`try`</ph> <ph id="ph6">/</ph> <ph id="ph7">`catch`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous appelez une méthode récursive ou utiliser une grande quantité d’espace de pile, vous devez utiliser le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>A type handle that specifies the class constructor method to run.</source>
          <target state="translated">Handle de type qui spécifie la méthode de constructeur de classe à exécuter.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>Runs a specified class constructor method.</source>
          <target state="translated">Exécute une méthode de constructeur de classe spécifiée.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>The class initializer throws an exception.</source>
          <target state="translated">L'initialiseur de classe lève une exception.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>A handle that specifies the module constructor method to run.</source>
          <target state="translated">Handle qui spécifie la méthode du constructeur du module à exécuter.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>Runs a specified module constructor method.</source>
          <target state="translated">Exécute une méthode de constructeur de module spécifiée.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">Cette méthode est utilisée par les compilateurs.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>The module constructor throws an exception.</source>
          <target state="translated">Le constructeur de module lève une exception.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>