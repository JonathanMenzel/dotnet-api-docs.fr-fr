<Type Name="MarkupProperty" FullName="System.Windows.Markup.Primitives.MarkupProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cec9e4b44f9d6119d8e215019c75697d3421462b" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37560299" /></Metadata><TypeSignature Language="C#" Value="public abstract class MarkupProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MarkupProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.Primitives.MarkupProperty" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarkupProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarkupProperty abstract" />
  <TypeSignature Language="F#" Value="type MarkupProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Classe abstraite qui fournit une description de propriété à utiliser lors de l'écriture dans le balisage pour encapsuler l'accès aux propriétés et à leurs valeurs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est représentée comme une chaîne ou une liste d’éléments.  
  
 Si la propriété peut être représentée sous forme de chaîne, <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> est `false`.  
  
 Si <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> est `true`, la propriété est une liste d’éléments.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.ComponentModel.AttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.AttributeCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::ComponentModel::AttributeCollection ^ Attributes { System::ComponentModel::AttributeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.ComponentModel.AttributeCollection" Usage="System.Windows.Markup.Primitives.MarkupProperty.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient les attributs associés à ce <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" />.</summary>
        <value>Collection d’attributs.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient l'identificateur <see cref="T:System.Windows.DependencyProperty" /> pour la propriété du balisage si la propriété est implémentée en tant que propriété de dépendance.</summary>
        <value>Identificateur de la propriété de dépendance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut retourne `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttached">
      <MemberSignature Language="C#" Value="public virtual bool IsAttached { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttached" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsAttached" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAttached As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAttached { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttached : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsAttached" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, détermine si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> est une <see cref="T:System.Windows.DependencyProperty" /> attachée.</summary>
        <value><see langword="true" /> si la propriété est une <see cref="T:System.Windows.DependencyProperty" /> attachée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut consiste à retourner `false`.  
  
 Lorsque <xref:System.Windows.Markup.Primitives.MarkupProperty.IsAttached%2A> est `true`, <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> n’est pas `null` et <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> peut être `null`, mais n’est pas requis pour être.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComposite">
      <MemberSignature Language="C#" Value="public virtual bool IsComposite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsComposite" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsComposite" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsComposite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsComposite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsComposite : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsComposite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, détermine si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> est une propriété composite.</summary>
        <value><see langword="true" /> s'il s'agit d'une propriété composite ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut consiste à retourner `false`.  
  
 Si <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> est `false`, la propriété peut être représentée sous forme de chaîne et <xref:System.Windows.Markup.Primitives.MarkupProperty.Value%2A> et <xref:System.Windows.Markup.Primitives.MarkupProperty.StringValue%2A> sont valides à utiliser.  
  
 Si <xref:System.Windows.Markup.Primitives.MarkupProperty.IsComposite%2A> est `true`, la propriété est un ou plusieurs éléments et <xref:System.Windows.Markup.Primitives.MarkupProperty.Items%2A> est valide à utiliser.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructorArgument">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructorArgument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructorArgument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructorArgument As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructorArgument { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructorArgument : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, détermine si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> représente un argument de constructeur.</summary>
        <value><see langword="true" /> si cette propriété représente un argument de constructeur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut est de retour `false`.  
  
 Lorsque <xref:System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument%2A> est `true`, <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> et <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> sont tous deux `null`.  
  
 XAML utilise uniquement <xref:System.Windows.Markup.Primitives.MarkupProperty.IsConstructorArgument%2A> pour représenter les arguments de constructeur d’instances de <xref:System.Windows.Markup.MarkupExtension>. Consultez [Extensions de balisage et XAML de WPF](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContent">
      <MemberSignature Language="C#" Value="public virtual bool IsContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContent : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, détermine si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> représente le contenu direct d'une collection.</summary>
        <value><see langword="true" /> si la propriété représente le contenu direct ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut consiste à retourner `false`.  
  
 Lorsque <xref:System.Windows.Markup.Primitives.MarkupProperty.IsContent%2A> est `true`, <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> et <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> sont tous deux `null`.  
  
 Les dictionnaires sont inclus lorsque vous déterminez si cela <xref:System.Windows.Markup.Primitives.MarkupProperty> représente le contenu direct.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKey">
      <MemberSignature Language="C#" Value="public virtual bool IsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsKey { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKey : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, détermine si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> représente la clé utilisée par l'<see cref="T:System.Windows.Markup.Primitives.MarkupObject" /> pour stocker l'élément dans un dictionnaire.</summary>
        <value><see langword="true" /> si cette propriété représente une clé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut consiste à retourner `false`.  
  
 Lorsque <xref:System.Windows.Markup.Primitives.MarkupProperty.IsKey%2A> est `true`, <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> et <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> sont `null`.  
  
 XAML utilise la propriété identifiée comme un `x:Key` attribut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueAsString">
      <MemberSignature Language="C#" Value="public virtual bool IsValueAsString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueAsString" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsValueAsString As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsValueAsString { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueAsString : bool" Usage="System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, détermine si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> représente le texte passé à un convertisseur de type pour créer une instance de la propriété ou si un constructeur doit être utilisé.</summary>
        <value><see langword="true" />, si cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> représente une chaîne ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut consiste à retourner `false.`  
  
 Lorsque <xref:System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString%2A> est `true`, <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> et <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> sont tous deux `null`.  
  
 Si la propriété est fournie via <xref:System.Windows.Markup.Primitives.MarkupObject.Properties%2A> et <xref:System.Windows.Markup.Primitives.MarkupProperty.IsValueAsString%2A> est `true`, il sera la seule propriété qui fournit le type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;System.Windows.Markup.Primitives.MarkupObject&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Markup.Primitives.MarkupObject&gt; Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Items" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Items As IEnumerable(Of MarkupObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;System::Windows::Markup::Primitives::MarkupObject ^&gt; ^ Items { System::Collections::Generic::IEnumerable&lt;System::Windows::Markup::Primitives::MarkupObject ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : seq&lt;System.Windows.Markup.Primitives.MarkupObject&gt;" Usage="System.Windows.Markup.Primitives.MarkupProperty.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Markup.Primitives.MarkupObject&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient les éléments qui constituent la valeur de cette propriété.</summary>
        <value>Éléments qui constituent la valeur de cette propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la propriété n’est pas une énumération, un seul élément sera retourné.  
  
 Si la propriété est une énumération ou énumérable, tous les éléments seront retournés.  
  
 Au moins un élément est toujours retourné, car <xref:System.Windows.Markup.Primitives.MarkupObject> ne crée pas une <xref:System.Windows.Markup.Primitives.MarkupProperty> pour les propriétés sans éléments.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.Markup.Primitives.MarkupProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient un nom utilisé pour le diagnostic et le signalement d'erreurs.</summary>
        <value>Nom de la propriété d'identificateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un sérialiseur ne doit pas utiliser cette valeur. Il doit utiliser le <xref:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor%2A> et/ou <xref:System.Windows.Markup.Primitives.MarkupProperty.DependencyProperty%2A> à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor PropertyDescriptor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor PropertyDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PropertyDescriptor As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ PropertyDescriptor { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyDescriptor : System.ComponentModel.PropertyDescriptor" Usage="System.Windows.Markup.Primitives.MarkupProperty.PropertyDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le <see cref="T:System.ComponentModel.PropertyDescriptor" /> pour la propriété de balisage.</summary>
        <value>Descripteur de propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut retourne `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public abstract Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.Markup.Primitives.MarkupProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le type CLR de la propriété.</summary>
        <value>Type CLR.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringValue">
      <MemberSignature Language="C#" Value="public abstract string StringValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StringValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.StringValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property StringValue As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ StringValue { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StringValue : string" Usage="System.Windows.Markup.Primitives.MarkupProperty.StringValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de chaîne de cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" />.</summary>
        <value>Valeur de chaîne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.TypeReferences" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeReferences As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeReferences : seq&lt;Type&gt;" Usage="System.Windows.Markup.Primitives.MarkupProperty.TypeReferences" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le jeu des types que cette <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" /> référencera lors de la sérialisation de sa valeur sous forme de chaîne.</summary>
        <value>Jeu de types.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.Primitives.MarkupProperty.TypeReferences%2A> permet à un sérialiseur pour vous assurer que le désérialiseur dispose de suffisamment d’informations pour convertir des références à ces types dans les représentations sous forme de chaîne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.Primitives.MarkupProperty.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Windows.Markup.Primitives.MarkupProperty.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur actuelle de <see cref="T:System.Windows.Markup.Primitives.MarkupProperty" />.</summary>
        <value>Valeur en cours.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>