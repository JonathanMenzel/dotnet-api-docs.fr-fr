<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9b2639e239210ebe728a40503f974e5c84411b76" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52740621" /></Metadata><TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente un type de données Large Object Binary (<see langword="LOB" />) stocké sur un serveur Oracle. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.OracleClient.OracleLob> diffère d’un <xref:System.Data.OracleClient.OracleBFile> car les données sont stockées sur le serveur au lieu de dans un fichier physique dans le système d’exploitation. Il peut également être un objet en lecture-écriture, contrairement à un <xref:System.Data.OracleClient.OracleBFile>, qui est toujours en lecture seule.  
  
 Un <xref:System.Data.OracleClient.OracleLob> peut être un de ces <xref:System.Data.OracleClient.OracleType> types de données.  
  
|Type de données OracleType|Description |  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` type de données qui contient des données binaires d’une taille maximale de 4 gigaoctets (Go). Correspond à un <xref:System.Array> de type <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` type de données qui contient des données caractères, selon le caractère par défaut défini sur le serveur, avec une taille maximale de 4 Go. Correspond à <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` type de données qui contient des données caractères, selon le jeu sur le serveur avec une taille maximale de 4 Go de caractères nationaux. Correspond à <xref:System.String>.|  
  
 Un développeur d’applications .NET peut récupérer le Oracle `LOB` valeurs dans les types de données de base .NET, telles que <xref:System.Array> de type <xref:System.Byte> et <xref:System.String>, ou spécialisées <xref:System.Data.OracleClient.OracleLob> type de données. Le <xref:System.Data.OracleClient.OracleLob> classe prend en charge la lecture et écriture dans Oracle `LOB` dans la base de données Oracle.  
  
 Voici les principales caractéristiques d’un <xref:System.Data.OracleClient.OracleLob> type de données qui la distinguent de types de données de base .NET :  
  
-   Après avoir récupéré le Oracle `LOB` valeur à partir de la base de données Oracle dans le <xref:System.Data.OracleClient.OracleLob> (classe), vous pouvez modifier le `LOB` données dans une transaction ouverte et vos modifications sont reflétées directement dans la base de données. Si vous récupérez le Oracle `LOB` valeur dans un <xref:System.Array> de type <xref:System.Byte> ou <xref:System.String> et mettre à jour ces tableaux, vos modifications ne sont pas reflétées dans la base de données.  
  
-   Lorsque vous utilisez le <xref:System.Data.OracleClient.OracleLob> classe pour accéder à un segment d’un `LOB` valeur, seul ce segment est passé à partir de la base de données Oracle au client. Lorsque vous utilisez le <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> méthode pour accéder à un segment d’un `LOB` valeur, tout le contenu de la valeur est passé à partir de la base de données Oracle au client.  
  
 Pour obtenir un <xref:System.Data.OracleClient.OracleLob> de l’objet, appelez le <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> (méthode).  
  
 Vous pouvez construire un <xref:System.Data.OracleClient.OracleLob> qui a la valeur NULL à l’aide de ce format :  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Cette technique est utilisée principalement pour tester si un `LOB` retournée par le serveur est NULL, comme l’illustre cet exemple :  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Une valeur NULL `LOB` se comporte comme un zéro octet `LOB` dans la mesure <xref:System.Data.OracleClient.OracleLob.Read%2A> réussit et retourne toujours zéro octet.  
  
 En sélectionnant un `LOB` colonne qui contient une valeur null retourne <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 Vous devez commencer une transaction avant d’obtenir une table temporaire `LOB`. Sinon, le <xref:System.Data.OracleClient.OracleDataReader> ne peut pas obtenir les données ultérieurement.  
  
 Vous pouvez également ouvrir une table temporaire `LOB` dans Oracle en appelant le DBMS_LOB. Système CREATETEMPORARY procédure stockée et liaison un `LOB` paramètre de sortie. Côté client, une table temporaire `LOB` se comporte comme une table de base `LOB`. Par exemple, pour mettre à jour la fichier temporaire `LOB`, il doit être placé dans une transaction.  
  
 L’exemple c# suivant montre comment ouvrir une table temporaire `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  Hérité <xref:System.IO.Stream.WriteByte%2A> méthode échoue si utilisé avec les données de type caractère et un <xref:System.InvalidOperationException> est levée. Utilisez plutôt la méthode <xref:System.Data.OracleClient.OracleLob.Write%2A>.  
>   
>  Temporaire `LOB`s ne sont fermés lorsque la connexion est fermée, mais avec le regroupement et sous charge, `LOB`s ne fermez pas. Cela peut être résolu en supprimant la fichier temporaire `LOB`, en appelant `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source"><see langword="LOB" /> à partir duquel ajouter des données.</param>
        <summary>Ajoute des données à partir du <see langword="LOB" /> spécifié au <see langword="LOB" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
 Toutes les données à partir de la source `LOB` est ajouté à la fin de l’actuel `LOB`. La position de ni `LOB` est évalué, ni modifié pendant ce processus.  
  
 Les types de données sous-jacente doivent toujours être le même. Par exemple, si vous ajoutez à partir d’un <xref:System.Data.OracleClient.OracleType.NClob>, la destination <xref:System.Data.OracleClient.OracleLob> doit également être un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  Dans cette version, une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Data.OracleClient.OracleLob" /> source est de type null.</exception>
        <exception cref="T:System.InvalidOperationException">La source <see cref="T:System.Data.OracleClient.OracleLob" /> est null, ou la connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet <see cref="T:System.Data.OracleClient.OracleLob" /> source était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empêche les déclencheurs côté serveur de s'activer lors d'opérations d'écriture multiples.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empêche les déclencheurs côté serveur de s'activer lors d'opérations de lecture multiples.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ouvre le `LOB` dans <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> mode ; par conséquent, le `LOB` peut uniquement être lu, ne pas écrit, jusqu'à l’appel correspondant à <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Pour effectuer des écritures par lots dans le `LOB`, appelez <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> avec <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 Appelant <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> plusieurs fois dans la même transaction lève Oracle « ORA-22293 : Erreur LOB déjà ouvert dans la même transaction ». En outre, si vous obtenez le `LOB` à l’aide d’un autre <xref:System.Data.OracleClient.OracleDataReader>, et l’appelant d’origine n’a pas appelé le <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> méthode, la même erreur est générée. Par conséquent, vous devez appeler la <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Mode (l'une des valeurs <see cref="T:System.Data.OracleClient.OracleLobOpenMode" />) dans lequel le <see langword="LOB" /> est accessible entre cet appel <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> et l'appel <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> correspondant.</param>
        <summary>Empêche les déclencheurs côté serveur de s'activer lors d'opérations de lecture et d'écriture dans le mode d'accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
 Appelant <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> plusieurs fois dans la même transaction lève Oracle « ORA-22293 : Erreur LOB déjà ouvert dans la même transaction ». En outre, si vous obtenez le `LOB` à l’aide d’un autre <xref:System.Data.OracleClient.OracleDataReader>, et l’appelant d’origine n’a pas appelé le <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> méthode, la même erreur est générée. Par conséquent, vous devez appeler la <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux <see langword="LOB" /> peut être lu.</summary>
        <value><see langword="true" /> si le flux <see langword="LOB" /> prend en charge la lecture ; sinon, <see langword="false" /> si <see langword="LOB" /> est fermé ou supprimé.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si des opérations de recherche vers l'avant ou vers l'arrière peuvent être effectuées.</summary>
        <value><see langword="false" /> si <see langword="LOB" /> est fermé ou supprimé ; sinon, <see langword="true" />. Toujours <see langword="true" /> pour <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne toujours la valeur true, que <see langword="LOB" /> prenne en charge l'écriture ou non.</summary>
        <value>Retourne toujours <see langword="true" />, qu'un <see langword="LOB" /> ouvert ou non supprimé prenne en charge l'écriture ou non ; <see langword="false" /> si <see langword="LOB" /> est fermé ou supprimé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et que vous devez avoir démarré une transaction locale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant le nombre minimal d'octets à récupérer du serveur ou à envoyer à celui-ci au cours d'une opération de lecture/écriture.</summary>
        <value>Nombre minimal d'octets à récupérer ou à envoyer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par la <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> propriété n’est pas un paramètre du fournisseur de données .NET Framework pour Oracle. Au lieu de cela, c’est la valeur qui utilise l’Interface OCI (Oracle Call) pour communiquer avec le serveur. Utilisez <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> pour vous assurer que les fragments côté client ont la même taille. Lecture ou l’écriture en blocs plus petits ne met en cache des données et entraîne un aller-retour moins optimisé pour le serveur, car un paquet entier n’est pas reçu ou envoyé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet <see cref="T:System.Data.OracleClient.OracleLob" /> qui référence le même objet <see langword="LOB" /> Oracle que l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> d'origine.</summary>
        <returns>Nouvel objet <see cref="T:System.Data.OracleClient.OracleLob" /> qui référence le même objet <see langword="LOB" /> Oracle que l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> d'origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés du nouveau <xref:System.Data.OracleClient.OracleLob> objet ont initialement les mêmes valeurs que celles de l’objet d’origine. Toutefois, après le <xref:System.Data.OracleClient.OracleLob.Clone%2A> est terminée, chaque <xref:System.Data.OracleClient.OracleLob> objet est indépendant de l’autre. Par exemple, remplacer la valeur de la <xref:System.Data.OracleClient.OracleLob.Position%2A> propriété sur l’original <xref:System.Data.OracleClient.OracleLob> ne modifie pas la valeur de <xref:System.Data.OracleClient.OracleLob.Position%2A> sur la copie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="oracleLob.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le flux de données actuel et libère toutes les ressources système qui lui sont associées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Data.OracleClient.OracleConnection" /> utilisé par cette instance de <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Connexion à une source de données.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie de <see cref="T:System.Data.OracleClient.OracleLob" /> vers un <see cref="T:System.Data.OracleClient.OracleLob" /> de destination.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination"><see cref="T:System.Data.OracleClient.OracleLob" /> de destination.</param>
        <summary>Copie de <see cref="T:System.Data.OracleClient.OracleLob" /> vers un <see cref="T:System.Data.OracleClient.OracleLob" /> de destination.</summary>
        <returns>Nombre d'octets copiés. Les octets remplis sont exclus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types de données sous-jacente doivent toujours être le même. Par exemple, si vous copiez à partir d’un <xref:System.Data.OracleClient.OracleType.NClob>, la destination <xref:System.Data.OracleClient.OracleLob> doit également être un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Si l’offset de destination est au-delà de la fin de la destination `LOB`, le `LOB` à laquelle les données sont copiées est étendu. L’espace entre la fin de la `LOB` et l’offset de destination après la fin est rempli de zéros pour `BLOB` types de données et d’espaces pour `CLOB` et `NCLOB` des types de données.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Dans cette version, une opération d’écriture en lecture seule `LOB` peut aboutir, mais pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` sera mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
>   
>  Le `CopyTo` méthode n’efface pas le contenu de la destination `OracleLob` avant d’effectuer l’opération de copie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Data.OracleClient.OracleLob" /> spécifié dans le paramètre <paramref name="destination" /> est null.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><see cref="T:System.Data.OracleClient.OracleLob" /> de destination.</param>
        <param name="destinationOffset">L'offset auquel la copie doit être effectuée. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre d'octets.</param>
        <summary>Copie les données de l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> vers un objet <see cref="T:System.Data.OracleClient.OracleLob" /> de destination avec la quantité de données spécifiée.</summary>
        <returns>Nombre d'octets copiés. Les octets remplis sont exclus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types de données sous-jacente doivent toujours être le même. Par exemple, si vous copiez à partir d’un <xref:System.Data.OracleClient.OracleType.NClob>, la destination <xref:System.Data.OracleClient.OracleLob> doit également être un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Si l’offset de destination est au-delà de la fin de la destination `LOB`, le `LOB` à laquelle les données sont copiées est étendu. L’espace entre la fin de `LOB` et de l’offset de destination après la fin est rempli de zéros pour `BLOB` types de données et d’espaces pour `CLOB` et `NCLOB` des types de données.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Dans cette version, une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
>   
>  Le `CopyTo` méthode n’efface pas le contenu de la destination `OracleLob` avant d’effectuer l’opération de copie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Data.OracleClient.OracleLob" /> spécifié dans le paramètre <paramref name="destination" /> est complet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur spécifiée dans le paramètre <paramref name="destinationOffset" /> est inférieure à zéro ou supérieure à 4 giga-octets.  
  
- ou - 
Une valeur spécifiée dans le paramètre <paramref name="destinationOffset" /> pour un type de données <see langword="CLOB" /> ou <see langword="NCLOB" /> n'est pas paire.  
  
ou 
Vous devez spécifier les types de données <see langword="CLOB" /> et <see langword="NCLOB" /> en tant que nombre d'octets pair.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">L'offset à partir duquel la copie doit être effectuée. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <param name="destination"><see langword="OracleLob" /><see cref="N:System.Data.OracleClient" /> de destination.</param>
        <param name="destinationOffset">L'offset de destination vers lequel la copie doit être effectuée. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <param name="amount">Quantité de données, en octets, à copier. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <summary>Copie de cet objet <see cref="T:System.Data.OracleClient.OracleLob" /> vers l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> de destination avec la quantité de données spécifiée et l'offset source.</summary>
        <returns>Nombre d'octets copiés. Les octets remplis sont exclus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types de données sous-jacente doivent toujours être le même. Par exemple, si vous copiez à partir d’un <xref:System.Data.OracleClient.OracleType.NClob>, la destination <xref:System.Data.OracleClient.OracleLob> doit également être un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Si l’offset de destination est au-delà de la fin de la destination `LOB`, le `LOB` à laquelle les données sont copiées est étendu. L’espace entre la fin de `LOB` et de l’offset de destination après la fin est rempli de zéros pour `BLOB` types de données et d’espaces pour `CLOB` et `NCLOB` des types de données.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Dans cette version, une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
>   
>  Le `CopyTo` méthode n’efface pas le contenu de la destination `OracleLob` avant d’effectuer l’opération de copie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <see cref="T:System.Data.OracleClient.OracleLob" /> spécifié dans le paramètre <paramref name="destination" /> est complet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur spécifiée dans le paramètre <paramref name="amount" />, <paramref name="sourceOffset" /> ou <paramref name="destinationOffset" /> est inférieure à zéro ou supérieure à 4 giga-octets.  
  
ou 
Une valeur spécifiée dans le paramètre <paramref name="amount" />, <paramref name="sourceOffset" /> ou <paramref name="destinationOffset" /> pour un type de données <see langword="CLOB" /> ou <see langword="NCLOB" />n'est pas paire.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="oracleLob.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par cet objet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empêche les déclencheurs côté serveur de reprendre leur activité après des opérations d'écriture multiples.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> méthode avant de commencer à effectuer les opérations d’écriture sur le <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Efface des données dans <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les données de <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Nombre d'octets effacés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> ne tronque pas les données. Le `LOB` longueur reste la même pour un `BLOB` type de données, et les données effacées sont remplacées par 0 x 00. `CLOB` et `NCLOB` types de données sont remplacés par des espaces.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Dans cette version, une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">L'offset à partir duquel effacer. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <param name="amount">Quantité de données, en octets, à effacer. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <summary>Efface la quantité de données spécifiée dans <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Nombre d'octets effacés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La somme des valeurs dans le `offset` et `amount` paramètres peuvent être supérieures à celle de la taille de la <xref:System.Data.OracleClient.OracleLob>. Par conséquent, en spécifiant une valeur supérieure à celle retournée par la <xref:System.Data.OracleClient.OracleLob.Length%2A> propriété réussit ; toutefois <xref:System.Data.OracleClient.OracleLob.Erase%2A> n’efface que jusqu'à la fin de la <xref:System.Data.OracleClient.OracleLob>. (De même, si une valeur négative est passée à `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> réussira, mais n’efface qu’à partir du début de la <xref:System.Data.OracleClient.OracleLob>.) Ce comportement est différent de celui de la <xref:System.Data.OracleClient.OracleLob.Read%2A> et <xref:System.Data.OracleClient.OracleLob.Write%2A> méthodes et offre l’avantage de pouvoir effacer toutes les données à partir de la valeur spécifiée par `offset` sans effectuer un aller-retour supplémentaire vers le serveur pour vérifier la taille réelle.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> ne tronque pas les données. Le `LOB` longueur reste la même pour un `BLOB` type de données, et les données effacées sont remplacées par 0 x 00. `CLOB` et `NCLOB` types de données sont remplacés par des espaces.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Dans cette version, une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Actuellement non pris en charge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette version, cette méthode ne fonctionne pas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si une application a appelé <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />.</summary>
        <value><see langword="true" /> si l'application a appelé la méthode <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez un serveur Oracle 8.0.5 Oracle « ORA-00600 : code d’erreur interne « exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Data.OracleClient.OracleLob" /> est un flux <see cref="F:System.Data.OracleClient.OracleBFile.Null" />.</summary>
        <value><see langword="true" /> si <see cref="T:System.Data.OracleClient.OracleLob" /> est un flux <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Data.OracleClient.OracleLob" /> est un <see langword="LOB" /> temporaire.</summary>
        <value><see langword="true" /> si <see cref="T:System.Data.OracleClient.OracleLob" /> est un <see langword="LOB" /> temporaire ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’exemple suivant montre comment créer une table temporaire `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui retourne la taille de <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Taille de <see cref="T:System.Data.OracleClient.OracleLob" /> en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de la <xref:System.Data.OracleClient.OracleLob> est toujours retournée en octets pour tous les types de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui retourne le type de données <see langword="LOB" />.</summary>
        <value>Parmi les <see cref="T:System.Data.OracleClient.OracleType" /> <see langword="LOB" /> types de données.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.OracleClient.OracleLob> peut être une des opérations suivantes <xref:System.Data.OracleClient.OracleType> types de données.  
  
|Type de données OracleType|Description |  
|--------------------------|-----------------|  
|`Blob`|Type de données `BLOB` Oracle contenant des données binaires d'une taille maximale de 4 gigaoctets. Correspond à un <xref:System.Array> de type <xref:System.Byte>.|  
|`Clob`|Types de données `CLOB` Oracle contenant des données caractères, selon le jeu de caractères par défaut du serveur, d'une taille maximale de 4 gigaoctets. Correspond à <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` type de données qui contient des données caractères, selon le jeu sur le serveur avec une taille maximale de 4 gigaoctets de caractères nationaux. Correspond à <xref:System.String>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente un objet <see cref="T:System.Data.OracleClient.OracleLob" /> null.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez construire un <xref:System.Data.OracleClient.OracleLob> qui a la valeur NULL à l’aide de ce format :  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Cette technique est utilisée principalement pour tester si un `LOB` retournée par le serveur est NULL, comme l’illustre cet exemple :  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Une valeur NULL `LOB` se comporte comme un zéro octet `LOB` dans la mesure <xref:System.Data.OracleClient.OracleLob.Read%2A> réussit et retourne toujours zéro octet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la position de lecture actuelle dans le flux <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Position actuelle dans le flux <see cref="T:System.Data.OracleClient.OracleLob" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le flux doit prendre en charge la recherche pour obtenir ou définir la position. Utilisez le <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> propriété afin de déterminer si le flux prend en charge la recherche.  
  
 La recherche au-delà de la longueur du flux est pris en charge. Cherchant à une position d’impaire `CLOB` et `NCLOB` des types de données prend également en charge. Pour plus d’informations, consultez la section Notes de la <xref:System.Data.OracleClient.OracleLob.Read%2A> propriété.  
  
 Le <xref:System.Data.OracleClient.OracleLob.Position%2A> propriété n’assure pas le suivi du nombre d’octets à partir de flux de données qui ont été consommés, omis, ou les deux.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets. Lorsque cette méthode est retournée, la mémoire tampon contient le tableau d’octets spécifié dont les valeurs comprises entre <paramref name="offset" /> et (<paramref name="offset" /> + <paramref name="count" />) sont remplacées par les octets lus dans la source en cours.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer le stockage des données lues dans le flux actuel. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <param name="count">Nombre maximal d'octets à lire dans le flux actuel. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <summary>Lit une séquence d'octets à partir du flux <see cref="T:System.Data.OracleClient.OracleLob" /> actuel et avance la position dans le flux du nombre d'octets lus.</summary>
        <returns>Nombre total d'octets lus dans la mémoire tampon. Ceci peut être inférieur au nombre d'octets demandé si ce nombre n'est pas actuellement disponible ou égal à zéro (0) si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.OracleClient.OracleLob.Read%2A> méthode lit un maximum de `count` octets à partir du flux et les stocke dans `buffer` commençant à `offset`. La position actuelle dans le flux est avancée par le nombre d’octets lus ; Toutefois, si une exception se produit, la position actuelle dans le flux de données reste inchangée. <xref:System.Data.OracleClient.OracleLob.Read%2A> Retourne le nombre d’octets lus. La valeur de retour est zéro uniquement si la position est actuellement à la fin du flux. <xref:System.Data.OracleClient.OracleLob.Read%2A> bloque jusqu'à ce qu’au moins un octet de données peut être lu, dans le cas où aucune donnée n’est disponible.<xref:System.Data.OracleClient.OracleLob.Read%2A> retourne 0 si vous tentez de lire à partir d’un `LOB` lorsque la position actuelle est à la fin de `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> peut retourner les moins d’octets que demandé même si la fin du flux n’a pas été atteinte.  
  
 Le fournisseur de données .NET Framework pour Oracle gère toutes les `CLOB` et `NCLOB` données au format Unicode. Par conséquent, lors de l’accès `CLOB` et `NCLOB` des types de données, vous travaillez toujours avec le nombre d’octets, où chaque caractère représente 2 octets. Par exemple, si une chaîne de texte contenant trois caractères est enregistrée comme un `NCLOB` sur un serveur Oracle où le jeu de caractères est de 4 octets par caractère, et que vous effectuez une `Read` opération, vous spécifiez la longueur de la chaîne de 6 octets, bien qu’il soit stockées sous forme de 12 octets sur le serveur.  
  
 L’exemple c# suivant montre comment lire <xref:System.Data.OracleClient.OracleLob> objets.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 Vous pouvez construire un <xref:System.Data.OracleClient.OracleLob> qui a la valeur NULL à l’aide de ce format :  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Cette technique est utilisée principalement pour tester si un `LOB` retournée par le serveur est NULL, comme l’illustre l’exemple suivant.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Une valeur NULL `LOB` se comporte comme un zéro octet `LOB` dans la mesure <xref:System.Data.OracleClient.OracleLob.Read%2A> réussit et retourne toujours zéro octet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est une référence Null (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur du paramètre <paramref name="offset" /> ou <paramref name="count" /> n'est pas positive.  
  
ou 
La somme des paramètres offset et count est supérieure à la longueur de la mémoire tampon.  
  
- ou - 
Une valeur spécifiée dans le paramètre <paramref name="amount" /> ou <paramref name="offset" /> est inférieure à zéro ou supérieure à 4 giga-octets.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Offset d'octet par rapport à l'origine. Si <paramref name="offset" /> est négatif, la nouvelle position précède la position spécifiée par <paramref name="origin" /> du nombre d'octets spécifié par <paramref name="offset" />. Si <paramref name="offset" /> est égal à zéro, la nouvelle position est la position spécifiée par <paramref name="origin" />. Si <paramref name="offset" /> est positif, la nouvelle position suit la position spécifiée par <paramref name="origin" /> du nombre d'octets spécifié par <paramref name="offset" />.</param>
        <param name="origin">Valeur de type <see cref="T:System.IO.SeekOrigin" /> indiquant le point de référence utilisé pour obtenir la nouvelle position.</param>
        <summary>Définit la position dans le flux <see cref="T:System.Data.OracleClient.OracleLob" /> actuel.</summary>
        <returns>Nouvelle position dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `offset` est négatif, la nouvelle position doit précéder la position spécifiée par `origin` par le nombre d’octets spécifié par `offset`. Si `offset` est égal à zéro, la nouvelle position doit être la position spécifiée par `origin`. Si `offset` est un nombre positif, la nouvelle position doit suivre la position spécifiée par `origin` par le nombre d’octets spécifié par `offset`.  
  
 La recherche au-delà de la longueur du flux est pris en charge. Cherchant à une position d’impaire `CLOB` et `NCLOB` des types de données prend également en charge. Pour plus d’informations, consultez la section Notes de la <xref:System.Data.OracleClient.OracleLob.Read%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="origin" /> ne contient pas une valeur valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La position obtenue est au-delà de la longueur de la valeur.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet <see cref="T:System.Data.OracleClient.OracleLob" /> était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Longueur souhaitée du flux actuel en octets <see cref="T:System.Data.OracleClient.OracleLob" />. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <summary>Définit la longueur du flux <see cref="T:System.Data.OracleClient.OracleLob" /> selon une valeur inférieure à la longueur actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essayez d’augmenter la longueur de la <xref:System.Data.OracleClient.OracleLob> flux échoue et retourne « Message : ORA-22926 : spécifiée trim longueur est supérieure à la longueur de la valeur métier en cours » à partir du serveur Oracle.  
  
 Un flux doit prendre en charge écriture et la recherche pour <xref:System.Data.OracleClient.OracleLob.SetLength%2A> de la fonction.  
  
 Le fournisseur de données .NET Framework pour Oracle gère toutes les `CLOB` et `NCLOB` données au format Unicode. Par conséquent, lors de l’accès `CLOB` et `NCLOB` des types de données, vous travaillez toujours avec le nombre d’octets, où chaque caractère représente 2 octets. Par exemple, si une chaîne de texte contenant trois caractères est enregistrée comme un `NCLOB` sur un serveur Oracle où le jeu de caractères est de 4 octets par caractère, et que vous effectuez une `SetLength` opération, vous spécifiez la longueur de la chaîne de 6 octets, bien qu’il soit stockées sous forme de 12 octets sur le serveur.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur spécifiée dans le paramètre <paramref name="value" /> pour un type de données <see langword="CLOB" /> ou <see langword="NCLOB" /> n'est pas paire.  
  
ou 
Une valeur spécifiée dans le paramètre <paramref name="value" /> est inférieure à zéro ou supérieure à 4 giga-octets.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du flux Common Language Runtime équivalente à la valeur sous-jacente.</summary>
        <value>Pour <see cref="F:System.Data.OracleClient.OracleType.Blob" />, tableau de type <see langword="Byte[]" />. Pour <see cref="F:System.Data.OracleClient.OracleType.Clob" /> et <see cref="F:System.Data.OracleClient.OracleType.NClob" />, une valeur <see langword="String" />. Pour les données de type null, <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour <xref:System.Data.OracleClient.OracleType.Blob> des types de données, <xref:System.Data.OracleClient.OracleLob.Value%2A> retourne l’ensemble des données sous-jacentes en tant que tableau contigu de type `Byte[]`. Pour <xref:System.Data.OracleClient.OracleType.Clob> et <xref:System.Data.OracleClient.OracleType.NClob> des types de données, <xref:System.Data.OracleClient.OracleLob.Value%2A> retourne toutes les données comme un `String` type de données. Pour les données de valeur null, <xref:System.Data.OracleClient.OracleLob.Value%2A> retourne <xref:System.DBNull>. En comparant les valeurs renvoyées, vous pouvez faire la distinction entre les données vides, null des données et les données.  
  
> [!NOTE]
>  Un avantage de l’utilisation `LOB` types de données est la capacité à récupérer de grandes quantités de données dans des segments sur le client. Toutefois, lorsque vous utilisez <xref:System.Data.OracleClient.OracleLob.Value%2A>, vous obtenez toutes les données de la `LOB` colonne sous la forme d’un segment contigu unique, ce qui peut augmenter considérablement la charge de l’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets. Cette méthode copie le nombre d'octets spécifié dans <paramref name="count" /> à partir de <paramref name="buffer" /> dans le flux actuel.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer la copie des octets dans le flux actuel. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <param name="count">Nombre d'octets à écrire dans le flux actuel. Pour les types de données <see langword="CLOB" /> et <see langword="NCLOB" />, il doit s'agir d'un nombre pair.</param>
        <summary>Écrit une suite d'octets dans le flux <see cref="T:System.Data.OracleClient.OracleLob" /> actuel et avance la position actuelle dans ce flux du nombre d'octets écrits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération d’écriture réussite, la position dans le flux avance du nombre d’octets écrits. Si une exception se produit, la position dans le flux reste inchangée.  
  
 L’écriture au-delà de la fin de `LOB` est autorisée et agrandit le `LOB` par le nombre d’octets écrits.  
  
 Le fournisseur de données .NET Framework pour Oracle gère toutes les `CLOB` et `NCLOB` données au format Unicode. Par conséquent, lors de l’accès `CLOB` et `NCLOB` des types de données, vous travaillez toujours avec le nombre d’octets, où chaque caractère représente 2 octets. Par exemple, si une chaîne de texte contenant trois caractères est enregistrée comme un `NCLOB` sur un serveur Oracle où le jeu de caractères est de 4 octets par caractère, et que vous effectuez une `Write` opération, vous spécifiez la longueur de la chaîne de 6 octets, bien qu’il soit stockées sous forme de 12 octets sur le serveur.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
 L’exemple c# suivant montre comment écrire dans <xref:System.Data.OracleClient.OracleLob> objets.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  Une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="buffer" /> est une référence null (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur du paramètre <paramref name="offset" /> ou <paramref name="count" /> n'est pas positive.  
  
- ou - 
La somme des paramètres <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de <paramref name="buffer" />.  
  
- ou - 
Une valeur spécifiée dans le paramètre <paramref name="count" /> ou <paramref name="offset" /> est inférieure à zéro ou supérieure à 4 giga-octets.  
  
- ou - 
Vous devez spécifier les types de données <see langword="CLOB" /> et <see langword="NCLOB" /> en tant que nombre d'octets pair.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération ne fait pas partie d'une transaction, l'objet <see cref="T:System.Data.OracleClient.OracleLob" /> est de type null ou la connexion est fermée.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet était fermé ou supprimé.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Une erreur Oracle s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Octet à écrire dans le flux.</param>
        <summary>Écrit un octet à la position actuelle dans le flux <see cref="T:System.Data.OracleClient.OracleLob" /> et avance d'un octet la position dans flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération d’écriture réussite, la position dans le flux avance d’un octet. Si une exception se produit, la position dans le flux reste inchangée.  
  
 L’écriture au-delà de la fin de la `LOB` est autorisée et agrandit la `LOB` d’un octet.  
  
 Pour écrire dans le `LOB`, vous devez avoir récupéré le `LOB` à l’aide de la clause FOR UPDATE dans l’instruction SQL SELECT et vous devez disposer une transaction locale démarrée.  
  
> [!NOTE]
>  Une opération d’écriture en lecture seule `LOB` peut réussir, mais ne pas mettre à jour le `LOB` sur le serveur. Dans ce cas, toutefois, la copie locale de la `LOB` est mis à jour. Par conséquent, plus tard opérations de lecture sur le <xref:System.Data.OracleClient.OracleLob> objet peut retourner les résultats de l’opération d’écriture.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>