<Type Name="WorkflowApplication" FullName="System.Activities.WorkflowApplication">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f3823380661482a43a8cc40c25fb70788b8dbf4d" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39861021" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowApplication : System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowApplication extends System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowApplication&#xA;Inherits WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowApplication sealed : System::Activities::Hosting::WorkflowInstance" />
  <TypeSignature Language="F#" Value="type WorkflowApplication = class&#xA;    inherit WorkflowInstance" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Activities.Hosting.WorkflowInstance</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un hôte pour une instance unique d'un flux de travail.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.Activities.WorkflowApplication> fournit un hôte pour une instance de flux de travail unique. Il s'agit d'un proxy à l'instance de flux de travail gérée par l'exécution du flux de travail. Les utilisateurs de <xref:System.Activities.WorkflowApplication> peuvent indiquer à l'exécution du flux de travail d'effectuer des actions sur une instance de flux de travail en appelant les méthodes appropriées sur un objet <xref:System.Activities.WorkflowApplication>. Si une action demandée n'est pas valide, une exception est levée.  
  
 Vous pouvez effectuer les tâches suivantes à l'aide de <xref:System.Activities.WorkflowApplication> :  
  
1.  Créer une instance de flux de travail ou charger une instance de flux de travail à partir d'un magasin d'instances.  
  
2.  Fournir les extensions à utiliser par les activités dans une instance de flux de travail.  
  
3.  Contrôler l'exécution de l'instance de flux de travail.  
  
4.  Reprendre un signet créé par une activité dans une instance de flux de travail.  
  
5.  Rendre persistante ou décharger une instance de flux de travail.  
  
6.  Être informé des événements de cycle de vie de l'instance de flux de travail.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Lorsque le flux de travail est terminé, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Activities.WorkflowApplication" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication workflowDefinition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Définition de flux de travail.</param>
        <summary>Initialise une instance de la classe <see cref="T:System.Activities.WorkflowApplication" /> avec la définition de flux de travail spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide d'une définition de workflow qui se compose d'une activité `DiceRoll` unique. L'activité `DiceRoll` a deux arguments de sortie qui représentent les résultats du jet de dés. Lorsque le flux de travail se termine, les sorties sont récupérées dans le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A> et la sortie suivante s'affiche sur la console.  
  
```Output  
Workflow aae3fb48-7229-4737-b969-d63e131b96b3 Completed.   
The two dice are 1 and 5.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Définition de flux de travail.</param>
        <param name="definitionIdentity">Identité de définition.</param>
        <summary>Initialise une instance de la classe <see cref="T:System.Activities.WorkflowApplication" /> avec la définition de flux de travail et l'identité de définition spécifiées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Définition de flux de travail.</param>
        <param name="inputs">Valeurs des arguments définis sur l’activité racine de la définition de flux de travail ; elles sont indexées par nom d’argument.</param>
        <summary>Crée une instance de la classe <see cref="T:System.Activities.WorkflowApplication" /> qui utilise la définition de flux de travail et les valeurs d'argument spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide d'une définition de flux de travail qui comprend une activité `Divide` unique acceptant deux arguments d'entrée et d'un dictionnaire d'arguments d'entrée contenant les deux valeurs à passer, indexées par nom d'argument. Les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Lorsque le flux de travail est terminé, la sortie suivante s'affiche sur la console.  
  
```Output  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Completed  
500 / 36 = 13 Remainder 32  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object), definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Définition de flux de travail.</param>
        <param name="inputs">Identité de définition.</param>
        <param name="definitionIdentity">Valeurs des arguments définis sur l’activité racine de la définition de flux de travail ; elles sont indexées par nom d’argument.</param>
        <summary>Crée une instance de la classe <see cref="T:System.Activities.WorkflowApplication" /> qui utilise la définition de flux de travail, les valeurs d'argument et l'identité de définition spécifiées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Notifie l'exécution du flux de travail que cette instance de flux de travail doit être abandonnée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu'un flux de travail hébergé par un <xref:System.Activities.WorkflowApplication> est abandonné, le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Aborted%2A> est appelé, mais pas le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="workflowApplication.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifie l'exécution du flux de travail que cette instance de flux de travail doit être abandonnée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu'un flux de travail hébergé par un <xref:System.Activities.WorkflowApplication> est abandonné, le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Aborted%2A> est appelé, mais pas le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Abort%2A> est appelée. Lorsque le flux de travail est abandonné, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Idle.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The workflow has been aborted.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="override this.Abort : string -&gt; unit" Usage="workflowApplication.Abort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de la demande d'abandon.</param>
        <summary>Notifie l'exécution du flux de travail que cette instance de flux de travail doit être abandonnée pour la raison spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu'un flux de travail hébergé par un <xref:System.Activities.WorkflowApplication> est abandonné, le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Aborted%2A> est appelé, mais pas le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Abort%2A> est appelée. Lorsque le flux de travail est abandonné, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Idle.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The reason for aborting the workflow.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Aborted">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Aborted" />
      <MemberSignature Language="VB.NET" Value="Public Property Aborted As Action(Of WorkflowApplicationAbortedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ Aborted { Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Aborted : Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Aborted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Action`1" /> qui est appelé lorsque l'instance de flux de travail est abandonnée.</summary>
        <value>Action appelée lorsque l'instance de flux de travail est abandonnée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu'un flux de travail hébergé par un <xref:System.Activities.WorkflowApplication> est abandonné, le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Aborted%2A> est appelé, mais pas le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 L'exemple de code suivant inspecte l'objet <xref:System.Activities.WorkflowApplicationAbortedEventArgs> passé dans le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Aborted%2A> d'une instance de <xref:System.Activities.WorkflowApplication> et indique la raison pour laquelle le flux de travail a été abandonné.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#5](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInitialInstanceValues">
      <MemberSignature Language="C#" Value="public void AddInitialInstanceValues (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,object&gt; writeOnlyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInitialInstanceValues(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, object&gt; writeOnlyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.AddInitialInstanceValues(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInitialInstanceValues (writeOnlyValues As IDictionary(Of XName, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInitialInstanceValues(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Object ^&gt; ^ writeOnlyValues);" />
      <MemberSignature Language="F#" Value="member this.AddInitialInstanceValues : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, obj&gt; -&gt; unit" Usage="workflowApplication.AddInitialInstanceValues writeOnlyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writeOnlyValues" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="writeOnlyValues">Valeurs de métadonnées à inclure avec la première persistance.</param>
        <summary>Spécifie les valeurs des métadonnées de l'instance qui sont incluses avec la première persistance d'une nouvelle instance.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Annule de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode à appeler lorsque l'opération d'annulation est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Annule de façon asynchrone une instance de flux de travail à l'aide de l'objet <see cref="T:System.AsyncCallback" /> spécifié et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération d'annulation asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération d'annulation a réussi, appelez <xref:System.Activities.WorkflowApplication.EndCancel%2A>. <xref:System.Activities.WorkflowApplication.EndCancel%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndCancel%2A> est appelée avant la fin de l'opération d'annulation, elle demeure bloquée jusqu'à la fin de l'opération d'annulation. Par défaut, l'opération d'annulation doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndCancel%2A>.  
  
 Cette méthode annule de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle dans lequel l'opération d'annulation doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération d'annulation est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Annule de façon asynchrone une instance de flux de travail à l'aide du délai d'attente spécifié, de l'objet <see cref="T:System.AsyncCallback" /> et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération d'annulation asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération d'annulation a réussi, appelez <xref:System.Activities.WorkflowApplication.EndCancel%2A>. <xref:System.Activities.WorkflowApplication.EndCancel%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode spécifiée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndCancel%2A> est appelée avant la fin de l'opération d'annulation, elle demeure bloquée jusqu'à la fin de l'opération d'annulation. Si l'opération d'annulation ne se réalise pas dans l'intervalle spécifié par le paramètre `timeOut`, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndCancel%2A>.  
  
 Cette méthode annule de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un propriétaire d'instance par défaut de façon asynchrone à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="definitionIdentity">Identité de définition.</param>
        <param name="identityFilter">Filtre d'identité.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Crée un propriétaire d'instance par défaut de façon asynchrone à l'aide du modèle de design asynchrone <see cref="T:System.IAsyncResult" /> avec un magasin d'instances, une identité de définition, un filtre d'identité, un rappel et un état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="definitionIdentity">Identité de définition.</param>
        <param name="identityFilter">Filtre d'identité.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Crée un propriétaire d'instance par défaut de façon asynchrone à l'aide du modèle de design asynchrone <see cref="T:System.IAsyncResult" /> avec un magasin d'instances, une identité de définition, un filtre d'identité, un intervalle de délai d'expiration, un rappel et un état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginDeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un propriétaire d'instance par défaut de façon asynchrone à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Supprime un propriétaire d'instance par défaut de façon asynchrone à l'aide du modèle de conception de façon asynchrone <see cref="T:System.IAsyncResult" /> avec les fonctions d'enregistrement, de rappel et d'état de l'instance spécifiée.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Supprime un propriétaire d'instance par défaut de façon asynchrone à l'aide du modèle de conception de façon asynchrone <see cref="T:System.IAsyncResult" /> avec les fonctions d'enregistrement, d'intervalle de délai d'attente, de rappel et d'état de l'instance spécifiée.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère un propriétaire d'instance de façon asynchrone à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur d'instance.</param>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Extrait un propriétaire d'instance de façon asynchrone à l'aide du modèle de design asynchrone <see cref="T:System.IAsyncResult" /> avec l'identificateur d'instance, le magasin d'instance, le rappel et l'état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur d'instance.</param>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Extrait un propriétaire d'instance de façon asynchrone à l'aide du modèle de design asynchrone <see cref="T:System.IAsyncResult" /> avec l'identificateur d'instance, le magasin d'instance, l'intervalle de délai d'expiration, le rappel et l'état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère un propriétaire d'instance exécutable de façon asynchrone à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Extrait un propriétaire d'instance exécutable de façon asynchrone à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" /> avec les fonctions d'enregistrement, de rappel et d'état de l'instance spécifiée.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Extrait un propriétaire d'instance exécutable de façon asynchrone à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" /> avec les fonctions d'enregistrement, d'intervalle de délai d'expiration, de rappel et d'état de l'instance spécifiée.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" /> avec l'instance, le rappel et l'état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur 128 bits global unique de l'instance de flux de travail.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide de l'identificateur d'instance, de la méthode de rappel et de l'état fourni par l'utilisateur qui sont spécifiés.</summary>
        <returns>État d'une opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="updateMap">Carte de mise à jour.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" /> avec l'instance, la carte de mise à jour, le rappel et l'état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" /> avec l'instance, l'intervalle de délai d'expiration, le rappel et l'état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur 128 bits global unique de l'instance de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide de l'identificateur d'instance, du délai, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>État d'une opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="updateMap">Carte de mise à jour.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de chargement est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Charge de façon asynchrone un flux de travail à partir d'un magasin d'instances à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" /> avec l'instance, la carte de mise à jour, l'intervalle de délai d'attente, le rappel et l'état spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise le processus asynchrone du chargement d'une instance de flux de travail exécutable à partir de la propriété <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance exécutable est une instance pour laquelle une horloge ou un verrou d'instance a expiré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode à appeler lorsque l'opération est terminée.</param>
        <param name="state">Objet facultatif spécifique à l'application qui contient les informations sur l'opération asynchrone.</param>
        <summary>Initialise une opération pour charger une instance de flux de travail exécutable à partir de la propriété <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance exécutable est une instance pour laquelle une horloge ou un verrou d'instance a expiré.  
  
 Pour déterminer si l'opération de chargement a réussi, appelez <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise. Par défaut, l'opération de reprise doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>.  
  
 Cette méthode charge de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération est terminée.</param>
        <param name="state">Objet facultatif spécifique à l'application qui contient les informations sur l'opération asynchrone.</param>
        <summary>Initialise une opération pour charger une instance de flux de travail exécutable à partir de la propriété <see cref="P:System.Activities.WorkflowApplication.InstanceStore" /> à l'aide de l'intervalle de délai d'attente spécifié.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance exécutable est une instance pour laquelle une horloge ou un verrou d'instance a expiré.  
  
 Pour déterminer si l'opération de chargement a réussi, appelez <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise. Si l'opération de chargement ne se termine pas dans le délai d'attente spécifié, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>.  
  
 Cette méthode charge de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPersist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend persistante de façon asynchrone une instance de flux de travail dans un magasin d'instances à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode à appeler lorsque l'opération de persistance est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Rend persistante de façon asynchrone une instance de flux de travail dans un magasin d'instances à l'aide de la méthode de rappel spécifiée et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération de persistance asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération de persistance a réussi, appelez <xref:System.Activities.WorkflowApplication.EndPersist%2A>. <xref:System.Activities.WorkflowApplication.EndPersist%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndPersist%2A> est appelée avant la fin de l'opération asynchrone, elle demeure bloquée jusqu'à ce que l'opération de persistance soit terminée. Si l'opération de persistance ne se réalise pas dans un délai de 30 secondes, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndPersist%2A>.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 Cette méthode rend persistant de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle au cours duquel l'opération de persistance doit être exécutée ; au-delà de ce délai, l'opération est annulée et une exception <see cref="T:System.TimeoutException" /> est levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de persistance est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Rend persistante de façon asynchrone une instance de flux de travail dans un magasin d'instances à l'aide du délai spécifié, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération de persistance asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération de persistance a réussi, appelez <xref:System.Activities.WorkflowApplication.EndPersist%2A>. <xref:System.Activities.WorkflowApplication.EndPersist%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndPersist%2A> est appelée avant la fin de l'opération asynchrone, elle demeure bloquée jusqu'à ce que l'opération de persistance soit terminée. Si l'opération de persistance ne se termine pas avant l'issue du délai spécifié, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndPersist%2A>.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 Cette méthode rend persistante de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lance une opération asynchrone pour reprendre un signet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de reprise est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Initialise une opération pour reprendre un signet à l'aide de la valeur, de la méthode de rappel et de l'état.</summary>
        <returns>Référence à l'opération de reprise de signet asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération de reprise a réussi, appelez <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise. Par défaut, l'opération de reprise doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>.  
  
 Cette méthode reprend de façon asynchrone un signet à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nom du signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <param name="callback">Méthode appelée lorsque l'opération asynchrone est terminée.</param>
        <param name="state">État d'exécution d'un flux de travail qui a été conservé par le thread appelant avant qu'une opération asynchrone ait commencé.</param>
        <summary>Initialise une opération asynchrone pour reprendre le signet avec le nom spécifié, à l'aide de la valeur, de la méthode de rappel et de l'état. Le signet à reprendre est créé précédemment par une activité dans l'instance de flux de travail.</summary>
        <returns>Résultat de l'opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat indique si l'opération de reprise a réussi ou échoué.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <param name="timeout">Intervalle dans lequel l'opération de reprise doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de reprise est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Initialise une opération pour reprendre un signet, à l'aide de la valeur, du délai d'attente, de la méthode de rappel et de l'état.</summary>
        <returns>Référence à l'opération de reprise de signet asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération de reprise a réussi, appelez <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise. Si l'opération de reprise ne se termine pas avant l'issue du délai spécifié, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>.  
  
 Cette méthode reprend de façon asynchrone un signet à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nom du signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <param name="timeout">Intervalle de temps pendant lequel le signet doit être repris.</param>
        <param name="callback">Méthode appelée lorsque l'opération asynchrone est terminée.</param>
        <param name="state">État d'exécution d'un flux de travail qui a été sauvegardé par le thread appelant avant qu'une opération asynchrone ait commencé.</param>
        <summary>Initialise une opération asynchrone pour reprendre le signet avec le nom spécifié, à l'aide de la valeur, du délai d'attente, de la méthode de rappel et de l'état. Le signet à reprendre est créé précédemment par une activité dans l'instance de flux de travail.</summary>
        <returns>Résultat de l'opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat indique si l'opération de reprise a réussi ou échoué.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginRun">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre ou reprend de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode à appeler lorsque l'opération de reprise est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Démarre ou reprend de façon asynchrone une instance de flux de travail à l'aide de la méthode de rappel spécifiée et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération d'exécution asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération d'exécution a réussi, appelez <xref:System.Activities.WorkflowApplication.EndRun%2A>. <xref:System.Activities.WorkflowApplication.EndRun%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndRun%2A> est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise. Par défaut, l'opération de reprise doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndRun%2A>.  
  
 Cette méthode démarre ou reprend de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle dans lequel l'opération de reprise doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération de reprise est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Démarre ou reprend de façon asynchrone une instance de flux de travail à l'aide de l'intervalle spécifié, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération d'exécution asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération d'exécution a réussi, appelez <xref:System.Activities.WorkflowApplication.EndRun%2A>. <xref:System.Activities.WorkflowApplication.EndRun%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndRun%2A> est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise. Si l'opération de reprise ne se termine pas avant l'issue du délai spécifié, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndRun%2A>.  
  
 Cette méthode démarre ou reprend de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTerminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termine de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <param name="callback">Méthode à appeler lorsque l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Termine de façon asynchrone une instance de flux de travail à l'aide de l'exception spécifiée, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération en cours <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Pour déterminer si l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> a réussi, appelez <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndTerminate%2A> est appelée avant que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> ne se termine, elle demeure bloquée jusqu'à ce que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> soit terminée. Par défaut, l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Cette méthode termine de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <param name="callback">Méthode à appeler lorsque l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Termine de façon asynchrone une instance de flux de travail à l'aide du message d'erreur, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération en cours <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Pour déterminer si l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> a réussi, appelez <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndTerminate%2A> est appelée avant que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> ne se termine, elle demeure bloquée jusqu'à ce que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> soit terminée. Par défaut, l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Cette méthode termine de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Termine de façon asynchrone une instance de flux de travail à l'aide de l'exception, du délai, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération en cours <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Pour déterminer si l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> a réussi, appelez <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndTerminate%2A> est appelée avant que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> ne se termine, elle demeure bloquée jusqu'à ce que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> soit terminée. Si l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> ne se termine pas avant l'issue du délai spécifié, un objet <xref:System.TimeoutException> est généré. Cette exception ou toute autre exception qui se produit pendant le processus <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> est levée depuis <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Cette méthode termine de façon asynchrone un flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Termine de façon asynchrone une instance de flux de travail à l'aide du message d'erreur, du délai, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération asynchrone <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Pour déterminer si l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> a réussi, appelez <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndTerminate%2A> est appelée avant que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> ne se termine, elle demeure bloquée jusqu'à ce que l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> soit terminée. Si l'opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> ne se termine pas avant l'issue du délai spécifié, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Cette méthode termine de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginUnload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend persistante et supprime de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode à appeler lorsque l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" /> est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Rend persistante et supprime de façon asynchrone une instance de flux de travail à l'aide de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération asynchrone <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> a réussi, appelez <xref:System.Activities.WorkflowApplication.EndUnload%2A>. <xref:System.Activities.WorkflowApplication.EndUnload%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndUnload%2A> est appelée avant que l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> ne se termine, elle demeure bloquée jusqu'à ce que l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> soit terminée. Par défaut, l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndUnload%2A>.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 Cette méthode rend persistante et supprime de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle dans lequel l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <param name="callback">Méthode à appeler lorsque l'opération <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" /> est terminée.</param>
        <param name="state">Objet spécifique à l'application facultatif qui contient les informations sur l'opération asynchrone.</param>
        <summary>Rend persistante et supprime de façon asynchrone une instance de flux de travail à l'aide du délai, de la méthode de rappel et de l'état fourni par l'utilisateur.</summary>
        <returns>Référence à l'opération asynchrone <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer si l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> a réussi, appelez <xref:System.Activities.WorkflowApplication.EndUnload%2A>. <xref:System.Activities.WorkflowApplication.EndUnload%2A> peut être appelée à l'intérieur ou à l'extérieur de la méthode référencée dans le paramètre `callback`. Si la méthode <xref:System.Activities.WorkflowApplication.EndUnload%2A> est appelée avant que l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> ne se termine, elle demeure bloquée jusqu'à ce que l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> soit terminée. Si l'opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> ne se termine pas avant l'issue du délai spécifié, une <xref:System.TimeoutException> est levée depuis <xref:System.Activities.WorkflowApplication.EndUnload%2A>.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 Cette méthode rend persistante et décharge de façon asynchrone une instance de flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Cancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Annule l'instance de flux de travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'annulation de l'instance de flux de travail. Pour être informé que l'annulation s'est correctement déroulée, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Par défaut, l'opération d'annulation doit être exécutée dans un délai de 30 secondes, sinon une exception <xref:System.TimeoutException> est levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; unit" Usage="workflowApplication.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule l'instance de flux de travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'annulation de l'instance de flux de travail. Pour être averti lorsque l'annulation est terminée, utilisez le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Par défaut, l'opération d'annulation doit être exécutée dans un délai de 30 secondes, sinon une exception <xref:System.TimeoutException> est levée.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Cancel%2A> est appelée. Lorsque le flux de travail est annulé, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Cancel : TimeSpan -&gt; unit" Usage="workflowApplication.Cancel timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle dans lequel l'opération d'annulation doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <summary>Annule l'instance de flux de travail à l'aide du délai d'attente spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'annulation de l'instance de flux de travail. Pour être averti lorsque l'annulation est terminée, utilisez le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Cancel%2A> est appelée. Lorsque le flux de travail est annulé, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Property Completed As Action(Of WorkflowApplicationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ Completed { Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Completed : Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Completed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Action`1" /> qui est appelé lorsque l'instance de flux de travail se termine.</summary>
        <value>Action appelée lorsque l'instance de flux de travail est terminée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple de code suivant inspecte l'objet <xref:System.Activities.WorkflowApplicationCompletedEventArgs> passé dans le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Completed%2A> d'une instance de <xref:System.Activities.WorkflowApplication> et indique la façon dont le flux de travail s'est terminé.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#4](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un propriétaire d'instance par défaut du flux de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="definitionIdentity">Identité de la définition du flux de travail.</param>
        <param name="identityFilter">Filtre d'identité.</param>
        <summary>Crée un propriétaire d'instance par défaut pour le flux de travail à l'aide d'un magasin d'instances, d'une identité de définition et d'un filtre d'identité spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="definitionIdentity">Identité de la définition du flux de travail.</param>
        <param name="identityFilter">Filtre d'identité.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée.</param>
        <summary>Crée un propriétaire d'instance par défaut pour le flux de travail à l'aide d'un magasin d'instances, d'une identité de définition, d'un filtre d'identité et d'un intervalle de délai d'expiration spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un propriétaire d'instance par défaut du flux de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <summary>Supprime un propriétaire d'instance par défaut du flux de travail avec la fonction d'enregistrement de l'instance spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée.</param>
        <summary>Supprime un propriétaire d'instance par défaut du flux de travail avec les fonctions d'enregistrement et d'intervalle de délai d'attente de l'instance spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public void EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndCancel (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndCancel : IAsyncResult -&gt; unit" Usage="workflowApplication.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Opération d'annulation asynchrone.</param>
        <summary>Attend que l'opération d'annulation asynchrone en attente soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si une opération <xref:System.Activities.WorkflowApplication.BeginCancel%2A> a réussi. Si la méthode est appelée avant la fin de l'opération d'annulation, elle demeure bloquée jusqu'à la fin de l'opération d'annulation.  
  
 Cette méthode complète l'opération d'annulation asynchrone à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndCreateDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCreateDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCreateDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCreateDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndCreateDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Résultat asynchrone.</param>
        <summary>Attend que la création du propriétaire d'instance par défaut soit terminée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndDeleteDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndDeleteDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndDeleteDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndDeleteDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndDeleteDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Résultat asynchrone.</param>
        <summary>Attend que la suppression du propriétaire d'instance par défaut soit terminée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Résultat asynchrone.</param>
        <summary>Attend que la récupération d'instance soit terminée.</summary>
        <returns>Résultat de l'opération.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetRunnableInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetRunnableInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetRunnableInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetRunnableInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetRunnableInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetRunnableInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Résultat asynchrone.</param>
        <summary>Attend que récupération asynchrone de l'opération de l'instance exécutable se termine.</summary>
        <returns>Résultat de l'opération.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoad">
      <MemberSignature Language="C#" Value="public void EndLoad (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoad(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoad(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoad (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoad(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoad : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoad result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Opération de chargement asynchrone.</param>
        <summary>Attend que l'opération de chargement asynchrone en attente soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode est appelée avant que l'opération de chargement ne soit terminée, elle s'interrompt jusqu'à ce que l'opération de chargement soit terminée.  
  
 Cette méthode complète l'opération de chargement asynchrone à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void EndLoadRunnableInstance (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadRunnableInstance(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoadRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadRunnableInstance (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadRunnableInstance(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoadRunnableInstance : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoadRunnableInstance result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à l'opération de chargement asynchrone.</param>
        <summary>Attend que l'opération de l'instance exécutable de chargement asynchrone soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si une opération <xref:System.Activities.WorkflowApplication.BeginLoadRunnableInstance%2A> a réussi. Si la méthode est appelée avant que l'opération de chargement soit terminée, elle demeure bloquée jusqu'à ce que l'opération soit terminée.  
  
 Cette méthode charge de façon asynchrone les flux de travail à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndPersist">
      <MemberSignature Language="C#" Value="public void EndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.EndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Opération de persistance asynchrone.</param>
        <summary>Attend que l'opération de persistance asynchrone en attente soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si une opération <xref:System.Activities.WorkflowApplication.BeginPersist%2A> a réussi. Si la méthode est appelée avant la fin de l'opération asynchrone, elle demeure bloquée jusqu'à ce que l'opération de persistance soit terminée.  
  
 Cette méthode complète l'opération de persistance asynchrone à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult EndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult EndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult EndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.EndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à l'opération de reprise de signet asynchrone.</param>
        <summary>Attend qu'une opération de reprise de signet soit terminée.</summary>
        <returns>L'une des valeurs d'énumération qui indique les résultats d'une opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si une opération <xref:System.Activities.WorkflowApplication.BeginResumeBookmark%2A> a réussi. Si la méthode est appelée avant que l'opération de chargement soit terminée, elle demeure bloquée jusqu'à ce que l'opération soit terminée.  
  
 Cette méthode reprend de façon asynchrone un signet à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRun">
      <MemberSignature Language="C#" Value="public void EndRun (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndRun(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndRun(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndRun (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndRun(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndRun : IAsyncResult -&gt; unit" Usage="workflowApplication.EndRun result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Opération d'exécution asynchrone.</param>
        <summary>Attend que l'opération d'exécution asynchrone en attente soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si une opération <xref:System.Activities.WorkflowApplication.BeginRun%2A> a réussi. Si cette méthode est appelée avant la fin de l'opération de reprise, elle demeure bloquée jusqu'à la fin de l'opération de reprise.  
  
 Cette méthode complète l'opération d'exécution asynchrone à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTerminate">
      <MemberSignature Language="C#" Value="public void EndTerminate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndTerminate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndTerminate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndTerminate (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndTerminate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndTerminate : IAsyncResult -&gt; unit" Usage="workflowApplication.EndTerminate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Opération d'arrêt asynchrone.</param>
        <summary>Attend que l'opération de fin asynchrone en attente soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée pour déterminer si une opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> a réussi. Si la méthode est appelée avant que l'opération de fin soit terminée, elle demeure bloquée jusqu'à ce que l'opération soit terminée.  
  
 Cette méthode complète une opération <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> asynchrone à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUnload">
      <MemberSignature Language="C#" Value="public void EndUnload (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUnload(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndUnload(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndUnload (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndUnload(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndUnload : IAsyncResult -&gt; unit" Usage="workflowApplication.EndUnload result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Opération de déchargement asynchrone.</param>
        <summary>Attend que l'opération de déchargement asynchrone en attente soit terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée pour déterminer si une opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> a réussi. Si la méthode est appelée avant que l'opération de déchargement soit terminée, elle demeure bloquée jusqu'à ce que l'opération soit terminée.  
  
 Cette méthode complète une opération <xref:System.Activities.WorkflowApplication.BeginUnload%2A> asynchrone à l'aide du modèle de conception asynchrone <xref:System.IAsyncResult>. Pour plus d’informations, consultez [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowApplication.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d’extensions pour l’instance de flux de travail actuelle.</summary>
        <value>Collection d’objets.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBookmarks">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la collection de signets de l’instance de flux de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks () As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks();" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la collection de signets de l’instance de flux de travail.</summary>
        <returns>Collection en lecture seule de signets de l’instance de flux de travail.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette opération n'est pas exécutée dans un délai de 30 secondes, une exception <xref:System.TimeoutException> est levée.  
  
   
  
## Examples  
 L'exemple suivant génère un flux de travail utilisant une activité `ReadLine` qui crée un <xref:System.Activities.Bookmark>. Le workflow démarre et, une fois que <xref:System.Activities.Bookmark> est créé et que le workflow est inactif, la méthode <xref:System.Activities.WorkflowApplication.GetBookmarks%2A> est appelée. Lorsque le flux de travail est terminé, la sortie suivante s'affiche sur la console.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks (timeout As TimeSpan) As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : TimeSpan -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle durant lequel cette méthode doit se terminer avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <summary>Retourne la collection de signets pour l’instance de flux de travail à l’aide du délai d’attente spécifié.</summary>
        <returns>Collection en lecture seule de signets de l’instance de flux de travail.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant génère un flux de travail utilisant une activité `ReadLine` qui crée un <xref:System.Activities.Bookmark>. Le workflow démarre et, une fois que <xref:System.Activities.Bookmark> est créé et que le workflow est inactif, la méthode <xref:System.Activities.WorkflowApplication.GetBookmarks%2A> est appelée. Lorsque le flux de travail est terminé, la sortie suivante s'affiche sur la console.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Extrait l'instance de flux de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur d'instance.</param>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <summary>Récupère l'instance de flux de travail à l'aide de l'identificateur d'instance et du magasin d'instances spécifiés.</summary>
        <returns>Instance récupérée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur d'instance.</param>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée.</param>
        <summary>Récupère l'instance de flux de travail à l'aide de l'identificateur d'instance, du magasin d'instances et de l'intervalle de délai d'expiration spécifiés.</summary>
        <returns>Référence à l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère l'instance exécutable du flux de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail</param>
        <summary>Récupère l'instance exécutable du flux de travail avec le magasin d'instance spécifié.</summary>
        <returns>Instance exécutable.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Accès à un état persistant de l'instance actuelle de l'application de flux de travail</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée.</param>
        <summary>Récupère l'instance exécutable du flux de travail avec le magasin d'instance spécifié et l'intervalle de délai d'expiration.</summary>
        <returns>Instance exécutable.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public override Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Id" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Activities.WorkflowApplication.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur GUID 128 bits de l'instance d'application de flux de travail actuelle.</summary>
        <value>Identificateur GUID 128 bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant crée une instance de <xref:System.Activities.WorkflowApplication>, puis affiche la valeur <xref:System.Activities.WorkflowApplication.Id%2A> sur la console.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Property Idle As Action(Of WorkflowApplicationIdleEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ Idle { Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Idle : Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Idle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Action`1" /> appelé lorsque l'instance de flux de travail active devient inactive.</summary>
        <value>Action qui s'exécute lorsqu'une instance de flux de travail devient inactive.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple de code suivant inspecte l'objet <xref:System.Activities.WorkflowApplicationIdleEventArgs> passé dans le gestionnaire <xref:System.Activities.WorkflowApplication.Idle%2A> d'une instance de <xref:System.Activities.WorkflowApplication>. Dans cet exemple, le workflow qui devient inactif comporte un <xref:System.Activities.Bookmark> portant le nom `EnterGuess` et appartenant à une activité nommée `ReadInt`. Cet exemple de code repose issu de [Comment : exécuter un Workflow](~/docs/framework/windows-workflow-foundation/how-to-run-a-workflow.md), qui fait partie de la [Getting Started Tutorial &#91;.NET Framework 4.5&#93;](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md). Si le gestionnaire <xref:System.Activities.WorkflowApplication.Idle%2A> utilisé dans cette étape est modifié de façon à contenir le code de cet exemple, la sortie suivante s'affiche.  
  
```Output  
BookmarkName: EnterGuess - OwnerDisplayName: ReadInt  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceStore">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceStore InstanceStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceStore InstanceStore" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.InstanceStore" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceStore As InstanceStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceStore ^ InstanceStore { System::Runtime::DurableInstancing::InstanceStore ^ get(); void set(System::Runtime::DurableInstancing::InstanceStore ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceStore : System.Runtime.DurableInstancing.InstanceStore with get, set" Usage="System.Activities.WorkflowApplication.InstanceStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet qui permet d'accéder à l'état persistant de l'instance actuelle de l'application de flux de travail.</summary>
        <value>Magasin d'instances.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant crée une instance de WorkflowApplication, puis configure la propriété <xref:System.Activities.WorkflowApplication.InstanceStore%2A> à l'aide d'un <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>. Cet exemple de code fait partie de [Comment : créer et exécuter un Workflow de longue durée](~/docs/framework/windows-workflow-foundation/how-to-create-and-run-a-long-running-workflow.md), qui fait partie de la [Getting Started Tutorial &#91;.NET Framework 4.5&#93;](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md).  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge une instance de flux de travail à partir d'un magasin d'instances.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance -&gt; unit" Usage="workflowApplication.Load instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <summary>Charge une instance de flux de travail à partir d'un magasin d'instances avec l'instance spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid -&gt; unit" Usage="workflowApplication.Load instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur 128 bits global unique de l'instance de flux de travail.</param>
        <summary>Charge l'instance de flux de travail spécifiée en mémoire à partir d'un magasin d'instances.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant appelle <xref:System.Activities.WorkflowApplication.Load%2A> pour charger l'instance de flux de travail persistante à partir d'un <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>. Cet exemple est issu le `LoadAndCompleteInstance` méthode dans le [persistance d’une Application de flux de travail](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) exemple.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap -&gt; unit" Usage="workflowApplication.Load (instance, updateMap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="updateMap">Carte de mise à jour.</param>
        <summary>Charge une instance du flux de travail à partir d'un magasin d'instances avec l'instance et la carte de mise à jour spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée.</param>
        <summary>Charge une instance du flux de travail à partir d'un magasin d'instances avec l'instance et l'intervalle de délai d'attente spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instanceId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceId">Identificateur 128 bits global unique de l'instance de flux de travail.</param>
        <param name="timeout">Intervalle au cours duquel l'opération de chargement doit être exécutée ; au-delà de ce délai, l'opération de chargement est annulée et une exception <see cref="T:System.TimeoutException" /> est levée.</param>
        <summary>Charge en mémoire l'instance de flux de travail spécifiée à partir d'un magasin d'instances à l'aide de l'intervalle de délai d'attente spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant appelle <xref:System.Activities.WorkflowApplication.Load%2A> pour charger l'instance de flux de travail persistante à partir d'un <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>. Cet exemple est issu le `LoadAndCompleteInstance` méthode dans le [persistance d’une Application de flux de travail](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) exemple.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, updateMap, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instance">Instance.</param>
        <param name="updateMap">Carte de mise à jour.</param>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée.</param>
        <summary>Charge une instance du flux de travail à partir d'un magasin d'instances avec l'instance, la carte de mise à jour et l'intervalle de délai d'attente spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge une instance de flux de travail exécutable à partir de la propriété <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance exécutable est une instance pour laquelle une horloge ou un verrou d'instance a expiré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance();" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : unit -&gt; unit" Usage="workflowApplication.LoadRunnableInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Charge une instance de flux de travail exécutable à partir de la propriété <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance exécutable est une instance pour laquelle une horloge ou un verrou d'instance a expiré.  
  
 Par défaut, l'opération de chargement doit être réalisée en 30 secondes, à défaut de quoi une <xref:System.TimeoutException> est levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : TimeSpan -&gt; unit" Usage="workflowApplication.LoadRunnableInstance timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle dans lequel l'opération de chargement doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <summary>Charge une instance de flux de travail exécutable à partir de la propriété <see cref="P:System.Activities.WorkflowApplication.InstanceStore" /> à l'aide du délai d'attente spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance exécutable est une instance pour laquelle une horloge ou un verrou d'instance a expiré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginAssociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginAssociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginAssociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginAssociateKeys (keys As ICollection(Of InstanceKey), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginAssociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginAssociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginAssociateKeys (keys, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginPersist">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">To be added.</param>
        <param name="value">To be added.</param>
        <param name="timeout">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisassociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnDisassociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnDisassociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnDisassociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnDisassociateKeys (keys As ICollection(Of InstanceKey))" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnDisassociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="override this.OnDisassociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; -&gt; unit" Usage="workflowApplication.OnDisassociateKeys keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnEndAssociateKeys (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndAssociateKeys(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndAssociateKeys(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndAssociateKeys (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndAssociateKeys(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndAssociateKeys : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndAssociateKeys result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndPersist">
      <MemberSignature Language="C#" Value="protected internal override void OnEndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override System.Activities.BookmarkResumptionResult OnEndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance valuetype System.Activities.BookmarkResumptionResult OnEndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnEndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Activities::BookmarkResumptionResult OnEndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.OnEndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyPaused">
      <MemberSignature Language="C#" Value="protected override void OnNotifyPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyPaused" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnNotifyPaused ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyPaused();" />
      <MemberSignature Language="F#" Value="override this.OnNotifyPaused : unit -&gt; unit" Usage="workflowApplication.OnNotifyPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyUnhandledException">
      <MemberSignature Language="C#" Value="protected override void OnNotifyUnhandledException (Exception exception, System.Activities.Activity exceptionSource, string exceptionSourceInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyUnhandledException(class System.Exception exception, class System.Activities.Activity exceptionSource, string exceptionSourceInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyUnhandledException(System.Exception,System.Activities.Activity,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyUnhandledException(Exception ^ exception, System::Activities::Activity ^ exceptionSource, System::String ^ exceptionSourceInstanceId);" />
      <MemberSignature Language="F#" Value="override this.OnNotifyUnhandledException : Exception * System.Activities.Activity * string -&gt; unit" Usage="workflowApplication.OnNotifyUnhandledException (exception, exceptionSource, exceptionSourceInstanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="exceptionSource" Type="System.Activities.Activity" />
        <Parameter Name="exceptionSourceInstanceId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exception">To be added.</param>
        <param name="exceptionSource">To be added.</param>
        <param name="exceptionSourceInstanceId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRequestAbort">
      <MemberSignature Language="C#" Value="protected internal override void OnRequestAbort (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRequestAbort(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnRequestAbort(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRequestAbort (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRequestAbort(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="override this.OnRequestAbort : Exception -&gt; unit" Usage="workflowApplication.OnRequestAbort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnhandledException">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt; OnUnhandledException { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, valuetype System.Activities.UnhandledExceptionAction&gt; OnUnhandledException" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Property OnUnhandledException As Func(Of WorkflowApplicationUnhandledExceptionEventArgs, UnhandledExceptionAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ OnUnhandledException { Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OnUnhandledException : Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, System.Activities.UnhandledExceptionAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Func`2" /> qui est appelé lorsque l'instance de flux de travail actuelle rencontre une exception non gérée.</summary>
        <value>Délégué appelé lorsqu'une instance de flux de travail rencontre une exception non gérée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> et <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> dictent le comportement du runtime lorsqu'une exception n'est pas gérée dans le workflow ; toutefois, <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> peut laisser en suspens le workflow dans le magasin de persistance, contrairement à <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A>. La raison de cela est que ce qui arrive à un workflow suspendu est spécifique à l'hôte, contrairement à <xref:System.Activities.WorkflowApplication>. Pour implémenter cette fonctionnalité à l'aide de <xref:System.Activities.WorkflowApplication>, créez un <xref:System.Activities.Persistence.PersistenceParticipant> personnalisé qui a ce comportement.  
  
   
  
## Examples  
 L'exemple suivant appelle un workflow qui lève une exception. L'exception n'est pas prise en charge par le workflow et le gestionnaire <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> est appelé. L'objet <xref:System.Activities.WorkflowApplicationUnhandledExceptionEventArgs> est inspecté de façon à fournir des informations sur l'exception, et le workflow est arrêté.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend une instance de flux de travail persistante dans un magasin d'instances.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist();" />
      <MemberSignature Language="F#" Value="member this.Persist : unit -&gt; unit" Usage="workflowApplication.Persist " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend une instance de flux de travail persistante dans un magasin d'instances.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'opération de persistance n'est pas exécutée dans un délai de 30 secondes, une exception <xref:System.TimeoutException> est levée.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
   
  
## Examples  
 L'exemple suivant appelle <xref:System.Activities.WorkflowApplication.Persist%2A> pour rendre une instance de flux de travail persistante avant le démarrage du flux de travail. Cet exemple fait partie de la `StartAndUnloadInstance` méthode dans le [persistance d’une Application de flux de travail](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) exemple.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Persist : TimeSpan -&gt; unit" Usage="workflowApplication.Persist timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle au cours duquel l'opération de persistance doit être exécutée ; au-delà de ce délai, l'opération est annulée et une exception <see cref="T:System.TimeoutException" /> est levée.</param>
        <summary>Rend une instance de flux de travail persistante dans un magasin d'instances avec l'intervalle de délai d'attente spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
   
  
## Examples  
 L'exemple suivant appelle <xref:System.Activities.WorkflowApplication.Persist%2A> pour rendre une instance de flux de travail persistante avant le démarrage du flux de travail. Cet exemple est issu le `StartAndUnloadInstance` méthode dans le [persistance d’une Application de flux de travail](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) exemple.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistableIdle">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt; PersistableIdle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationIdleEventArgs, valuetype System.Activities.PersistableIdleAction&gt; PersistableIdle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberSignature Language="VB.NET" Value="Public Property PersistableIdle As Func(Of WorkflowApplicationIdleEventArgs, PersistableIdleAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ PersistableIdle { Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PersistableIdle : Func&lt;System.Activities.WorkflowApplicationIdleEventArgs, System.Activities.PersistableIdleAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le délégué qui est appelé lorsque l’instance de flux de travail actuelle est inactive et peut être rendue persistante.</summary>
        <value>Le délégué est appelé lorsque l’instance de flux de travail actuelle est inactive et peut être rendu persistant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu'un flux de travail devient inactif et peut être rendu persistant, les propriétés <xref:System.Activities.WorkflowApplication.Idle%2A> et <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> sont appelées, dans cet ordre. Le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> retourne une des valeurs d'énumération <xref:System.Activities.PersistableIdleAction> de <xref:System.Activities.PersistableIdleAction.None>, <xref:System.Activities.PersistableIdleAction.Persist> ou <xref:System.Activities.PersistableIdleAction.Unload>.  
  
   
  
## Examples  
 L'exemple suivant gère le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> et indique au runtime qu'il doit rendre le flux de travail persistant et le décharger.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#26](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lance une opération pour reprendre un signet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <summary>Initialise une opération pour reprendre le signet spécifié, à l'aide de la valeur spécifiée. Le signet à reprendre est créé précédemment par une activité dans l'instance de flux de travail.</summary>
        <returns>Résultat de l'opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat indique si l'opération de reprise a réussi ou échoué.  
  
   
  
## Examples  
 L'exemple suivant génère un flux de travail utilisant une activité `ReadLine` qui crée un <xref:System.Activities.Bookmark>. Le flux de travail démarre, et une fois que le <xref:System.Activities.Bookmark> est créé et que le flux de travail est inactif, l'entrée de l'utilisateur est collectée et le signet est repris.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#24](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nom du signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <summary>Lance une opération pour reprendre le signet portant le nom spécifié, à l'aide de la valeur indiquée. Le signet à reprendre est créé précédemment par une activité dans l'instance de flux de travail.</summary>
        <returns>Résultat de l'opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat indique si l'opération de reprise a réussi ou échoué.  
  
   
  
## Examples  
 L'exemple suivant génère un flux de travail utilisant une activité `ReadLine` qui crée un <xref:System.Activities.Bookmark>. Le flux de travail démarre, et une fois que le <xref:System.Activities.Bookmark> est créé et que le flux de travail est inactif, l'entrée de l'utilisateur est collectée et le signet est repris.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmark">Signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <param name="timeout">Intervalle de temps pendant lequel le signet doit être repris.</param>
        <summary>Lance une opération pour reprendre le signet spécifié, à l'aide de la valeur et de l'intervalle de délai d'attente indiqués. Le signet à reprendre est créé précédemment par une activité dans l'instance de flux de travail.</summary>
        <returns>Résultat de l'opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat indique si l'opération de reprise a réussi ou échoué.  
  
   
  
## Examples  
 L'exemple suivant génère un flux de travail utilisant une activité `ReadLine` qui crée un <xref:System.Activities.Bookmark>. Le flux de travail démarre, et une fois que le <xref:System.Activities.Bookmark> est créé et que le flux de travail est inactif, l'entrée de l'utilisateur est collectée et le signet est repris.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#25](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Nom du signet à reprendre.</param>
        <param name="value">Objet passé comme paramètre à la méthode appelée lors de la reprise du signet.</param>
        <param name="timeout">Intervalle de temps pendant lequel le signet doit être repris.</param>
        <summary>Lance une opération pour reprendre le signet portant le nom spécifié, à l'aide de la valeur et de l'intervalle de délai d'attente indiqués. Le signet à reprendre est créé précédemment par une activité dans l'instance de flux de travail.</summary>
        <returns>Résultat de l'opération de reprise de signet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat indique si l'opération de reprise a réussi ou échoué.  
  
   
  
## Examples  
 L'exemple suivant génère un flux de travail utilisant une activité `ReadLine` qui crée un <xref:System.Activities.Bookmark>. Le flux de travail démarre, et une fois que le <xref:System.Activities.Bookmark> est créé et que le flux de travail est inactif, l'entrée de l'utilisateur est collectée et le signet est repris.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence ou reprend l'exécution d'une instance de flux de travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour lancer l'exécution d'une instance de flux de travail récemment créée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; unit" Usage="workflowApplication.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence ou reprend l'exécution d'une instance de flux de travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour lancer l'exécution d'une instance de flux de travail récemment créée.  
  
 Si l'opération d'exécution n'est pas réalisée dans un délai de 30 secondes, une exception <xref:System.TimeoutException> est levée.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Lorsque le flux de travail est terminé, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Run : TimeSpan -&gt; unit" Usage="workflowApplication.Run timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Appelez cette méthode pour lancer l'exécution d'une instance de flux de travail récemment créée.  
  
Intervalle au cours duquel l'opération d'exécution doit être réalisée ; au-delà de ce délai, l'opération est annulée et une exception <see cref="T:System.TimeoutException" /> est levée.</param>
        <summary>Commence ou continue l'exécution d'une instance de flux de travail à l'aide du délai d'attente spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que contrairement à la méthode <xref:System.Activities.WorkflowInvoker.Invoke%2A>, cette méthode expirera uniquement si le workflow ne démarre pas dans le délai  spécifié, au lieu d'expirer si elle n'est pas terminée dans le délai imparti. La raison de cela est que <xref:System.Activities.WorkflowInvoker.Invoke%2A> exécute le workflow de façon synchrone (en bloquant le thread hôte), tandis que <xref:System.Activities.WorkflowApplication.Run%2A> s'exécute de façon asynchrone, en bloquant uniquement le thread hôte le temps nécessaire pour que le workflow démarre.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Lorsque le flux de travail est terminé, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsInstanceKeys">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsInstanceKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsInstanceKeys" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsInstanceKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsInstanceKeys { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsInstanceKeys : bool" Usage="System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Terminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met fin à une instance de flux de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <summary>Met fin à une instance de flux de travail à l'aide de l'exception spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Par défaut, l'opération <xref:System.Activities.WorkflowApplication.Terminate%2A> doit être exécutée dans un délai de 30 secondes, sinon une exception <xref:System.TimeoutException> est levée.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Terminate%2A> est appelée. Lorsque le flux de travail est arrêté, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#16](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <summary>Met fin à une instance de flux de travail avec le message d'erreur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Par défaut, l'opération <xref:System.Activities.WorkflowApplication.Terminate%2A> doit être exécutée dans un délai de 30 secondes, sinon une exception <xref:System.TimeoutException> est levée.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Terminate%2A> est appelée. Lorsque le flux de travail est arrêté, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#18](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération <see cref="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" /> doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <summary>Met fin à une instance de flux de travail avec l'exception et l'intervalle de délai d'attente spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt du flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Terminate%2A> est appelée. Lorsque le flux de travail est arrêté, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#17](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Motif de fin de l'instance de flux de travail.</param>
        <param name="timeout">Intervalle dans lequel l'opération <see cref="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" /> doit être réalisée avant que l'opération ne soit annulée et qu'une <see cref="T:System.TimeoutException" /> ne soit levée.</param>
        <summary>Met fin à une instance de flux de travail avec le message d'erreur et l'intervalle de délai d'attente spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode planifie l'arrêt de l'instance de flux de travail. Pour être averti lorsque l'arrêt est terminé, utilisez le handle <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 L'exemple suivant héberge un workflow à l'aide de <xref:System.Activities.WorkflowApplication>. Une instance de <xref:System.Activities.WorkflowApplication> est construite à l'aide de la définition de flux de travail spécifiée, les événements de cycle de vie souhaités du flux de travail sont gérés et le flux de travail est appelé au moyen d'un appel à <xref:System.Activities.WorkflowApplication.Run%2A>. Une fois que le flux de travail a démarré, la méthode <xref:System.Activities.WorkflowApplication.Terminate%2A> est appelée. Lorsque le flux de travail est arrêté, la sortie suivante s'affiche sur la console.  
  
```Output  
Starting the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#19](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend persistante et décharge une instance de flux de travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, l'opération de déchargement doit être exécutée dans un délai de 30 secondes, sinon une exception <xref:System.TimeoutException> est levée.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowApplication.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend persistante et décharge une instance de flux de travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, l'opération de déchargement doit être exécutée dans un délai de 30 secondes, sinon une exception <xref:System.TimeoutException> est levée.  
  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
   
  
## Examples  
 L’exemple de code suivant fait partie de la [activité NoPersistScope](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) exemple. Dans cet exemple, le flux de travail est inactif et l'application hôte attend des entrées d'utilisateur. Si l'utilisateur choisit de procéder au déchargement, la méthode <xref:System.Activities.WorkflowApplication.Unload%2A> est appelée. Si l'opération réussit, le flux de travail est rendu persistant et déchargé de la mémoire.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Unload : TimeSpan -&gt; unit" Usage="workflowApplication.Unload timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalle au cours duquel l'opération de déchargement doit être exécutée ; au-delà de ce délai, l'opération est annulée et une exception <see cref="T:System.TimeoutException" /> est levée.</param>
        <summary>Rend persistante et décharge une instance de flux de travail à l'aide du délai d'attente spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'instance de workflow a été précédemment chargée à partir d'un point de persistance, alors, le même <xref:System.Runtime.DurableInstancing.InstanceStore> utilisé pour charger le workflow est utilisé pour la persistance. Si le workflow a été créé et n'a pas encore été rendu persistant, alors un <xref:System.Activities.WorkflowApplication.InstanceStore%2A> doit être configuré avant d'appeler cette méthode ou bien une exception <xref:System.InvalidOperationException> est levée lorsque cette méthode est appelée.  
  
   
  
## Examples  
 L’exemple de code suivant fait partie de la [activité NoPersistScope](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) exemple. Dans cet exemple, le flux de travail est inactif et l'application hôte attend des entrées d'utilisateur. Si l'utilisateur choisit de procéder au déchargement, la méthode <xref:System.Activities.WorkflowApplication.Unload%2A> est appelée. Si l'opération réussit, le flux de travail est rendu persistant et déchargé de la mémoire.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; Unloaded { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationEventArgs&gt; Unloaded" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Property Unloaded As Action(Of WorkflowApplicationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ Unloaded { Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Unloaded : Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Unloaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Action`1" /> qui est appelé lorsque le flux de travail actuel est déchargé.</summary>
        <value>Action appelée lorsqu'une instance de flux de travail est déchargée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple de code suivant inspecte l'objet <xref:System.Activities.WorkflowApplicationEventArgs> passé dans le gestionnaire d'événements <xref:System.Activities.WorkflowApplication.Unloaded%2A> d'une instance de <xref:System.Activities.WorkflowApplication> et affiche la propriété <xref:System.Activities.WorkflowApplicationEventArgs.InstanceId%2A> du flux de travail déchargé.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#3](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>