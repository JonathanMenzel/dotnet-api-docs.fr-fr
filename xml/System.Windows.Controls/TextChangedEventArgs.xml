<Type Name="TextChangedEventArgs" FullName="System.Windows.Controls.TextChangedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc1711706be81f923248687a59a8a6f50170ace7" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39806505" /></Metadata><TypeSignature Language="C#" Value="public class TextChangedEventArgs : System.Windows.RoutedEventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextChangedEventArgs extends System.Windows.RoutedEventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.TextChangedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class TextChangedEventArgs&#xA;Inherits RoutedEventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextChangedEventArgs : System::Windows::RoutedEventArgs" />
  <TypeSignature Language="F#" Value="type TextChangedEventArgs = class&#xA;    inherit RoutedEventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.RoutedEventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des données pour l'événement <see cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le nombre de fois où le texte dans un <xref:System.Windows.Controls.TextBox> modifications. Voici le code XAML pour l’exemple.  
  
 [!code-xaml[TextBoxMiscSnippets_snip#DetectChangedTextExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/detectchangedtextexample.xaml#detectchangedtextexamplewholepage)]  
  
 Voici le code-behind de l’exemple.  
  
 [!code-csharp[TextBoxMiscSnippets_snip#DetectChangedTextCodeExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/csharp/detectchangedtextexample.xaml.cs#detectchangedtextcodeexamplewholepage)]
 [!code-vb[TextBoxMiscSnippets_snip#DetectChangedTextCodeExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_snip/visualbasic/detectchangedtextexample.xaml.vb#detectchangedtextcodeexamplewholepage)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.TextChangedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextChangedEventArgs (System.Windows.RoutedEvent id, System.Windows.Controls.UndoAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent id, valuetype System.Windows.Controls.UndoAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextChangedEventArgs.#ctor(System.Windows.RoutedEvent,System.Windows.Controls.UndoAction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (id As RoutedEvent, action As UndoAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextChangedEventArgs(System::Windows::RoutedEvent ^ id, System::Windows::Controls::UndoAction action);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.TextChangedEventArgs : System.Windows.RoutedEvent * System.Windows.Controls.UndoAction -&gt; System.Windows.Controls.TextChangedEventArgs" Usage="new System.Windows.Controls.TextChangedEventArgs (id, action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="id" Type="System.Windows.RoutedEvent" />
        <Parameter Name="action" Type="System.Windows.Controls.UndoAction" />
      </Parameters>
      <Docs>
        <param name="id">Événement [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</param>
        <param name="action"><see cref="P:System.Windows.Controls.TextChangedEventArgs.UndoAction" /> provoquée par la modification du texte.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.TextChangedEventArgs" /> avec l'ID d'événement et l'opération d'annulation spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextChangedEventArgs (System.Windows.RoutedEvent id, System.Windows.Controls.UndoAction action, System.Collections.Generic.ICollection&lt;System.Windows.Controls.TextChange&gt; changes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent id, valuetype System.Windows.Controls.UndoAction action, class System.Collections.Generic.ICollection`1&lt;class System.Windows.Controls.TextChange&gt; changes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextChangedEventArgs.#ctor(System.Windows.RoutedEvent,System.Windows.Controls.UndoAction,System.Collections.Generic.ICollection{System.Windows.Controls.TextChange})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (id As RoutedEvent, action As UndoAction, changes As ICollection(Of TextChange))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextChangedEventArgs(System::Windows::RoutedEvent ^ id, System::Windows::Controls::UndoAction action, System::Collections::Generic::ICollection&lt;System::Windows::Controls::TextChange ^&gt; ^ changes);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.TextChangedEventArgs : System.Windows.RoutedEvent * System.Windows.Controls.UndoAction * System.Collections.Generic.ICollection&lt;System.Windows.Controls.TextChange&gt; -&gt; System.Windows.Controls.TextChangedEventArgs" Usage="new System.Windows.Controls.TextChangedEventArgs (id, action, changes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="id" Type="System.Windows.RoutedEvent" />
        <Parameter Name="action" Type="System.Windows.Controls.UndoAction" />
        <Parameter Name="changes" Type="System.Collections.Generic.ICollection&lt;System.Windows.Controls.TextChange&gt;" />
      </Parameters>
      <Docs>
        <param name="id">Événement [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</param>
        <param name="action"><see cref="P:System.Windows.Controls.TextChangedEventArgs.UndoAction" /> provoquée par la modification du texte.</param>
        <param name="changes">Modifications qui ont été effectuées pendant cet événement. Pour plus d'informations, consultez <see cref="P:System.Windows.Controls.TextChangedEventArgs.Changes" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.TextChangedEventArgs" /> avec l'ID d'événement, l'opération d'annulation et les modifications de texte spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextChangedEventArgs.%23ctor%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Changes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Windows.Controls.TextChange&gt; Changes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.Windows.Controls.TextChange&gt; Changes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextChangedEventArgs.Changes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Changes As ICollection(Of TextChange)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::Windows::Controls::TextChange ^&gt; ^ Changes { System::Collections::Generic::ICollection&lt;System::Windows::Controls::TextChange ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Changes : System.Collections.Generic.ICollection&lt;System.Windows.Controls.TextChange&gt;" Usage="System.Windows.Controls.TextChangedEventArgs.Changes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Windows.Controls.TextChange&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection d'objets qui contient des informations sur les modifications effectuées.</summary>
        <value>Collection d'objets qui contient des informations sur les modifications effectuées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il y a un <xref:System.Windows.Controls.TextChange> objet pour chaque modification consécutive au contrôle. Plusieurs modifications consécutives peuvent se produire pendant une occurrence de la <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> événement lorsque la modification implique de changer la structure du document sous-jacent.  
  
 Par exemple, supposons qu’un <xref:System.Windows.Controls.RichTextBox> contient la chaîne `"This is some text."` la structure de la <xref:System.Windows.Controls.RichTextBox.Document%2A?displayProperty=nameWithType> est `<Paragraph><Run>This is some text.</Run></Paragraph>`. Si l’utilisateur met en gras les mots `"is some"`, la structure de sous-jacent <xref:System.Windows.Documents.FlowDocument> devient `<Paragraph><Run>This </Run><Run  FontWeight="Bold">is some</Run><Run> text.</Run></Paragraph>`. Il existe en fait quatre modifications qui ont eu lieu à la suite d’action de l’utilisateur :  
  
1.  Le `<Run>` symbole est supprimé et rajouté avant le mot `This`.  
  
2.  Les symboles `</Run><Run>` sont ajoutés après le mot `This`.  
  
3.  Les symboles `</Run><Run>` sont ajoutés après le mot `some`.  
  
4.  Le `</Run>` symbole est supprimé et rajouté après le mot `Text`.  
  
 En règle générale, les éléments suivants sera toujours trus :  
  
-   Les modifications qui se produisent le résultat dans le document en cours dans un état valide.  
  
-   La collection est classée de manière consécutive, liés à où la modification s’est produite dans le contrôle.  Par exemple, un <xref:System.Windows.Controls.TextChange> objet qui représente une modification à la position 2 est avant un <xref:System.Windows.Controls.TextChange> objet qui représente une modification à la position 10.  
  
-   Deux <xref:System.Windows.Controls.TextChange> objets ne représentent pas une zone de chevauchement.  La valeur de <xref:System.Windows.Controls.TextChange.Offset%2A> plus la valeur de <xref:System.Windows.Controls.TextChange.AddedLength%2A> d’un <xref:System.Windows.Controls.TextChange> objet est toujours inférieure ou égale à la valeur de <xref:System.Windows.Controls.TextChange.Offset%2A> de la prochaine <xref:System.Windows.Controls.TextChange> objet dans la collection. De même, la valeur de <xref:System.Windows.Controls.TextChange.Offset%2A> plus la valeur de <xref:System.Windows.Controls.TextChange.RemovedLength%2A> d’un <xref:System.Windows.Controls.TextChange> objet est toujours inférieure ou égale à la valeur de <xref:System.Windows.Controls.TextChange.Offset%2A> de la prochaine <xref:System.Windows.Controls.TextChange> objet dans la collection.  
  
-   La collection reflète toutes les modifications effectuées, même s’il semble n’y avoir aucune modification nette. Dans l’exemple précédent, ni la modification de premier ou le quatrième entraîne une modification nette, car chacune a simplement supprimé et rajouté le `<Run>` et `</Run>` les symboles, respectivement. Mais les symboles ont été supprimés et ajoutés, ils sont inclus dans la collection.  
  
 Si le <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> événement se produit suite à une modification de propriété, <xref:System.Windows.Controls.TextChangedEventArgs.Changes%2A> est une collection vide.  Dans l’exemple précédent, si l’utilisateur met en gras la chaîne entière, le <xref:System.Windows.Documents.TextElement.FontWeight%2A> propriété de la <xref:System.Windows.Documents.Run> a la valeur <xref:System.Windows.FontWeights.Bold%2A>, mais rien n’est ajouté ou supprimé du document, par conséquent, <xref:System.Windows.Controls.TextChangedEventArgs.Changes%2A> est vide.  
  
 <xref:System.Windows.Controls.TextChangedEventArgs.Changes%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected override void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextChangedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="textChangedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Gestionnaire à appeler.</param>
        <param name="genericTarget">Objet en cours le long de l'itinéraire de l'événement.</param>
        <summary>Effectue le cast de type approprié pour appeler le délégué <see cref="T:System.Windows.Controls.TextChangedEventHandler" /> de type sécurisé pour l'événement <see cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UndoAction">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.UndoAction UndoAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.UndoAction UndoAction" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextChangedEventArgs.UndoAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoAction As UndoAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::UndoAction UndoAction { System::Windows::Controls::UndoAction get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoAction : System.Windows.Controls.UndoAction" Usage="System.Windows.Controls.TextChangedEventArgs.UndoAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.UndoAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la manière dont la pile d'annulation est entraînée ou affectée par cette modification du texte.</summary>
        <value><see cref="T:System.Windows.Controls.UndoAction" /> appropriée pour cette modification du texte.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>