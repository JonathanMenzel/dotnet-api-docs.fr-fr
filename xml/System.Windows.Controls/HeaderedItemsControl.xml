<Type Name="HeaderedItemsControl" FullName="System.Windows.Controls.HeaderedItemsControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="750f3b1006573d1fbdeeabd234067b7d30da3c82" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51889305" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HeaderedItemsControl : System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HeaderedItemsControl extends System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.HeaderedItemsControl" />
  <TypeSignature Language="VB.NET" Value="Public Class HeaderedItemsControl&#xA;Inherits ItemsControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class HeaderedItemsControl : System::Windows::Controls::ItemsControl" />
  <TypeSignature Language="F#" Value="type HeaderedItemsControl = class&#xA;    inherit ItemsControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ItemsControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("Header")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Menu)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un contrôle qui contient plusieurs éléments et possède un en-tête.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette classe pour créer un contrôle qui contient un en-tête (ou titre) et plusieurs éléments. Le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A?displayProperty=nameWithType> propriété peut être n’importe quel type. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fournit trois contrôles qui héritent de <xref:System.Windows.Controls.HeaderedItemsControl>:  
  
-   <xref:System.Windows.Controls.MenuItem>  
  
-   <xref:System.Windows.Controls.ToolBar>  
  
-   <xref:System.Windows.Controls.TreeViewItem>  
  
 Un <xref:System.Windows.Controls.HeaderedItemsControl> a un style par défaut limité. Pour créer un <xref:System.Windows.Controls.HeaderedItemsControl> avec une apparence personnalisée, créez un <xref:System.Windows.Controls.ControlTemplate>.  
  
 Définir le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A> propriété pour spécifier l’étiquette de la <xref:System.Windows.Controls.HeaderedItemsControl>.  <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A> peut être tout type d’objet.  Définir le <xref:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate%2A> propriété un <xref:System.Windows.DataTemplate> pour personnaliser l’en-tête.  Pour plus d’informations sur les modèles de données, consultez [Vue d’ensemble des modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
 Les propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut.  Si une propriété est définie par un style par défaut, la propriété peut changer à partir de sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’exécution de l’application.  Pour plus d’informations, consultez [thèmes WPF par défaut](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.TreeViewItem>. Le <xref:System.Windows.Controls.TreeView> contrôle contienne un seul <xref:System.Windows.Controls.TreeViewItem>, qui porte le nom `TreeViewItem 1`, et comprend les éléments suivants :  
  
-   Chaîne.  
  
-   Objet <xref:System.DateTime>.  
  
-   Un <xref:System.Windows.Controls.TreeViewItem> objet qui contient un <xref:System.Windows.Shapes.Rectangle> dans son <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A>.  
  
-   Un <xref:System.Windows.Controls.TreeViewItem> de l’objet dont la propriété <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A> propriété est définie sur une <xref:System.Windows.Controls.StackPanel> qui contient deux objets.  
  
> [!NOTE]
>  L’exemple crée explicitement <xref:System.Windows.Controls.TreeViewItem> objets pour le dernier, car les deux éléments <xref:System.Windows.Shapes.Rectangle> et <xref:System.Windows.Controls.StackPanel> héritent la <xref:System.Windows.Media.Visual> classe. Le style par défaut pour le <xref:System.Windows.Controls.TreeViewItem> définit le <xref:System.Windows.Controls.Control.Foreground%2A> propriété. Les objets enfants héritent la valeur de propriété créé explicitement <xref:System.Windows.Controls.TreeViewItem>, qui est généralement le comportement souhaité.  
  
 [!code-xaml[ControlContentOverviewSnippets#17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#17)]  
  
 L’exemple suivant crée un <xref:System.Windows.Controls.ControlTemplate> pour un <xref:System.Windows.Controls.HeaderedItemsControl>.  
  
 [!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Style](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_style)]  
[!code-xaml[HeaderedItemsControl#HeaderedItemsControl](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HeaderedItemsControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.HeaderedItemsControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HeaderedItemsControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.HeaderedItemsControl" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasHeader">
      <MemberSignature Language="C#" Value="public bool HasHeader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasHeader" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.HeaderedItemsControl.HasHeader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasHeader { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasHeader : bool" Usage="System.Windows.Controls.HeaderedItemsControl.HasHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Windows.Controls.HeaderedItemsControl" /> est doté d'un en-tête.</summary>
        <value>
          <see langword="true" /> si le contrôle est doté d'un en-tête ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A> propriété est `null`, cette propriété retourne `false`.  
  
<a name="dependencyPropertyInfo_HasHeader"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.HeaderedItemsControl.HasHeaderProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette propriété pour déterminer si le contrôle a un en-tête.  
  
 [!code-csharp[HeaderedItemsControl#HeaderedItemsControl_HasHeader](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml.cs#headereditemscontrol_hasheader)]
 [!code-vb[HeaderedItemsControl#HeaderedItemsControl_HasHeader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeaderedItemsControl/visualbasic/page1.xaml.vb#headereditemscontrol_hasheader)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasHeaderProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasHeaderProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasHeaderProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.HeaderedItemsControl.HasHeaderProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasHeaderProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasHeaderProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasHeaderProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.HeaderedItemsControl.HasHeaderProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.HeaderedItemsControl.HasHeader" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public object Header { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Header" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.HeaderedItemsControl.Header" />
      <MemberSignature Language="VB.NET" Value="Public Property Header As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Header { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Header : obj with get, set" Usage="System.Windows.Controls.HeaderedItemsControl.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'élément qui étiquette le contrôle.</summary>
        <value>Objet qui étiquette le <see cref="T:System.Windows.Controls.HeaderedItemsControl" />. La valeur par défaut est <see langword="null" />. Un en-tête peut être une chaîne ou un <see cref="T:System.Windows.UIElement" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A> propriété est de type <xref:System.Object>, il n’existe aucune restriction sur ce que vous pouvez placer dans le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A>. Le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A> est affiché par un <xref:System.Windows.Controls.ContentPresenter>, qui se trouve dans le <xref:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate%2A> de la <xref:System.Windows.Controls.HeaderedItemsControl>. Pour plus d’informations sur la façon dont <xref:System.Windows.Controls.ContentPresenter> affiche le <xref:System.Windows.Controls.HeaderedItemsControl.Header%2A>, consultez <xref:System.Windows.Controls.ContentPresenter>.  
  
<a name="xamlAttributeUsage_Header"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Header="headerString"/>  
```  
  
<a name="xamlPropertyElementUsage_Header"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Header>  
    <UIElement />  
  </object.Header>  
</object>  
  
```  
  
<a name="xamlValues_Header"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *headerString*  
 Chaîne à utiliser comme en-tête.  
  
<a name="dependencyPropertyInfo_Header"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.HeaderedItemsControl.HeaderProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment créer et utiliser un modèle d’en-tête pour spécifier l’apparence de l’en-tête.  
  
 [!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Style](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_style)]  
[!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Template1](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_template1)]  
[!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Template2](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_template2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeaderProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeaderProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.HeaderedItemsControl.HeaderProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeaderProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.HeaderedItemsControl.Header" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderStringFormat">
      <MemberSignature Language="C#" Value="public string HeaderStringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderStringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.HeaderedItemsControl.HeaderStringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderStringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HeaderStringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderStringFormat : string with get, set" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderStringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une chaîne composite qui spécifie la manière de mettre en forme la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.Header" /> si celle-ci s'affiche en tant que chaîne.</summary>
        <value>Chaîne composite qui spécifie la manière de mettre en forme la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.Header" /> si celle-ci s'affiche en tant que chaîne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderStringFormatProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeaderStringFormatProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeaderStringFormatProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.HeaderedItemsControl.HeaderStringFormatProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderStringFormatProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeaderStringFormatProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderStringFormatProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderStringFormatProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderStringFormat" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderTemplate">
      <MemberSignature Language="C#" Value="public System.Windows.DataTemplate HeaderTemplate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DataTemplate HeaderTemplate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderTemplate As DataTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DataTemplate ^ HeaderTemplate { System::Windows::DataTemplate ^ get(); void set(System::Windows::DataTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderTemplate : System.Windows.DataTemplate with get, set" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderTemplate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DataTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le modèle utilisé pour afficher le contenu de l'en-tête du contrôle.</summary>
        <value>Modèle de données utilisé pour afficher l'en-tête d'un contrôle. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour personnaliser l’en-tête de la <xref:System.Windows.Controls.HeaderedItemsControl>, définissez cette propriété sur un <xref:System.Windows.DataTemplate>. Pour plus d’informations sur les modèles de données, consultez [vue d’ensemble de la création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_HeaderTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object HeaderTemplate="{ResourceExtension TemplateResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_HeaderTemplate"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
<a name="xamlValues_HeaderTemplate"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *ResourceExtension*  
 Une des opérations suivantes : `StaticResource`, ou `DynamicResource`. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *TemplateResourceKey*  
 La clé qui identifie le modèle demandé. La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Syntaxe d’élément de propriété est techniquement possible, mais non recommandée. Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Une liaison à l’aide de la référence ou est également possible, mais rare.  
  
<a name="dependencyPropertyInfo_HeaderTemplate"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment créer et utiliser un modèle d’en-tête pour spécifier l’apparence de l’en-tête.  
  
 [!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Style](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_style)]  
[!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Template1](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_template1)]  
[!code-xaml[HeaderedItemsControl#HeaderedItemsControl_Template2](~/samples/snippets/csharp/VS_Snippets_Wpf/HeaderedItemsControl/CSharp/Page1.xaml#headereditemscontrol_template2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.HierarchicalDataTemplate" />
      </Docs>
    </Member>
    <Member MemberName="HeaderTemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeaderTemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeaderTemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderTemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeaderTemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderTemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderTemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderTemplateSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.DataTemplateSelector HeaderTemplateSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.DataTemplateSelector HeaderTemplateSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderTemplateSelector As DataTemplateSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::DataTemplateSelector ^ HeaderTemplateSelector { System::Windows::Controls::DataTemplateSelector ^ get(); void set(System::Windows::Controls::DataTemplateSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderTemplateSelector : System.Windows.Controls.DataTemplateSelector with get, set" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.DataTemplateSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet qui fournit la logique de sélection personnalisée d'un modèle utilisé pour afficher l'en-tête de chaque élément.</summary>
        <value>Sélecteur de modèle de données. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En général, vous créez un <xref:System.Windows.Controls.DataTemplateSelector> lorsque vous avez plusieurs <xref:System.Windows.DataTemplate> pour le même type d’objets et que vous souhaitez fournir votre propre logique pour choisir un <xref:System.Windows.DataTemplate> à appliquer en fonction des propriétés de chaque objet de données. Notez que si vous avez des objets de différents types que vous pouvez définir le <xref:System.Windows.DataTemplate.DataType%2A> propriété sur le <xref:System.Windows.DataTemplate>. Si vous le faire, il est inutile de créer un <xref:System.Windows.Controls.DataTemplateSelector>. En outre, si vous avez les objets du même type, mais avec des propriétés différentes, vous pouvez également envisager d’utiliser un <xref:System.Windows.DataTrigger> ou un convertisseur de données. Pour plus d’informations, consultez [Vue d’ensemble des modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
 Pour créer un sélecteur de modèle, créez une classe qui hérite de <xref:System.Windows.Controls.DataTemplateSelector> et remplacer le <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> (méthode). Après avoir défini votre classe, vous pouvez assigner une instance de la classe à la propriété de sélecteur de modèle de votre élément.  
  
 Si les deux le <xref:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector%2A> et <xref:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate%2A> propriétés sont définies, la propriété de sélecteur de modèle est ignorée.  
  
<a name="xamlAttributeUsage_HeaderTemplateSelector"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object HeaderTemplateSelector="{ResourceExtension DataTemplateSelectorClassKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_HeaderTemplateSelector"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.HeaderTemplateSelector>  
    <MyDataTemplateSelectorImplementation .../>  
  </object.HeaderTemplateSelector>  
</object>  
```  
  
<a name="xamlValues_HeaderTemplateSelector"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *MyDataTemplateSelectorImplementation*  
 Une classe dérivée de <xref:System.Windows.Controls.DataTemplateSelector> qui implémente une pratique <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> remplacer. Pour plus d’informations sur le mappage de votre classe personnalisée, consultez [espaces de noms XAML et Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
 *ResourceExtension*  
 Une des opérations suivantes : `StaticResource`, ou `DynamicResource`. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *DataTemplateSelectorClassKey*  
 La clé qui identifie l’implémentation de sélecteur demandée. La clé fait référence à une classe dérivée qui implémente une pratique <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> remplacer. Pour plus d’informations sur le mappage de votre classe personnalisée, consultez [espaces de noms XAML et Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md). Vous pouvez également ajouter par programme une instance de votre <xref:System.Windows.Controls.DataTemplateSelector> classe en tant que ressource à un dictionnaire de ressources.  
  
<a name="dependencyPropertyInfo_HeaderTemplateSelector"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelectorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderTemplateSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeaderTemplateSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeaderTemplateSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderTemplateSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeaderTemplateSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderTemplateSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.HeaderedItemsControl.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.HeaderedItemsControl.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un énumérateur pour les éléments enfants logiques de <see cref="T:System.Windows.Controls.HeaderedItemsControl" />.</summary>
        <value>Énumérateur. La valeur par défaut est <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHeaderChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHeaderChanged (object oldHeader, object newHeader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHeaderChanged(object oldHeader, object newHeader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.HeaderedItemsControl.OnHeaderChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHeaderChanged (oldHeader As Object, newHeader As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHeaderChanged(System::Object ^ oldHeader, System::Object ^ newHeader);" />
      <MemberSignature Language="F#" Value="abstract member OnHeaderChanged : obj * obj -&gt; unit&#xA;override this.OnHeaderChanged : obj * obj -&gt; unit" Usage="headeredItemsControl.OnHeaderChanged (oldHeader, newHeader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldHeader" Type="System.Object" />
        <Parameter Name="newHeader" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldHeader">Ancienne valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.Header" />.</param>
        <param name="newHeader">Nouvelle valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.Header" />.</param>
        <summary>Appelée lorsque la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.Header" /> d'un <see cref="T:System.Windows.Controls.HeaderedItemsControl" /> est modifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHeaderStringFormatChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHeaderStringFormatChanged (string oldHeaderStringFormat, string newHeaderStringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.HeaderedItemsControl.OnHeaderStringFormatChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHeaderStringFormatChanged (oldHeaderStringFormat As String, newHeaderStringFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHeaderStringFormatChanged(System::String ^ oldHeaderStringFormat, System::String ^ newHeaderStringFormat);" />
      <MemberSignature Language="F#" Value="abstract member OnHeaderStringFormatChanged : string * string -&gt; unit&#xA;override this.OnHeaderStringFormatChanged : string * string -&gt; unit" Usage="headeredItemsControl.OnHeaderStringFormatChanged (oldHeaderStringFormat, newHeaderStringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldHeaderStringFormat" Type="System.String" />
        <Parameter Name="newHeaderStringFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldHeaderStringFormat">Ancienne valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderStringFormat" />.</param>
        <param name="newHeaderStringFormat">Nouvelle valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderStringFormat" />.</param>
        <summary>Se produit quand la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderStringFormat" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHeaderTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHeaderTemplateChanged (System.Windows.DataTemplate oldHeaderTemplate, System.Windows.DataTemplate newHeaderTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHeaderTemplateChanged(class System.Windows.DataTemplate oldHeaderTemplate, class System.Windows.DataTemplate newHeaderTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.HeaderedItemsControl.OnHeaderTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHeaderTemplateChanged (oldHeaderTemplate As DataTemplate, newHeaderTemplate As DataTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHeaderTemplateChanged(System::Windows::DataTemplate ^ oldHeaderTemplate, System::Windows::DataTemplate ^ newHeaderTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnHeaderTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit&#xA;override this.OnHeaderTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit" Usage="headeredItemsControl.OnHeaderTemplateChanged (oldHeaderTemplate, newHeaderTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldHeaderTemplate" Type="System.Windows.DataTemplate" />
        <Parameter Name="newHeaderTemplate" Type="System.Windows.DataTemplate" />
      </Parameters>
      <Docs>
        <param name="oldHeaderTemplate">Ancienne valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate" />.</param>
        <param name="newHeaderTemplate">Nouvelle valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate" />.</param>
        <summary>Appelé quand la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplate" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHeaderTemplateSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnHeaderTemplateSelectorChanged (System.Windows.Controls.DataTemplateSelector oldHeaderTemplateSelector, System.Windows.Controls.DataTemplateSelector newHeaderTemplateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHeaderTemplateSelectorChanged(class System.Windows.Controls.DataTemplateSelector oldHeaderTemplateSelector, class System.Windows.Controls.DataTemplateSelector newHeaderTemplateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.HeaderedItemsControl.OnHeaderTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHeaderTemplateSelectorChanged (oldHeaderTemplateSelector As DataTemplateSelector, newHeaderTemplateSelector As DataTemplateSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHeaderTemplateSelectorChanged(System::Windows::Controls::DataTemplateSelector ^ oldHeaderTemplateSelector, System::Windows::Controls::DataTemplateSelector ^ newHeaderTemplateSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnHeaderTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit&#xA;override this.OnHeaderTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit" Usage="headeredItemsControl.OnHeaderTemplateSelectorChanged (oldHeaderTemplateSelector, newHeaderTemplateSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldHeaderTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
        <Parameter Name="newHeaderTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
      </Parameters>
      <Docs>
        <param name="oldHeaderTemplateSelector">Ancienne valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector" />.</param>
        <param name="newHeaderTemplateSelector">Nouvelle valeur de la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector" />.</param>
        <summary>Appelé quand la propriété <see cref="P:System.Windows.Controls.HeaderedItemsControl.HeaderTemplateSelector" /> change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.HeaderedItemsControl.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="headeredItemsControl.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la représentation sous forme de chaîne d'un objet <see cref="T:System.Windows.Controls.HeaderedItemsControl" />.</summary>
        <returns>Chaîne représentant cet objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne une chaîne qui contient des informations sur la propriété d’en-tête et le nombre d’éléments dans le <xref:System.Windows.Controls.ItemsControl.Items%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>