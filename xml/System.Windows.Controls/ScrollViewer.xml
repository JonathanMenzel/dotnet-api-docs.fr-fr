<Type Name="ScrollViewer" FullName="System.Windows.Controls.ScrollViewer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="036b415e8c005b477274d00cab422907bbe840d0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30620793" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ScrollViewer : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollViewer extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ScrollViewer" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollViewer&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollViewer : System::Windows::Controls::ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ScrollChangedEvent")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_HorizontalScrollBar", Type=typeof(System.Windows.Controls.Primitives.ScrollBar))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_VerticalScrollBar", Type=typeof(System.Windows.Controls.Primitives.ScrollBar))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_ScrollContentPresenter", Type=typeof(System.Windows.Controls.ScrollContentPresenter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une zone avec défilement qui peut contenir d'autres éléments visibles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Controls.ScrollViewer> permet le contenu devant être affiché dans une zone moins étendue que sa taille réelle.  Lorsque le contenu de la <xref:System.Windows.Controls.ScrollViewer> n’est pas entièrement visible, la <xref:System.Windows.Controls.ScrollViewer> affiche des barres de défilement que l’utilisateur peut utiliser pour déplacer les zones de contenu qui est visible.  La zone qui inclut tout le contenu de la <xref:System.Windows.Controls.ScrollViewer> est l’étendue.  La zone visible du contenu est la fenêtre d’affichage.  
  
 Le défilement physique est utilisé pour faire défiler le contenu selon un incrément physique prédéterminé, généralement une valeur déclarée en pixels. Le défilement logique est utilisé pour faire défiler l’écran jusqu’à l’élément suivant dans l’arborescence logique. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`. Le défilement physique est le comportement de défilement par défaut pour la plupart des <xref:System.Windows.Controls.Panel> éléments.  
  
 Si votre <xref:System.Windows.Controls.ScrollViewer> contient un grand nombre d’éléments, les performances de défilement peuvent être affectées.  Dans ce cas, définissez <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> à `true`.  Cela entraîne l’affichage de contenu reste statique tout en faisant glisser le <xref:System.Windows.Controls.Primitives.Thumb> et mettre à jour uniquement lorsque le <xref:System.Windows.Controls.Primitives.Thumb> est libérée.  
  
 Étant donné que les barres de défilement pour une <xref:System.Windows.Controls.ScrollViewer> élément sont définis dans le style par défaut de l’élément, de barres de défilement n’apparaît plus si vous appliquez un style personnalisé à un <xref:System.Windows.Controls.ScrollViewer>. Barres de défilement doivent être définis dans le style personnalisé pour qu’ils apparaissent.  
  
## <a name="customizing-the-scrollviewer-control"></a>Personnalisation du contrôle ScrollViewer  
 Pour appliquer les mêmes paramètres de propriété à plusieurs <xref:System.Windows.Controls.ScrollViewer> contrôles, utilisez le <xref:System.Windows.FrameworkElement.Style%2A> propriété. Vous pouvez modifier la valeur par défaut <xref:System.Windows.Controls.ControlTemplate> pour donner une apparence unique au contrôle. Pour plus d’informations sur la création d’un <xref:System.Windows.Controls.ControlTemplate>, consultez [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Pour afficher les parties et les États qui sont spécifiques à la <xref:System.Windows.Controls.ScrollViewer>, consultez [ScrollViewer Styles et modèles](~/docs/framework/wpf/controls/scrollviewer-styles-and-templates.md).  
  
 Propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut.  Si une propriété est définie par un style par défaut, la propriété peut changer sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’application est en cours d’exécution.  Pour plus d’informations, consultez [par défaut des thèmes WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Définition d’une propriété visuelle uniquement aura un effet si ces propriétés sont toutes deux présentes dans <xref:System.Windows.Controls.ScrollViewer> contrôle du modèle par défaut et est définie à l’aide d’un. Vous trouverez une liste de propriétés visual dans la section « Modification le Visual Structure d’un contrôle » [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.ScrollViewer> qui contient du texte et un rectangle. Les barres de défilement s’affichent uniquement lorsqu’elles sont nécessaires. Lorsque vous redimensionnez la fenêtre, les barres de défilement apparaissent et disparaissent.  
  
 [!code-cpp[ScrollViewer#1](~/samples/snippets/cpp/VS_Snippets_Wpf/ScrollViewer/CPP/ScrollViewer_wcp.cpp#1)]
 [!code-csharp[ScrollViewer#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollViewer/CSharp/ScrollViewer_wcp.cs#1)]
 [!code-vb[ScrollViewer#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollViewer/VisualBasic/ScrollViewer.vb#1)]
 [!code-xaml[ScrollViewer#1](~/samples/snippets/xaml/VS_Snippets_Wpf/ScrollViewer/XAML/Pane1.xaml#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollViewer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollViewer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">Dernière zone dans le parent que cet élément doit utiliser pour se réorganiser et réorganiser ses enfants.</param>
        <summary>Réorganise le contenu du <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Controls.ScrollViewer.ArrangeOverride(System.Windows.Size)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Controls.ScrollViewer.ArrangeOverride(System.Windows.Size)" /> (méthode)</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CanContentScroll">
      <MemberSignature Language="C#" Value="public bool CanContentScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanContentScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />
      <MemberSignature Language="VB.NET" Value="Public Property CanContentScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanContentScroll { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les éléments qui prennent en charge l'interface <see cref="T:System.Windows.Controls.Primitives.IScrollInfo" /> peuvent défiler.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Windows.Controls.ScrollViewer" /> défile en unités logiques ; <see langword="false" /> si le <see cref="T:System.Windows.Controls.ScrollViewer" /> défile en unités physiques. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contenu dans un <xref:System.Windows.Controls.ScrollViewer> peut défiler en termes d’unités physiques ou d’unités logiques. Unités physiques sont des pixels indépendants du périphérique. Unités logiques sont utilisées pour le défilement des éléments dans un <xref:System.Windows.Controls.ItemsControl>. Le comportement par défaut de la <xref:System.Windows.Controls.ScrollViewer> consiste à utiliser des unités physiques pour faire défiler son contenu. Toutefois, dans le cas où la <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> a la valeur `true`, le contenu peut utiliser des unités logiques pour faire défiler. Par exemple, <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView>et d’autres contrôles qui héritent de <xref:System.Windows.Controls.ItemsControl> utiliser des unités logiques pour faire défiler. Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `true`, les valeurs de la <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>, et <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> propriétés sont un nombres d’éléments, au lieu d’unités physiques.  
  
 Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`. Le défilement physique est le comportement de défilement par défaut pour la plupart des <xref:System.Windows.Controls.Panel> éléments.  
  
<a name="dependencyPropertyInfo_CanContentScroll"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.CanContentScrollProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété à l’aide de code.  
  
 [!code-csharp[scrollchangedeventargsLayout#4](~/samples/snippets/csharp/VS_Snippets_Wpf/scrollchangedeventargsLayout/CSharp/Window1.xaml.cs#4)]
 [!code-vb[scrollchangedeventargsLayout#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/scrollchangedeventargsLayout/VisualBasic/Window1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanContentScrollProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CanContentScrollProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CanContentScrollProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.CanContentScrollProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CanContentScrollProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CanContentScrollProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" />
      </Docs>
    </Member>
    <Member MemberName="ComputedHorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility ComputedHorizontalScrollBarVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility ComputedHorizontalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComputedHorizontalScrollBarVisibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility ComputedHorizontalScrollBarVisibility { System::Windows::Visibility get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontale est visible.</summary>
        <value>
          <see cref="T:System.Windows.Visibility" /> qui indique si la barre de défilement horizontale est visible. La valeur par défaut est <see cref="F:System.Windows.Controls.ScrollBarVisibility.Hidden" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ComputedHorizontalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
      </Docs>
    </Member>
    <Member MemberName="ComputedHorizontalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ComputedHorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ComputedHorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ComputedHorizontalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ComputedHorizontalScrollBarVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ComputedHorizontalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ComputedVerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility ComputedVerticalScrollBarVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility ComputedVerticalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComputedVerticalScrollBarVisibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility ComputedVerticalScrollBarVisibility { System::Windows::Visibility get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale est visible.</summary>
        <value>
          <see cref="T:System.Windows.Visibility" /> qui indique si la barre de défilement verticale est visible. La valeur par défaut est <see cref="F:System.Windows.Controls.ScrollBarVisibility.Visible" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ComputedVerticalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollBar" />
      </Docs>
    </Member>
    <Member MemberName="ComputedVerticalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ComputedVerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ComputedVerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ComputedVerticalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ComputedVerticalScrollBarVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ComputedVerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ContentHorizontalOffset">
      <MemberSignature Language="C#" Value="public double ContentHorizontalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ContentHorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentHorizontalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ContentHorizontalOffset { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le décalage horizontal du contenu visible.</summary>
        <value>Décalage horizontal du contenu visible.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> est `true`, le contenu défile lorsque l’utilisateur relâche le <xref:System.Windows.Controls.Primitives.Thumb> de la <xref:System.Windows.Controls.Primitives.ScrollBar>.  Lorsque l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>, le <xref:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset%2A> valeur ne change pas.   Lorsque l’utilisateur relâche le <xref:System.Windows.Controls.Primitives.Thumb>, <xref:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset%2A> mises à jour en cours <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> valeur.  
  
 Lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> est `false`, le contenu défile lorsque l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>.  Dans ce cas, <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> est toujours égale à <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentHorizontalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentHorizontalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentHorizontalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ContentHorizontalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentHorizontalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentHorizontalOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentVerticalOffset">
      <MemberSignature Language="C#" Value="public double ContentVerticalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ContentVerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ContentVerticalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentVerticalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ContentVerticalOffset { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le décalage vertical du contenu visible.</summary>
        <value>Décalage vertical du contenu visible.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> est `true`, le contenu défile lorsque l’utilisateur relâche le <xref:System.Windows.Controls.Primitives.Thumb> de la <xref:System.Windows.Controls.Primitives.ScrollBar>.  Lorsque l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>, le <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> ne change pas.  Lorsque l’utilisateur relâche le <xref:System.Windows.Controls.Primitives.Thumb>, <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> mises à jour en cours <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> valeur.  
  
 Lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> est `false`, le contenu défile lorsque l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>.  Dans ce cas, <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> est toujours égale à <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentVerticalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentVerticalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentVerticalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ContentVerticalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentVerticalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentVerticalOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ContentVerticalOffset" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentHeight">
      <MemberSignature Language="C#" Value="public double ExtentHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ExtentHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtentHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ExtentHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui contient la taille verticale de l’étendue.</summary>
        <value>
          <see cref="T:System.Double" /> qui représente la taille verticale de l’étendue. La valeur par défaut est 0.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A> est uniquement une propriété de sortie ; elle peut être définie efficacement en spécifiant la <xref:System.Windows.FrameworkElement.Height%2A> de l’élément de contenu.  
  
 Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `true`, les valeurs de la <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>, et <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> propriétés sont un nombres d’éléments. Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `false`, les valeurs de ces propriétés sont les Pixels indépendants du périphérique.  
  
<a name="dependencyPropertyInfo_ExtentHeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ExtentHeightProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ExtentHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ExtentHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ExtentHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ExtentHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ExtentHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ExtentHeight" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ExtentHeight" />
      </Docs>
    </Member>
    <Member MemberName="ExtentWidth">
      <MemberSignature Language="C#" Value="public double ExtentWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ExtentWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtentWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ExtentWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui contient la taille horizontale de l’étendue.</summary>
        <value>
          <see cref="T:System.Double" /> qui représente la taille horizontale de l’étendue. La valeur par défaut est 0.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ScrollViewer.ExtentWidth%2A> est uniquement une propriété de sortie ; elle peut être définie efficacement en spécifiant la <xref:System.Windows.FrameworkElement.Width%2A> de l’élément de contenu.  
  
 La valeur retournée est décrite en Pixels indépendants du périphérique.  
  
<a name="dependencyPropertyInfo_ExtentWidth"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ExtentWidthProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtentWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ExtentWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ExtentWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ExtentWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ExtentWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ExtentWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ExtentWidth" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ExtentWidth" />
      </Docs>
    </Member>
    <Member MemberName="GetCanContentScroll">
      <MemberSignature Language="C#" Value="public static bool GetCanContentScroll (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetCanContentScroll(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetCanContentScroll(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCanContentScroll (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetCanContentScroll(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément à partir duquel la valeur de la propriété est lue.</param>
        <summary>Obtient la valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" /> à partir d’un élément donné.</summary>
        <returns>
          <see langword="true" /> si cet élément peut défiler ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ScrollBarVisibility GetHorizontalScrollBarVisibility (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.ScrollBarVisibility GetHorizontalScrollBarVisibility(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetHorizontalScrollBarVisibility(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHorizontalScrollBarVisibility (element As DependencyObject) As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ScrollBarVisibility GetHorizontalScrollBarVisibility(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément à partir duquel la valeur de la propriété est lue.</param>
        <summary>Obtient la valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" /> à partir d’un élément donné.</summary>
        <returns>Valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsDeferredScrollingEnabled">
      <MemberSignature Language="C#" Value="public static bool GetIsDeferredScrollingEnabled (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsDeferredScrollingEnabled(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetIsDeferredScrollingEnabled(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsDeferredScrollingEnabled (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsDeferredScrollingEnabled(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objet à partir duquel obtenir <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />.</param>
        <summary>Retourne la valeur de la propriété <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" /> de l’objet spécifié.</summary>
        <returns>
          <see langword="true" /> si le contenu est stationnaire lorsque l'utilisateur fait glisser <see cref="T:System.Windows.Controls.Primitives.Thumb" /> de <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPanningDeceleration">
      <MemberSignature Language="C#" Value="public static double GetPanningDeceleration (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetPanningDeceleration(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetPanningDeceleration(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPanningDeceleration (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetPanningDeceleration(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément à partir duquel la valeur de la propriété est lue.</param>
        <summary>Retourne la valeur de la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" /> de l’objet spécifié.</summary>
        <returns>Le taux <see cref="T:System.Windows.Controls.ScrollViewer" /> ralentit dans [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] par milliseconde au carré.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPanningMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.PanningMode GetPanningMode (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.PanningMode GetPanningMode(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetPanningMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPanningMode (element As DependencyObject) As PanningMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::PanningMode GetPanningMode(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.PanningMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément à partir duquel la valeur de la propriété est lue.</param>
        <summary>Retourne la valeur de la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" /> de l’objet spécifié.</summary>
        <returns>Valeur qui spécifie la manière dont <see cref="T:System.Windows.Controls.ScrollViewer" /> réagit à la manipulation tactile.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPanningRatio">
      <MemberSignature Language="C#" Value="public static double GetPanningRatio (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetPanningRatio(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetPanningRatio(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPanningRatio (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetPanningRatio(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément à partir duquel la valeur de la propriété est lue.</param>
        <summary>Retourne la valeur de la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" /> de l’objet spécifié.</summary>
        <returns>Rapport de décalage de défilement à traduire en décalage de manipulation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ScrollBarVisibility GetVerticalScrollBarVisibility (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Controls.ScrollBarVisibility GetVerticalScrollBarVisibility(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.GetVerticalScrollBarVisibility(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVerticalScrollBarVisibility (element As DependencyObject) As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ScrollBarVisibility GetVerticalScrollBarVisibility(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément à partir duquel la valeur de la propriété est lue.</param>
        <summary>Obtient la valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" /> à partir d’un élément donné.</summary>
        <returns>Valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected internal override bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.HandlesScrolling" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property HandlesScrolling As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HandlesScrolling { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique qu'un contrôle est doté d'un <see cref="T:System.Windows.Controls.ScrollViewer" /> défini dans son style, qui définit un comportement de défilement clavier personnalisé.</summary>
        <value>
          <see langword="true" /> si ce contrôle définit un comportement de défilement clavier personnalisé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété retourne `true`, entrée au clavier n’est pas gérée par le <xref:System.Windows.Controls.ScrollViewer>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Paramètres du test d'atteinte d'un objet visuel.</param>
        <summary>Effectue un test d'atteinte pour déterminer si les points spécifiés se trouvent dans les limites de ce <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <returns>Résultat du test d'atteinte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffset">
      <MemberSignature Language="C#" Value="public double HorizontalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.HorizontalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HorizontalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalOffset { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui contient le décalage horizontal du contenu parcouru.</summary>
        <value>
          <see cref="T:System.Double" /> qui représente le décalage horizontal du contenu parcouru. La valeur par défaut est 0.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nombre positif <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> valeur correspond au contenu décalé vers la gauche.  
  
 Les valeurs valides sont comprises entre zéro et la <xref:System.Windows.Controls.ScrollViewer.ExtentWidth%2A> moins la <xref:System.Windows.Controls.ScrollViewer.ViewportWidth%2A>.  
  
 La valeur retournée est décrite en Pixels indépendants du périphérique.  
  
 À compter de .NET Framework version 3.5 SP1, lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> est `true`, <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> continue d’être modifié en tant que l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>, mais ne modifie pas l’affichage du contenu jusqu'à ce que le <xref:System.Windows.Controls.Primitives.Thumb> est libérée.  Dans ce cas, <xref:System.Windows.Controls.ScrollViewer.ContentHorizontalOffset%2A> représente le décalage de contenu visible et <xref:System.Windows.Controls.ScrollViewer.HorizontalOffset%2A> représente le décalage de contenu basé sur le <xref:System.Windows.Controls.Primitives.Thumb> position.  
  
<a name="dependencyPropertyInfo_HorizontalOffset"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.HorizontalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalOffset" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.HorizontalOffset" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalScrollBarVisibility As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ScrollBarVisibility HorizontalScrollBarVisibility { System::Windows::Controls::ScrollBarVisibility get(); void set(System::Windows::Controls::ScrollBarVisibility value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontale doit être affichée.</summary>
        <value>Valeur <see cref="T:System.Windows.Controls.ScrollBarVisibility" /> qui indique si une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontale doit être affichée. La valeur par défaut est <see cref="F:System.Windows.Controls.ScrollBarVisibility.Hidden" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété a également une utilisation de la propriété jointe.  
  
<a name="dependencyPropertyInfo_HorizontalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalScrollBarVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateScrollInfo">
      <MemberSignature Language="C#" Value="public void InvalidateScrollInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateScrollInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.InvalidateScrollInfo" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateScrollInfo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateScrollInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par une interface <see cref="T:System.Windows.Controls.Primitives.IScrollInfo" /> jointe à un <see cref="T:System.Windows.Controls.ScrollViewer" /> lorsque la valeur de la taille des propriétés de défilement est modifiée. Les propriétés de défilement incluent le décalage, l’étendue ou la fenêtre d’affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode gère l’invalidation d’autres éléments, tels que des barres de défilement, qui dépendent des propriétés de défilement de ce <xref:System.Windows.Controls.ScrollViewer>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.IScrollInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsDeferredScrollingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDeferredScrollingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDeferredScrollingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDeferredScrollingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDeferredScrollingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le contenu est stationnaire lorsque l'utilisateur fait glisser <see cref="T:System.Windows.Controls.Primitives.Thumb" /> de <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <value>
          <see langword="true" /> si le contenu est stationnaire lorsque l'utilisateur fait glisser <see cref="T:System.Windows.Controls.Primitives.Thumb" /> de <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affichage d’un grand nombre d’éléments peut entraîner des problèmes de performances.  Dans ce cas, il peut être utile d’utiliser le défilement différé.  Pour plus d’informations, consultez [optimisation des performances : contrôles](~/docs/framework/wpf/advanced/optimizing-performance-controls.md).  
  
 Cette propriété peut être utilisée comme une propriété d’instance et une propriété jointe.  
  
   
  
## Examples  
 L’exemple suivant montre un <xref:System.Windows.Controls.ScrollViewer> avec la <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> propriété `true`.  
  
 [!code-xaml[DeferredScrolling#DeferredScrolling](~/samples/snippets/xaml/VS_Snippets_Wpf/DeferredScrolling/xaml/window1.xaml#deferredscrolling)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDeferredScrollingEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDeferredScrollingEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDeferredScrollingEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDeferredScrollingEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDeferredScrollingEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDown">
      <MemberSignature Language="C#" Value="public void LineDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineDown" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineDown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineDown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'une ligne vers le bas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineLeft">
      <MemberSignature Language="C#" Value="public void LineLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineLeft" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineLeft();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'un montant prédéterminé vers la gauche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineRight">
      <MemberSignature Language="C#" Value="public void LineRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineRight" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineRight ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineRight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'un montant prédéterminé vers la droite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineUp">
      <MemberSignature Language="C#" Value="public void LineUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.LineUp" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineUp ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineUp();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'une ligne vers le haut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">
          <see cref="T:System.Windows.Size" /> de limite supérieure à ne pas dépasser.</param>
        <summary>Mesure le contenu d'un élément <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <returns>
          <see cref="T:System.Windows.Size" /> limite, calculée, souhaitée de l'élément <see cref="T:System.Windows.Controls.ScrollViewer" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelée lorsqu'une application ou un processus interne appelle <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />, modèle utilisé pour générer l'arborescence d'éléments visuels du modèle en cours.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ApplyTemplate" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit une implémentation de <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> appropriée pour ce contrôle, au sein de l'infrastructure d'automation [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</summary>
        <returns>Implémentation <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> appropriée pour ce contrôle.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Automation.Peers.AutomationPeer" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Arguments requis pour cet événement.</param>
        <summary>Répond aux entrées au clavier spécifiques et appelle le comportement de défilement associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’entrée au clavier suivantes est reconnue :  
  
-   La touche gauche : fait défiler le contenu une seule ligne à gauche.  
  
-   La touche flèche droite : fait défiler le contenu une ligne vers la droite.  
  
-   La touche haut : fait défiler le contenu d’une ligne vers le haut.  
  
-   La touche bas : fait défiler le contenu vers le bas d’une ligne.  
  
-   PAGE précédente : Fait défiler le contenu vers le haut de la page actuelle.  
  
-   PAGE suivante : Fait défiler le contenu vers le bas de la page actuelle.  
  
-   Page d’accueil : Fait défiler le contenu vers le haut de la première page.  
  
-   FIN : Fait défiler le contenu vers le bas de la dernière page.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected override void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationCompleted (e As ManipulationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationCompleted(System::Windows::Input::ManipulationCompletedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Appelée lorsque l'événement <see cref="E:System.Windows.UIElement.ManipulationCompleted" /> se produit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ScrollViewer.OnManipulationCompleted%2A> méthode définit la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected override void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationDelta (e As ManipulationDeltaEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationDelta(System::Windows::Input::ManipulationDeltaEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Appelée lorsque l'événement <see cref="E:System.Windows.UIElement.ManipulationDelta" /> se produit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ScrollViewer.OnManipulationDelta%2A> méthode définit la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected override void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationInertiaStarting (e As ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationInertiaStarting(System::Windows::Input::ManipulationInertiaStartingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Appelée lorsque l'événement <see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> se produit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ScrollViewer.OnManipulationInertiaStarting%2A> méthode définit la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected override void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationStarting (e As ManipulationStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationStarting(System::Windows::Input::ManipulationStartingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Appelée lorsque l'événement <see cref="E:System.Windows.UIElement.ManipulationStarting" /> se produit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ScrollViewer.OnManipulationInertiaStarting%2A> méthode définit la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Arguments requis qui décrivent cet événement.</param>
        <summary>Répond à un clic du bouton gauche de la souris.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Arguments requis qui décrivent cet événement.</param>
        <summary>Répond à un clic de la roulette de la souris.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnScrollChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnScrollChanged (System.Windows.Controls.ScrollChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnScrollChanged(class System.Windows.Controls.ScrollChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnScrollChanged(System.Windows.Controls.ScrollChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnScrollChanged (e As ScrollChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnScrollChanged(System::Windows::Controls::ScrollChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ScrollChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Controls.ScrollChangedEventArgs" /> contenant des informations sur la modification de l'état de défilement.</param>
        <summary>Méthode appelée quand une modification de l’état de défilement est détectée, par exemple un changement de position de défilement, d’étendue ou de taille de fenêtre d’affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous substituez cette méthode, appelez `base.OnScrollChanged(ScrollChangedEventArgs)` pour vous assurer que cet événement est déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected override void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> qui contient des informations sur le mouvement.</param>
        <summary>Appelé quand une action d'appuyer initiée par un stylet est détectée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisé en interne pour prendre des décisions concernant le panoramique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDown">
      <MemberSignature Language="C#" Value="public void PageDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageDown" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageDown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageDown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'une page vers le bas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageLeft">
      <MemberSignature Language="C#" Value="public void PageLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageLeft" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageLeft();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'une page vers la gauche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageRight">
      <MemberSignature Language="C#" Value="public void PageRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageRight" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageRight ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageRight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'une page vers la droite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageUp">
      <MemberSignature Language="C#" Value="public void PageUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.PageUp" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageUp ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageUp();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> d'une page vers le haut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningDeceleration">
      <MemberSignature Language="C#" Value="public double PanningDeceleration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PanningDeceleration" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />
      <MemberSignature Language="VB.NET" Value="Public Property PanningDeceleration As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double PanningDeceleration { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le taux de ralentissement de <see cref="T:System.Windows.Controls.ScrollViewer" /> en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] par milliseconde au carré lorsqu'il est en inertie.</summary>
        <value>Le taux <see cref="T:System.Windows.Controls.ScrollViewer" /> ralentit dans [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] par milliseconde au carré.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur fait défiler le <xref:System.Windows.Controls.ScrollViewer> à l’aide des fonctions tactiles, l’utilisateur place un doigt sur le <xref:System.Windows.Controls.ScrollViewer>, déplace le doigt sur l’écran sur une courte distance, puis élévations le doigt pendant qu’il se déplace.  La conséquence de cela est que le <xref:System.Windows.Controls.ScrollViewer> continuera à se déplacer une fois que l’utilisateur lève le doigt. Le <xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A> propriété spécifie le taux de ralentissement du défilement après que l’utilisateur a soulevé le doigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningDecelerationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PanningDecelerationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PanningDecelerationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.PanningDecelerationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PanningDecelerationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PanningDecelerationProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.PanningMode PanningMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.PanningMode PanningMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.PanningMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PanningMode As PanningMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::PanningMode PanningMode { System::Windows::Controls::PanningMode get(); void set(System::Windows::Controls::PanningMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.PanningMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la façon dont <see cref="T:System.Windows.Controls.ScrollViewer" /> réagit à la manipulation tactile.</summary>
        <value>Valeur qui spécifie la manière dont <see cref="T:System.Windows.Controls.ScrollViewer" /> réagit à la manipulation tactile.  La valeur par défaut est <see cref="F:System.Windows.Controls.PanningMode.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> propriété spécifie si le <xref:System.Windows.Controls.ScrollViewer> défile horizontalement, verticalement, ou les deux. Le <xref:System.Windows.Controls.ScrollViewer> défile lorsqu’un utilisateur fait glisser un doigt sur le contrôle sur un périphérique tactile qui prend en charge l’interface tactile Windows.  
  
 <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> peut être défini directement sur un <xref:System.Windows.Controls.ScrollViewer> ou utilisé comme une propriété jointe.  Lorsqu’un contrôle contient un <xref:System.Windows.Controls.ScrollViewer> dans son <xref:System.Windows.Controls.ControlTemplate>, utilisez <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> comme une propriété jointe pour spécifier le comportement de la <xref:System.Windows.Controls.ScrollViewer> dans le <xref:System.Windows.Controls.ControlTemplate>. Lorsque vous utilisez un <xref:System.Windows.Controls.ScrollViewer> en dehors d’un <xref:System.Windows.Controls.ControlTemplate>, définissez <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> directement sur le <xref:System.Windows.Controls.ScrollViewer>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.ScrollViewer> et lui ajoute plusieurs éléments.  Dans cet exemple, lorsque la taille de la fenêtre change, la taille de `textblock1` change également.  Lorsque le <xref:System.Windows.Controls.TextBlock> est trop petite pour afficher tout le contenu, le <xref:System.Windows.Controls.ScrollViewer> devient permettant le défilement. L’exemple définit <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> à <xref:System.Windows.Controls.PanningMode.Both> afin que l’utilisateur peut faire défiler vers le <xref:System.Windows.Controls.ScrollViewer> horizontalement et verticalement en utilisant un doigt.  
  
 [!code-xaml[ScrollViewerPanning#PanningModeDirect](~/samples/snippets/csharp/VS_Snippets_Wpf/scrollviewerpanning/CS/mainwindow.xaml#panningmodedirect)]   
  
 L’exemple suivant crée un <xref:System.Windows.Controls.TextBox> et utilise <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> comme une propriété jointe. Par défaut le <xref:System.Windows.Controls.ScrollViewer> dans les <xref:System.Windows.Controls.ControlTemplate> d’un <xref:System.Windows.Controls.TextBox> a son <xref:System.Windows.Controls.PanningMode> à <xref:System.Windows.Controls.PanningMode.VerticalFirst>.  Il s’agit afin que lorsque l’utilisateur déplace horizontalement un doigt avant de le déplacer verticalement, l’utilisateur met en surbrillance le texte.  L’exemple définit <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A> à <xref:System.Windows.Controls.PanningMode.VerticalOnly> afin que l’utilisateur ne peut pas sélectionner le texte à l’aide d’un doigt.  Notez que la définition <xref:System.Windows.Controls.PanningMode> à <xref:System.Windows.Controls.PanningMode.Both> empêche également l’utilisateur à partir de la sélection de texte.  L’exemple définit le <xref:System.Windows.TextWrapping> propriété <xref:System.Windows.TextWrapping.Wrap>, n’est pas nécessaire de défilement horizontal.  
  
 [!code-xaml[ScrollViewerPanning#PanningModeAttached](~/samples/snippets/csharp/VS_Snippets_Wpf/scrollviewerpanning/CS/mainwindow.xaml#panningmodeattached)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PanningModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PanningModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.PanningModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PanningModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PanningModeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningRatio">
      <MemberSignature Language="C#" Value="public double PanningRatio { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PanningRatio" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.PanningRatio" />
      <MemberSignature Language="VB.NET" Value="Public Property PanningRatio As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double PanningRatio { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le rapport de décalage de défilement pour traduire le décalage de manipulation.</summary>
        <value>Rapport de décalage de défilement à traduire en décalage de manipulation. La valeur par défaut est 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur fait glisser un doigt sur un objet, il est considéré comme une manipulation de translation.  Le <xref:System.Windows.Controls.ScrollViewer> utilise cette manipulation pour faire défiler. Le <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A> propriété spécifie de combien le <xref:System.Windows.Controls.ScrollViewer> fait défiler pour chaque unité de traduction.  Par exemple, si <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A> est 2, le <xref:System.Windows.Controls.ScrollViewer> défilera 2 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] pour chaque [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] de la translation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PanningRatioProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PanningRatioProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PanningRatioProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.PanningRatioProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PanningRatioProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PanningRatioProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollableHeight">
      <MemberSignature Language="C#" Value="public double ScrollableHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ScrollableHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ScrollableHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollableHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ScrollableHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui représente la taille verticale de l’élément de contenu pouvant défiler.</summary>
        <value>
          <see cref="T:System.Double" /> qui représente la taille verticale de l'élément de contenu pouvant défiler. Cette propriété n’a aucune valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `true`, les valeurs de la <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>, et <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> propriétés sont un nombres d’éléments. Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `false`, les valeurs de ces propriétés sont les Pixels indépendants du périphérique.  
  
<a name="dependencyPropertyInfo_ScrollableHeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ScrollableHeightProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollableHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ScrollableHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ScrollableHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ScrollableHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollableHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ScrollableHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ScrollableHeight" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ScrollableHeight" />
      </Docs>
    </Member>
    <Member MemberName="ScrollableWidth">
      <MemberSignature Language="C#" Value="public double ScrollableWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ScrollableWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ScrollableWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollableWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ScrollableWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui représente la taille horizontale de l'élément de contenu pouvant défiler.</summary>
        <value>
          <see cref="T:System.Double" /> qui représente la taille horizontale de l'élément de contenu pouvant défiler. Cette propriété n’a aucune valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ScrollableWidth"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ScrollableWidthProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollableWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ScrollableWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ScrollableWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ScrollableWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollableWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ScrollableWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ScrollableWidth" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ScrollableWidth" />
      </Docs>
    </Member>
    <Member MemberName="ScrollChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ScrollChangedEventHandler ScrollChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ScrollChangedEventHandler ScrollChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.ScrollViewer.ScrollChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ScrollChanged As ScrollChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ScrollChangedEventHandler ^ ScrollChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque des modifications de la position de défilement, de l'étendue ou de la taille de la fenêtre d'affichage sont détectées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_ScrollChanged"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ScrollChangedEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Controls.ScrollChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ScrollChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.Controls.ScrollViewer.ScrollChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Controls.ScrollViewer.ScrollChanged" />
      </Docs>
    </Member>
    <Member MemberName="ScrollInfo">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Controls.Primitives.IScrollInfo ScrollInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.IScrollInfo ScrollInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ScrollInfo" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property ScrollInfo As IScrollInfo" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Controls::Primitives::IScrollInfo ^ ScrollInfo { System::Windows::Controls::Primitives::IScrollInfo ^ get(); void set(System::Windows::Controls::Primitives::IScrollInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.IScrollInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'élément qui implémente l'interface <see cref="T:System.Windows.Controls.Primitives.IScrollInfo" /> et fournit des valeurs pour les propriétés de défilement de ce <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <value>Élément qui contrôle les propriétés de défilement, telles que l’étendue, le décalage ou la taille de fenêtre d’affichage. Cette propriété n’a aucune valeur par défaut.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottom">
      <MemberSignature Language="C#" Value="public void ScrollToBottom ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToBottom() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToBottom" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToBottom ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToBottom();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler verticalement le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> jusqu'à la fin.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEnd">
      <MemberSignature Language="C#" Value="public void ScrollToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler verticalement le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> jusqu'à la fin.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fait défiler pour les deux points de terminaison verticales et horizontales du contenu.  
  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHome">
      <MemberSignature Language="C#" Value="public void ScrollToHome ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHome() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToHome" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToHome ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToHome();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler verticalement le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> jusqu'au début.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToHorizontalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHorizontalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToHorizontalOffset(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToHorizontalOffset (offset As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToHorizontalOffset(double offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">Position à laquelle défile le contenu.</param>
        <summary>Fait défiler le contenu du <see cref="T:System.Windows.Controls.ScrollViewer" /> à la position de décalage horizontale spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEnd">
      <MemberSignature Language="C#" Value="public void ScrollToLeftEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToLeftEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToLeftEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToLeftEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToLeftEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler horizontalement le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> jusqu'au début.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEnd">
      <MemberSignature Language="C#" Value="public void ScrollToRightEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToRightEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToRightEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToRightEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToRightEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler horizontalement le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> jusqu'à la fin.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTop">
      <MemberSignature Language="C#" Value="public void ScrollToTop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToTop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToTop" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToTop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToTop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait défiler verticalement le contenu <see cref="T:System.Windows.Controls.ScrollViewer" /> jusqu'au début.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’induit pas de comportement de défilement si <xref:System.Windows.Controls.ScrollViewer.ScrollInfo%2A> est `null`.  
  
 Défilement logique est utilisé pour accéder à l’élément suivant dans l’arborescence logique. Cela diffère du défilement physique, qui fait défiler le contenu par un incrément physique défini dans une direction donnée. Si vous avez besoin de défilement physique au lieu de défilement logique, encapsulez l’hôte <xref:System.Windows.Controls.Panel> élément dans une <xref:System.Windows.Controls.ScrollViewer> et définir son <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToVerticalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToVerticalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.ScrollToVerticalOffset(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToVerticalOffset (offset As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToVerticalOffset(double offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">Position à laquelle défile le contenu.</param>
        <summary>Fait défiler le contenu du <see cref="T:System.Windows.Controls.ScrollViewer" /> à la position de décalage verticale spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCanContentScroll">
      <MemberSignature Language="C#" Value="public static void SetCanContentScroll (System.Windows.DependencyObject element, bool canContentScroll);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCanContentScroll(class System.Windows.DependencyObject element, bool canContentScroll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetCanContentScroll(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCanContentScroll (element As DependencyObject, canContentScroll As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCanContentScroll(System::Windows::DependencyObject ^ element, bool canContentScroll);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="canContentScroll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Élément au niveau duquel la valeur de propriété doit être définie.</param>
        <param name="canContentScroll">Valeur de propriété à définir.</param>
        <summary>Définit la valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.CanContentScroll" /> en lui affectant un élément donné.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static void SetHorizontalScrollBarVisibility (System.Windows.DependencyObject element, System.Windows.Controls.ScrollBarVisibility horizontalScrollBarVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetHorizontalScrollBarVisibility(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.ScrollBarVisibility horizontalScrollBarVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetHorizontalScrollBarVisibility(System.Windows.DependencyObject,System.Windows.Controls.ScrollBarVisibility)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetHorizontalScrollBarVisibility (element As DependencyObject, horizontalScrollBarVisibility As ScrollBarVisibility)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetHorizontalScrollBarVisibility(System::Windows::DependencyObject ^ element, System::Windows::Controls::ScrollBarVisibility horizontalScrollBarVisibility);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="horizontalScrollBarVisibility" Type="System.Windows.Controls.ScrollBarVisibility" />
      </Parameters>
      <Docs>
        <param name="element">Élément au niveau duquel la valeur de propriété doit être définie.</param>
        <param name="horizontalScrollBarVisibility">Valeur de propriété à définir.</param>
        <summary>Définit la valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.HorizontalScrollBarVisibility" /> en lui affectant un élément donné.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsDeferredScrollingEnabled">
      <MemberSignature Language="C#" Value="public static void SetIsDeferredScrollingEnabled (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsDeferredScrollingEnabled(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetIsDeferredScrollingEnabled(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsDeferredScrollingEnabled (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsDeferredScrollingEnabled(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Objet sur lequel définir la propriété <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" />.</param>
        <param name="value">
          <see langword="true" /> pour que le contenu reste stationnaire lorsque l'utilisateur fait glisser <see cref="T:System.Windows.Controls.Primitives.Thumb" /> de <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ; sinon, <see langword="false" />.</param>
        <summary>Définit la propriété <see cref="P:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled" /> pour l'objet spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affichage d’un grand nombre d’éléments peut entraîner des problèmes de performances.  Dans ce cas, il peut être utile d’utiliser le défilement différé.  Pour plus d’informations, consultez [optimisation des performances : contrôles](~/docs/framework/wpf/advanced/optimizing-performance-controls.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPanningDeceleration">
      <MemberSignature Language="C#" Value="public static void SetPanningDeceleration (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetPanningDeceleration(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetPanningDeceleration(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetPanningDeceleration (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetPanningDeceleration(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Objet sur lequel définir la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" />.</param>
        <param name="value">Le taux <see cref="T:System.Windows.Controls.ScrollViewer" /> ralentit dans [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)] par milliseconde au carré.</param>
        <summary>Définit la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningDeceleration" /> pour l'objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPanningMode">
      <MemberSignature Language="C#" Value="public static void SetPanningMode (System.Windows.DependencyObject element, System.Windows.Controls.PanningMode panningMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetPanningMode(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.PanningMode panningMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetPanningMode(System.Windows.DependencyObject,System.Windows.Controls.PanningMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetPanningMode(System::Windows::DependencyObject ^ element, System::Windows::Controls::PanningMode panningMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="panningMode" Type="System.Windows.Controls.PanningMode" />
      </Parameters>
      <Docs>
        <param name="element">Objet sur lequel définir la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" />.</param>
        <param name="panningMode">Valeur qui spécifie la manière dont <see cref="T:System.Windows.Controls.ScrollViewer" /> réagit à la manipulation tactile.</param>
        <summary>Définit la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningMode" /> pour l'objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPanningRatio">
      <MemberSignature Language="C#" Value="public static void SetPanningRatio (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetPanningRatio(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetPanningRatio(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetPanningRatio (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetPanningRatio(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Objet sur lequel définir la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" />.</param>
        <param name="value">Rapport de décalage de défilement à traduire en décalage de manipulation.</param>
        <summary>Définit la propriété <see cref="P:System.Windows.Controls.ScrollViewer.PanningRatio" /> pour l'objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetVerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public static void SetVerticalScrollBarVisibility (System.Windows.DependencyObject element, System.Windows.Controls.ScrollBarVisibility verticalScrollBarVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetVerticalScrollBarVisibility(class System.Windows.DependencyObject element, valuetype System.Windows.Controls.ScrollBarVisibility verticalScrollBarVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ScrollViewer.SetVerticalScrollBarVisibility(System.Windows.DependencyObject,System.Windows.Controls.ScrollBarVisibility)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetVerticalScrollBarVisibility (element As DependencyObject, verticalScrollBarVisibility As ScrollBarVisibility)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetVerticalScrollBarVisibility(System::Windows::DependencyObject ^ element, System::Windows::Controls::ScrollBarVisibility verticalScrollBarVisibility);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="verticalScrollBarVisibility" Type="System.Windows.Controls.ScrollBarVisibility" />
      </Parameters>
      <Docs>
        <param name="element">Élément au niveau duquel la valeur de propriété doit être définie.</param>
        <param name="verticalScrollBarVisibility">Valeur de propriété à définir.</param>
        <summary>Définit la valeur de la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" /> en lui affectant un élément donné.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffset">
      <MemberSignature Language="C#" Value="public double VerticalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.VerticalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VerticalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalOffset { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui contient le décalage vertical du contenu parcouru.</summary>
        <value>Un <see cref="T:System.Double" /> qui représente le décalage vertical du contenu parcouru. La valeur par défaut est 0.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nombre positif <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> valeur correspond au contenu décalé vers le haut.  
  
 Les valeurs valides sont comprises entre zéro et la <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A> moins la <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>.  
  
 Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `true`, les valeurs de la <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>, et <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> propriétés sont un nombres d’éléments. Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `false`, les valeurs de ces propriétés sont les Pixels indépendants du périphérique.  
  
 À compter de .NET Framework version 3.5 SP1, lorsque <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A> est `true`, <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> continue d’être modifié en tant que l’utilisateur fait glisser le <xref:System.Windows.Controls.Primitives.Thumb>, mais ne modifie pas l’affichage du contenu jusqu'à ce que le <xref:System.Windows.Controls.Primitives.Thumb> est libérée.  Dans ce cas, <xref:System.Windows.Controls.ScrollViewer.ContentVerticalOffset%2A> représente le décalage de contenu visible et <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> représente le décalage de contenu basé sur le <xref:System.Windows.Controls.Primitives.Thumb> position.  
  
<a name="dependencyPropertyInfo_VerticalOffset"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.VerticalOffsetProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.VerticalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.VerticalOffset" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.VerticalOffset" />
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalScrollBarVisibility As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ScrollBarVisibility VerticalScrollBarVisibility { System::Windows::Controls::ScrollBarVisibility get(); void set(System::Windows::Controls::ScrollBarVisibility value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale doit être affichée.</summary>
        <value>Valeur <see cref="T:System.Windows.Controls.ScrollBarVisibility" /> qui indique si une <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> verticale doit être affichée. La valeur par défaut est <see cref="F:System.Windows.Controls.ScrollBarVisibility.Visible" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_VerticalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalScrollBarVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.VerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ViewportHeight">
      <MemberSignature Language="C#" Value="public double ViewportHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ViewportHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewportHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui contient la taille verticale de la fenêtre d’affichage du contenu.</summary>
        <value>Un <see cref="T:System.Double" /> qui représente la taille verticale de la fenêtre d’affichage du contenu. Cette propriété n’a aucune valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fenêtre d’affichage est la zone visible du contenu.  
  
 <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A> est uniquement une propriété de sortie ; elle peut être définie efficacement en spécifiant la <xref:System.Windows.FrameworkElement.Height%2A> de l’élément de contenu.  
  
 Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `true`, les valeurs de la <xref:System.Windows.Controls.ScrollViewer.ExtentHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ScrollableHeight%2A>, <xref:System.Windows.Controls.ScrollViewer.ViewportHeight%2A>, et <xref:System.Windows.Controls.ScrollViewer.VerticalOffset%2A> propriétés sont un nombres d’éléments. Si <xref:System.Windows.Controls.ScrollViewer.CanContentScroll%2A> est `false`, les valeurs de ces propriétés sont les Pixels indépendants du périphérique.  
  
<a name="dependencyPropertyInfo_ViewportHeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ViewportHeightProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ViewportHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ViewportHeight" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ViewportHeight" />
      </Docs>
    </Member>
    <Member MemberName="ViewportWidth">
      <MemberSignature Language="C#" Value="public double ViewportWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ScrollViewer.ViewportWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewportWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui contient la taille horizontale de la fenêtre d’affichage du contenu.</summary>
        <value>Un <see cref="T:System.Double" /> qui représente la taille horizontale de la fenêtre d’affichage du contenu. La valeur par défaut est 0.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fenêtre d’affichage est la zone visible du contenu.  
  
<a name="dependencyPropertyInfo_ViewportWidth"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ScrollViewer.ViewportWidthProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ScrollViewer.ViewportWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.ScrollViewer.ViewportWidth" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ScrollViewer.ViewportWidth" />
      </Docs>
    </Member>
  </Members>
</Type>