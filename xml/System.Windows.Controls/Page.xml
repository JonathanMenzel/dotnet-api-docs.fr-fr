<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d2b2f547328a5918908d2949cdc123c74c5786fc" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694917" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsule une page de contenu dans laquelle il est possible de naviguer et qui peut être hébergée par Windows Internet Explorer, <see cref="T:System.Windows.Navigation.NavigationWindow" /> et <see cref="T:System.Windows.Controls.Frame" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> Encapsule une page de contenu qui peut être parcouru, a les membres clés suivants :  
  
-   **Gestion de la durée de vie**: <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
-   **Navigation**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Apparence**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>, <xref:System.Windows.Controls.Page.FontSize%2A>, <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>, <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   **Héberger l’apparence de la fenêtre**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Une page peut être définie à l’aide de balisage, balisage et code-behind ou le code. Une page est le meilleur moyen pour la navigation, le contenu du package pour les raisons suivantes :  
  
-   Il est facile de définir, réutiliser et gérer.  
  
-   Elle peut accéder et utiliser le <xref:System.Windows.Navigation.NavigationService> qui a navigué vers elle.  
  
-   Il peut modifier le titre, la largeur, la hauteur et la navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de sa fenêtre hôte (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Elle est prise en charge de concepteur [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)].  
  
 Une page peut être hébergée dans <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, ou à partir d’un navigateur. Pour être hébergé, une page peut être :  
  
-   L’enfant direct d’un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, ou <xref:System.Windows.Controls.Frame> élément [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Instanciée et définie comme la valeur de la `Content` propriété du <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, et <xref:System.Windows.Controls.Frame>.  
  
-   Définir en tant que le [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] source de la `Source` propriété du <xref:System.Windows.Navigation.NavigationWindow> ou <xref:System.Windows.Controls.Frame>.  
  
-   Définir en tant que le <xref:System.Windows.Application.StartupUri%2A> dans une application autonome.  
  
-   Définir en tant que le <xref:System.Windows.Application.StartupUri%2A> dans un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
 En règle générale, une application possède deux ou plusieurs pages, il est peuvent de naviguer entre à l’aide des mécanismes suivants :  
  
-   Façon déclarative à l’aide de <xref:System.Windows.Documents.Hyperlink>.  
  
-   Par programme en utilisant <xref:System.Windows.Navigation.NavigationService>.  
  
-   Visuellement à l’aide de la barre de navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de l’hôte, y compris [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, et <xref:System.Windows.Controls.Frame>.  
  
 Pour la navigation structurée à l’aide de fonctions de page (<xref:System.Windows.Navigation.PageFunction%601>), consultez [Structured Navigation Overview](~/docs/framework/wpf/app-development/structured-navigation-overview.md) et [vue d’ensemble des Topologies de Navigation](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut.  Si une propriété est définie par un style par défaut, la propriété peut changer sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’application est en cours d’exécution.  Pour plus d’informations, consultez [par défaut des thèmes WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 L’exemple suivant montre comment une page standard est définie à l’aide de balisage uniquement :  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 L’exemple suivant montre comment une page standard est définie en utilisant uniquement un code :  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 L’exemple suivant montre comment une page standard est définie à l’aide d’une combinaison de balisage et code-behind.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Windows.Controls.Page> n’est pas gardée active (consultez <xref:System.Windows.Controls.Page.KeepAlive%2A>), elle doit implémenter un constructeur par défaut pour autoriser [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] pour créer une nouvelle instance, lors de la navigation arrière ou avant dans l’historique de navigation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Taille à utiliser pour réorganiser les éléments enfants.</param>
        <summary>Réorganise le contenu (éléments enfants) de la <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>
          <see cref="T:System.Windows.Size" /> qui représente la taille réorganisée de la page.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'arrière-plan d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Le <see cref="T:System.Windows.Media.Brush" /> que la <see cref="T:System.Windows.Controls.Page" /> utilise pour peindre son arrière-plan.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.Background" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contenu d'un <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Objet qui contient le contenu d'une <see cref="T:System.Windows.Controls.Page" />. La valeur par défaut est <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Controls.Page> peut avoir qu’un seul élément enfant. Tous les autres éléments sur un <xref:System.Windows.Controls.Page> doivent être descendants de cet élément. En règle générale, le contenu d’un <xref:System.Windows.Controls.Page> héberge un élément de disposition : tels que <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, et <xref:System.Windows.Controls.DockPanel>— qui héberge le contenu de la <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.ContentProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de la famille de polices spécifiée.</summary>
        <value>
          <see cref="T:System.Windows.Media.FontFamily" /> qui est la famille de polices pour le contenu d'une <see cref="T:System.Windows.Controls.Page" />. La valeur par défaut est <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.FontFamily" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateur de la propriété de dépendance <xref:System.Windows.Controls.Page.FontFamily%2A>.  
  
   
  
## Examples  
 [Vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la police.</summary>
        <value>Taille de police pour le contenu d'une <see cref="T:System.Windows.Controls.Page" />. La valeur par défaut est <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de police doit être un nombre positif dans la plage de la <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.FontSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateur de la propriété de dépendance <xref:System.Windows.Controls.Page.FontSize%2A>.  
  
   
  
## Examples  
 [Vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le premier plan d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Le <see cref="T:System.Windows.Media.Brush" /> que la <see cref="T:System.Windows.Controls.Page" /> utilise pour peindre son premier plan. La valeur par défaut est <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.Foreground" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateur de la propriété de dépendance <xref:System.Windows.Controls.Page.Foreground%2A>.  
  
   
  
## Examples  
 [Vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'instance <see cref="T:System.Windows.Controls.Page" /> est conservée dans l'historique de navigation.</summary>
        <value>
          <see langword="true" /> si l'instance de la <see cref="T:System.Windows.Controls.Page" /> est conservée dans l'historique de navigation ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une page est une première navigation, une nouvelle instance de la <xref:System.Windows.Controls.Page> classe est créée. Lorsqu’une page est accédée de (précédent ou suivant), une entrée de la page est ajoutée à l’historique de navigation. Par défaut, l’entrée ne fait pas référence à l’objet de la page. Au lieu de cela, l’entrée contient un pack URI (URI) de la page. Lorsque l’entrée de la page est accédée à l’aide de l’historique de navigation, l’URI à en-tête pack est utilisé pour créer une nouvelle instance de la page. Ce comportement est la valeur par défaut, afin d’éviter l’utilisation de mémoire excessive : en conservant les instances de la page peut consommer rapidement la mémoire, en particulier celles ayant un contenu non négligeable. Ce problème est complété par le fait qu’il n’existe aucune limite au nombre d’entrées qui peuvent être stockées à l’arrière et piles vers l’avant de l’historique de navigation. En revanche, le stockage pour les pages d’un URI à en-tête pack n’a pratiquement aucun impact sur la consommation de mémoire.  
  
 L’effet secondaire principal de la création de nouvelles instances d’une page est qu’état de la page n’est pas mémorisée à partir d’une instance d’une page à un autre. Dans ce cas, Windows Presentation Foundation offre plusieurs techniques pour mémoriser l’état.  
  
 Pour garder une page active, vous définissez la <xref:System.Windows.Controls.Page.KeepAlive%2A> propriété `true` (la valeur par défaut est `false`).  
  
> [!NOTE]
>  Les pages qui sont instanciés et accédés à l’aide du code uniquement (par exemple, l’appel <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), sont automatiquement conservées.  
  
 Vous devez éviter de définir <xref:System.Windows.Controls.Page.KeepAlive%2A> à `true` sauf si vous avez besoin :  
  
-   Lorsqu’une page a beaucoup de contenu, il peut prendre beaucoup de temps à instancier. Si la page n’est pas persistante, et souvent de l’accès à la page, le coût d’instancier constamment la page peut avoir un impact négatif sur l’expérience utilisateur. Toutefois, à partir d’un point de vue des performances, vous devez s’appuient sur les paramètres par défaut et profiler les performances de votre application ; Si les tests identifient des pages avec des temps de chargement qui se trouvent au-dessous de la plage requise pour votre application, la configuration des pages pour être gardées actives peut être une façon de résoudre le problème.  
  
> [!NOTE]
>  Entrées pour les pages qui sont gardées actives ne sont pas conservées dans l’historique de navigation d’un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] si un utilisateur s’éloigne d’et vers le [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]. Uniquement les entrées de journal pour les pages qui ne sont pas maintenues sont conservées dans l’historique de navigation.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
> [!NOTE]
>  Le type de métadonnées sur cette propriété de dépendance est <xref:System.Windows.PropertyMetadata>, et non <xref:System.Windows.FrameworkPropertyMetadata>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pour conserver une instance de la <xref:System.Windows.Controls.Page> classe sur plusieurs navigations.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.KeepAlive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateur de la propriété de dépendance <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
   
  
## Examples  
 [Vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne un énumérateur pour les éléments enfants logiques d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> pour les éléments enfants logiques d'une <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">La zone disponible que la fenêtre peut donner à ses enfants.</param>
        <summary>Mesure les éléments enfants de la <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Une <see cref="T:System.Windows.Size" /> qui est la grandeur réelle de la fenêtre. La méthode peut retourner une plus grande valeur, auquel cas le parent peut devoir ajouter des barres de défilement.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le service de navigation que l'hôte de la page utilise pour gérer la navigation.</summary>
        <value>L'objet <see cref="T:System.Windows.Navigation.NavigationService" /> que l'hôte de la page utilise pour gérer la navigation, ou <see langword="null" /> si l'hôte ne prend pas en charge la navigation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les pages peuvent être hébergées par plusieurs types d’hôtes, y compris <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>et d’un navigateur.  
  
 Pages doivent souvent d’intégrer la navigation de leur hôte pour prendre en charge la navigation dans la page. Toutefois, car une page ne peut pas savoir ce que son ordinateur hôte sera en cours d’exécution, il ne peut pas s’intégrer directement avec les membres de navigation de l’ordinateur hôte pour ce faire.  
  
 Au lieu de cela, elle peut essayer d’utiliser un service de navigation, qui est un service qui prend en charge la navigation de style navigateur et est encapsulé par le <xref:System.Windows.Navigation.NavigationService> classe. Vous ne pouvez pas créer votre propre <xref:System.Windows.Navigation.NavigationService> d’instance, cependant. Au lieu de cela, héberger des types tels que <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, ou un navigateur créent leur propre <xref:System.Windows.Navigation.NavigationService> instance auxquels vous pouvez accéder à partir de la <xref:System.Windows.Controls.Page.NavigationService%2A> propriété.  
  
 Le service de navigation qui est retourné à partir de la <xref:System.Windows.Controls.Page.NavigationService%2A> propriété est l’instance de la <xref:System.Windows.Navigation.NavigationService> classe qui est géré par le premier navigateur en haut de l’arborescence d’éléments visuels. Si un n’est trouvé, `null` est retourné, indiquant qu’un hôte de page ne prend pas en charge la navigation.  
  
> [!NOTE]
>  La <xref:System.Windows.Window> classe ne prend pas en charge la navigation et ne fournit pas un service de navigation.  
  
   
  
## Examples  
 L’exemple suivant montre comment une page peut vérifier si un service de navigation est disponible et, dans ce cas, l’utiliser pour revenir à la page précédente.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Ancien modèle.</param>
        <param name="newTemplate">Nouveau modèle.</param>
        <summary>Appelée lorsque le modèle pour une <see cref="T:System.Windows.Controls.Page" /> est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Parent précédent. De valeur <see langword="null" /> si le <see cref="T:System.Windows.DependencyObject" /> n'a pas de parent précédent.</param>
        <summary>Appelée lorsque le parent de la <see cref="T:System.Windows.Controls.Page" /> est modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le nouveau parent n'est ni une <see cref="T:System.Windows.Window" /> ni un <see cref="T:System.Windows.Controls.Frame" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet aux classes dérivées de déterminer le comportement de sérialisation de la propriété <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />.</summary>
        <returns>
          <see langword="true" /> si le contenu devrait être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet aux classes dérivées de déterminer le comportement de sérialisation de la propriété <see cref="P:System.Windows.Controls.Page.Title" />.</summary>
        <returns>
          <see langword="true" /> si le contenu devrait être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet aux classes dérivées de déterminer le comportement de sérialisation de la propriété <see cref="P:System.Windows.Controls.Page.WindowHeight" />.</summary>
        <returns>
          <see langword="true" /> si le contenu devrait être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet aux classes dérivées de déterminer le comportement de sérialisation de la propriété <see cref="P:System.Windows.Controls.Page.WindowTitle" />.</summary>
        <returns>
          <see langword="true" /> si le contenu devrait être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet aux classes dérivées de déterminer le comportement de sérialisation de la propriété <see cref="P:System.Windows.Controls.Page.WindowWidth" />.</summary>
        <returns>
          <see langword="true" /> si le contenu devrait être sérialisé ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l’[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de navigation d’une <see cref="T:System.Windows.Navigation.NavigationWindow" /> dans [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] est visible.</summary>
        <value>
          <see langword="true" /> si l'[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de navigation d'une <see cref="T:System.Windows.Navigation.NavigationWindow" /> hôte est visible ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow> Affiche la navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] par défaut pour permettre de style navigateur vers l’avant et vers l’arrière la navigation. Si une page est définie comme le <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> s’ouvre automatiquement une <xref:System.Windows.Navigation.NavigationWindow> pour héberger la page. Si la page ne souhaite pas utiliser la valeur par défaut <xref:System.Windows.Navigation.NavigationWindow> navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], elle peut définir <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> à `false`.  
  
> [!NOTE]
>  Étant donné que [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ne s’intègrent pas le volet de navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] pour [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], il fournit son propre navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], qui peuvent être affiché ou masqué en définissant <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] s’intègre avec les [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], le paramètre donc <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> sur les pages de [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] n’a aucun effet.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] pour masquer le volet de navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] d’un <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> est inspectée sur une instance <see cref="T:System.Windows.Controls.Page" /> qui n'est pas hébergée par une <see cref="T:System.Windows.Window" />, <see cref="T:System.Windows.Navigation.NavigationWindow" />ou un navigateur.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet enfant à ajouter.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Controls.Page> est castée en interface <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Texte à ajouter à l’objet.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Controls.Page> est castée en interface <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le modèle de contrôle d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>
          <see cref="T:System.Windows.Controls.ControlTemplate" /> d'une <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *resourceExtension*  
 Une extension de balisage qui identifie comment référencer la ressource de modèle, soit `StaticResource` ou `DynamicResource`. Consultez [ressources XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Clé qui identifie le sélecteur de modèle demandé. La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Syntaxe d’élément de propriété est techniquement possible, mais non recommandée. Pour plus d’informations, consultez [Inline Styles et modèles](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.Template" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le titre de la <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Titre de la <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Windows.Controls.Page.Title%2A> propriété n’est pas affichée par <xref:System.Windows.Controls.Page>, ni ne s’affiche dans la barre de titre de la fenêtre qui héberge un <xref:System.Windows.Controls.Page>. Au lieu de cela, vous définissez <xref:System.Windows.Controls.Page.WindowTitle%2A> pour modifier le titre d’une fenêtre hôte.  
  
 <xref:System.Windows.Controls.Page.Title%2A> peut également être utilisé pour générer le nom de l’entrée de l’historique de navigation pour un élément de contenu navigué. Les éléments de données suivants sont utilisés pour construire automatiquement un nom de saisie de l’historique de navigation, par ordre de priorité :  
  
-   Le fichier joint <xref:System.Windows.Navigation.JournalEntry.Name%2A> attribut.  
  
-   La propriété <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   Le <xref:System.Windows.Controls.Page.WindowTitle%2A> propriété et le [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] pour la page actuelle  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] pour la page active.  
  
 Si vous avez associé un <xref:System.Windows.Navigation.CustomContentState> objet avec un élément de contenu dans l’historique de navigation, vous pouvez spécifier le nom qui apparaît dans l’entrée de l’historique de navigation en substituant <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Page.TitleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Page.Title" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateur de la propriété de dépendance <xref:System.Windows.Controls.Page.Title%2A>.  
  
   
  
## Examples  
 [Vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la hauteur de la <see cref="T:System.Windows.Window" /> ou <see cref="T:System.Windows.Navigation.NavigationWindow" /> hôte d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>La hauteur d'une fenêtre qui héberge directement une <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A> est appliqué uniquement lorsqu’un <xref:System.Windows.Controls.Page> est hébergé directement par une fenêtre, qui inclut :  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Si un <xref:System.Windows.Controls.Page> est hébergé par un <xref:System.Windows.Controls.Frame>, le paramètre <xref:System.Windows.Controls.Page.WindowHeight%2A> n’a aucun effet, mais vous pouvez obtenir toujours la valeur de <xref:System.Windows.Controls.Page.WindowHeight%2A>.  
  
 A <xref:System.Windows.Controls.Page> dans un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] peuvent uniquement utiliser <xref:System.Windows.Controls.Page.WindowHeight%2A> pour modifier la hauteur de [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; la hauteur ne peut pas être modifiée en définissant <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, ou <xref:System.Windows.FrameworkElement.MaxHeight%2A>.  
  
 La hauteur minimale de la [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] fenêtre est 150 pixels. Pour les pages hébergées par un navigateur, cela signifie que la valeur de <xref:System.Windows.Controls.Page.WindowHeight%2A> ne peut pas être appliquée si cela provoquerait la hauteur totale de la [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] fenêtre moins de 150 pixels.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la hauteur d’une fenêtre à partir d’une page.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le titre de la <see cref="T:System.Windows.Window" /> ou de la <see cref="T:System.Windows.Navigation.NavigationWindow" /> hôte d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Titre d'une fenêtre qui héberge directement la <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le titre d’une fenêtre qui héberge une page, y compris <xref:System.Windows.Navigation.NavigationWindow> et [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], est le nom du fichier qui est actuellement hébergé (avec une extension .xaml si la page est libre [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], ou une extension .xbap si la page fait partie d’un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Une page peut modifier la valeur par défaut en définissant son <xref:System.Windows.Controls.Page.WindowTitle%2A> propriété.  
  
 Une fois qu’une page définit le titre d’une fenêtre de cette façon, le titre de la fenêtre ne change pas jusqu'à ce qu’une autre page définit <xref:System.Windows.Controls.Page.WindowTitle%2A> avec une valeur différente.  
  
> [!NOTE]
>  Le <xref:System.Windows.Controls.Page> doit être la partie supérieure du contenu dans une fenêtre pour <xref:System.Windows.Controls.Page.WindowTitle%2A> ait un effet ; si un <xref:System.Windows.Controls.Page> est hébergé dans un <xref:System.Windows.Controls.Frame>, par exemple, si <xref:System.Windows.Controls.Page.WindowTitle%2A> ne modifie pas le titre de la fenêtre hôte.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A> peut également être utilisé pour générer le nom de l’entrée de l’historique de navigation pour un élément de contenu navigué. Les éléments de données suivants sont utilisés pour construire automatiquement un nom de saisie de l’historique de navigation, par ordre de priorité :  
  
-   Le fichier joint <xref:System.Windows.Navigation.JournalEntry.Name%2A> attribut.  
  
-   La propriété <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   Le <xref:System.Windows.Controls.Page.WindowTitle%2A> propriété et le [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] pour la page actuelle  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] pour la page active.  
  
 Si vous avez associé un <xref:System.Windows.Navigation.CustomContentState> objet avec un élément de contenu dans l’historique de navigation, vous pouvez spécifier la valeur de nom d’un élément de l’historique de navigation en substituant <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le titre d’une fenêtre à partir d’une page.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la largeur de la <see cref="T:System.Windows.Window" /> ou de la <see cref="T:System.Windows.Navigation.NavigationWindow" /> hôte d'une <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Largeur d'une fenêtre qui héberge directement une <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A> est appliqué uniquement lorsqu’un <xref:System.Windows.Controls.Page> est hébergé directement par une fenêtre, qui inclut :  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Si un <xref:System.Windows.Controls.Page> est hébergé par un <xref:System.Windows.Controls.Frame>, le paramètre <xref:System.Windows.Controls.Page.WindowWidth%2A> n’a aucun effet, mais vous pouvez obtenir toujours la valeur de <xref:System.Windows.Controls.Page.WindowWidth%2A>.  
  
 A <xref:System.Windows.Controls.Page> dans un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] peuvent uniquement utiliser <xref:System.Windows.Controls.Page.WindowWidth%2A> pour modifier la largeur de [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; la largeur ne peut pas être modifiée en définissant <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, ou <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  
  
 La largeur minimale de la [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] fenêtre est 250 pixels. Pour les pages hébergées par un navigateur, cela signifie que la valeur de <xref:System.Windows.Controls.Page.WindowWidth%2A> ne peut pas être appliquée si cela provoquerait la largeur totale de la [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] fenêtre moins de 250 pixels.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la largeur d’une fenêtre à partir d’une page.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>