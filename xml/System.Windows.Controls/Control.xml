<Type Name="Control" FullName="System.Windows.Controls.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ab2475bc9453787b9c4720b74d10ac3ec5b2872f" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53484614" /></Metadata><TypeSignature Language="C#" Value="public class Control : System.Windows.FrameworkElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.Windows.FrameworkElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits FrameworkElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::Windows::FrameworkElement" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit FrameworkElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente la classe de base des éléments d’interface utilisateur (IU) qui utilisent un <see cref="T:System.Windows.Controls.ControlTemplate" /> pour définir leur apparence.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.Control> est la classe de base pour la plupart des contrôles que vous ajoutez à une application. Le <xref:System.Windows.Controls.Control> classe définit le comportement très peu ; alors qu’il est possible d’ajouter un <xref:System.Windows.Controls.Control> à votre application, il est plus courant d’ajouter un contrôle qui hérite de <xref:System.Windows.Controls.Control>, comme un <xref:System.Windows.Controls.Button> ou <xref:System.Windows.Controls.ListBox>.  
  
 Le <xref:System.Windows.Controls.Control.Template%2A> propriété, qui est un <xref:System.Windows.Controls.ControlTemplate>, spécifie l’apparence de la <xref:System.Windows.Controls.Control>. Si vous souhaitez modifier l’apparence d’un contrôle mais conserver ses fonctionnalités, vous devez envisager de créer un nouveau <xref:System.Windows.Controls.ControlTemplate> au lieu de créer une nouvelle classe. Pour plus d’informations, consultez [Application d’un style et création de modèles](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 Si vous souhaitez créer un contrôle avec un comportement personnalisé, ainsi que d’autres utilisateurs de personnaliser son apparence, votre contrôle peut hériter de la <xref:System.Windows.Controls.Control> classe et définir un <xref:System.Windows.Controls.ControlTemplate>.  Si vous souhaitez étendre le comportement d’un contrôle existant, vous pouvez hériter d’une classe qui hérite de <xref:System.Windows.Controls.Control>.  
  
 Un <xref:System.Windows.Controls.Control> qui n’a pas un <xref:System.Windows.Controls.ControlTemplate> n’est pas visible dans votre application et en définissant les propriétés suivantes n’a aucun effet à moins que le <xref:System.Windows.Controls.ControlTemplate> les référence explicitement :  
  
-   <xref:System.Windows.Controls.Control.Background%2A>  
  
-   <xref:System.Windows.Controls.Control.BorderBrush%2A>  
  
-   <xref:System.Windows.Controls.Control.BorderThickness%2A>  
  
-   <xref:System.Windows.Controls.Control.FontFamily%2A>  
  
-   <xref:System.Windows.Controls.Control.FontSize%2A>  
  
-   <xref:System.Windows.Controls.Control.FontStretch%2A>  
  
-   <xref:System.Windows.Controls.Control.FontWeight%2A>  
  
-   <xref:System.Windows.Controls.Control.Foreground%2A>  
  
-   <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A>  
  
-   <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A>  
  
 Une façon courante d’utiliser ces propriétés est de lier un élément dans le <xref:System.Windows.Controls.ControlTemplate> à la propriété.  Par exemple, si vous souhaitez que votre contrôle pour modifier la couleur en fonction de la valeur de la <xref:System.Windows.Controls.Control.Background%2A> propriété, vous pouvez lier une propriété d’un élément dans le <xref:System.Windows.Controls.ControlTemplate> à la <xref:System.Windows.Controls.Control.Background%2A>. Utilisez le [Extension de balisage TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) pour lier les propriétés sur un contrôle à un élément dans le <xref:System.Windows.Controls.ControlTemplate>.  
  
 <xref:System.Windows.Controls.Control> substitue les métadonnées de la <xref:System.Windows.UIElement.Focusable%2A> propriété et définit sa valeur par défaut sur `true`. Pour plus d’informations, consultez [vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160053">Exemple de galerie de contrôles WPF</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Controls.Control" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="control.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Taille calculée utilisée pour réorganiser le contenu.</param>
        <summary>Appelée pour réorganiser et dimensionner le contenu d’un objet <see cref="T:System.Windows.Controls.Control" />.</summary>
        <returns>Taille du contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La disposition du contrôle par défaut réorganise uniquement le premier enfant visuel. Aucun sont appliquées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Control.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un pinceau qui décrit l'arrière-plan d'un contrôle.</summary>
        <value>Le pinceau qui est utilisé pour remplir l'arrière-plan du contrôle. La valeur par défaut est <see cref="P:System.Windows.Media.Brushes.Transparent" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.Control.Background%2A> propriété s’applique uniquement à l’état de repos d’un contrôle.  Le style par défaut du contrôle spécifie son apparence lorsque l’état du contrôle change. Par exemple, si vous définissez la <xref:System.Windows.Controls.Control.Background%2A> propriété sur un <xref:System.Windows.Controls.Button>, le bouton a cette valeur uniquement lorsqu’il n’est pas activé ou désactivé. Si vous souhaitez créer un contrôle qui a une personnalisation plus avancée de l’arrière-plan, vous devez définir le style du contrôle.  
  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.Background%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.BackgroundProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété d’arrière-plan d’un contrôle.  
  
 [!code-xaml[ControlProps#11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#11)]  
  
 [!code-csharp[ControlProps#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[ControlProps#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#1)]  
  
 L’exemple suivant montre un modèle qui permet à un déclencheur changer l’arrière-plan d’un bouton lorsqu’elle est activée.  
  
 [!code-xaml[BackgroundProp_snip#ButtonTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/BackgroundProp_snip/CS/page1.xaml#buttontemplate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.Background" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.BorderBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ BorderBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BorderBrush : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Control.BorderBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un pinceau qui décrit l'arrière-plan de bordure d'un contrôle.</summary>
        <value>Le pinceau qui est utilisé pour remplir la bordure du contrôle ; la valeur par défaut est <see cref="P:System.Windows.Media.Brushes.Transparent" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.BorderBrush%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.BorderBrushProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété de pinceau de bordure d’un contrôle.  
  
 [!code-xaml[ControlProps#17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#17)]  
  
 [!code-csharp[ControlProps#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#7)]
 [!code-vb[ControlProps#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BorderBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderBrushProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderBrushProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.BorderBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.BorderBrush" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.BorderThickness" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderThickness As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness BorderThickness { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.BorderThickness : System.Windows.Thickness with get, set" Usage="System.Windows.Controls.Control.BorderThickness" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'épaisseur de la bordure d'un contrôle.</summary>
        <value>Une valeur d'épaisseur ; la valeur par défaut est une épaisseur de 0 sur chacun des quatre côtés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.BorderThickness%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.BorderThicknessProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété d’épaisseur de bordure d’un contrôle.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops11)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops1)]
 [!code-vb[ControlProps_snip#AdditionalControlProps1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.BorderThicknessProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderThicknessProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderThicknessProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderThicknessProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.BorderThicknessProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.BorderThickness" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.Control.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la famille de polices du contrôle.</summary>
        <value>Famille de polices. La valeur par défaut est la police des boîtes de dialogue du système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.FontFamily%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.FontFamilyProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété de famille de police d’un contrôle.  
  
 [!code-xaml[ControlProps#13](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#13)]  
  
 [!code-csharp[ControlProps#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#3)]
 [!code-vb[ControlProps#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.FontFamily" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.Control.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la police.</summary>
        <value>Taille du texte dans le <see cref="T:System.Windows.Controls.Control" />. La valeur par défaut est <see cref="P:System.Windows.SystemFonts.MessageFontSize" />. La taille de la police doit être un nombre positif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.FontSize%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.FontSizeProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object FontSize="double"/>  
- or -  
<object FontSize ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Une chaîne représentant un <xref:System.Double> valeur. Ceci est interprété comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, une valeur de `1` est acceptable.  
  
 Le même <xref:System.Double> applique des restrictions qui sont mentionnées dans la section de la valeur de propriété ici.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit précédemment qui est suivie par l’un de ces chaînes de déclaration d’unité : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` est de points ; 1pt==(96/72) px  
  
 **Remarque** dans de nombreux cas, un double peut être la valeur « Auto », mais un <xref:System.Windows.Controls.Control.FontSize%2A?displayProperty=nameWithType> n’affiche pas si la valeur est « Auto ».  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété de taille de police d’un contrôle.  
  
 [!code-xaml[ControlProps#14](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#14)]  
  
 [!code-csharp[ControlProps#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#4)]
 [!code-vb[ControlProps#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.FontSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberSignature Language="F#" Value="member this.FontStretch : System.Windows.FontStretch with get, set" Usage="System.Windows.Controls.Control.FontStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le degré auquel une police est condensée ou étendue à l’écran.</summary>
        <value>Valeur <see cref="T:System.Windows.FontStretch" />. La valeur par défaut est <see cref="P:System.Windows.FontStretches.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.FontStretch%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.FontStretchProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété d’étirement de police d’un contrôle. Pour les valeurs d’étirement possibles, consultez <xref:System.Windows.FontStretches>.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops12)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops2)]
 [!code-vb[ControlProps_snip#AdditionalControlProps2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStretchProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.FontStretchProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.FontStretch" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FontStyle : System.Windows.FontStyle with get, set" Usage="System.Windows.Controls.Control.FontStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style de la police.</summary>
        <value>Valeur <see cref="T:System.Windows.FontStyle" />. La valeur par défaut est <see cref="P:System.Windows.FontStyles.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.FontStyle%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.FontStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété de style de police d’un contrôle.  
  
 [!code-xaml[ControlProps#15](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#15)]  
  
 [!code-csharp[ControlProps#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#5)]
 [!code-vb[ControlProps#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.FontStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.FontStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberSignature Language="F#" Value="member this.FontWeight : System.Windows.FontWeight with get, set" Usage="System.Windows.Controls.Control.FontWeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’épaisseur de la police spécifiée.</summary>
        <value>Valeur <see cref="T:System.Windows.FontWeight" />. La valeur par défaut est <see cref="P:System.Windows.FontWeights.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.FontWeight%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles. Pour obtenir la liste de prédéfinis <xref:System.Windows.FontWeight> valeurs, consultez la <xref:System.Windows.FontWeights> classe.  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.FontWeightProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Controls.Control.FontWeight%2A> propriété d’un contrôle.  
  
 [!code-xaml[ControlProps#16](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#16)]  
  
 [!code-csharp[ControlProps#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#6)]
 [!code-vb[ControlProps#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontWeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.FontWeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.FontWeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Control.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un pinceau qui décrit la couleur du premier plan.</summary>
        <value>Le pinceau qui peint le premier plan du contrôle. La valeur par défaut est la couleur de la police des boîtes de dialogue du système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.Foreground%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.ForegroundProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété de style de police d’un contrôle.  
  
 [!code-xaml[ControlProps#12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#12)]  
  
 [!code-csharp[ControlProps#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ControlProps#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.Foreground" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected internal virtual bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.HandlesScrolling" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property HandlesScrolling As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HandlesScrolling { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HandlesScrolling : bool" Usage="System.Windows.Controls.Control.HandlesScrolling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si un contrôle prend en charge le défilement.</summary>
        <value><see langword="true" /> si le contrôle a un <see cref="T:System.Windows.Controls.ScrollViewer" /> dans son style et a un comportement de défilement clavier personnalisé ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalContentAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalContentAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalContentAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.HorizontalContentAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalContentAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalContentAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalContentAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.Controls.Control.HorizontalContentAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'alignement horizontal du contenu du contrôle.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.HorizontalAlignment" />. La valeur par défaut est <see cref="F:System.Windows.HorizontalAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En plus de <xref:System.Windows.HorizontalAlignment.Left>, <xref:System.Windows.HorizontalAlignment.Right>, et <xref:System.Windows.HorizontalAlignment.Center>, vous pouvez définir le <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> propriété <xref:System.Windows.HorizontalAlignment.Stretch>, qui s’étend de l’élément enfant pour remplir l’espace alloué de l’élément parent. Pour plus d’informations, consultez [l’alignement, marges et remplissage de vue d’ensemble](~/docs/framework/wpf/advanced/alignment-margins-and-padding-overview.md).  
  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_HorizontalContentAlignment"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.HorizontalContentAlignmentProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété d’alignement horizontal du contenu d’un contrôle.  
  
 [!code-xaml[ControlProps#18](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#18)]  
  
 [!code-csharp[ControlProps#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#8)]
 [!code-vb[ControlProps#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalContentAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalContentAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalContentAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.HorizontalContentAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalContentAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalContentAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalContentAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.HorizontalContentAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.HorizontalContentAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTabStop">
      <MemberSignature Language="C#" Value="public bool IsTabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.IsTabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTabStop : bool with get, set" Usage="System.Windows.Controls.Control.IsTabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'inclusion ou non d'un contrôle dans la navigation par onglets.</summary>
        <value><see langword="true" />, si le contrôle est inclus dans la navigation par onglets ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Controls.Control.IsTabStop%2A> est `false`, le contrôle est exclu de la navigation par onglets.  
  
<a name="dependencyPropertyInfo_IsTabStop"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.IsTabStopProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Controls.Control.IsTabStop%2A> propriété et comment tester si un contrôle est inclus dans la navigation à onglet.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps15](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops15)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops4)]
 [!code-vb[ControlProps_snip#AdditionalControlProps4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTabStopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTabStopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTabStopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.IsTabStopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTabStopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTabStopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTabStopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.IsTabStopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.IsTabStop" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="control.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">La taille maximale que la méthode peut retourner.</param>
        <summary>Appelée pour remesurer un contrôle.</summary>
        <returns>La taille du contrôle, jusqu'au maximum spécifié par <paramref name="constraint" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut contrôle mesure seulement le premier enfant visuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand un utilisateur clique plusieurs fois sur un bouton de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que cet événement routé semble suivre un itinéraire de propagation dans une arborescence d’éléments, il est en fait un événement routé direct qui a déclenché le long de l’arborescence d’éléments par chaque <xref:System.Windows.UIElement>. Si vous définissez la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true` dans un <xref:System.Windows.Controls.Control.MouseDoubleClick> Gestionnaire d’événements suivante <xref:System.Windows.Controls.Control.MouseDoubleClick> événements le long de l’itinéraire se produisent avec <xref:System.Windows.RoutedEventArgs.Handled%2A> défini sur `false`. Il s’agit d’un événement de niveau supérieur pour les consommateurs de contrôle qui souhaitent être avertis lorsque l’utilisateur double-clique sur le contrôle et à gérer l’événement dans une application.  
  
 Les auteurs de contrôle qui souhaitent gérer les double-clics de souris doivent utiliser le <xref:System.Windows.UIElement.MouseLeftButtonDown> événement lorsque <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> est égal à deux.  Cela entraînera l’état de <xref:System.Windows.RoutedEventArgs.Handled%2A> se propager de façon appropriée dans le cas où un autre élément dans l’arborescence d’éléments gère l’événement.  
  
 Le <xref:System.Windows.Controls.Control> classe définit la <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> et <xref:System.Windows.Controls.Control.MouseDoubleClick> les événements, mais les événements de clic pas correspondants.  Pour voir si l’utilisateur a cliqué sur le contrôle une seule fois, gérer la <xref:System.Windows.UIElement.MouseDown> événement (ou un de ses homologues) et vérifiez si le <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> valeur de propriété est 1.  
  
<a name="routedEventInfo_MouseDoubleClick"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.MouseDoubleClickEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
   
  
## Examples  
 L’exemple suivant montre comment attacher un gestionnaire d’événements pour le <xref:System.Windows.Controls.Control.MouseDoubleClick> événement.  
  
 [!code-xaml[ControlProps_snip#ControlEvents11](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#controlevents11)]  
  
 L’exemple suivant montre le Gestionnaire d’événements de la <xref:System.Windows.Controls.Control.MouseDoubleClick> événement.  
  
 [!code-csharp[ControlProps_snip#ControlEvents1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#controlevents1)]
 [!code-vb[ControlProps_snip#ControlEvents1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#controlevents1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDoubleClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDoubleClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.MouseDoubleClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDoubleClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDoubleClickEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDoubleClickEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Control.MouseDoubleClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.Controls.Control.MouseDoubleClick" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Déclenche l'événement routé <see cref="E:System.Windows.Controls.Control.MouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contrôle déclenche le <xref:System.Windows.Controls.Control.MouseDoubleClick> événement en appelant le <xref:System.Windows.UIElement.RaiseEvent%2A> (méthode). Pour plus d’informations, consultez [vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDoubleClick (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDoubleClick(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseDoubleClick (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseDoubleClick(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDoubleClick : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDoubleClick : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="control.OnPreviewMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement.</param>
        <summary>Déclenche l'événement routé <see cref="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contrôle déclenche le <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> événement en appelant le <xref:System.Windows.UIElement.RaiseEvent%2A> (méthode).  Pour plus d’informations, consultez [vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit&#xA;override this.OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit" Usage="control.OnTemplateChanged (oldTemplate, newTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Ancien modèle.</param>
        <param name="newTemplate">Nouveau modèle.</param>
        <summary>Appelée quand le modèle du contrôle change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le minutage de la modification du modèle est comme suit :  
  
1.  Le modèle est modifié par un <xref:System.Windows.DependencyObject.SetValue%2A> appel de méthode, un déclencheur de style ou d’autres moyens.  
  
2.  La valeur de propriété change ; le rappel de modification de propriété est appelé.  
  
3.  L’arborescence visuelle ancien est supprimé.  
  
4.  Une méthode interne est appelée qui appelle finalement la <xref:System.Windows.Controls.Control.OnTemplateChanged%2A> (méthode).  
  
5.  Une version ultérieure, une mesure, <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> est appelée et une nouvelle arborescence d’éléments visuels est attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Thickness with get, set" Usage="System.Windows.Controls.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la marge intérieure d’un contrôle.</summary>
        <value>La quantité d'espace entre le contenu d'un <see cref="T:System.Windows.Controls.Control" /> et sa <see cref="P:System.Windows.FrameworkElement.Margin" /> ou sa <see cref="T:System.Windows.Controls.Border" />.  La valeur par défaut est une épaisseur de 0 sur chacun des quatre côtés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marge intérieure est spécifiée dans l’ordre de gauche, haut, droite et bas. Pour plus d’informations, consultez <xref:System.Windows.Thickness> et [l’alignement, marges et remplissage de vue d’ensemble](~/docs/framework/wpf/advanced/alignment-margins-and-padding-overview.md).  
  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.Padding%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.PaddingProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété de remplissage d’un contrôle.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps13](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops13)]  
  
 [!code-csharp[ControlProps_snip#AdditionalControlProps3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#additionalcontrolprops3)]
 [!code-vb[ControlProps_snip#AdditionalControlProps3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#additionalcontrolprops3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.Padding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDoubleClick As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDoubleClick : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDoubleClick : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand un utilisateur clique sur le bouton de la souris à plusieurs reprises.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que cet événement routé semble suivre un itinéraire de tunneling dans une arborescence d’éléments, il est en fait un événement routé direct qui a déclenché le long de l’arborescence d’éléments par chaque <xref:System.Windows.UIElement>. Si vous définissez la <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété `true` dans un <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> Gestionnaire d’événements suivante <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> événements le long de l’itinéraire se produisent avec <xref:System.Windows.RoutedEventArgs.Handled%2A> définie sur `false`, mais la <xref:System.Windows.Controls.Control.MouseDoubleClick> événement se produit avec <xref:System.Windows.RoutedEventArgs.Handled%2A>défini sur `true`. Il s’agit d’un événement de niveau supérieur pour les consommateurs de contrôle qui souhaitent être avertis lorsque l’utilisateur double-clique sur le contrôle et à gérer l’événement dans une application.  
  
 Les auteurs de contrôle qui souhaitent gérer les double-clics de souris doivent utiliser le <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> événement lorsque <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> est égal à deux.  Cela entraînera l’état de <xref:System.Windows.RoutedEventArgs.Handled%2A> se propager de façon appropriée dans le cas où un autre élément dans l’arborescence d’éléments gère l’événement.  
  
 Le <xref:System.Windows.Controls.Control> classe définit la <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> et <xref:System.Windows.Controls.Control.MouseDoubleClick> les événements, mais les événements de clic pas correspondants.  Pour voir si l’utilisateur a cliqué sur le contrôle une seule fois, gérer la <xref:System.Windows.UIElement.MouseDown> événement (ou un de ses homologues) et vérifiez si le <xref:System.Windows.Input.MouseButtonEventArgs.ClickCount%2A> valeur de propriété est 1.  
  
<a name="routedEventInfo_PreviewMouseDoubleClick"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.PreviewMouseDoubleClickEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
   
  
## Examples  
 L’exemple suivant montre comment attacher un gestionnaire d’événements le <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> événement.  
  
 [!code-xaml[ControlProps_snip#ControlEvents12](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#controlevents12)]  
  
 L’exemple suivant montre le Gestionnaire d’événements de la <xref:System.Windows.Controls.Control.PreviewMouseDoubleClick> événement.  
  
 [!code-csharp[ControlProps_snip#ControlEvents2](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml.cs#controlevents2)]
 [!code-vb[ControlProps_snip#ControlEvents2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps_snip/VisualBasic/Window1.xaml.vb#controlevents2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDoubleClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDoubleClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDoubleClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.PreviewMouseDoubleClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDoubleClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDoubleClickEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDoubleClickEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Control.PreviewMouseDoubleClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.Controls.Control.PreviewMouseDoubleClick" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Controls.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine l'ordre dans lequel les éléments reçoivent le focus lorsque l'utilisateur navigue à travers des contrôles à l'aide de la touche TAB.</summary>
        <value>Valeur qui détermine l'ordre de navigation logique pour un périphérique. La valeur par défaut est <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contrôle avec un index de tabulation inférieure reçoit le focus avant un contrôle avec un index supérieur.  
  
<a name="dependencyPropertyInfo_TabIndex"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.TabIndexProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant définit l’index de tabulation de trois boutons.  
  
 [!code-xaml[ControlProps_snip#AdditionalControlProps17](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps_snip/CSharp/Pane1.xaml#additionalcontrolprops17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TabIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TabIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.TabIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TabIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TabIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TabIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.TabIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.TabIndex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Template : System.Windows.Controls.ControlTemplate with get, set" Usage="System.Windows.Controls.Control.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un modèle de contrôle.</summary>
        <value>Modèle qui définit l’apparence de <see cref="T:System.Windows.Controls.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ControlTemplate> Spécifie l’apparence d’un <xref:System.Windows.Controls.Control>; si un <xref:System.Windows.Controls.Control> n’a pas un <xref:System.Windows.Controls.ControlTemplate>, le <xref:System.Windows.Controls.Control> n’apparaissent pas dans votre application. L’auteur du contrôle définit le modèle de contrôle par défaut, et l’auteur de l’application peut substituer le <xref:System.Windows.Controls.ControlTemplate> à redéfinir l’arborescence visuelle du contrôle. Consultez [Styles et modèles Control](~/docs/framework/wpf/controls/control-styles-and-templates.md) pour plus d’informations et des exemples montrant comment modifier l’arborescence visuelle des contrôles existants.  
  
 Un <xref:System.Windows.Controls.ControlTemplate> est destinée à être une unité autonome de détails d’implémentation est invisible aux utilisateurs extérieurs et aux objets, y compris <xref:System.Windows.Style> objets. Le seul moyen de manipuler le contenu du modèle de contrôle provient dans le même modèle de contrôle.  
  
<a name="dependencyPropertyInfo_Template"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.TemplateProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.ControlTemplate> pour un <xref:System.Windows.Controls.Button>.  Si vous ajoutez ceci à votre application en tant que ressource, tous les boutons dans l’application s’affichent en tant que points de suspension, mais continuera à fonctionner sous forme de boutons.  
  
 [!code-xaml[StylingIntroSample_snippet#ButtonCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#buttonct)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.Template" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Control.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="control.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la représentation sous forme de chaîne d'un objet <see cref="T:System.Windows.Controls.Control" />.</summary>
        <returns>Chaîne qui représente le contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les auteurs de contrôle doivent substituer cette méthode pour retourner une chaîne qui contient des informations qui seraient intéressantes pour les consommateurs du contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalContentAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalContentAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalContentAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Control.VerticalContentAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalContentAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalContentAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalContentAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.Controls.Control.VerticalContentAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'alignement vertical du contenu du contrôle.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.VerticalAlignment" />. La valeur par défaut est <see cref="F:System.Windows.VerticalAlignment.Top" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En plus de <xref:System.Windows.VerticalAlignment.Top>, <xref:System.Windows.VerticalAlignment.Bottom>, et <xref:System.Windows.VerticalAlignment.Center>, vous pouvez définir le <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> propriété <xref:System.Windows.VerticalAlignment.Stretch>, qui s’étend de l’élément enfant pour remplir l’espace de disposition alloué de l’élément parent. Pour plus d’informations, consultez [l’alignement, marges et remplissage de vue d’ensemble](~/docs/framework/wpf/advanced/alignment-margins-and-padding-overview.md).  
  
 Cette propriété affecte uniquement un contrôle dont le modèle utilise le <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> propriété en tant que paramètre. Cette propriété n’a aucun impact sur les autres contrôles.  
  
<a name="dependencyPropertyInfo_VerticalContentAlignment"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.Control.VerticalContentAlignmentProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir la propriété d’alignement vertical du contenu sur un contrôle.  
  
 [!code-xaml[ControlProps#19](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml#19)]  
  
 [!code-csharp[ControlProps#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlProps/CSharp/Pane1.xaml.cs#9)]
 [!code-vb[ControlProps#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlProps/VisualBasic/Pane1.xaml.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalContentAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalContentAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalContentAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Control.VerticalContentAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalContentAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalContentAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalContentAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Control.VerticalContentAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Controls.Control.VerticalContentAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>