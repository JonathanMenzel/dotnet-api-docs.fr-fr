<Type Name="ItemsControl" FullName="System.Windows.Controls.ItemsControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e58f350480fe8fd078bf81691a78d6bee1b62e55" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37524042" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ItemsControl : System.Windows.Controls.Control, System.Windows.Controls.Primitives.IContainItemStorage, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ItemsControl extends System.Windows.Controls.Control implements class System.Windows.Controls.Primitives.IContainItemStorage, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ItemsControl&#xA;Inherits Control&#xA;Implements IAddChild, IContainItemStorage" />
  <TypeSignature Language="C++ CLI" Value="public ref class ItemsControl : System::Windows::Controls::Control, System::Windows::Controls::Primitives::IContainItemStorage, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type ItemsControl = class&#xA;    inherit Control&#xA;    interface IAddChild&#xA;    interface IContainItemStorage" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Controls.Primitives.IContainItemStorage</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("OnItemsChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="ItemContainerStyle", StyleTargetType=typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a control that can be used to present a collection of items.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Controls.ItemsControl> est un type de <xref:System.Windows.Controls.Control> qui peut contenir plusieurs éléments, tels que des chaînes, des objets ou des autres éléments. L’illustration suivante montre un <xref:System.Windows.Controls.ListBox> contrôle qui contient les différents types d’éléments suivants :  
  
-   Chaîne.  
  
-   Objet <xref:System.DateTime>.  
  
-   Objet <xref:System.Windows.UIElement>.  
  
-   Un <xref:System.Windows.Controls.Panel> contrôle contenant un <xref:System.Windows.Shapes.Ellipse> et un <xref:System.Windows.Controls.TextBlock>.  
  
 ![ListBox avec quatre types de contenu](~/add/media/controlcontentmodellistbox2.PNG "ListBox avec quatre types de contenu")  
ListBox contenant plusieurs types de contenu  
  
 Utilisez le <xref:System.Windows.Controls.ItemsControl.Items%2A> ou <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété pour spécifier la collection à utiliser pour générer le contenu de votre <xref:System.Windows.Controls.ItemsControl>. Vous pouvez définir le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété à n’importe quel type qui implémente <xref:System.Collections.IEnumerable>. <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> est généralement utilisé pour afficher une collection de données ou pour lier un <xref:System.Windows.Controls.ItemsControl> à un objet de collection.  
  
 Si vous ne souhaitez pas utiliser un objet qui implémente <xref:System.Collections.IEnumerable> pour remplir le <xref:System.Windows.Controls.ItemsControl>, vous pouvez ajouter des éléments à l’aide de la <xref:System.Windows.Controls.ItemsControl.Items%2A> propriété. Les éléments dans un <xref:System.Windows.Controls.ItemsControl> peut avoir différents types. Par exemple, un <xref:System.Windows.Controls.ListBox> peut contenir un élément qui est une chaîne et un autre élément qui est un <xref:System.Windows.Controls.Image>.  
  
 Lorsque le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété est définie, le <xref:System.Windows.Controls.ItemsControl.Items%2A> collection est définie sur en lecture seule et de taille fixe. Cela signifie que vous ne pouvez pas ajouter des éléments à la collection directement. Lorsque <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> est en cours d’utilisation, en affectant à la propriété `null` supprime la collection et restaure l’utilisation à <xref:System.Windows.Controls.ItemsControl.Items%2A>, qui sera vide <xref:System.Windows.Controls.ItemCollection>.  
  
 Chaque <xref:System.Windows.Controls.ItemsControl> type a un type de conteneur d’élément correspondant. Le conteneur d’éléments correspondant pour chaque <xref:System.Windows.Controls.ItemsControl> ajoute `Item` à son nom. Par exemple, pour <xref:System.Windows.Controls.ListBox>, les conteneurs d’éléments sont <xref:System.Windows.Controls.ListBoxItem> contrôle ; pour <xref:System.Windows.Controls.ComboBox>, ils sont <xref:System.Windows.Controls.ComboBoxItem> contrôles. Vous pouvez créer explicitement un type de conteneur pour chaque élément dans le <xref:System.Windows.Controls.ItemsControl>, mais il n’est pas nécessaire. Lorsque vous ne créez pas explicitement le type de conteneur, une est générée qui contient un élément de données dans la collection d’éléments. Par exemple, si vous liez une collection d’objets de chaîne pour le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété d’un <xref:System.Windows.Controls.ListBox>, vous ne créez pas explicitement <xref:System.Windows.Controls.ListBoxItem> objets, mais le <xref:System.Windows.Controls.ListBox> générera un pour chaque chaîne. Vous pouvez accéder à un conteneur d’éléments générés à l’aide de la <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> propriété.  
  
> [!NOTE]
>  Certaines fonctionnalités d’automatisation d’interface utilisateur ne fonctionnent pas correctement lorsqu’une <xref:System.Windows.Controls.ItemsControl> contient des objets en double.   Si un objet apparaît plusieurs fois, seule la première instance s’affiche dans l’arborescence automation.   (Deux objets **x** et **y** sont considérés en double si `Object.Equals(x, y)` retourne `true`.)  
>   
>  Tandis que d’un objet **x** est en cours d’utilisation par un <xref:System.Windows.Controls.ItemsControl> la valeur retournée par **x.**`GetHashCode()` ne doit pas changer.  Modifications apportées à cette valeur sont non pris en charge et entraîner un comportement imprévisible.  
  
 Les propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut. Si une propriété est définie par un style par défaut, la propriété peut changer à partir de sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’exécution de l’application. Pour plus d’informations, consultez [thèmes WPF par défaut](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 Les exemples suivants illustrent la liaison de données à un <xref:System.Windows.Controls.ItemsControl>. Le premier exemple crée une classe appelée `MyData` qui est une collection de chaîne simple.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 L’exemple suivant lie la <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> objet d’un <xref:System.Windows.Controls.ItemsControl> à `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 L’illustration suivante montre le <xref:System.Windows.Controls.ListBox> contrôle créé dans l’exemple précédent.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 L’exemple suivant montre comment remplir un <xref:System.Windows.Controls.ItemsControl> à l’aide de la <xref:System.Windows.Controls.ItemsControl.Items%2A> propriété. L’exemple ajoute les différents types suivants d’éléments à la <xref:System.Windows.Controls.ListBox>:  
  
-   Chaîne.  
  
-   Objet <xref:System.DateTime>.  
  
-   Objet <xref:System.Windows.UIElement>.  
  
-   Un <xref:System.Windows.Controls.Panel> contrôle qui contient d’autres <xref:System.Windows.UIElement> objets.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 L’illustration suivante montre le <xref:System.Windows.Controls.ListBox> créé dans l’exemple précédent.  
  
 ![ListBox avec quatre types de contenu](~/add/media/controlcontentmodellistbox2.PNG "ListBox avec quatre types de contenu")  
  
 L’exemple suivant illustre comment utiliser les différents styles et les propriétés liées à la création de modèles qui sont fournies par le <xref:System.Windows.Controls.ItemsControl>. Le <xref:System.Windows.Controls.ItemsControl> dans cet exemple est lié à une collection de `Task` objets. À des fins de démonstration, les styles et les modèles de cet exemple sont tous déclarés inline.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 L’illustration suivante est une capture d’écran de l’exemple lorsqu’il est restitué.  
  
 ![Capture d’écran de ItemsControl](~/add/media/databinding-itemscontrolproperties.png "capture d’écran de ItemsControl")  
  
 Deux autres propriétés de style de la <xref:System.Windows.Controls.ItemsControl> qui ne sont pas affichés ici sont <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> et <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ItemCollection" />
    <altmember cref="T:System.Windows.Controls.ItemContainerGenerator" />
    <altmember cref="T:System.Windows.Controls.ItemsPresenter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ItemsControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ItemsControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.ItemsControl" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="AddChild">
      <MemberSignature Language="C#" Value="protected virtual void AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddChild (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddChild(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member AddChild : obj -&gt; unit&#xA;override this.AddChild : obj -&gt; unit" Usage="itemsControl.AddChild value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to add as a child.</param>
        <summary>Adds the specified object as the child of the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddText">
      <MemberSignature Language="C#" Value="protected virtual void AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddText(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member AddText : string -&gt; unit&#xA;override this.AddText : string -&gt; unit" Usage="itemsControl.AddText text" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The string to add.</param>
        <summary>Adds the specified text string to the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCount">
      <MemberSignature Language="C#" Value="public int AlternationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AlternationCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property AlternationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AlternationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AlternationCount : int with get, set" Usage="System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of alternating item containers in the <see cref="T:System.Windows.Controls.ItemsControl" />, which enables alternating containers to have a unique appearance.</summary>
        <value>Nombre de conteneurs d’éléments de remplacement dans <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> et <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> propriétés vous permettent de spécifier l’apparence pour deux ou plusieurs conteneurs d’élément de remplacement. Par exemple, vous pouvez spécifier des couleurs d’arrière-plan en alternance pour tous les trois éléments dans un <xref:System.Windows.Controls.ItemsControl>.  Le <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> est assignée à chaque conteneur d’éléments dans le <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> commence à 0, incrémente jusqu'à ce qu’il soit <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> moins 1, puis redémarre à 0. Par exemple, si <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> est 3 et il existe sept éléments dans le <xref:System.Windows.Controls.ItemsControl>, le tableau suivant répertorie les <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> pour chaque élément.  
  
|Position d’élément dans le <xref:System.Windows.Controls.ItemsControl>|<xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|1|0|  
|2|1|  
|3|2|  
|4|0|  
|5|1|  
|6|2|  
|7|0|  
  
 Il existe plusieurs méthodes que vous pouvez utiliser pour spécifier différentes apparences pour les conteneurs d’éléments en alternance. Une méthode consiste à lier les propriétés du conteneur d’éléments à la <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Vous pouvez ensuite utiliser un <xref:System.Windows.Controls.AlternationConverter> pour spécifier la valeur doit être appliquée au conteneur d’élément qui a une certaine <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> valeur. Vous pouvez également utiliser des déclencheurs pour modifier la valeur de propriété d’un conteneur d’éléments selon la valeur de son <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant spécifie que le <xref:System.Windows.Controls.ListBox> (qui hérite <xref:System.Windows.Controls.ItemsControl>) a des conteneurs d’élément de remplacement (qui sont de type <xref:System.Windows.Controls.ListBoxItem>) et spécifie un autre et arrière-plan pour chacun d'entre eux.  L’exemple lie la <xref:System.Windows.Controls.Control.Background%2A> et <xref:System.Windows.Controls.Control.Foreground%2A> propriétés pour le <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> et fournit un <xref:System.Windows.Controls.AlternationConverter> pour chaque propriété.  
  
 [!code-xaml[AlternationIndexSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#2)]  
  
 L’exemple suivant fait la même chose que l’exemple précédent à l’aide de <xref:System.Windows.Trigger> objets.  
  
 [!code-xaml[AlternationIndexSnippets#1](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCountProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationCountProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationCountProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationCountProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationCountProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationCountProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndex">
      <MemberSignature Language="C#" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="ILAsm" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationIndex" />
      <MemberSignature Language="VB.NET" Value="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberSignature Language="F#" Value="see GetAlternationIndex, and SetAlternationIndex" Usage="see GetAlternationIndex, and SetAlternationIndex" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public override void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void BeginInit();" />
      <MemberSignature Language="F#" Value="override this.BeginInit : unit -&gt; unit" Usage="itemsControl.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the initialization of the <see cref="T:System.Windows.Controls.ItemsControl" /> object is about to start.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="ClearContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void ClearContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ClearContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.ClearContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">The container element.</param>
        <param name="item">The item.</param>
        <summary>When overridden in a derived class, undoes the effects of the <see cref="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" /> method.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de base ne fait rien.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ContainerFromElement">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the container that belongs to the current <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given container element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject ContainerFromElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject ContainerFromElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainerFromElement (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="member this.ContainerFromElement : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="itemsControl.ContainerFromElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The element to return the container for.</param>
        <summary>Returns the container that belongs to the current <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given element.</summary>
        <returns>The container that belongs to the current <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given element or <see langword="null" /> if no such container exists.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject ContainerFromElement (System.Windows.Controls.ItemsControl itemsControl, System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject ContainerFromElement(class System.Windows.Controls.ItemsControl itemsControl, class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.Controls.ItemsControl,System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::Controls::ItemsControl ^ itemsControl, System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member ContainerFromElement : System.Windows.Controls.ItemsControl * System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Controls.ItemsControl.ContainerFromElement (itemsControl, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemsControl" Type="System.Windows.Controls.ItemsControl" />
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="itemsControl">The <see cref="T:System.Windows.Controls.ItemsControl" /> to return the container for.</param>
        <param name="element">The element to return the container for.</param>
        <summary>Returns the container that belongs to the specified <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given container element.</summary>
        <returns>The container that belongs to the specified <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the given element, if <paramref name="itemsControl" /> is not <see langword="null" />. If <paramref name="itemsControl" /> is <see langword="null" />, returns the closest container that belongs to any <see cref="T:System.Windows.Controls.ItemsControl" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPath">
      <MemberSignature Language="C#" Value="public string DisplayMemberPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayMemberPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayMemberPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayMemberPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMemberPath : string with get, set" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a path to a value on the source object to serve as the visual representation of the object.</summary>
        <value>Chemin d’une valeur de l’objet source. Cela peut être n’importe quel chemin d’accès ou un XPath tel que «@Name». La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est un moyen simple de définir un modèle par défaut qui décrit comment afficher les objets de données.  
  
<a name="dependencyPropertyInfo_DisplayMemberPath"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 Dans l’exemple suivant, la ressource statique nommée `places` est défini comme une collection de `Place` objets, dans lequel chaque `Place` objet possède un `CityName` propriété et un `State` propriété. Le préfixe `src` est mappé à l’espace de noms dans lequel la source de données `Places` est défini. Les préfixes `scm` et `dat` sont mappées à la <xref:System.ComponentModel> et <xref:System.Windows.Data> espaces de noms, respectivement.  
  
 L’exemple suivant crée une vue de la collecte de données qui est triée par nom de ville et regroupée par l’état.  
  
 [!code-xaml[CollectionViewSource#1](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#1)]  
  
 La vue peut être une source de liaison, comme dans l’exemple suivant. En raison de l’élément spécifié <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A>, chaque`Place` objet est affiché avec son `CityName` valeur. Si <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A> n’est pas spécifié et qu’il existe aucune <xref:System.Windows.DataTemplate>, puis le <xref:System.Windows.Controls.ListBox> affiche une représentation sous forme de chaîne de chaque objet dans la collection sous-jacente (dans ce cas, « SDKSample.Place »).  
  
 [!code-xaml[CollectionViewSource#2](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPathProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DisplayMemberPathProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DisplayMemberPathProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DisplayMemberPathProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DisplayMemberPathProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DisplayMemberPathProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public override void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndInit();" />
      <MemberSignature Language="F#" Value="override this.EndInit : unit -&gt; unit" Usage="itemsControl.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the initialization of the <see cref="T:System.Windows.Controls.ItemsControl" /> object is complete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAlternationIndex">
      <MemberSignature Language="C#" Value="public static int GetAlternationIndex (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetAlternationIndex(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetAlternationIndex(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAlternationIndex (element As DependencyObject) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetAlternationIndex(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetAlternationIndex : System.Windows.DependencyObject -&gt; int" Usage="System.Windows.Controls.ItemsControl.GetAlternationIndex element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The object from which to get the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</param>
        <summary>Gets the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> for the specified object.</summary>
        <returns>The value of the <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetContainerForItemOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.DependencyObject GetContainerForItemOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetContainerForItemOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContainerForItemOverride () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::DependencyObject ^ GetContainerForItemOverride();" />
      <MemberSignature Language="F#" Value="abstract member GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject" Usage="itemsControl.GetContainerForItemOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates or identifies the element that is used to display the given item.</summary>
        <returns>The element that is used to display the given item.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="GetItemsOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl GetItemsOwner (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl GetItemsOwner(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetItemsOwner(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetItemsOwner (element As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ GetItemsOwner(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetItemsOwner : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.GetItemsOwner element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The host element.</param>
        <summary>Returns the <see cref="T:System.Windows.Controls.ItemsControl" /> that the specified element hosts items for.</summary>
        <returns>The <see cref="T:System.Windows.Controls.ItemsControl" /> that the specified element hosts items for, or <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Controls.Panel.IsItemsHost%2A> a la valeur `true` sur `element` dans un style ou si `element` est un panneau créé par le <xref:System.Windows.Controls.ItemsPresenter> pour un <xref:System.Windows.Controls.ItemsControl>, le <xref:System.Windows.Controls.ItemsControl> est retourné ; sinon, `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupStyle">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt; GroupStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.Windows.Controls.GroupStyle&gt; GroupStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupStyle As ObservableCollection(Of GroupStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ GroupStyle { System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyle : System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;" Usage="System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of <see cref="T:System.Windows.Controls.GroupStyle" /> objects that define the appearance of each level of groups.</summary>
        <value>Une collection de <see cref="T:System.Windows.Controls.GroupStyle" /> les objets qui définissent l’apparence de chaque niveau de groupes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’entrée à l’index 0 décrit les groupes de niveau supérieur, l’entrée à l’index 1 décrit l’autre niveau, et ainsi de suite. S’il existe davantage de niveaux de regroupement que les entrées dans la collection, la dernière entrée est utilisée pour les niveaux supplémentaires.  
  
<a name="xamlPropertyElementUsage_GroupStyle"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.GroupStyle>  
    OneOrMoreGroupStyleObjects  
  </object.GroupStyle>  
</object>  
  
```  
  
<a name="xamlValues_GroupStyle"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *OneOrMoreGroupStyleObjects*  
 Un ou plusieurs <xref:System.Windows.Controls.GroupStyle> objets.  
  
   
  
## Examples  
 Les exemples suivants montrent une <xref:System.Windows.Controls.ItemsControl> qui est lié à un <xref:System.Windows.Data.XmlDataProvider> et le contenu de code-behind qui contient la logique pour ajouter et supprimer le regroupement. Lorsque la case à cocher est activée, le contenu de la <xref:System.Windows.Controls.ItemsControl> sont regroupées par le `Type` attribut.  
  
 Chaque groupe est de type <xref:System.Windows.Data.CollectionViewGroup>. Le <xref:System.Windows.Controls.GroupStyle> <xref:System.Windows.Controls.GroupStyle.HeaderTemplate%2A> est spécifié afin qu’il apparaisse en tant qu’un <xref:System.Windows.Controls.TextBlock> qui affiche le <xref:System.Windows.Data.CollectionViewGroup.Name%2A> de chacun d’eux le groupe. Dans ce cas, le <xref:System.Windows.Data.CollectionViewGroup.Name%2A> est soit `Work` ou `Home`.  
  
 [!code-xaml[GroupingSample#XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml#xaml)]  
  
 [!code-csharp[GroupingSample#Code](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#code)]
 [!code-vb[GroupingSample#Code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#code)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.GroupStyleSelector GroupStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.GroupStyleSelector GroupStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupStyleSelector As GroupStyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::GroupStyleSelector ^ GroupStyleSelector { System::Windows::Controls::GroupStyleSelector ^ get(); void set(System::Windows::Controls::GroupStyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyleSelector : System.Windows.Controls.GroupStyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.GroupStyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a method that enables you to provide custom selection logic for a <see cref="T:System.Windows.Controls.GroupStyle" /> to apply to each group in a collection.</summary>
        <value>Une méthode qui vous permet de fournir la logique de sélection personnalisée pour un <see cref="T:System.Windows.Controls.GroupStyle" /> à appliquer à chaque groupe dans une collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_GroupStyleSelector"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.PropertyGroupDescription" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty GroupStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty GroupStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GroupStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ GroupStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable GroupStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItems">
      <MemberSignature Language="C#" Value="public bool HasItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.HasItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasItems As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasItems { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasItems : bool" Usage="System.Windows.Controls.ItemsControl.HasItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Windows.Controls.ItemsControl" /> contains items.</summary>
        <value>
          <see langword="true" /> si le nombre d’éléments est supérieur à 0 ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_HasItems"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.HasItemsProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItemsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasItemsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasItemsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasItemsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasItemsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasItemsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.HasItems" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGrouping">
      <MemberSignature Language="C#" Value="public bool IsGrouping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGrouping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGrouping As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGrouping { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGrouping : bool" Usage="System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the control is using grouping.</summary>
        <value>
          <see langword="true" /> Si un contrôle utilise le regroupement ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsGrouping"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.IsGroupingProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGroupingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsGroupingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsGroupingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsGroupingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsGroupingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsGroupingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.IsGrouping" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainer">
      <MemberSignature Language="C#" Value="public bool IsItemItsOwnContainer (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsItemItsOwnContainer(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainer(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsItemItsOwnContainer (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsItemItsOwnContainer(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="member this.IsItemItsOwnContainer : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainer item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.Controls.IGeneratorHost.IsItemItsOwnContainer(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to check.</param>
        <summary>Determines if the specified item is (or is eligible to be) its own container.</summary>
        <returns>
          <see langword="true" /> if the item is (or is eligible to be) its own container; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle la méthode <xref:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainerOverride">
      <MemberSignature Language="C#" Value="protected virtual bool IsItemItsOwnContainerOverride (object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsItemItsOwnContainerOverride(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsItemItsOwnContainerOverride (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsItemItsOwnContainerOverride(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member IsItemItsOwnContainerOverride : obj -&gt; bool&#xA;override this.IsItemItsOwnContainerOverride : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainerOverride item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to check.</param>
        <summary>Determines if the specified item is (or is eligible to be) its own container.</summary>
        <returns>
          <see langword="true" /> if the item is (or is eligible to be) its own container; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitive">
      <MemberSignature Language="C#" Value="public bool IsTextSearchCaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchCaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchCaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchCaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchCaseSensitive : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether case is a condition when searching for items.</summary>
        <value>
          <see langword="true" /> Si les recherches de texte respectent la casse ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabled%2A> propriété est définie sur `true`, le <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> propriété spécifie si le cas détermine si un élément est sélectionné dans un <xref:System.Windows.Controls.ItemsControl>. Par exemple, si un <xref:System.Windows.Controls.ItemsControl> contient deux chaînes qui diffèrent uniquement par la casse, telles que « ITEM » et « item », la première chaîne est toujours sélectionnée, quel que soit le cas de l’entrée.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.ComboBox> qui contient les chaînes, « DOG », « CAT », « dog » et « cat ». L’exemple lie la <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> propriété le <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> propriété d’un <xref:System.Windows.Controls.CheckBox>. Si la case à cocher est sélectionnée et que l’utilisateur tape « chien », le troisième élément dans le <xref:System.Windows.Controls.ItemsControl> est sélectionné. Si l’utilisateur désactive la case à cocher et les types « dog », le premier élément est sélectionné, car la casse n’est pas une condition de la recherche.  
  
 [!code-xaml[ComboBoxProps_snip#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchCaseSensitiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchCaseSensitiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabled">
      <MemberSignature Language="C#" Value="public bool IsTextSearchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchEnabled : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether <see cref="T:System.Windows.Controls.TextSearch" /> is enabled on the <see cref="T:System.Windows.Controls.ItemsControl" /> instance.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Windows.Controls.TextSearch" /> est activé ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsTextSearchEnabled"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup ItemBindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup ItemBindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemBindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ ItemBindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemBindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is copied to each item in the <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Le <see cref="T:System.Windows.Data.BindingGroup" /> qui est copié dans chaque élément dans le <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez la <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> chaque conteneur d’élément de propriété, obtient un <xref:System.Windows.Data.BindingGroup> qui a le même <xref:System.Windows.Controls.ValidationRule> objets en tant que le <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A>, mais les propriétés qui décrivent les données dans les liaisons, tel que <xref:System.Windows.Data.BindingGroup.Items%2A> et <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>, sont des données pour chaque élément dans le <xref:System.Windows.Controls.ItemsControl>.  Vous devez accéder à du conteneur d’élément <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> pour effectuer des opérations telles que valident des données et recherchez les erreurs sur un élément.  
  
   
  
## Examples  
 L’exemple suivant fait partie d’une application qui invite l’utilisateur à entrer plusieurs clients et affecter un représentant commercial à chaque client, puis vérifie que le commercial et le client appartiennent à la même région. L’exemple définit le <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> de la <xref:System.Windows.Controls.ItemsControl> la <xref:System.Windows.Controls.ValidationRule>, `AreasMatch`, validera chaque élément. L’exemple crée également un <xref:System.Windows.Controls.Label> qui affiche des erreurs de validation. Notez que le <xref:System.Windows.Controls.ContentControl.Content%2A> de la <xref:System.Windows.Controls.Label> est lié à un <xref:System.Windows.Controls.ValidationError> qu’il obtient à partir de la <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> propriété. La valeur de <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> est le conteneur d’élément qui a l’erreur.  
  
 [!code-xaml[BindingGroupSnippets#ItemBindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#itembindinggroup)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSiteFor](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#validationadornersitefor)]  
  
 L’exemple suivant obtient le conteneur d’éléments et les appels <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> sur le conteneur <xref:System.Windows.Data.BindingGroup> pour valider les données. Vous devez valider les données en appelant une méthode sur le conteneur d’élément <xref:System.Windows.FrameworkContentElement.BindingGroup%2A>, et non sur le <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> de la <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemBindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemBindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemBindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemBindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemBindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerGenerator">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemContainerGenerator As ItemContainerGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemContainerGenerator ^ ItemContainerGenerator { System::Windows::Controls::ItemContainerGenerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerGenerator : System.Windows.Controls.ItemContainerGenerator" Usage="System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemContainerGenerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.Controls.ItemContainerGenerator" /> that is associated with the control.</summary>
        <value>Le <see cref="T:System.Windows.Controls.ItemContainerGenerator" /> qui est associé au contrôle. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> est chargé de générer la [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] pour son hôte, comme un <xref:System.Windows.Controls.ItemsControl>. Il maintient l’association entre les éléments dans la vue de données du contrôle et le correspondantes <xref:System.Windows.UIElement> objets. Chaque <xref:System.Windows.Controls.ItemsControl> a un conteneur d’éléments associé qui contient un élément de données dans la collection d’éléments. Vous pouvez utiliser la <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> propriété pour accéder au conteneur d’élément qui est associé à votre <xref:System.Windows.Controls.ItemsControl>. Par exemple, si vous avez lié aux données <xref:System.Windows.Controls.TreeView> contrôle et que vous souhaitez obtenir un <xref:System.Windows.Controls.TreeViewItem> en fonction de son index ou son élément de données associé, vous pouvez utiliser la <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromIndex%2A?displayProperty=nameWithType> ou <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromItem%2A?displayProperty=nameWithType> (méthode). Vous pouvez également utiliser le <xref:System.Windows.Controls.ItemContainerGenerator.IndexFromContainer%2A?displayProperty=nameWithType> ou <xref:System.Windows.Controls.ItemContainerGenerator.ItemFromContainer%2A?displayProperty=nameWithType> méthode pour obtenir l’élément de données ou d’index qui est associé à un élément conteneur généré donné.  
  
 Le <xref:System.Windows.Controls.Primitives.IItemContainerGenerator> interface est également utilisée dans les scénarios avancés. En règle générale, les applications avancées qui ont leur propre implémentation d’un panneau de virtualisation appellent des membres de l’interface.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style ItemContainerStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style ItemContainerStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ ItemContainerStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyle : System.Windows.Style with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Style" /> that is applied to the container element generated for each item.</summary>
        <value>Le <see cref="T:System.Windows.Style" /> qui est appliqué à l’élément conteneur généré pour chaque élément. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez cette propriété ou le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> propriété à définir un style pour l’apparence des éléments qui contiennent les éléments de données. Par exemple, pour <xref:System.Windows.Controls.ListBox>, les conteneurs générés sont <xref:System.Windows.Controls.ListBoxItem> contrôle ; pour <xref:System.Windows.Controls.ComboBox>, ils sont <xref:System.Windows.Controls.ComboBoxItem> contrôles.  
  
 Le <xref:System.Windows.Controls.ItemsControl> offre une grande souplesse pour la personnalisation visuelle et fournit de nombreuses propriétés de style et création de modèles. Pour affecter la disposition des éléments, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> propriété. Si vous utilisez le regroupement sur votre contrôle, vous pouvez utiliser la <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> ou <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> propriété. Pour spécifier la visualisation des objets de données, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> ou <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> propriété. Pour plus d’informations sur la façon de spécifier un <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, consultez [vue d’ensemble de la création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemContainerStyle"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object ItemContainerStyle="ResourceExtension StyleResourceKey"/>  
```  
  
<a name="xamlValues_ItemContainerStyle"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *ResourceExtension*  
 Une des opérations suivantes : `StaticResource`, ou `DynamicResource`. À moins que les styles contiennent eux-mêmes des références à des références d’exécution potentiels tels que les ressources système ou les préférences de l’utilisateur, `StaticResource` référence à un style est généralement recommandée pour des performances.  
  
 *StyleResourceKey*  
 `x:Key` valeur de chaîne qui fait référence au style demandé en tant que ressource.  
  
<a name="dependencyPropertyInfo_ItemContainerStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette propriété. Considérez les éléments suivants liés aux données <xref:System.Windows.Controls.ListBox>:  
  
 [!code-xaml[StylingIntroSnippet#UIListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#uilistbox)]   
  
 Pour créer un style pour les éléments qui contiennent les éléments de données, créez un <xref:System.Windows.Controls.ListBoxItem> de style, comme illustré dans l’exemple suivant. Le style est appliqué à tous les <xref:System.Windows.Controls.ListBoxItem> éléments au sein de la portée pour le style est défini.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxItemStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxitemstyle)]   
  
 Le <xref:System.Windows.Controls.ListBoxItem> est l’élément conteneur pour le <xref:System.Windows.Controls.ListBox> contrôle. Par conséquent, une alternative à l’exemple précédent consiste à définir le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété de la <xref:System.Windows.Controls.ListBox> pour le style défini. Pour ce faire, vous devez donner le <xref:System.Windows.Controls.ListBoxItem> style un `x:Key` afin qu’il soit disponible en tant que ressource :  
  
 [!code-xaml[StylingIntroSample_snippet#ContainerStyle1](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#containerstyle1)]   
  
 Ensuite, définissez le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété à la ressource, comme dans l’exemple suivant :  
  
 [!code-xaml[StylingIntroSample_snippet#ListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#listbox)]   
  
 Les deux scénarios précédents produisent le même résultat. Toutefois, un des avantages de la mise à disposition le style en tant que ressource est que vous pouvez réutiliser le style. Définition de la <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété explicitement peut également fournir une meilleure lisibilité.  
  
 Pour obtenir un exemple complet, consultez [Introduction aux styles et modèles exemple](http://go.microsoft.com/fwlink/?LinkID=160010).  
  
 L’exemple suivant est conçu pour illustrer la fonction des différents styles et modèles liés propriétés fournies par le <xref:System.Windows.Controls.ItemsControl>. Le <xref:System.Windows.Controls.ItemsControl> dans cet exemple est lié à une collection de `Task` objets. À des fins de démonstration, les styles et les modèles de cet exemple sont tous déclarés inline.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 Voici une capture d’écran du rendu de l’exemple :  
  
 ![Capture d’écran de ItemsControl](~/add/media/databinding-itemscontrolproperties.png "capture d’écran de ItemsControl")  
  
 Deux autres propriétés de style de la <xref:System.Windows.Controls.ItemsControl> qui ne sont pas affichés ici sont <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> et <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.StyleSelector ItemContainerStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.StyleSelector ItemContainerStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyleSelector As StyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::StyleSelector ^ ItemContainerStyleSelector { System::Windows::Controls::StyleSelector ^ get(); void set(System::Windows::Controls::StyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyleSelector : System.Windows.Controls.StyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.StyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets custom style-selection logic for a style that can be applied to each generated container element.</summary>
        <value>Un <see cref="T:System.Windows.Controls.StyleSelector" /> objet qui contient la logique qui choisit le style à utiliser en tant que le <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété à définir un style pour l’apparence des éléments qui contiennent les éléments de données. Par exemple, pour <xref:System.Windows.Controls.ListBox>, les conteneurs générés sont <xref:System.Windows.Controls.ListBoxItem> contrôle ; pour <xref:System.Windows.Controls.ComboBox>, ils sont <xref:System.Windows.Controls.ComboBoxItem> contrôles. Si vous avez plusieurs styles définis et que vous devez fournir la logique permettant de choisir à appliquer, puis vous utilisez le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> propriété au lieu du <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété. Notez que cette propriété est ignorée si le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété est définie.  
  
 Le <xref:System.Windows.Controls.ItemsControl> offre une grande souplesse pour la personnalisation visuelle et fournit de nombreuses propriétés de style et création de modèles. Pour affecter la disposition des éléments, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> propriété. Si vous utilisez le regroupement sur votre contrôle, vous pouvez utiliser la <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> ou <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> propriété. Pour spécifier la visualisation des objets de données, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> ou <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> propriété. Pour plus d’informations sur la façon de spécifier un <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, consultez [vue d’ensemble de la création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemContainerStyleSelector"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemCollection Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemCollection Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ItemCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemCollection ^ Items { System::Windows::Controls::ItemCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Windows.Controls.ItemCollection" Usage="System.Windows.Controls.ItemsControl.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection used to generate the content of the <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>La collection qui est utilisée pour générer le contenu de la <see cref="T:System.Windows.Controls.ItemsControl" />. La valeur par défaut est une collection vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut être utilisée pour ajouter des éléments à un <xref:System.Windows.Controls.ItemsControl>. Ajout d’un enfant à un <xref:System.Windows.Controls.ItemsControl> objet ajoute implicitement à la <xref:System.Windows.Controls.ItemCollection> pour le <xref:System.Windows.Controls.ItemsControl> objet.  
  
> [!NOTE]
>  Cette propriété peut uniquement être définie [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] via la syntaxe de collection indiquée, ou en accédant à l’objet de collection et à l’aide de ses différentes méthodes telles que `Add`. La propriété pour accéder à l’objet de collection lui-même est en lecture seule, et la collection elle-même est en lecture-écriture.  
  
 Notez que vous utilisez le <xref:System.Windows.Controls.ItemsControl.Items%2A> ou le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété pour indiquer le regroupement qui doit être utilisé pour générer le contenu de votre <xref:System.Windows.Controls.ItemsControl>. Lorsque le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété est définie, le <xref:System.Windows.Controls.ItemsControl.Items%2A> collection est effectuée en lecture seule et de taille fixe.  
  
 Lorsque <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> est en cours d’utilisation, en définissant le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété `null` supprime la collection et restaure l’utilisation à <xref:System.Windows.Controls.ItemsControl.Items%2A>, qui sera vide <xref:System.Windows.Controls.ItemCollection>.  
  
<a name="xamlPropertyElementUsage_Items"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  OneOrMoreElements  
</object>  
```  
  
<a name="xamlValues_Items"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *OneOrMoreElements*  
 Un ou plusieurs <xref:System.Windows.UIElement> objets.  
  
   
  
## Examples  
 Les exemples suivants illustrent la liaison de données à un <xref:System.Windows.Controls.ItemsControl>. Le premier exemple crée une classe appelée `MyData` qui est une collection de chaîne simple.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 L’exemple suivant lie la <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> objet d’un <xref:System.Windows.Controls.ItemsControl> à `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 L’illustration suivante montre le <xref:System.Windows.Controls.ListBox> contrôle créé dans l’exemple précédent.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 L’exemple suivant montre comment remplir un <xref:System.Windows.Controls.ItemsControl> à l’aide de la <xref:System.Windows.Controls.ItemsControl.Items%2A> propriété. L’exemple ajoute les différents types suivants d’éléments à la <xref:System.Windows.Controls.ListBox>:  
  
-   Chaîne.  
  
-   Objet <xref:System.DateTime>.  
  
-   Objet <xref:System.Windows.UIElement>.  
  
-   Un <xref:System.Windows.Controls.Panel> contrôle qui contient d’autres <xref:System.Windows.UIElement> objets.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 L’illustration suivante montre le <xref:System.Windows.Controls.ListBox> créé dans l’exemple précédent.  
  
 ![ListBox avec quatre types de contenu](~/add/media/controlcontentmodellistbox2.PNG "ListBox avec quatre types de contenu")  
  
 Notez que le <xref:System.Windows.Controls.ItemCollection> est une vue, vous pouvez donc utiliser les fonctionnalités liées aux vues, telles que le tri, filtrage et regroupement.  
  
 Par exemple, si vous avez une instance d’un <xref:System.Windows.Controls.ListBox>, `myListBox`, vous pouvez procédez comme suit pour trier le contenu de la <xref:System.Windows.Controls.ListBox>. Dans cet exemple, `Content` est le nom de la propriété par laquelle trier.  
  
 [!code-csharp[ListBoxSort_snip#Sort](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxSort_snip/CSharp/Window1.xaml.cs#sort)]
 [!code-vb[ListBoxSort_snip#Sort](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxSort_snip/visualbasic/window1.xaml.vb#sort)]  
  
 Notez que lorsque vous procédez ainsi, si le contrôle est lié directement à une collection, la vue de collection par défaut est utilisée et les critères de tri sont appliquées à tous les autres contrôles liés directement à la même collection. La vue ne sera pas la vue par défaut si le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété est liée à un <xref:System.Windows.Data.CollectionViewSource>.  
  
 Si votre <xref:System.Windows.Controls.ItemsControl> est directement lié à une collection, vous pouvez procéder comme suit pour obtenir la vue par défaut :  
  
 [!code-csharp[GroupingSample#MyView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#myview)]
 [!code-vb[GroupingSample#MyView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#myview)]  
[!code-csharp[GroupingSample#GetView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#getview)]
[!code-vb[GroupingSample#GetView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#getview)]  
  
 Alternativement, vous pouvez spécifier le tri, regroupement et filtrage des critères dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ou du code en utilisant un <xref:System.Windows.Data.CollectionViewSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsControlFromItemContainer">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl ItemsControlFromItemContainer (System.Windows.DependencyObject container);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl ItemsControlFromItemContainer(class System.Windows.DependencyObject container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ItemsControlFromItemContainer (container As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ ItemsControlFromItemContainer(System::Windows::DependencyObject ^ container);" />
      <MemberSignature Language="F#" Value="static member ItemsControlFromItemContainer : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="container">The container element to return the <see cref="T:System.Windows.Controls.ItemsControl" /> for.</param>
        <summary>Returns the <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the specified container element.</summary>
        <returns>The <see cref="T:System.Windows.Controls.ItemsControl" /> that owns the specified container element.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ItemsPanel">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemsPanelTemplate ItemsPanel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemsPanelTemplate ItemsPanel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsPanel As ItemsPanelTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemsPanelTemplate ^ ItemsPanel { System::Windows::Controls::ItemsPanelTemplate ^ get(); void set(System::Windows::Controls::ItemsPanelTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsPanel : System.Windows.Controls.ItemsPanelTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsPanelTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the template that defines the panel that controls the layout of items.</summary>
        <value>Un <see cref="T:System.Windows.Controls.ItemsPanelTemplate" /> qui définit le panneau à utiliser pour la disposition des éléments. La valeur par défaut pour le <see cref="T:System.Windows.Controls.ItemsControl" /> est un <see cref="T:System.Windows.Controls.ItemsPanelTemplate" /> qui spécifie un <see cref="T:System.Windows.Controls.StackPanel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour le <xref:System.Windows.Controls.ListBox>, la valeur par défaut <xref:System.Windows.Controls.ItemsPanelTemplate> Spécifie le <xref:System.Windows.Controls.VirtualizingStackPanel>. Pour <xref:System.Windows.Controls.MenuItem>, utilise la valeur par défaut <xref:System.Windows.Controls.WrapPanel>. Pour <xref:System.Windows.Controls.Primitives.StatusBar>, utilise la valeur par défaut <xref:System.Windows.Controls.DockPanel>.  
  
 Affecte la disposition des éléments dans un <xref:System.Windows.Controls.ItemsControl>, cette propriété vous permet de spécifier un <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 Le <xref:System.Windows.Controls.ItemsControl> offre une grande souplesse pour la personnalisation visuelle et fournit de nombreuses propriétés de style et création de modèles. Vous utilisez le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété ou le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> propriété à définir un style pour l’apparence des éléments qui contiennent les éléments de données. Par exemple, pour <xref:System.Windows.Controls.ListBox>, les conteneurs générés sont <xref:System.Windows.Controls.ListBoxItem> contrôle ; pour <xref:System.Windows.Controls.ComboBox>, ils sont <xref:System.Windows.Controls.ComboBoxItem> contrôles. Si vous utilisez le regroupement sur votre contrôle, vous pouvez utiliser la <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> ou <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> propriété. Pour spécifier la visualisation des objets de données, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> ou <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> propriété. Pour plus d’informations, consultez [Vue d’ensemble des modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemsPanel"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.ItemsPanelProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 Pour créer un horizontal <xref:System.Windows.Controls.ListBox>, vous pouvez créer un modèle qui spécifie un horizontal <xref:System.Windows.Controls.StackPanel> et définissez-le comme le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> propriété. L’exemple suivant montre un <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Style> qui crée un horizontal <xref:System.Windows.Controls.ListBox>.  
  
 [!code-xaml[StylingIntroSample_snippet#ItemsPanel](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#itemspanel)] 
  
 L’exemple suivant utilise un <xref:System.Windows.Controls.ControlTemplate> pour créer un horizontal <xref:System.Windows.Controls.ListBox> qui a des angles arrondis. Dans cet exemple, au lieu de définir la <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> propriété, comme dans l’exemple précédent, horizontal <xref:System.Windows.Controls.StackPanel> est spécifié dans le <xref:System.Windows.Controls.ControlTemplate>. Le <xref:System.Windows.Controls.Panel.IsItemsHost%2A> propriété est définie sur `true` sur le <xref:System.Windows.Controls.StackPanel>, ce qui indique que les éléments générés doivent entrer dans le panneau de configuration. Lorsque vous spécifiez de cette façon, le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> ne peut pas être remplacé par l’utilisateur du contrôle sans utiliser un <xref:System.Windows.Controls.ControlTemplate>. Par conséquent, ne cela que si vous savez que vous ne pouvez pas le panneau de configuration pour être remplacé sans l’utilisation d’un modèle.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxct)]   
  
 Vous pouvez également effectuer la commande suivante pour obtenir les mêmes résultats. Dans ce cas, le <xref:System.Windows.Controls.ItemsPresenter> crée le panneau pour la disposition des éléments en fonction de ce qui est spécifiée par le <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 [!code-xaml[StyleOvw01#ItemsPanelTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#itemspaneltemplate)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsPanelProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsPanelProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsPanelProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsPanelProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsPanelProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsPanelProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSource">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ItemsSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable ItemsSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsSource As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ ItemsSource { System::Collections::IEnumerable ^ get(); void set(System::Collections::IEnumerable ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsSource : System.Collections.IEnumerable with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a collection used to generate the content of the <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Une collection qui est utilisée pour générer le contenu de la <see cref="T:System.Windows.Controls.ItemsControl" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Modèle de contenu :** cette propriété peut être utilisée pour ajouter des éléments à un <xref:System.Windows.Controls.ItemsControl>.  
  
 Un scénario courant consiste à utiliser un <xref:System.Windows.Controls.ItemsControl> comme un <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView>, ou <xref:System.Windows.Controls.TreeView> pour afficher une collection de données, ou pour lier un <xref:System.Windows.Controls.ItemsControl> à un objet de collection. Pour lier un <xref:System.Windows.Controls.ItemsControl> à un objet de collection, utilisez la <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété. Notez que le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> prend en charge de la propriété <xref:System.Windows.Data.BindingMode.OneWay> liaison par défaut.  
  
 Lorsque le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> propriété est définie, le <xref:System.Windows.Controls.ItemsControl.Items%2A> collection est effectuée en lecture seule et de taille fixe.  
  
 Lorsque <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> est en cours d’utilisation, en affectant à la propriété `null` supprime la collection et restaure l’utilisation à <xref:System.Windows.Controls.ItemsControl.Items%2A>, qui sera vide <xref:System.Windows.Controls.ItemCollection>. Lorsque <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> est pas en cours d’utilisation, la valeur de cette propriété est `null`et l’affectation `null` n’a aucun effet.  
  
> [!NOTE]
>  Dans la plupart des cas il est inutile d’implémenter vos propres regroupements. Au lieu de cela, envisagez d’utiliser <xref:System.Collections.ObjectModel.ObservableCollection%601> ou d’autres collections existantes. Pour plus d’informations, consultez la « Collection objets utilisés en tant que liaison Source » dans [vue d’ensemble des Sources de liaison](~/docs/framework/wpf/data/binding-sources-overview.md).  
  
<a name="xamlAttributeUsage_ItemsSource"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object ItemsSource="bindingDeclaration"/>  
```  
  
<a name="xamlValues_ItemsSource"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *bindingDeclaration*  
 Un <xref:System.Windows.Data.Binding> déclaration. Consultez [Extension de balisage Binding](~/docs/framework/wpf/advanced/binding-markup-extension.md) pour plus d’informations.  
  
<a name="dependencyPropertyInfo_ItemsSource"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.ItemsSourceProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSourceProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsSourceProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsSourceProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsSourceProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsSourceProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsSourceProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormat">
      <MemberSignature Language="C#" Value="public string ItemStringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ItemStringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemStringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ItemStringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemStringFormat : string with get, set" Usage="System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a composite string that specifies how to format the items in the <see cref="T:System.Windows.Controls.ItemsControl" /> if they are displayed as strings.</summary>
        <value>Chaîne composite qui spécifie comment mettre en forme les éléments dans le <see cref="T:System.Windows.Controls.ItemsControl" /> s’ils sont affichés sous forme de chaînes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> peut être un format de chaîne prédéfini, composite ou personnalisé. Pour plus d’informations sur les formats de chaîne, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md). Si vous définissez la <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> ou <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> d’un <xref:System.Windows.Controls.ItemsControl>, le <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> propriété est ignorée.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> pour spécifier le format d’une liste de <xref:System.DateTime> objets.  
  
 [!code-xaml[ContentStringSnippets#ItemsControl](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#itemscontrol)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormatProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemStringFormatProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemStringFormatProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemStringFormatProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemStringFormatProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemStringFormatProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplate">
      <MemberSignature Language="C#" Value="public System.Windows.DataTemplate ItemTemplate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DataTemplate ItemTemplate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplate As DataTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DataTemplate ^ ItemTemplate { System::Windows::DataTemplate ^ get(); void set(System::Windows::DataTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplate : System.Windows.DataTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DataTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.DataTemplate" /> used to display each item.</summary>
        <value>Un <see cref="T:System.Windows.DataTemplate" /> qui spécifie la visualisation des objets de données. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez le <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> pour spécifier la visualisation des objets de données. Si votre <xref:System.Windows.Controls.ItemsControl> est lié à une collection objet et vous ne fournissez pas les instructions d’affichage spécifiques à l’aide un <xref:System.Windows.DataTemplate>, résultant [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de chaque élément est une représentation sous forme de chaîne de chaque objet dans la collection sous-jacente.  
  
 Lorsque vous définissez un <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> sur un <xref:System.Windows.Controls.ItemsControl>, le [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] est générée comme suit (à l’aide de la <xref:System.Windows.Controls.ListBox> par exemple) :  
  
1.  Pendant la génération du contenu, le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> lance une demande pour le <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> pour créer un conteneur pour chaque élément de données. Pour <xref:System.Windows.Controls.ListBox>, le conteneur est un <xref:System.Windows.Controls.ListBoxItem>. Le générateur rappelle le <xref:System.Windows.Controls.ItemsControl> pour préparer le conteneur.  
  
2.  Partie de la préparation consiste à copier le <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> de la <xref:System.Windows.Controls.ListBox> pour être le <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> de la <xref:System.Windows.Controls.ListBoxItem>.  
  
3.  Similaire à tous les <xref:System.Windows.Controls.ContentControl> types, le <xref:System.Windows.Controls.ControlTemplate> d’un <xref:System.Windows.Controls.ListBoxItem> contient un <xref:System.Windows.Controls.ContentPresenter>. Lorsque le modèle est appliqué, il crée un <xref:System.Windows.Controls.ContentPresenter> dont <xref:System.Windows.Controls.ContentPresenter.ContentTemplate%2A> est lié à la <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> de la <xref:System.Windows.Controls.ListBoxItem>.  
  
4.  Enfin, le <xref:System.Windows.Controls.ContentPresenter> s’applique que <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> à lui-même, et qui crée le [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Si vous avez plusieurs <xref:System.Windows.DataTemplate> défini et que vous souhaitez fournir une logique permettant de choisir et appliquer par programme un <xref:System.Windows.DataTemplate>, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> propriété.  
  
 Le <xref:System.Windows.Controls.ItemsControl> offre une grande souplesse pour la personnalisation visuelle et fournit de nombreuses propriétés de style et création de modèles. Utilisez le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété ou le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> propriété à définir un style pour l’apparence des éléments qui contiennent les éléments de données. Par exemple, pour <xref:System.Windows.Controls.ListBox>, les conteneurs générés sont <xref:System.Windows.Controls.ListBoxItem> contrôle ; pour <xref:System.Windows.Controls.ComboBox>, ils sont <xref:System.Windows.Controls.ComboBoxItem> contrôles. Pour affecter la disposition des éléments, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> propriété. Si vous utilisez le regroupement sur votre contrôle, vous pouvez utiliser la <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> ou <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> propriété.  
  
 Pour plus d’informations, consultez [Vue d’ensemble des modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object ItemTemplate=" ResourceExtension TemplateResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplate"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *ResourceExtension*  
 Une des opérations suivantes : [Extension de balisage StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md), ou [Extension de balisage DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). À moins que les styles contiennent eux-mêmes des références à des références d’exécution potentiels tels que les ressources système ou les préférences de l’utilisateur, [Extension de balisage StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) référence à un style est généralement recommandée pour des performances.  
  
 *TemplateResourceKey*  
 [x : Key Directive](~/docs/framework/xaml-services/x-key-directive.md) valeur de chaîne qui fait référence au modèle demandé en tant que ressource.  
  
<a name="dependencyPropertyInfo_ItemTemplate"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.ItemTemplateProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Windows.DataTemplate> inline. Le <xref:System.Windows.DataTemplate> Spécifie que chaque élément de données s’affiche sous forme de trois <xref:System.Windows.Controls.TextBlock> éléments au sein d’un <xref:System.Windows.Controls.StackPanel>. Dans cet exemple, l’objet de données est une classe appelée `Task`. Notez que chaque <xref:System.Windows.Controls.TextBlock> élément dans ce modèle est lié à une propriété de la `Task` classe.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 Il est plus courant pour définir un <xref:System.Windows.DataTemplate> dans la section de ressources afin d’en faire un objet réutilisable, comme dans l’exemple suivant :  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 Vous pouvez à présent utiliser `myTaskTemplate` comme ressource, comme dans l’exemple suivant :  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Vous trouverez l’exemple complet sur la page [Présentation d’un exemple de création de modèles de données](http://go.microsoft.com/fwlink/?LinkID=160009).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.DataTemplateSelector ItemTemplateSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.DataTemplateSelector ItemTemplateSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplateSelector As DataTemplateSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::DataTemplateSelector ^ ItemTemplateSelector { System::Windows::Controls::DataTemplateSelector ^ get(); void set(System::Windows::Controls::DataTemplateSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplateSelector : System.Windows.Controls.DataTemplateSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.DataTemplateSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the custom logic for choosing a template used to display each item.</summary>
        <value>Personnalisé <see cref="T:System.Windows.Controls.DataTemplateSelector" /> objet qui fournit la logique et retourne un <see cref="T:System.Windows.DataTemplate" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez le <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> pour spécifier la visualisation des objets de données. Si vous avez plusieurs modèles définis et que vous souhaitez fournir une logique permettant de retourner un modèle à utiliser, vous utilisez cette propriété. Notez que cette propriété est ignorée si <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> est défini.  
  
 Le <xref:System.Windows.Controls.ItemsControl> offre une grande souplesse pour la personnalisation visuelle et fournit de nombreuses propriétés de style et création de modèles. Utilisez le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> propriété ou le <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> propriété à définir un style pour l’apparence des éléments qui contiennent les éléments de données. Par exemple, pour <xref:System.Windows.Controls.ListBox>, les conteneurs générés sont <xref:System.Windows.Controls.ListBoxItem> contrôle ; pour <xref:System.Windows.Controls.ComboBox>, ils sont <xref:System.Windows.Controls.ComboBoxItem> contrôles. Pour affecter la disposition des éléments, utilisez le <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> propriété. Si vous utilisez le regroupement sur votre contrôle, vous pouvez utiliser la <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> ou <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A> propriété.  
  
 Pour plus d’informations, consultez [Vue d’ensemble des modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplateSelector"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object ItemTemplateSelector="ResourceExtension SelectorResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplateSelector"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *ResourceExtension*  
 Une des opérations suivantes : `StaticResource`, ou `DynamicResource`. À moins que les styles contiennent eux-mêmes des références à des références d’exécution potentiels tels que les ressources système ou les préférences de l’utilisateur, `StaticResource` référence à un style est généralement recommandée pour des performances.  
  
 *SelectorResourceKey*  
 `x:Key` valeur de chaîne qui fait référence au sélecteur demandée en tant que ressource.  
  
<a name="dependencyPropertyInfo_ItemTemplateSelector"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 Dans l’exemple suivant, le `auctionItemDataTemplateSelector` nom de la ressource (correspondant à un `AuctionItemDataTemplateSelector` classe) est affectée à la <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> propriété de la <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-xaml[DataTemplateSelector#ItemTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/Window1.xaml#itemtemplateselector)]  
  
 L’exemple suivant montre l’implémentation de la `AuctionItemDataTemplateSelector` classe avec une substitution de la <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> méthode :  
  
 [!code-csharp[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/AuctionItemDataTemplateSelector.cs#datatemplateselector)]
 [!code-vb[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DataTemplateSelector/visualbasic/auctionitemdatatemplateselector.vb#datatemplateselector)]  
  
 Dans ce cas, dans le <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> méthode de la classe, il est logique de retourner le modèle approprié en fonction de la valeur de la `SpecialFeatures` propriété de la `item` objet passé. Le modèle à retourner se trouve dans les ressources de l’enveloppe <xref:System.Windows.Window> élément.  
  
 Lorsque vous définissez la <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> propriété, le <xref:System.Windows.Controls.ItemsControl> est dirigé vers appellent automatiquement le <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> méthode de `AuctionItemDataTemplateSelector` pour chacun des éléments dans la collection à laquelle le <xref:System.Windows.Controls.ItemsControl> est lié. L’appel passe l’élément de données en tant qu’objet. Le <xref:System.Windows.DataTemplate> qui est retourné par la méthode est ensuite utilisée pour afficher cet élément de données.  
  
 Pour un autre exemple, consultez [vue d’ensemble de la création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator for the logical child objects of the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <value>Un énumérateur pour les objets enfants logiques de la <see cref="T:System.Windows.Controls.ItemsControl" /> objet. La valeur par défaut est <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAlternationCountChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAlternationCountChanged (int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAlternationCountChanged(int32 oldAlternationCount, int32 newAlternationCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnAlternationCountChanged(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAlternationCountChanged (oldAlternationCount As Integer, newAlternationCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="F#" Value="abstract member OnAlternationCountChanged : int * int -&gt; unit&#xA;override this.OnAlternationCountChanged : int * int -&gt; unit" Usage="itemsControl.OnAlternationCountChanged (oldAlternationCount, newAlternationCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldAlternationCount" Type="System.Int32" />
        <Parameter Name="newAlternationCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldAlternationCount">The old value of <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <param name="newAlternationCount">The new value of <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayMemberPathChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayMemberPathChanged (string oldDisplayMemberPath, string newDisplayMemberPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnDisplayMemberPathChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayMemberPathChanged (oldDisplayMemberPath As String, newDisplayMemberPath As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayMemberPathChanged(System::String ^ oldDisplayMemberPath, System::String ^ newDisplayMemberPath);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayMemberPathChanged : string * string -&gt; unit&#xA;override this.OnDisplayMemberPathChanged : string * string -&gt; unit" Usage="itemsControl.OnDisplayMemberPathChanged (oldDisplayMemberPath, newDisplayMemberPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDisplayMemberPath" Type="System.String" />
        <Parameter Name="newDisplayMemberPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldDisplayMemberPath">The old value of the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> property.</param>
        <param name="newDisplayMemberPath">New value of the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGroupStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnGroupStyleSelectorChanged (System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, System.Windows.Controls.GroupStyleSelector newGroupStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGroupStyleSelectorChanged(class System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, class System.Windows.Controls.GroupStyleSelector newGroupStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnGroupStyleSelectorChanged(System.Windows.Controls.GroupStyleSelector,System.Windows.Controls.GroupStyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGroupStyleSelectorChanged (oldGroupStyleSelector As GroupStyleSelector, newGroupStyleSelector As GroupStyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGroupStyleSelectorChanged(System::Windows::Controls::GroupStyleSelector ^ oldGroupStyleSelector, System::Windows::Controls::GroupStyleSelector ^ newGroupStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit&#xA;override this.OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit" Usage="itemsControl.OnGroupStyleSelectorChanged (oldGroupStyleSelector, newGroupStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
        <Parameter Name="newGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldGroupStyleSelector">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> property.</param>
        <param name="newGroupStyleSelector">New value of the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemBindingGroupChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemBindingGroupChanged (System.Windows.Data.BindingGroup oldItemBindingGroup, System.Windows.Data.BindingGroup newItemBindingGroup);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemBindingGroupChanged(class System.Windows.Data.BindingGroup oldItemBindingGroup, class System.Windows.Data.BindingGroup newItemBindingGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemBindingGroupChanged(System.Windows.Data.BindingGroup,System.Windows.Data.BindingGroup)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemBindingGroupChanged (oldItemBindingGroup As BindingGroup, newItemBindingGroup As BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemBindingGroupChanged(System::Windows::Data::BindingGroup ^ oldItemBindingGroup, System::Windows::Data::BindingGroup ^ newItemBindingGroup);" />
      <MemberSignature Language="F#" Value="abstract member OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit&#xA;override this.OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit" Usage="itemsControl.OnItemBindingGroupChanged (oldItemBindingGroup, newItemBindingGroup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
        <Parameter Name="newItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
      </Parameters>
      <Docs>
        <param name="oldItemBindingGroup">The old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <param name="newItemBindingGroup">The new value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleChanged (System.Windows.Style oldItemContainerStyle, System.Windows.Style newItemContainerStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleChanged(class System.Windows.Style oldItemContainerStyle, class System.Windows.Style newItemContainerStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleChanged (oldItemContainerStyle As Style, newItemContainerStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleChanged(System::Windows::Style ^ oldItemContainerStyle, System::Windows::Style ^ newItemContainerStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="itemsControl.OnItemContainerStyleChanged (oldItemContainerStyle, newItemContainerStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyle" Type="System.Windows.Style" />
        <Parameter Name="newItemContainerStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyle">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> property.</param>
        <param name="newItemContainerStyle">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleSelectorChanged (System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, System.Windows.Controls.StyleSelector newItemContainerStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleSelectorChanged(class System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, class System.Windows.Controls.StyleSelector newItemContainerStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleSelectorChanged(System.Windows.Controls.StyleSelector,System.Windows.Controls.StyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector As StyleSelector, newItemContainerStyleSelector As StyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleSelectorChanged(System::Windows::Controls::StyleSelector ^ oldItemContainerStyleSelector, System::Windows::Controls::StyleSelector ^ newItemContainerStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit&#xA;override this.OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit" Usage="itemsControl.OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector, newItemContainerStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
        <Parameter Name="newItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyleSelector">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property.</param>
        <param name="newItemContainerStyleSelector">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="itemsControl.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Information about the change.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.Items" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsPanelChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsPanelChanged (System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, System.Windows.Controls.ItemsPanelTemplate newItemsPanel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsPanelChanged(class System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, class System.Windows.Controls.ItemsPanelTemplate newItemsPanel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsPanelChanged(System.Windows.Controls.ItemsPanelTemplate,System.Windows.Controls.ItemsPanelTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsPanelChanged (oldItemsPanel As ItemsPanelTemplate, newItemsPanel As ItemsPanelTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsPanelChanged(System::Windows::Controls::ItemsPanelTemplate ^ oldItemsPanel, System::Windows::Controls::ItemsPanelTemplate ^ newItemsPanel);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit&#xA;override this.OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit" Usage="itemsControl.OnItemsPanelChanged (oldItemsPanel, newItemsPanel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
        <Parameter Name="newItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemsPanel">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> property.</param>
        <param name="newItemsPanel">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsSourceChanged (System.Collections.IEnumerable oldValue, System.Collections.IEnumerable newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsSourceChanged(class System.Collections.IEnumerable oldValue, class System.Collections.IEnumerable newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsSourceChanged(System.Collections.IEnumerable,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsSourceChanged (oldValue As IEnumerable, newValue As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsSourceChanged(System::Collections::IEnumerable ^ oldValue, System::Collections::IEnumerable ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit&#xA;override this.OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit" Usage="itemsControl.OnItemsSourceChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Collections.IEnumerable" />
        <Parameter Name="newValue" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="oldValue">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property.</param>
        <param name="newValue">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property.</param>
        <summary>Called when the <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemStringFormatChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemStringFormatChanged (string oldItemStringFormat, string newItemStringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemStringFormatChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemStringFormatChanged (oldItemStringFormat As String, newItemStringFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemStringFormatChanged(System::String ^ oldItemStringFormat, System::String ^ newItemStringFormat);" />
      <MemberSignature Language="F#" Value="abstract member OnItemStringFormatChanged : string * string -&gt; unit&#xA;override this.OnItemStringFormatChanged : string * string -&gt; unit" Usage="itemsControl.OnItemStringFormatChanged (oldItemStringFormat, newItemStringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemStringFormat" Type="System.String" />
        <Parameter Name="newItemStringFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldItemStringFormat">The old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> property.</param>
        <param name="newItemStringFormat">The new value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateChanged (System.Windows.DataTemplate oldItemTemplate, System.Windows.DataTemplate newItemTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateChanged(class System.Windows.DataTemplate oldItemTemplate, class System.Windows.DataTemplate newItemTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateChanged (oldItemTemplate As DataTemplate, newItemTemplate As DataTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateChanged(System::Windows::DataTemplate ^ oldItemTemplate, System::Windows::DataTemplate ^ newItemTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit&#xA;override this.OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit" Usage="itemsControl.OnItemTemplateChanged (oldItemTemplate, newItemTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplate" Type="System.Windows.DataTemplate" />
        <Parameter Name="newItemTemplate" Type="System.Windows.DataTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplate">The old <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> property value.</param>
        <param name="newItemTemplate">The new <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> property value.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateSelectorChanged (System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, System.Windows.Controls.DataTemplateSelector newItemTemplateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateSelectorChanged(class System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, class System.Windows.Controls.DataTemplateSelector newItemTemplateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateSelectorChanged (oldItemTemplateSelector As DataTemplateSelector, newItemTemplateSelector As DataTemplateSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateSelectorChanged(System::Windows::Controls::DataTemplateSelector ^ oldItemTemplateSelector, System::Windows::Controls::DataTemplateSelector ^ newItemTemplateSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit&#xA;override this.OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit" Usage="itemsControl.OnItemTemplateSelectorChanged (oldItemTemplateSelector, newItemTemplateSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
        <Parameter Name="newItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplateSelector">Old value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> property.</param>
        <param name="newItemTemplateSelector">New value of the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> property.</param>
        <summary>Invoked when the <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="itemsControl.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Information about the event.</param>
        <summary>Invoked when the <see cref="E:System.Windows.UIElement.KeyDown" /> event is received.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected override void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="itemsControl.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Information about the event.</param>
        <summary>Invoked when the <see cref="E:System.Windows.UIElement.TextInput" /> event is received.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Element used to display the specified item.</param>
        <param name="item">Specified item.</param>
        <summary>Prepares the specified element to display the specified item.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Préparation de l’élément peut impliquer l’application de styles, la définition de liaisons et ainsi de suite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldApplyItemContainerStyle">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldApplyItemContainerStyle (System.Windows.DependencyObject container, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldApplyItemContainerStyle(class System.Windows.DependencyObject container, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldApplyItemContainerStyle(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldApplyItemContainerStyle (container As DependencyObject, item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldApplyItemContainerStyle(System::Windows::DependencyObject ^ container, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool&#xA;override this.ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool" Usage="itemsControl.ShouldApplyItemContainerStyle (container, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="container">The container element.</param>
        <param name="item">The item of interest.</param>
        <summary>Returns a value that indicates whether to apply the style from the <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> or <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> property to the container element of the specified item.</summary>
        <returns>Always <see langword="true" /> for the base implementation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeGroupStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeGroupStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeGroupStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeGroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeGroupStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeGroupStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeGroupStyle : unit -&gt; bool" Usage="itemsControl.ShouldSerializeGroupStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether serialization processes should serialize the effective value of the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeItems">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeItems ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeItems" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeItems () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeItems();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeItems : unit -&gt; bool" Usage="itemsControl.ShouldSerializeItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether serialization processes should serialize the effective value of the <see cref="P:System.Windows.Controls.ItemsControl.Items" /> property.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.ItemsControl.Items" /> property value should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.Clear">
      <MemberSignature Language="C#" Value="void IContainItemStorage.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IContainItemStorage.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.Clear() = System::Windows::Controls::Primitives::IContainItemStorage::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all property associations.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearItemValue (item As Object, dp As DependencyProperty) Implements IContainItemStorage.ClearItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="item">The associated item.</param>
        <param name="dp">The associated property.</param>
        <summary>Removes the association between the specified item and property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearValue (dp As DependencyProperty) Implements IContainItemStorage.ClearValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The property to remove.</param>
        <summary>Removes the specified property from all property lists.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue">
      <MemberSignature Language="C#" Value="object IContainItemStorage.ReadItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ReadItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function ReadItemValue (item As Object, dp As DependencyProperty) As Object Implements IContainItemStorage.ReadItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ReadItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="item">The item that has the specified property associated with it.</param>
        <param name="dp">The property whose value to return.</param>
        <summary>Returns the value of the specified property that is associated with the specified item.</summary>
        <returns>The value of the specified property that is associated with the specified item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.StoreItemValue (object item, System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub StoreItemValue (item As Object, dp As DependencyProperty, value As Object) Implements IContainItemStorage.StoreItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp, System::Object ^ value) = System::Windows::Controls::Primitives::IContainItemStorage::StoreItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to associate the value and property with.</param>
        <param name="dp">The property that is associated with the specified item.</param>
        <param name="value">The value of the associated property.</param>
        <summary>Stores the specified property and value and associates them with the specified item.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to add as a child.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">The text to add.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="itemsControl.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provides a string representation of the <see cref="T:System.Windows.Controls.ItemsControl" /> object.</summary>
        <returns>The string representation of the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>