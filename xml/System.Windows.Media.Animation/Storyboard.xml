<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ce141dc7761c50fbe3baa83fc9aece459ee15c5" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39764359" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Chronologie de conteneur qui fournit des informations sur le ciblage des objets et des propriétés pour ses animations enfants.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Contrôler les Storyboards de façon interactive  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le balisage, vous spécifiez le <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> propriété de la <xref:System.Windows.Media.Animation.BeginStoryboard> l’objet qui le crée ; pour obtenir un exemple, consultez [Comment : utiliser les déclencheurs d’événements pour contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Liaison de données et animation des chronologies  
 La plupart des propriétés de chronologie peuvent être liées aux données ou animées ; Toutefois, en raison du mode le système de minutage fonctionne, données chronologies liées ou animées ne se comportent pas comme les autres données liées ou objets animés. Pour comprendre leur comportement, il est utile de comprendre ce que cela signifie d’activer une chronologie.  
  
 Lorsqu’une chronologie est activée, les copies sont effectuées de la chronologie et ses chronologies enfants. Ces copies sont figées (en lecture seule) et <xref:System.Windows.Media.Animation.Clock> objets sont créés à partir de celles-ci. Ces horloges effectuent le travail réel de l’animation des propriétés ciblées. Si une chronologie est lié aux données ou animée, une capture instantanée de ses valeurs actuelles est effectuée lors de la création de son horloge. Bien que la chronologie d’origine peut continuer à modifier, son horloge ne fait pas.  
  
 Pour une chronologie refléter les modifications d’animation ou de liaison de données, son horloge doit être recréée. Horloges ne sont pas ré-créées pour vous automatiquement. Voici plusieurs façons d’appliquer des modifications de chronologie :  
  
-   Si la chronologie est ou appartient à un <xref:System.Windows.Media.Animation.Storyboard>, vous lui faire refléter les modifications en réappliquant son storyboard à l’aide un <xref:System.Windows.Media.Animation.BeginStoryboard> ou <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode). Cela a pour effet secondaire de redémarrer également l’animation. Dans le code, vous pouvez utiliser le <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> retour de méthode pour faire avancer le storyboard à sa position précédente.  
  
-   Si vous avez appliqué une animation directement à une propriété à l’aide de la <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> méthode, appelez le <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> méthode à nouveau et passez-lui l’animation qui a été modifiée.  
  
-   Si vous travaillez directement au niveau de l’horloge, créez et appliquez un nouveau jeu d’horloges et utilisez-les pour remplacer le précédent jeu d’horloges créées.  
  
 Pour un exemple de données lié à l’animation, consultez [Animation de Spline clé, exemple](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise le jeu d'animations associé à ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Applique les animations associées à ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <summary>Applique les animations associées à ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportement de transfert.  
  
 Storyboards démarrés avec cette méthode ne peut pas être suspendus, repris ou sinon contrôlées de façon interactive après leur démarrage. Pour rendre une table de montage séquentiel contrôlable, utilisez la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ou <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode).  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
   
  
## Examples  
 L’exemple suivant utilise un storyboard pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <summary>Applique les animations associées à ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportement de transfert.  
  
 Storyboards démarrés avec cette méthode ne peut pas être suspendus, repris ou sinon contrôlées de façon interactive après leur démarrage. Pour rendre une table de montage séquentiel contrôlable, utilisez la <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> ou <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> (méthode).  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> si le plan conceptuel doit être contrôlable de façon interactive ; sinon, <see langword="false" />.</param>
        <summary>Applique les animations associées à ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportement de transfert.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez spécifier les mêmes `containingObject` lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportement que la nouvelle animation doit utiliser pour interagir avec toutes les animations actuelles.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise à l'aide du <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage Supprimez ces horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs manières de supprimer une horloge.  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas appelé si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> à animer lorsque l’utilisateur left-clicks et le <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> lorsque l’utilisateur clique sur.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> si le plan conceptuel doit être contrôlable de façon interactive ; sinon, <see langword="false" />.</param>
        <summary>Applique les animations associées à ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportement de transfert.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet auquel le <c>frameworkTemplate</c> spécifié a été appliqué. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modèle à animer.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles dans le modèle spécifié et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportement de transfert.  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportement que la nouvelle animation doit utiliser pour interagir avec toutes les animations actuelles.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise à l'aide du <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> à animer lorsque l’utilisateur left-clicks et le <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> lorsque l’utilisateur clique sur.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportement que la nouvelle animation doit utiliser pour interagir avec toutes les animations actuelles.</param>
        <param name="isControllable">Déclare si l'animation est contrôlable (peut être suspendue) une fois démarrée.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise à l'aide du <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide du comportement de transfert spécifié.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez spécifier les mêmes `containingObject` lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage Supprimez ces horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs manières de supprimer une horloge.  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas appelé si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 L’exemple suivant utilise le <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> à animer lorsque l’utilisateur left-clicks et le <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> lorsque l’utilisateur clique sur.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet auquel le <c>frameworkTemplate</c> spécifié a été appliqué.  Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modèle à animer.</param>
        <param name="isControllable">
          <see langword="true" /> si le plan conceptuel doit être contrôlable de façon interactive ; sinon, <see langword="false" />.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles dans le modèle spécifié et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les propriétés ciblées sont déjà animées, elles sont remplacées à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportement de transfert.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez spécifier les mêmes `containingObject` lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet auquel le <c>frameworkTemplate</c> spécifié a été appliqué. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modèle à animer.</param>
        <param name="handoffBehavior">Comportement que la nouvelle animation doit utiliser pour interagir avec toutes les animations actuelles.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles dans le modèle spécifié et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage Supprimez ces horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs manières de supprimer une horloge.  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas appelé si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet contenu dans la même portée de nom que les cibles des animations de ce plan conceptuel. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportement que la nouvelle animation doit utiliser pour interagir avec toutes les animations actuelles.</param>
        <param name="isControllable">Déclare si l'animation est contrôlable (peut être suspendue) une fois démarrée.</param>
        <summary>Applique les animations associées à ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage Supprimez ces horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs manières de supprimer une horloge.  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas appelé si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une table de montage séquentiel contrôlable.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 L’exemple suivant utilise le <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> à animer lorsque l’utilisateur left-clicks et le <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> lorsque l’utilisateur clique sur.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet auquel le <c>frameworkTemplate</c> spécifié a été appliqué. Les animations sans <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> sont appliquées à <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Modèle à animer.</param>
        <param name="handoffBehavior">Comportement que la nouvelle animation doit utiliser pour interagir avec toutes les animations actuelles.</param>
        <param name="isControllable">
          <see langword="true" /> si le plan conceptuel doit être contrôlable de façon interactive ; sinon, <see langword="false" />.</param>
        <summary>Applique les animations associées avec ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à leurs cibles dans le modèle spécifié et les initialise.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez spécifier les mêmes `containingObject` lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel  
  
 Lorsque cette méthode est appelée, <xref:System.Windows.Media.Animation.Clock> objets sont créés pour la table de montage séquentiel et les chronologies qu’il contient. Ces horloges sont stockées avec `containingObject`.  
  
 À partir d’un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événements.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage Supprimez ces horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs manières de supprimer une horloge.  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas appelé si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable de ce <see cref="T:System.Windows.Media.Animation.Storyboard" />, en créant des copies complètes des valeurs de cet objet. Pendant la copie des propriétés de dépendance, cette méthode copie les références de ressources et les liaisons de données (qui risquent toutefois de ne plus pouvoir se résoudre), mais pas les animations ni leurs valeurs actuelles.</summary>
        <returns>Clone modifiable de l'objet actif. La valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l’objet cloné est <see langword="false" />, même si la valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source est <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour générer des copies modifiables de figé <xref:System.Windows.Freezable> objets (ou n’importe quel <xref:System.Windows.Freezable> objet). Pour des raisons pratiques, cette méthode occulte la version héritée avec une implémentation fortement typée.  
  
 Pour plus d'informations, consultez <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance de la classe <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Nouvelle instance de <see cref="T:System.Windows.Media.Animation.Storyboard" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée en interne par <xref:System.Windows.Freezable.CreateInstance%2A> lors de la création de nouvelles instances de la <xref:System.Windows.Media.Animation.Storyboard> classe pour les différentes méthodes de clonage (tel que <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 L’exemple suivant montre une implémentation classique de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chaque <see cref="T:System.Windows.Media.Animation.Storyboard" /> sous-classe doit implémenter cette méthode. Implémentation classique consiste à simplement appeler le constructeur par défaut de classe et retournent le résultat.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 D’une horloge <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> vitesse est la vitesse à laquelle son temps s’écoule actuellement par rapport à l’heure réelle.  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Vitesse globale actuelle ou 0 si l'horloge est arrêtée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Vitesse globale actuelle ou <see langword="null" /> si l'horloge est arrêtée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 D’une horloge <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> vitesse est la vitesse à laquelle son temps s’écoule actuellement par rapport à l’heure réelle.  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Vitesse globale actuelle ou <see langword="null" /> si l'horloge est arrêtée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 D’une horloge <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> vitesse est la vitesse à laquelle son temps s’écoule actuellement par rapport à l’heure réelle.  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>L'itération actuelle de cette horloge dans sa période active actuelle, ou <see langword="null" /> si cette horloge est arrêtée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Itération premier d’une horloge a la valeur 1.  
  
 Si cette animation a un <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> paramètre `true`, une itération complète se compose d’une paire avant-arrière, et pas seulement un de ces segments.  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>L'itération actuelle de cette horloge dans sa période active actuelle, ou <see langword="null" /> si cette horloge est arrêtée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Itération premier d’une horloge a la valeur 1.  
  
 Si cette animation a un <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> paramètre `true`, une itération complète se compose d’une paire avant-arrière, et pas seulement un de ces segments.  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>L'itération actuelle de cette horloge dans sa période active actuelle, ou <see langword="null" /> si cette horloge est arrêtée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Itération premier d’une horloge a la valeur 1.  
  
 Si cette chronologie horloge a un <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> paramètre `true`, une itération complète se compose d’une paire avant-arrière, et pas seulement un de ces segments.  
  
 Quel que soit son itération actuelle, la recherche d’une horloge retourne son itération actuelle à 1. Le redémarrage d’une horloge retourne également son itération actuelle à 1.  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si cette horloge est <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ou 0.0 si cette horloge est active et que <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> de <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> a la valeur <see cref="P:System.Windows.Duration.Forever" /> ; sinon, une valeur comprise entre 0.0 et 1.0 qui indique la progression actuelle de cette horloge dans son itération actuelle. Une valeur de 0.0 n'indique aucune progression, et une valeur de 1.0 indique que l'horloge est à la fin de son itération actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si cette horloge est <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ou 0.0 si cette horloge est active et que <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> de <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> a la valeur <see cref="P:System.Windows.Duration.Forever" /> ; sinon, une valeur comprise entre 0.0 et 1.0 qui indique la progression actuelle de cette horloge dans son itération actuelle. Une valeur de 0.0 n'indique aucune progression, et une valeur de 1.0 indique que l'horloge est à la fin de son itération actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si cette horloge est <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ou 0.0 si cette horloge est active et que <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> de <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> a la valeur <see cref="P:System.Windows.Duration.Forever" /> ; sinon, une valeur comprise entre 0.0 et 1.0 qui indique la progression actuelle de cette horloge dans son itération actuelle. Une valeur de 0.0 n'indique aucune progression, et une valeur de 1.0 indique que l'horloge est à la fin de son itération actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>État actuel de l'horloge créé pour cette table de montage séquentiel : <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />ou <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’indique pas si une table de montage séquentiel est suspendue. Pour déterminer si une table de montage séquentiel est suspendu, utilisez la <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> (méthode).  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>État actuel de l'horloge créé pour cette table de montage séquentiel : <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />ou <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’indique pas si une table de montage séquentiel est suspendue. Pour déterminer si une table de montage séquentiel est suspendu, utilisez la <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> (méthode).  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>État actuel de l'horloge créé pour cette table de montage séquentiel : <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" />ou <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’indique pas si une table de montage séquentiel est suspendue. Pour déterminer si une table de montage séquentiel est suspendu, utilisez la <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> (méthode).  
  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si l'horloge de cette table de montage séquentiel est <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ; sinon, l'heure actuelle de l'horloge de la table de montage séquentiel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si l'horloge de cette table de montage séquentiel est <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ; sinon, l'heure actuelle de l'horloge de la table de montage séquentiel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère la <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> du <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si l'horloge de cette table de montage séquentiel est <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ; sinon, l'heure actuelle de l'horloge de la table de montage séquentiel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère une valeur qui indique si <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une valeur qui indique si <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère une valeur qui indique si <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Récupère une valeur qui indique si <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.Windows.Media.Animation.Clock" /> créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> est suspendu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode pour récupérer des informations sur l’horloge d’une table de montage séquentiel, celle-ci doit être contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Chronologie à partir de laquelle récupérer le <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Récupère la valeur <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> du <see cref="T:System.Windows.Media.Animation.Timeline" /> spécifié.</summary>
        <returns>Objet de dépendance ciblé par <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propriété des chronologies d’animation pour indiquer l’objet qu’elles ciblent jointe. Pour plus d’informations sur le fonctionne de la table de montage séquentiel ciblant, consultez <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Pour plus d’informations sur comment jointes propriétés, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Chronologie à partir de laquelle récupérer le <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Récupère la valeur <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> du <see cref="T:System.Windows.Media.Animation.Timeline" /> spécifié.</summary>
        <returns>Nom de l'objet de dépendance ciblé par <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode obtient le <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> propriété jointe sur l’objet spécifié. Pour plus d’informations sur le fonctionne de la table de montage séquentiel ciblant, consultez <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Pour plus d’informations sur comment jointes propriétés, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objet de dépendance à partir duquel obtenir le <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Récupère la valeur <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> du <see cref="T:System.Windows.Media.Animation.Timeline" /> spécifié.</summary>
        <returns>Propriété ciblée par <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode obtient le <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propriété jointe sur l’objet spécifié. Pour plus d’informations sur le fonctionne de la table de montage séquentiel ciblant, consultez <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propriété jointe. Pour plus d’informations sur comment jointes propriétés, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Notez que si le <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> a été défini dans le balisage, cette méthode retourne un vide <xref:System.Windows.PropertyPath> , car la référence de propriété est résolue et stockée en interne lors de l’analyse.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Suspend <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspend <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode suspend le storyboard, mais n’a aucun effet visible si elle n’est pas actif ou actuellement en pause. En conséquence, tous les enfants associés sont également suspendues.  
  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>À partir d’une table de montage séquentiel suspendue  
 Lorsque vous <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> une animation qui a été suspendue, elle semble redémarrer. Toutefois, ce n’est pas ce qui se passe réellement. Le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode remplace en fait le suspendu <xref:System.Windows.Media.Animation.Storyboard> avec une nouvelle version non suspendue. Chaque fois que le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est appelée, objets d’horloge sont créés pour la table de montage séquentiel. Ces horloges sont distribuées aux propriétés qu’ils animent. Donc, quand le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est appelée à nouveau, il ne redémarre pas ses horloges ; il les remplace par de nouvelles.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Suspend <see cref="T:System.Windows.Media.Animation.Clock" /> du <see cref="T:System.Windows.FrameworkContentElement" /> spécifié associé à <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode suspend le storyboard, mais n’a aucun effet visible si elle n’est pas actif ou actuellement en pause. En conséquence, tous les enfants associés sont également suspendues.  
  
 Recherche une table de montage séquentiel suspendue ne pas reprend. La seule façon de reprendre une table de montage séquentiel suspendue consiste à utiliser le <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (méthode). Appel de la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode remplace à nouveau la table de montage séquentiel suspendue par un autre, ce qui a l’apparence de la reprise.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suspension des déclencheurs de l’horloge d’une table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événement.  
  
## <a name="beginning-a-paused-storyboard"></a>À partir d’une table de montage séquentiel suspendue  
 Lorsque vous <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> une animation qui a été suspendue, elle semble redémarrer. Toutefois, ce n’est pas ce qui se passe réellement. Le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode remplace en fait avec une version non suspendue. Chaque fois que le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est appelée, objets d’horloge sont créés pour la table de montage séquentiel. Ces horloges sont distribuées aux propriétés qu’ils animent. Donc, quand le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est appelée à nouveau, il ne redémarre pas ses horloges ; il les remplace par de nouvelles.  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Suspend <see cref="T:System.Windows.Media.Animation.Clock" /> du <see cref="T:System.Windows.FrameworkElement" /> spécifié associé à <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode suspend le storyboard, mais n’a aucun effet visible si elle n’est pas actif ou actuellement en pause. En conséquence, tous les enfants associés sont également suspendues.  
  
 Recherche une table de montage séquentiel suspendue ne pas reprend. La seule façon de reprendre une table de montage séquentiel suspendue consiste à utiliser le <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (méthode). Appel de la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode remplace à nouveau la table de montage séquentiel suspendue par un autre, ce qui a l’apparence de la reprise.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suspension des déclencheurs de l’horloge d’une table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événement.  
  
## <a name="beginning-a-paused-storyboard"></a>À partir d’une table de montage séquentiel suspendue  
 Lorsque vous <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> une animation qui a été suspendue, elle semble redémarrer. Toutefois, ce n’est pas ce qui se passe réellement. Le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode remplace en fait avec une version non suspendue. Chaque fois que le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est appelée, objets d’horloge sont créés pour la table de montage séquentiel. Ces horloges sont distribuées aux propriétés qu’ils animent. Donc, quand le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est appelée à nouveau, il ne redémarre pas ses horloges ; il les remplace par de nouvelles.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour <see cref="T:System.Windows.Media.Animation.Storyboard" />. Les animations qui font partie de <see cref="T:System.Windows.Media.Animation.Storyboard" /> n'affectent plus les propriétés qu'elles animaient auparavant, indépendamment de leur paramètre <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour <see cref="T:System.Windows.Media.Animation.Storyboard" />. Les animations qui font partie de <see cref="T:System.Windows.Media.Animation.Storyboard" /> n'affectent plus les propriétés qu'elles animaient auparavant, indépendamment de leur paramètre <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Toutes les actions interactives effectuées sur un <xref:System.Windows.Media.Animation.Clock>et par conséquent également sur un <xref:System.Windows.Media.Animation.Storyboard>, se produisent sur le prochain cycle de moteur de minutage, ce qui se produit peu de temps avant le rendu suivant. Cela signifie que le <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> méthode affecte toujours les propriétés animées jusqu'à ce moment. En d’autres termes, la prochaine fois que le frame est affiché, la table de montage séquentiel est supprimée. Si vous devez dissocier une animation d’une propriété avant cette date, utilisez le <xref:System.Windows.UIElement.BeginAnimation%2A> méthode avec un `animation` valeur du paramètre de `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Supprime les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour <see cref="T:System.Windows.Media.Animation.Storyboard" />. Les animations qui font partie de <see cref="T:System.Windows.Media.Animation.Storyboard" /> n'affectent plus les propriétés qu'elles animaient auparavant, indépendamment de leur paramètre <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suppression de déclencheurs de l’horloge d’une table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Supprime les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour <see cref="T:System.Windows.Media.Animation.Storyboard" />. Les animations qui font partie de <see cref="T:System.Windows.Media.Animation.Storyboard" /> n'affectent plus les propriétés qu'elles animaient auparavant, indépendamment de leur paramètre <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suppression de déclencheurs de l’horloge d’une table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reprend <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reprend <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Reprend <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La reprise d’une table de montage séquentiel qui n’est pas interrompue n’a aucun effet.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Recherche une table de montage séquentiel suspendue ne pas reprend. La seule façon de reprendre une table de montage séquentiel suspendue consiste à utiliser le <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (méthode). Appel de la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode après le démarrage de la table de montage séquentiel remplace l’ancienne table de montage séquentiel, qui a l’apparence de la reprise.  
  
 La reprise d’une horloge d’une table de montage séquentiel déclenche suspendu le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événement.  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Reprend <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La reprise d’une table de montage séquentiel qui n’est pas interrompue n’a aucun effet.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Recherche une table de montage séquentiel suspendue ne pas reprend. La seule façon de reprendre une table de montage séquentiel suspendue consiste à utiliser le <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> (méthode). Appel de la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode après le démarrage de la table de montage séquentiel remplace l’ancienne table de montage séquentiel, qui a l’apparence de la reprise.  
  
 La reprise d’une horloge d’une table de montage séquentiel déclenche suspendu le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à une nouvelle position lorsque le battement d'horloge suivant se produit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valeur négative ou positive qui décrit la durée nécessaire pour que la chronologie avance ou recule.</param>
        <summary>Recherche ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à la position spécifiée. Le <see cref="T:System.Windows.Media.Animation.Storyboard" /> exécute la recherche demandée lors du battement d'horloge suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valeur positive ou négative qui décrit la valeur du déplacement de la chronologie vers l’avant ou vers l’arrière par rapport à l’élément <c>origin</c> spécifié.</param>
        <param name="origin">Position à partir de laquelle <c>offset</c> est appliqué.</param>
        <summary>Recherche ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à la position spécifiée. Le <see cref="T:System.Windows.Media.Animation.Storyboard" /> exécute la recherche demandée lors du battement d'horloge suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <param name="offset">Valeur positive ou négative qui décrit la valeur du déplacement de la chronologie vers l’avant ou vers l’arrière par rapport à l’élément <c>origin</c> spécifié.</param>
        <param name="origin">Position à partir de laquelle <c>offset</c> est appliqué.</param>
        <summary>Recherche ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à la position spécifiée. Le <see cref="T:System.Windows.Media.Animation.Storyboard" /> exécute la recherche demandée lors du battement d'horloge suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Cette méthode modifie l’horloge d’animation <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> à <xref:System.Windows.Media.Animation.ClockState.Active>. Cette méthode n’a aucun effet sur l’arborescence de minutage jusqu'à la prochaine fois qu’un cycle est traité. Comme un effet secondaire, les événements appropriés sont également pas déclenchés d’ici là.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Recherche un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements.  
  
   
  
## Examples  
 L’exemple suivant montre les deux le <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> et <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> méthodes.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <param name="offset">Valeur positive ou négative qui décrit la valeur du déplacement de la chronologie vers l’avant ou vers l’arrière par rapport à l’élément <c>origin</c> spécifié.</param>
        <param name="origin">Position à partir de laquelle <c>offset</c> est appliqué.</param>
        <summary>Recherche ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> à la position spécifiée. Le <see cref="T:System.Windows.Media.Animation.Storyboard" /> exécute la recherche demandée lors du battement d'horloge suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Cette méthode modifie l’horloge d’animation <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> à <xref:System.Windows.Media.Animation.ClockState.Active>. Cette méthode n’a aucun effet sur l’arborescence de minutage jusqu'à la prochaine fois qu’un cycle est traité. Comme un effet secondaire, les événements appropriés sont également pas déclenchés d’ici là.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimée si elle est rendue contrôlable. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Recherche un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements.  
  
   
  
## Examples  
 L’exemple suivant montre comment rechercher (ignorer) à une seconde après qu’un Storyboard commence.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 L’exemple suivant montre les deux le <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> et <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> méthodes.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche immédiatement ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> dans une nouvelle position (de façon synchrone).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valeur négative ou positive qui décrit la durée nécessaire pour que la chronologie avance ou recule.</param>
        <summary>Recherche immédiatement ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> dans une nouvelle position (de façon synchrone).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Aligne la durée recherchée de le <xref:System.Windows.Media.Animation.Storyboard> avec le dernier cycle d’horloge. Les valeurs sont immédiatement mis à jour pour refléter les modifications dues à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, même si l’écran ne reflète pas ces modifications jusqu'à ce que les mises à jour de l’écran.  
  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valeur positive ou négative qui décrit la valeur du déplacement de la chronologie vers l’avant ou vers l’arrière par rapport à l’élément <c>origin</c> spécifié.</param>
        <param name="origin">Position à partir de laquelle <c>offset</c> est appliqué.</param>
        <summary>Recherche immédiatement ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> dans une nouvelle position (de façon synchrone).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Aligne la durée recherchée de le <xref:System.Windows.Media.Animation.Storyboard> avec le dernier cycle d’horloge. Les valeurs sont immédiatement mis à jour pour refléter les modifications dues à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, même si l’écran ne reflète pas ces modifications jusqu'à ce que les mises à jour de l’écran.  
  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <param name="offset">Valeur positive ou négative qui décrit la valeur du déplacement de la chronologie vers l’avant ou vers l’arrière par rapport à l’élément <c>origin</c> spécifié.</param>
        <param name="origin">Position à partir de laquelle <c>offset</c> est appliqué.</param>
        <summary>Recherche immédiatement ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> dans une nouvelle position (de façon synchrone).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Aligne la durée recherchée de le <xref:System.Windows.Media.Animation.Storyboard> avec le dernier cycle d’horloge. Les valeurs sont immédiatement mis à jour pour refléter les modifications dues à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, même si l’écran ne reflète pas ces modifications jusqu'à ce que les mises à jour de l’écran.  
  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Cette méthode modifie l’horloge d’animation <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> à  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Recherche un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 L’exemple suivant montre les deux le <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> et <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> méthodes.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <param name="offset">Valeur positive ou négative qui décrit la valeur du déplacement de la chronologie vers l’avant ou vers l’arrière par rapport à l’élément <c>origin</c> spécifié.</param>
        <param name="origin">Position à partir de laquelle <c>offset</c> est appliqué.</param>
        <summary>Recherche immédiatement ce <see cref="T:System.Windows.Media.Animation.Storyboard" /> dans une nouvelle position (de façon synchrone).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Aligne la durée recherchée de le <xref:System.Windows.Media.Animation.Storyboard> avec le dernier cycle d’horloge. Les valeurs sont immédiatement mis à jour pour refléter les modifications dues à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, même si l’écran ne reflète pas ces modifications jusqu'à ce que les mises à jour de l’écran.  
  
 Notez que les opérations de recherche ne prennent pas de la table de montage séquentiel <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> compte des paramètres. La table de montage séquentiel est traité comme s’il a un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> égale à 1 et aucune <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Cette méthode modifie l’horloge d’animation <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> à  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Recherche un déclencheurs de la table de montage séquentiel le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 L’exemple suivant montre les deux le <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> et <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> méthodes.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit le quotient de vitesse interactif pour le <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Valeur finie supérieure à zéro, qui est le nouveau quotient de vitesse interactif du plan conceptuel. Cette valeur est multipliée contre la valeur <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de la table de montage séquentiel pour déterminer la vitesse effective de la table de montage séquentiel. Cette valeur ne remplace pas la propriété <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de la table de montage séquentiel. Par exemple, l'appel de cette méthode et la spécification d'un quotient de vitesse interactif de 3 sur une table de montage séquentiel avec un <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de 0,5 donnent une vitesse effective de 1,5 à la table de montage séquentiel.</param>
        <summary>Définit le quotient de vitesse interactif pour le <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour ce <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <param name="speedRatio">Valeur finie supérieure à zéro, qui est le nouveau quotient de vitesse interactif du plan conceptuel. Cette valeur est multipliée contre la valeur <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de la table de montage séquentiel pour déterminer la vitesse effective de la table de montage séquentiel. Cette valeur ne remplace pas la propriété <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de la table de montage séquentiel. Par exemple, l'appel de cette méthode et la spécification d'un quotient de vitesse interactif de 3 sur une table de montage séquentiel avec un <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de 0,5 donnent une vitesse effective de 1,5 à la table de montage séquentiel.</param>
        <summary>Définit le quotient de vitesse interactif de <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 L’appel de cette méthode déclenche la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événement.  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <param name="speedRatio">Valeur finie supérieure à zéro, qui est le nouveau quotient de vitesse interactif du plan conceptuel. Cette valeur est multipliée contre la valeur <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de la table de montage séquentiel pour déterminer la vitesse effective de la table de montage séquentiel. Cette valeur ne remplace pas la propriété <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de la table de montage séquentiel. Par exemple, l'appel de cette méthode et la spécification d'un quotient de vitesse interactif de 3 sur une table de montage séquentiel avec un <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de 0,5 donnent une vitesse effective de 1,5 à la table de montage séquentiel.</param>
        <summary>Définit le quotient de vitesse interactif de <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 L’appel de cette méthode déclenche la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> qui doit cibler l'objet de dépendance spécifié.</param>
        <param name="value">Objet de dépendance à cibler.</param>
        <summary>Permet que le <see cref="T:System.Windows.Media.Animation.Timeline" /> spécifié cible l'objet de dépendance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit le <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propriété jointe sur l’objet spécifié. Pour plus d’informations sur le fonctionne de la table de montage séquentiel ciblant, consultez <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Pour plus d’informations sur comment jointes propriétés, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  Le <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propriété n’est pas sérialisable, car elle peut être définie sur any <xref:System.Windows.DependencyObject>. Il n’est pas garanti que cet objet puisse être correctement référencé à partir de XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> qui doit cibler l'objet de dépendance spécifié.</param>
        <param name="name">Nom de l’objet de dépendance à cibler.</param>
        <summary>Permet que le <see cref="T:System.Windows.Media.Animation.Timeline" /> spécifié cible l'objet de dépendance avec le nom spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit le <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> propriété jointe sur l’objet spécifié. Pour plus d’informations sur le fonctionne de la table de montage séquentiel ciblant, consultez <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Pour plus d’informations sur comment jointes propriétés, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> avec lequel associer la propriété de dépendance spécifiée.</param>
        <param name="path">Chemin qui décrit la propriété de dépendance à animer.</param>
        <summary>Permet que le <see cref="T:System.Windows.Media.Animation.Timeline" /> spécifié cible la propriété de dépendance spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit le <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propriété jointe sur l’objet spécifié. Pour plus d’informations sur le fonctionne de la table de montage séquentiel ciblant, consultez <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Pour plus d’informations sur comment jointes propriétés, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avance l'heure actuelle du <see cref="T:System.Windows.Media.Animation.Clock" /> de cette table de montage séquentiel jusqu'à la fin de sa période active.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avance l'heure actuelle du <see cref="T:System.Windows.Media.Animation.Clock" /> de cette table de montage séquentiel jusqu'à la fin de sa période active.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Avance l'heure actuelle du <see cref="T:System.Windows.Media.Animation.Clock" /> de cette table de montage séquentiel jusqu'à la fin de sa période active.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode avance la table de montage séquentiel heure actuelle à la fin de sa période active ; comportement de la table de montage séquentiel à ce stade est spécifié par son <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> paramètre. Si <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> a la valeur <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, la table de montage séquentiel se remplit ; si la propriété est définie sur <xref:System.Windows.Media.Animation.FillBehavior.Stop>, les taquets de la table de montage séquentiel.  
  
 Cette méthode est appelée sur une table de montage séquentiel avec une durée illimitée, un nombre infini de répétitions n’a aucun effet. L’appel de cette méthode sur une table de montage séquentiel inactive n’a aucun effet.  
  
 Avancer d’une horloge à son remplissage déclencheurs périodes le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Avance l'heure actuelle du <see cref="T:System.Windows.Media.Animation.Clock" /> de cette table de montage séquentiel jusqu'à la fin de sa période active.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode avance la table de montage séquentiel heure actuelle à la fin de sa période active ; comportement de la table de montage séquentiel à ce stade est spécifié par son <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> paramètre. Si <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> a la valeur <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, la table de montage séquentiel se remplit ; si la propriété est définie sur <xref:System.Windows.Media.Animation.FillBehavior.Stop>, les taquets de la table de montage séquentiel.  
  
 Cette méthode est appelée sur une table de montage séquentiel avec une durée illimitée, un nombre infini de répétitions n’a aucun effet. L’appel de cette méthode sur une table de montage séquentiel inactive n’a aucun effet.  
  
 Avancer d’une horloge à son remplissage déclencheurs périodes le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Arrête <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que l’arrêt d’un storyboard ne déclenche pas le <xref:System.Windows.Media.Animation.Timeline.Completed> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Arrête <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Media.Animation.ClockState.Stopped> storyboard n’affecte plus ses propriétés cibles : les propriétés qui ont été animées reprennent leurs valeurs précédentes.  
  
 L’arrêt d’une horloge déclenche le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements, mais pas le <xref:System.Windows.Media.Animation.Timeline.Completed> événement.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 L’exemple suivant utilise une table de montage séquentiel contrôlable pour animer un <xref:System.Windows.Media.TextEffect>. Le <xref:System.Windows.Media.TextEffect> est contenue dans un <xref:System.Windows.FrameworkContentElement>du nom d’étendue.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objet spécifié lorsque la méthode <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> a été appelée. Cet objet contient les objets <see cref="T:System.Windows.Media.Animation.Clock" /> qui ont été créés pour ce storyboard et ses enfants.</param>
        <summary>Arrête <see cref="T:System.Windows.Media.Animation.Clock" /> qui a été créé pour <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Media.Animation.ClockState.Stopped> storyboard n’affecte plus ses propriétés cibles : les propriétés qui ont été animées reprennent leurs valeurs précédentes.  
  
 L’arrêt d’une horloge déclenche le <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> et <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> événements, mais pas le <xref:System.Windows.Media.Animation.Timeline.Completed> événement.  
  
 Pour contrôler cette table de montage séquentiel de façon interactive, vous devez utiliser le même `containingObject` paramètre lors de l’appel des méthodes interactives qui vous permet de commencer le plan conceptuel. Une table de montage séquentiel contrôlable peut suspendre, reprendre, rechercher, arrêter et être supprimés. Pour rendre une table de montage séquentiel contrôlable dans le code, vous devez utiliser la surcharge appropriée de la table de montage séquentiel <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode) et spécifiez `true` pour qu’elle soit contrôlable. Pour obtenir un exemple, consultez [Comment : contrôler un Storyboard après son démarrage](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient ou définit l'objet qui doit être animé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet cible doit être un objet de dépendance.  
  
> [!NOTE]
>  Le <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propriété n’est pas sérialisable, car elle peut être définie sur any <xref:System.Windows.DependencyObject>. Il existe aucune garantie que cet objet peut être référencé correctement dans XAML.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient ou définit le nom de l’objet à animer. L'objet doit être un <see cref="T:System.Windows.FrameworkElement" />, un <see cref="T:System.Windows.FrameworkContentElement" /> ou un <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de cette propriété est facultative. Si le <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> n’est pas spécifié, les animations d’une table de montage séquentiel sont appliquées à une des opérations suivantes :  
  
-   Si la table de montage séquentiel à laquelle appartient l’animation a été démarrée avec un <xref:System.Windows.Media.Animation.BeginStoryboard>, l’élément qui possède le <xref:System.Windows.Media.Animation.BeginStoryboard> action qui déclenche la table de montage séquentiel est ciblée.  
  
-   Si la table de montage séquentiel a été démarré à l’aide de la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> (méthode), le <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement> spécifié lorsque l’animation a été démarrée avec le <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> méthode est ciblée.  
  
 Lorsque cette propriété est définie sur une chronologie avec des enfants, ces chronologies enfants « héritent » du parent <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> , sauf si elles spécifient leurs propres.  
  
## <a name="making-an-object-targetable"></a>Rendre un objet pouvant être ciblées  
 Lorsque vous utilisez [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], vous effectuez l’une des deux actions suivantes pour rendre un objet pouvant être ciblées par une table de montage séquentiel :  
  
-   Si l’objet est un <xref:System.Windows.FrameworkElement> ou un <xref:System.Windows.FrameworkContentElement>, définissez son <xref:System.Windows.FrameworkElement.Name%2A> propriété.  
  
-   Si l’objet est un <xref:System.Windows.Freezable> ou personnalisé <xref:System.Windows.FrameworkContentElement> ou <xref:System.Windows.FrameworkContentElement>, attribuez-lui un nom à l’aide de la [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md) extension de balisage.  
  
 Lorsque vous utilisez le code, vous rendez un objet pouvant être ciblées à l’aide de la <xref:System.Windows.NameScope.RegisterName%2A> méthode pour attribuer l’objet un nom.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété jointe <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété jointe <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété jointe <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>