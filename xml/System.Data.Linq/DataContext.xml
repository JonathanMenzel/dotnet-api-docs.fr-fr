<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DataContext.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-567ae5a" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7c5b04be-ac4f-4958-bcde-0afae0584552159bccce18dd45bee0b51643dd362a7301a71164.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">159bccce18dd45bee0b51643dd362a7301a71164</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3507e865a3613c00760f25ad1045aaa11bae4dd8</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/23/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Represents the main entry point for the LINQ to SQL framework.</source>
          <target state="translated">Représente le point d’entrée principal de l’infrastructure LINQ to SQL.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is the source of all entities mapped over a database connection.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> est la source de toutes les entités sont mappées sur une connexion de base de données.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>It tracks changes that you made to all retrieved entities and maintains an "identity cache" that guarantees that entities retrieved more than one time are represented by using the same object instance.</source>
          <target state="translated">Suivi des modifications que vous avez apportées à toutes les entités récupérées et maintient un « cache d’identité » qui garantit que les entités récupérées plusieurs fois est représentées par à l’aide de la même instance d’objet.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>In general, a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instance is designed to last for one "unit of work" however your application defines that term.</source>
          <target state="translated">En règle générale, un <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instance est conçue pour avoir un « unité de travail » toutefois votre application définit ce terme.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>A <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is lightweight and is not expensive to create.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> est léger et n’est pas difficile à créer.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>A typical <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> application creates <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instances at method scope or as a member of short-lived classes that represent a logical set of related database operations.</source>
          <target state="translated">Par défaut <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> application crée <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> instances au niveau de la portée de la méthode ou en tant que membre des classes de courte durée de vie qui représentent un ensemble logique de liées des opérations de base de données.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>The connection string you use can be an ADO.NET connection string.</source>
          <target state="translated">La chaîne de connexion que vous utilisez peut être une chaîne de connexion ADO.NET.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>You can also specify a filename to a SQL Server Express or SQL Server Compact file.</source>
          <target state="translated">Vous pouvez également spécifier un nom de fichier pour un fichier SQL Server Express ou SQL Server Compact.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>The connection used by the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">Connexion utilisée par le <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing the connection used by the <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> en référençant la connexion utilisée par le <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>A <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> opens and closes a database connection as needed if you provide a closed connection or a connection string.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> s’ouvre et ferme une connexion de base de données en fonction des besoins si vous fournissez une connexion fermée ou une chaîne de connexion.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>In general, you should never have to call <ph id="ph1">`Dispose`</ph> on a <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">En règle générale, vous ne devriez jamais avoir à appeler <ph id="ph1">`Dispose`</ph> sur un <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>If you provide an open connection, the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> will not close it.</source>
          <target state="translated">Si vous fournissez une connexion ouverte, la <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> fermera pas.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>Therefore, do not instantiate a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> with an open connection unless you have a good reason to do this.</source>
          <target state="translated">Par conséquent, n’instanciez pas un <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> avec une connexion ouverte, sauf si vous avez une bonne raison à cela.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)">
          <source>In a <ph id="ph1">&lt;xref:System.Transactions&gt;</ph> transaction, a <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> will not open or close a connection to avoid promotion.</source>
          <target state="translated">Dans un <ph id="ph1">&lt;xref:System.Transactions&gt;</ph> transaction, un <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> ne sera pas ouvrir ou fermer une connexion pour éviter la promotion.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)">
          <source>The connection used by the .NET Framework.</source>
          <target state="translated">Connexion utilisée par le .NET Framework.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)">
          <source>A source for mapping.</source>
          <target state="translated">Source pour le mappage.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing a connection and a mapping source.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> en référençant une connexion et une source de mappage.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>This argument can be any one of the following:</source>
          <target state="translated">Cet argument peut être l'un des éléments suivants :</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>The name of a file where a SQL Server Express database resides.</source>
          <target state="translated">le nom d'un fichier où réside une base de données SQL Server Express ;</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>The name of a server where a database is present.</source>
          <target state="translated">le nom d'un serveur où une base de données est présente ;</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>In this case the provider uses the default database for a user.</source>
          <target state="translated">dans ce cas le fournisseur utilise la base de données par défaut d'un utilisateur ;</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>A complete connection string.</source>
          <target state="translated">Chaîne de connexion complète.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> just passes the string to the provider without modification.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> passe juste la chaîne au fournisseur sans modification.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>A source for mapping.</source>
          <target state="translated">Source pour le mappage.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing a file source and a mapping source.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> en référençant une source de fichier et une source de mappage.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class by referencing a file source.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> en référençant une source de fichier.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.ChangeConflicts">
          <source>Gets a collection of objects that caused concurrency conflicts when <ph id="ph1">&lt;see cref="M:System.Data.Linq.DataContext.SubmitChanges" /&gt;</ph> was called.</source>
          <target state="translated">Obtient une collection des objets qui ont provoqué des conflits d'accès concurrentiel lors de l'appel à <ph id="ph1">&lt;see cref="M:System.Data.Linq.DataContext.SubmitChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ChangeConflicts">
          <source>A collection of objects that caused concurrency conflicts.</source>
          <target state="translated">Collection d'objets qui ont provoqué des conflits d'accès concurrentiel.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ChangeConflicts">
          <source>The following example shows how the collection can be iterated over to retrieve conflict information.</source>
          <target state="translated">L’exemple suivant montre comment la collection peut être itérée pour récupérer des informations sur les conflits.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>Gets or sets a value that increases the time-out period for queries that would otherwise time out during the default time-out period.</source>
          <target state="translated">Obtient ou définit une valeur entière qui augmente le délai d'attente pour les requêtes qui, sinon, expireraient pendant le délai d'attente par défaut.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>An integer value that increases the time-out period for queries that would otherwise time out during the default time-out period.</source>
          <target state="translated">Valeur entière qui augmente le délai d'attente pour les requêtes qui, sinon, expireraient pendant le délai d'attente par défaut.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>This property gets or sets the command time-out used to execute generated commands (<ph id="ph1">`IDbCommands`</ph>).</source>
          <target state="translated">Cette propriété obtient ou définit le délai d’expiration de commande utilisé pour exécuter les commandes générées (<ph id="ph1">`IDbCommands`</ph>).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>When this property is not set, the default value of <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph> is used for query command execution.</source>
          <target state="translated">Lorsque cette propriété est non définie, la valeur par défaut de <ph id="ph1">&lt;xref:System.Data.IDbCommand.CommandTimeout%2A&gt;</ph> est utilisé pour l’exécution de commande de requête.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>This default value is set by the storage provider.</source>
          <target state="translated">Cette valeur par défaut est définie par le fournisseur de stockage.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.CommandTimeout">
          <source>Note that some providers may throw exceptions if this value is set to a non-zero value.</source>
          <target state="translated">Notez que certains fournisseurs peuvent lever des exceptions si cette valeur est définie sur une valeur différente de zéro.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Connection">
          <source>Gets the connection used by the framework.</source>
          <target state="translated">Obtient la connexion utilisée par l'infrastructure.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Connection">
          <source>The connection used by the framework.</source>
          <target state="translated">Connexion utilisée par l'infrastructure.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Connection">
          <source>You can use this property to interoperate with relational ADO.NET code.</source>
          <target state="translated">Vous pouvez utiliser cette propriété pour interagir avec le code ADO.NET relationnel.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Connection">
          <source>The returned connection will be closed unless it has been explicitly opened by the user.</source>
          <target state="translated">La connexion retournée va être fermée, sauf si elle a été ouverte explicitement par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>Creates a database on the server.</source>
          <target state="translated">Crée une base de données sur le serveur.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>The name of the database is derived by using the following algorithm:</source>
          <target state="translated">Le nom de la base de données est dérivé à l’aide de l’algorithme suivant :</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If a database is identified in the connection string, its name is used.</source>
          <target state="translated">Si une base de données est identifiée dans la chaîne de connexion, son nom est utilisé.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If a <ph id="ph1">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute&gt;</ph> attribute is present, its <ph id="ph2">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A&gt;</ph> property is used as the name of the database.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute&gt;</ph> attribut est présent, sa <ph id="ph2">&lt;xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A&gt;</ph> propriété est utilisée en tant que le nom de la base de données.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If there is no database tag in the connection string and a strongly typed <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is used, a database that has the same name as the <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> inheriting class is checked.</source>
          <target state="translated">S’il n’existe aucune balise de base de données dans la chaîne de connexion et fortement typé <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> est utilisé, une base de données qui a le même nom que le <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph> héritage de classe est activée.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If a weakly typed <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is used, an exception is thrown.</source>
          <target state="translated">Si un faiblement typé <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> est utilisé, une exception est levée.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>If the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> has been created by using a file name, the database corresponding to that file name is created.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> a été créé en utilisant un nom de fichier, la base de données correspondant à ce nom de fichier est créé.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateDatabase">
          <source>The following code shows how to set up a temporary database and then remove it.</source>
          <target state="translated">Le code suivant montre comment configurer une base de données temporaire et les supprimer.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The type of the elements in the returned collection.</source>
          <target state="translated">Type des éléments de la collection retournée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The instance of the method invocation (the current object).</source>
          <target state="translated">Instance de l'appel de la méthode (l'objet actif).</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> that identifies the CLR method that corresponds to a database method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> qui identifie la méthode CLR qui correspond à une méthode de base de données.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">Tableau de paramètres à passer à la commande.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>Executes the table-valued database function associated with the specified CLR method.</source>
          <target state="translated">Exécute la fonction de base de données table associée à la méthode CLR spécifiée.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>A collection of resultant values returned by the database query.</source>
          <target state="translated">Collection de valeurs résultantes retournée par la requête de base de données.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A&gt;</ph> method is used in automatically generated code and acts as a proxy to database functions.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A&gt;</ph> méthode est utilisée dans le code généré automatiquement et agit comme un proxy pour les fonctions de base de données.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source>Determines whether the associated database can be opened.</source>
          <target state="translated">Détermine si la base de données associée peut être ouverte.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified database can be opened; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la base de données spécifiée peut être ouverte ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source>This method uses the connection in the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> property to attempt to open the associated database.</source>
          <target state="translated">Cette méthode utilise la connexion dans le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> propriété pour essayer d’ouvrir la base de données associée.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DatabaseExists">
          <source>The following example uses this method to determine whether a database already exists.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour déterminer si une base de données existe déjà.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Gets or sets a value that indicates whether to delay-load one-to-many or one-to-one relationships.</source>
          <target state="translated">Obtient ou définit une valeur qui indique s'il faut charger en différé les relations un-à-plusieurs ou un-à-un.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if deferred loading is enabled; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le chargement différé est activé ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>When the code accesses one of these relationships, null is returned if the relationship is one-to-one, and an empty collection is returned if it is one-to-many.</source>
          <target state="translated">Lorsque le code accède à l’une de ces relations, null est retournée si la relation est d’un à un, et une collection vide est retournée si elle est de type un-à-plusieurs.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>The relationships can still be filled by setting the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.LoadOptions%2A&gt;</ph> property.</source>
          <target state="translated">Les relations peuvent toujours être renseignées en définissant le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.LoadOptions%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>The main scenario for this property is to enable you to extract a piece of the object model and send it out (for example, to a Web service).</source>
          <target state="translated">Le scénario principal de cette propriété est pour vous permettre d’extraire une partie du modèle d’objet et l’envoyer (par exemple, pour un service Web).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>If this property is set to <ph id="ph1">`false`</ph> after a query has been executed, an exception is thrown.</source>
          <target state="translated">Si cette propriété est définie sur <ph id="ph1">`false`</ph> après l’exécution d’une requête, une exception est levée.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>See the <bpt id="p1">**</bpt>Valid Modes<ept id="p1">**</ept> section below for more information.</source>
          <target state="translated">Consultez le <bpt id="p1">**</bpt>Modes valides<ept id="p1">**</ept> section ci-dessous pour plus d’informations.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Valid modes</source>
          <target state="translated">Modes valides</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Deferred loading requires object tracking.</source>
          <target state="translated">Chargement différé requiert le suivi de l’objet.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Only the following three modes are valid:</source>
          <target state="translated">Seuls les trois modes suivants sont valides :</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> is ignored and inferred to be <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> est ignoré et déduit que <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>This behavior corresponds to a read-only <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Ce comportement correspond en lecture seule <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph><ph id="ph2"> = </ph><ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>This situation corresponds to a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> that allows users to load an object graph by using <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> directives, but it does not enable deferred loading.</source>
          <target state="translated">Cette situation correspond à un <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> qui permet aux utilisateurs de charger un graphique d’objet à l’aide de <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> directives, mais il n’active pas le chargement différé.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Both are set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Les deux ont la valeur <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>This is the default.</source>
          <target state="translated">Il s'agit de la valeur par défaut.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>The flags may not be changed after a query has been executed.</source>
          <target state="translated">Les indicateurs ne peuvent pas être modifiées après l’exécution d’une requête.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.DeferredLoadingEnabled">
          <source>Any change after the execution of the first query that uses that <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> throws an exception.</source>
          <target state="translated">Toute modification apportée après l’exécution de la première requête qui utilise ce <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> lève une exception.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.DeleteDatabase">
          <source>Deletes the associated database.</source>
          <target state="translated">Supprime la base de données associée.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DeleteDatabase">
          <source>This method uses the connection in the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> property to identify the database to be deleted.</source>
          <target state="translated">Cette méthode utilise la connexion dans le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.Connection%2A&gt;</ph> propriété pour identifier la base de données à supprimer.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.DeleteDatabase">
          <source>The following example shows how to delete a database that has been temporarily created.</source>
          <target state="translated">L’exemple suivant montre comment supprimer une base de données qui a été créé temporairement.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Releases the resources used by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class.</source>
          <target state="translated">Libère les ressources utilisées par la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour libérer les ressources managées et non managées ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> pour ne libérer que les ressources non managées.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> class and optionally releases the managed resource.</source>
          <target state="translated">Libère les ressources non managées utilisées par la classe <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> et libère éventuellement la ressource managée.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The SQL command to be executed.</source>
          <target state="translated">Commande SQL à exécuter.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">Tableau de paramètres à passer à la commande.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>Note the following behavior:</source>
          <target state="translated">Notez le comportement suivant :</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</source>
          <target state="translated">Si le nombre d'objets dans le tableau est inférieur au nombre le plus élevé identifié dans la chaîne de commande, une exception est levée.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>If the array contains objects that are not referenced in the command string, no exception is thrown.</source>
          <target state="translated">Si le tableau contient des objets qui ne sont pas référencés dans la chaîne de commande, aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>If any one of the parameters is null, it is converted to <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">Si l'un des paramètres est null, il est converti en <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>Executes SQL commands directly on the database.</source>
          <target state="translated">Exécute les commandes SQL directement sur la base de données.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The number of rows modified by the executed command.</source>
          <target state="translated">Nombre de lignes modifiées par la commande exécutée.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>This method is a pass-through mechanism for cases where <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> does not adequately provide for a particular scenario.</source>
          <target state="translated">Cette méthode est un mécanisme direct pour les cas où <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> ne fournit pas suffisamment pour un scénario particulier.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The syntax for the command is almost the same as the syntax used to create an ADO.NET <ph id="ph1">`DataCommand`</ph>.</source>
          <target state="translated">La syntaxe de la commande est presque identique à la syntaxe utilisée pour créer un élément ADO.NET <ph id="ph1">`DataCommand`</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The only difference is in how the parameters are specified.</source>
          <target state="translated">La seule différence est dans la façon dont les paramètres sont spécifiés.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>Specifically, you specify parameters by enclosing them in braces ({…}) and enumerate them starting from 0.</source>
          <target state="translated">Plus précisément, vous spécifiez des paramètres en les plaçant entre accolades ({...}), les énumérer à partir de 0.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The parameter is associated with the equally numbered object in the parameters array.</source>
          <target state="translated">Le paramètre est associé à l’objet de même numéro dans le tableau de paramètres.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source><ph id="ph1">`ExecuteQuery`</ph> and <ph id="ph2">`ExecuteCommand`</ph> allow you to specify a variable number of arguments for parameter substitution.</source>
          <target state="translated"><ph id="ph1">`ExecuteQuery`</ph> et <ph id="ph2">`ExecuteCommand`</ph> vous permettent de spécifier un nombre variable d’arguments pour la substitution de paramètre.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>For example, you can specify the parameters when invoking ExecuteQuery<ph id="ph1">\&lt;</ph>TResult&gt;:</source>
          <target state="translated">Par exemple, vous pouvez spécifier les paramètres lorsque vous appelez ExecuteQuery<ph id="ph1">\&lt;</ph>TResult &gt; :</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>And, another example:</source>
          <target state="translated">Ainsi, un autre exemple :</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])">
          <source>The following example opens a connection and passes a SQL <ph id="ph1">`UPDATE`</ph> command to the SQL engine.</source>
          <target state="translated">L’exemple suivant ouvre une connexion et passe une SQL <ph id="ph1">`UPDATE`</ph> commande au moteur SQL.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)">
          <source>The entity to be deleted.</source>
          <target state="translated">Entité à supprimer.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)">
          <source>Executes, inside delete override methods, to redelegate to <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> the task of generating and executing dynamic SQL for delete operations.</source>
          <target state="translated">S'exécute à l'intérieur des méthodes override de suppression pour déléguer à nouveau à <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> la tâche de génération et d'exécution de SQL dynamique pour les opérations de suppression.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>The entity to be inserted.</source>
          <target state="translated">Entité à insérer.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>Executes, inside insert override methods, to redelegate to <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> the task of generating and executing dynamic SQL for insert operations.</source>
          <target state="translated">S’exécute à l’intérieur des méthodes override d’insertion pour redéléguer à <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> la tâche de génération et d’exécution d’instructions SQL dynamique pour les opérations d’insertion.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>Note the following considerations:</source>
          <target state="translated">Notez les points suivants :</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>Because the method has a protected modifier, its use requires subclassing <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">La méthode a un modificateur protected, son utilisation requiert le sous-classement <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>An exception is thrown if this operation is not called inside a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> operation.</source>
          <target state="translated">Une exception est levée si cette opération n’est pas appelée à l’intérieur d’un <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> opération.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>It is not intended to be called as a stand-alone operation outside the scope of a <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> operation.</source>
          <target state="translated">Elle n’est pas destinée à être appelé comme une opération autonome à l’extérieur de l’étendue d’un <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> opération.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> itself calls override methods if they are implemented and the previous methods are intended to be called inside the override methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> lui-même appelle des méthodes override si elles sont implémentées et que les méthodes précédentes sont destinées à être appelées dans les méthodes de remplacement.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>It is the responsibility of the developer to pass in the correct entity.</source>
          <target state="translated">Il incombe au développeur de passer de l’entité correcte.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>The implementation verifies that the passed-in entity is tracked.</source>
          <target state="translated">L’implémentation vérifie que l’entité passée est suivie.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>However, it is the responsibility of the developer to maintain the order or pass in the same entity two times.</source>
          <target state="translated">Toutefois, il incombe au développeur de conserver l’ordre ou passer dans la même entité deux fois.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>It is the responsibility of the developer to invoke the correct dynamic API.</source>
          <target state="translated">Il incombe au développeur d’appeler l’API dynamique appropriée.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>For example, in the <ph id="ph1">`Update`</ph> override method, only the <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A&gt;</ph> method can be called.</source>
          <target state="translated">Par exemple, dans le <ph id="ph1">`Update`</ph> substituer la méthode, uniquement le <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A&gt;</ph> méthode peut être appelée.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> does not detect or verify whether the invoked dynamic method matches the applicable operation.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> ne détecte pas ni ne vérifie si la méthode dynamique appelée correspond à l'opération applicable.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)">
          <source>The results are undefined if an inapplicable method is called (for example, calling <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A&gt;</ph> for an object to be updated).</source>
          <target state="translated">Les résultats ne sont pas définis si une méthode inapplicable est appelée (par exemple, l’appel <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A&gt;</ph> pour un objet à mettre à jour).</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)">
          <source>The entity to be updated.</source>
          <target state="translated">Entité à mettre à jour.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)">
          <source>Executes, inside update override methods, to redelegate to <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> the task of generating and executing dynamic SQL for update operations.</source>
          <target state="translated">S'exécute à l'intérieur des méthodes override de mise à jour pour déléguer à nouveau à <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> la tâche de génération et d'exécution de SQL dynamique pour les opérations de mise à jour.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The instance of the method invocation (the current object).</source>
          <target state="translated">Instance de l'appel de la méthode (l'objet actif).</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>Identifies the CLR method that corresponds to a database method.</source>
          <target state="translated">Identifie la méthode CLR qui correspond à une méthode de base de données.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">Tableau de paramètres à passer à la commande.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>Executes the stored database procedure or scalar function associated with the specified CLR method.</source>
          <target state="translated">Exécute la procédure de base de données stockée ou la fonction scalaire associée à la méthode CLR spécifiée.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The result (the return value and output parameters) of executing the specified method.</source>
          <target state="translated">Résultat (valeur de retour et paramètres de sortie) de l'exécution de la méthode spécifiée.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A&gt;</ph> method is used in automatically generated code and acts as a proxy to database functions.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A&gt;</ph> méthode est utilisée dans le code généré automatiquement et agit comme un proxy pour les fonctions de base de données.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The type of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> to be returned.</source>
          <target state="translated">Type de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> à retourner.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The algorithm for matching columns in the result of the query to fields or properties in the object works as follows:</source>
          <target state="translated">L'algorithme qui fait correspondre les colonnes du résultat de la requête aux champs ou aux propriétés de l'objet fonctionne comme suit :</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If a field or property is mapped to a particular column name, that column name is expected in the resultset.</source>
          <target state="translated">Si un champ ou une propriété est mappé à un nom de colonne particulier, ce nom de colonne est attendu dans le jeu de résultats.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</source>
          <target state="translated">Si un champ ou une propriété n'est pas mappé, une colonne de même nom que le champ ou la propriété est attendue dans le jeu de résultats.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The comparison is performed by looking for a case-sensitive match first.</source>
          <target state="translated">la comparaison est effectuée en recherchant en premier une correspondance sensible à la casse.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If this match is not found, a subsequent search occurs for a case-insensitive match.</source>
          <target state="translated">Si cette correspondance est introuvable, une recherche ultérieure est effectuée pour une correspondance qui ne tient pas compte de la casse.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</source>
          <target state="translated">La requête doit retourner tous les champs et propriétés de l'objet pour lesquels un suivi est effectué (excepté ceux qui sont chargés sur une base différée) lorsque toutes les conditions suivantes sont réalisées :</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> is an entity explicitly tracked by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> est une entité faisant explicitement l’objet d’un suivi par <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> est <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The entity has a primary key.</source>
          <target state="translated">L'entité a une clé primaire.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>Otherwise an exception is thrown.</source>
          <target state="translated">Sinon, une exception est levée.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The SQL query to be executed.</source>
          <target state="translated">Requête SQL à exécuter.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">Tableau de paramètres à passer à la commande.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>Note the following behavior:</source>
          <target state="translated">Notez le comportement suivant :</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</source>
          <target state="translated">Si le nombre d'objets dans le tableau est inférieur au nombre le plus élevé identifié dans la chaîne de commande, une exception est levée.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If the array contains objects that are not referenced in the command string, no exception is thrown.</source>
          <target state="translated">Si le tableau contient des objets qui ne sont pas référencés dans la chaîne de commande, aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>If a parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, it is converted to <ph id="ph2">&lt;see langword="DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">Si un paramètre est <ph id="ph1">&lt;see langword="null" /&gt;</ph>, il est converti en <ph id="ph2">&lt;see langword="DBNull.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>Executes SQL queries directly on the database.</source>
          <target state="translated">Exécute des requêtes SQL directement sur la base de données.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of objects returned by the query.</source>
          <target state="translated">Collection <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> d'objets retournés par la requête.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The type of the elements in the returned collection.</source>
          <target state="translated">Type des éléments de la collection retournée.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The SQL query to be executed.</source>
          <target state="translated">Requête SQL à exécuter.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The array of parameters to be passed to the command.</source>
          <target state="translated">Tableau de paramètres à passer à la commande.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>Note the following behavior:</source>
          <target state="translated">Notez le comportement suivant :</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If the number of objects in the array is less than the highest number identified in the command string, an exception is thrown.</source>
          <target state="translated">Si le nombre d'objets dans le tableau est inférieur au nombre le plus élevé identifié dans la chaîne de commande, une exception est levée.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If the array contains objects that are not referenced in the command string, no exception is thrown.</source>
          <target state="translated">Si le tableau contient des objets qui ne sont pas référencés dans la chaîne de commande, aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If a parameter is null, it is converted to <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</source>
          <target state="translated">Si un paramètre est null, il est converti en <ph id="ph1">&lt;see langword="DBNull.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>Executes SQL queries directly on the database and returns objects.</source>
          <target state="translated">Exécute des requêtes SQL directement sur la base de données et retourne des objets.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>A collection of objects returned by the query.</source>
          <target state="translated">Collection d'objets retournés par la requête.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>This method is a pass-through mechanism for cases where <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> does not provide for a particular scenario.</source>
          <target state="translated">Cette méthode est un mécanisme direct pour les cas où <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> ne fournit pas d’un scénario particulier.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The algorithm for matching columns in the result of the query to fields and properties in the object works as follows:</source>
          <target state="translated">L’algorithme pour les colonnes correspondantes dans le résultat de la requête aux champs et propriétés de l’objet fonctionne comme suit :</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If a field or property is mapped to a particular column name, that column name is expected in the resultset.</source>
          <target state="translated">Si un champ ou une propriété est mappé à un nom de colonne particulier, ce nom de colonne est attendu dans le jeu de résultats.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</source>
          <target state="translated">Si un champ ou une propriété n'est pas mappé, une colonne de même nom que le champ ou la propriété est attendue dans le jeu de résultats.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The comparison is performed by first looking for a case-sensitive match.</source>
          <target state="translated">La comparaison est effectuée en recherchant en premier une correspondance qui respecte la casse.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If such a match is not found, a subsequent search occurs for a case-insensitive match.</source>
          <target state="translated">Si une correspondance est introuvable, une recherche ultérieure se produit pour une correspondance de la casse.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The query must return all the tracked fields and properties of the object (apart from those subject to deferred loading) when all the following are true:</source>
          <target state="translated">La requête doit retourner tous les champs suivis et les propriétés de l’objet (à l’exception de ceux soumis à chargement différé) lorsque les conditions suivantes sont remplies :</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>If <ph id="ph1">`&lt;T&gt;`</ph> is an entity explicitly tracked by the <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`&lt;T&gt;`</ph> est une entité suivie explicitement par le <ph id="ph2">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>ObjectTrackingEnabled is true.</source>
          <target state="translated">ObjectTrackingEnabled a la valeur true.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The entity has a primary key.</source>
          <target state="translated">L'entité a une clé primaire.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>Otherwise an exception is thrown.</source>
          <target state="translated">Sinon, une exception est levée.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>In all other cases, the query can retrieve just a subset of the tracked fields and properties for the object.</source>
          <target state="translated">Dans tous les autres cas, la requête peut récupérer uniquement un sous-ensemble des champs suivis et des propriétés de l’objet.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>The following C# snippet shows one use for this method:</source>
          <target state="translated">L’extrait de code c# suivant illustre une utilisation de cette méthode :</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])">
          <source>In Visual Basic</source>
          <target state="translated">En Visual Basic</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Gets the modified objects tracked by <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated">Obtient les objets modifiés suivis par le <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>The set of objects is returned as three read-only collections.</source>
          <target state="translated">L'ensemble des objets est retourné sous la forme de trois collections en lecture seule.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Note the following considerations:</source>
          <target state="translated">Notez les points suivants :</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetChangeSet%2A&gt;</ph> might have side effects, such as inference of insert and delete operations that are usually performed at the time of <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetChangeSet%2A&gt;</ph> peut avoir des effets secondaires, tels que l’inférence d’insérer et supprimer les opérations qui sont habituellement effectuées au moment de <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>For example, objects that are used in the following operations can create corresponding inferred operations in the following list:</source>
          <target state="translated">Par exemple, les objets qui sont utilisés dans les opérations suivantes peuvent créer des opérations déduites correspondantes dans la liste suivante :</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.EntitySet%601.Add%2A&gt;</ph> to <ph id="ph2">&lt;xref:System.Data.Linq.Table%601.InsertOnSubmit%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.EntitySet%601.Add%2A&gt;</ph> pour <ph id="ph2">&lt;xref:System.Data.Linq.Table%601.InsertOnSubmit%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.EntityRef%601&gt;</ph> assignment to null (possibly because of <ph id="ph2">&lt;xref:System.Data.Linq.EntitySet%601.Remove%2A&gt;</ph> to <ph id="ph3">&lt;xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.EntityRef%601&gt;</ph> affectation de null (raison d’éventuellement <ph id="ph2">&lt;xref:System.Data.Linq.EntitySet%601.Remove%2A&gt;</ph> à <ph id="ph3">&lt;xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>The set may not be ordered according to foreign key constraints.</source>
          <target state="translated">Le jeu ne peut pas être trié en fonction des contraintes de clé étrangère.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Database-generated values (for example, primary and foreign key values, timestamps, and so forth) are not available.</source>
          <target state="translated">Valeurs générées par la base de données (par exemple, les valeurs de clés primaires et étrangères, les horodatages, etc.) ne sont pas disponibles.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Such information requires database command execution and perhaps the propagation of retrieved information (for example, foreign key from primary key).</source>
          <target state="translated">De telles informations requièrent l’exécution de commande de base de données et peut-être la propagation d’informations récupérées (par exemple, la clé étrangère à partir de la clé primaire).</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>The set of changed objects is computed at the time of the call.</source>
          <target state="translated">L’ensemble des objets modifiés est calculée au moment de l’appel.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> can produce a different set if additional changes are made.</source>
          <target state="translated">Les appels suivants à <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> peut produire un ensemble différent si des modifications supplémentaires sont apportées.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetChangeSet">
          <source>Output when no changes have been made appears as follows:</source>
          <target state="translated">Sortie lorsque aucune modification a été apportée apparaît comme suit :</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>The query whose SQL command information is to be retrieved.</source>
          <target state="translated">Requête dont les informations de commande de SQL sont à récupérer.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Gets the information about SQL commands generated by <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>.</source>
          <target state="translated">Obtient les informations sur les commandes SQL générées par <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>The requested command information object.</source>
          <target state="translated">Objet d'informations de la commande demandée.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>This method is only a getter and does not affect <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> state.</source>
          <target state="translated">Cette méthode est uniquement un accesseur Get et n’affecte pas <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Note the following considerations:</source>
          <target state="translated">Notez les points suivants :</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>The argument must be non-null.</source>
          <target state="translated">L’argument doit être non null.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Otherwise, a null argument exception is thrown.</source>
          <target state="translated">Sinon, une exception d’argument null est levée.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Normal query translation exceptions thrown during <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> query execution apply for a query that cannot be translated.</source>
          <target state="translated">Exceptions de traduction de requête normales levées pendant <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> exécution de la requête s’appliquent à une requête qui ne peut pas être traduite.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Only the first query command is returned.</source>
          <target state="translated">La première commande de requête est retournée.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>Specifically, additional commands that are used for eager loading (<ph id="ph1">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph>) are not included.</source>
          <target state="translated">Plus précisément, les commandes supplémentaires qui sont utilisés pour le chargement hâtif (<ph id="ph1">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph>) ne sont pas inclus.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> does not track what the user does with the command.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> ne suit pas ce que l’utilisateur fait avec la commande.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)">
          <source>For example, results from the execution of the returned command are not tracked and do not affect <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> state.</source>
          <target state="translated">Par exemple, les résultats de l’exécution de la commande retournée ne sont pas suivies et n’affectent pas <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>The type of the objects to be returned.</source>
          <target state="translated">Type des objets à retourner.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>Returns a collection of objects of a particular type, where the type is defined by the <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Retourne une collection d'objets d'un type particulier, où le type est défini par le paramètre <ph id="ph1">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>A collection of objects defined by the <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Collection d'objets définie par le paramètre <ph id="ph1">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>This is a weakly typed version of <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetTable%2A&gt;</ph>.</source>
          <target state="translated">Il s’agit d’une version faiblement typée de <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.GetTable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>It is important to have a weakly typed version because it is a relatively common practice to construct queries dynamically.</source>
          <target state="translated">Il est important de disposer d’une version faiblement typée, car il est relativement courant pour construire des requêtes dynamiquement.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>It would be inconvenient to force the application to use reflection to call the correct generic method.</source>
          <target state="translated">Il serait pas pratique forcer l’application à utiliser la réflexion pour appeler la méthode générique correcte.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable(System.Type)">
          <source>If there is no collection for a particular type, an exception is thrown.</source>
          <target state="translated">S’il n’y a aucune collection pour un type particulier, une exception est levée.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>The type of the objects to be returned.</source>
          <target state="translated">Type des objets à retourner.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>Returns a collection of objects of a particular type, where the type is defined by the <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph> parameter.</source>
          <target state="translated">Retourne une collection d'objets d'un type particulier, où le type est défini par le paramètre <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>A collection of objects defined by the <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph> parameter.</source>
          <target state="translated">Collection d'objets définie par le paramètre <ph id="ph1">&lt;paramref name="TEntity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>This method is the main entry point for querying.</source>
          <target state="translated">Cette méthode est le point d’entrée principal pour l’interrogation.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>When a strongly typed <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is created, new generated properties encapsulate calls to this method.</source>
          <target state="translated">Lorsqu’il est fortement typé <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> est créées, de nouvelles propriétés générées encapsulent les appels à cette méthode.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>For example, a <ph id="ph1">`Customers`</ph> property is generated that returns <ph id="ph2">`GetTable&lt;Customer&gt;`</ph>.</source>
          <target state="translated">Par exemple, un <ph id="ph1">`Customers`</ph> générée, qui retourne la propriété <ph id="ph2">`GetTable&lt;Customer&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.GetTable``1">
          <source>If there is no collection for a particular type, an exception is thrown.</source>
          <target state="translated">S’il n’y a aucune collection pour un type particulier, une exception est levée.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.LoadOptions">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataLoadOptions" /&gt;</ph> associated with this <ph id="ph2">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit l'objet <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataLoadOptions" /&gt;</ph> associé à <ph id="ph2">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.LoadOptions">
          <source>The prefetch load options for related data.</source>
          <target state="translated">Options de la charge de prérécupération pour les données connexes.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.LoadOptions">
          <source>This property gets or sets the options that are used to define prefetch behavior for deferred-loaded members and membership of related collections.</source>
          <target state="translated">Cette propriété obtient ou définit les options qui sont utilisées pour définir le comportement de prérécupération pour les membres à chargement différé et l’appartenance des collections associées.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Log">
          <source>Gets or sets the destination to write the SQL query or command.</source>
          <target state="translated">Obtient ou définit la destination pour écrire la requête ou la commande SQL.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Log">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> to use for writing the command.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> à utiliser pour écrire la commande.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Log">
          <source>Set this property to <ph id="ph1">`null`</ph> to disable command logging.</source>
          <target state="translated">Définissez cette propriété sur <ph id="ph1">`null`</ph> pour désactiver la journalisation de la commande.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Log">
          <source>The following example displays generated SQL in the console window before it displays the results of the query.</source>
          <target state="translated">L’exemple suivant affiche le SQL généré dans la fenêtre de console avant d’afficher les résultats de la requête.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Mapping">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Data.Linq.Mapping.MetaModel" /&gt;</ph> on which the mapping is based.</source>
          <target state="translated">Obtient le <ph id="ph1">&lt;see cref="T:System.Data.Linq.Mapping.MetaModel" /&gt;</ph> sur laquelle est basé le mappage.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Mapping">
          <source>The mapping between a database and domain objects.</source>
          <target state="translated">Mappage entre une base de données et les objets de domaine.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>Gets or sets a value that indicates whether object tracking is enabled.</source>
          <target state="translated">Obtient ou définit une valeur qui indique si le suivi des objets est activé.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object tracking is enabled; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le suivi de l'objet est activé, sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>Setting this property to <ph id="ph1">`false`</ph> improves performance at retrieval time, because there are fewer items to track.</source>
          <target state="translated">Si cette propriété <ph id="ph1">`false`</ph> améliore les performances au moment de la récupération, car il existe moins d’éléments pour effectuer le suivi.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>An exception is thrown:</source>
          <target state="translated">Une exception est levée :</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If the property is set to <ph id="ph1">`false`</ph> after a query has been executed.</source>
          <target state="translated">Si la propriété est définie <ph id="ph1">`false`</ph> après l’exécution d’une requête.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>For more information, see the Valid Modes section in <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations, consultez la section Modes valides dans <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If the property is set to <ph id="ph1">`false`</ph> and <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> is called.</source>
          <target state="translated">Si la propriété est définie <ph id="ph1">`false`</ph> et <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> is <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> is ignored and treated as <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> est <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> est ignorée et traitée en tant que <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> is read-only.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>If <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> is <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A&gt;</ph> est <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A&gt;</ph> est <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.ObjectTrackingEnabled">
          <source>In this case, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> allows you to load an object graph by using <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> directives, but does not enable deferred loading.</source>
          <target state="translated">Dans ce cas, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> vous permet de charger un graphique d’objet à l’aide <ph id="ph2">&lt;xref:System.Data.Linq.DataLoadOptions.LoadWith%2A&gt;</ph> directives, mais n’active pas le chargement différé.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Refreshes object state by using data in the database.</source>
          <target state="translated">Actualise l'état d'objet à l'aide de données de la base de données.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>This method is useful after an optimistic concurrency error to bring items into a state for another attempt.</source>
          <target state="translated">Cette méthode est utile après une erreur d’accès concurrentiel optimiste pour placer des éléments dans un état pour une autre tentative.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>It updates the state of the primitive fields and properties on the objects.</source>
          <target state="translated">Il met à jour l’état des champs primitifs et des propriétés sur les objets.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>If an object is on the <bpt id="p1">*</bpt>many<ept id="p1">*</ept> side of a one-to-many relationship, the foreign key on the object will be set and the object pointer for the other side of the relationship will be set to the new value.</source>
          <target state="translated">Si un objet est sur le <bpt id="p1">*</bpt>nombreux<ept id="p1">*</ept> côté d’une relation un-à-plusieurs, la clé étrangère sur l’objet est définie et que le pointeur d’objet pour l’autre côté de la relation sera défini à la nouvelle valeur.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)">
          <source>A value that specifies how optimistic concurrency conflicts are handled.</source>
          <target state="translated">Valeur qui spécifie comment les conflits d'accès concurrentiel optimiste sont traités.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)">
          <source>The collection of entities to be refreshed.</source>
          <target state="translated">Collection d'entités à actualiser.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)">
          <source>Refreshes a collection of entity objects according to the specified mode.</source>
          <target state="translated">Actualise une collection d'objets d'entité selon le mode spécifié.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)">
          <source>A value that specifies how optimistic concurrency conflicts are handled.</source>
          <target state="translated">Valeur qui spécifie comment les conflits d'accès concurrentiel optimiste sont traités.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)">
          <source>The object to be refreshed.</source>
          <target state="translated">Objet à actualiser.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)">
          <source>Refreshes an entity object according to the specified mode.</source>
          <target state="translated">Actualise un objet d'entité selon le mode spécifié.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])">
          <source>A value that specifies how optimistic concurrency conflicts are handled.</source>
          <target state="translated">Valeur qui spécifie comment les conflits d'accès concurrentiel optimiste sont traités.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])">
          <source>The array of entity objects to be refreshed.</source>
          <target state="translated">Tableau d'objets d'entité à actualiser.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])">
          <source>Refreshes an array of entity objects according to the specified mode.</source>
          <target state="translated">Actualise un tableau d'objets d'entité selon le mode spécifié.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</source>
          <target state="translated">Traite l'ensemble des objets modifiés à insérer, mettre à jour ou supprimer et exécute les commandes appropriées pour implémenter les modifications de la base de données.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>If override methods are present for insert, update, or delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> executes these methods instead of the default <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> commands.</source>
          <target state="translated">Si les méthodes override sont présentes pour insert, update ou delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> exécute ces méthodes au lieu de la valeur par défaut <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> commandes.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> starts a transaction and will roll back if an exception occurs while <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> démarre une transaction et sera annulée si une exception se produit alors que <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> s’exécute.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>However, this does not roll back the changes in memory or tracked by the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>; those changes will need to be rolled back manually.</source>
          <target state="translated">Toutefois, cela n’annule pas les modifications en mémoire ou suivies par le <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph>; ces modifications devront être restaurées manuellement.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>You can start with a new instance of the <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> if the changes in memory are to be discarded.</source>
          <target state="translated">Vous pouvez démarrer avec une nouvelle instance de la <ph id="ph1">&lt;xref:System.Data.Linq.DataContext&gt;</ph> si les modifications en mémoire doivent être ignorées.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges">
          <source>Computes the set of modified objects to be inserted, updated, or deleted, and executes the appropriate commands to implement the changes to the database.</source>
          <target state="translated">Traite l'ensemble des objets modifiés à insérer, mettre à jour ou supprimer et exécute les commandes appropriées pour implémenter les modifications de la base de données.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.SubmitChanges">
          <source>If override methods are present for insert, update, or delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> executes these methods instead of the default <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> commands.</source>
          <target state="translated">Si les méthodes override sont présentes pour insert, update ou delete, <ph id="ph1">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> exécute ces méthodes au lieu de la valeur par défaut <ph id="ph2">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> commandes.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>The action to be taken if the submission fails.</source>
          <target state="translated">Action à effectuer en cas d'échec de la soumission.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>Valid arguments are as follows:</source>
          <target state="translated">Les arguments valides sont les suivants :</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>Sends changes that were made to retrieved objects to the underlying database, and specifies the action to be taken if the submission fails.</source>
          <target state="translated">Envoie à la base de données sous-jacente les modifications apportées aux objets récupérés, et spécifie l'action à effectuer si la soumission échoue.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)">
          <source>Default failure mode is <ph id="ph1">&lt;xref:System.Data.Linq.ConflictMode.FailOnFirstConflict&gt;</ph>.</source>
          <target state="translated">Mode d’échec par défaut est <ph id="ph1">&lt;xref:System.Data.Linq.ConflictMode.FailOnFirstConflict&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>Gets or sets a local transaction for the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> to use to access the database.</source>
          <target state="translated">Obtient ou définit une transaction locale à utiliser par le <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> pour accéder à la base de données.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>The transaction object used by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> when executing queries and commands.</source>
          <target state="translated">Objet transaction utilisé par <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph> lors de l'exécution des requêtes et des commandes.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>The primary scenario for this property is interoperability with relational <ph id="ph1">[!INCLUDE[vstecado](~/includes/vstecado-md.md)]</ph> code.</source>
          <target state="translated">Le scénario principal de cette propriété est l’interopérabilité avec relationnelle <ph id="ph1">[!INCLUDE[vstecado](~/includes/vstecado-md.md)]</ph> code.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>For example, use this property when you write your own <ph id="ph1">`Create`</ph><ph id="ph2">/</ph><ph id="ph3">`Update`</ph><ph id="ph4">/</ph><ph id="ph5">`Delete`</ph> methods to set the <ph id="ph6">`Transaction`</ph> property on the ADO <ph id="ph7">`Command`</ph> object.</source>
          <target state="translated">Par exemple, utilisez cette propriété lorsque vous écrivez votre propre <ph id="ph1">`Create`</ph> <ph id="ph2">/</ph> <ph id="ph3">`Update`</ph> <ph id="ph4">/</ph> <ph id="ph5">`Delete`</ph> méthodes pour définir le <ph id="ph6">`Transaction`</ph> propriété ADO <ph id="ph7">`Command`</ph> objet.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>Note the following:</source>
          <target state="translated">Notez les points suivants :</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>If this property has not been explicitly set, the getter returns null.</source>
          <target state="translated">Si cette propriété n’a pas été définie explicitement, la méthode getter retourne la valeur null.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>If the code is executing in a <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> context, setting this property throws an exception.</source>
          <target state="translated">Si l’exécution du code dans un <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> contexte, la définition de cette propriété lève une exception.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.Linq.DataContext.Transaction">
          <source>If this property is set and a new <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> is opened, an exception is thrown when a query or update is executed.</source>
          <target state="translated">Si cette propriété est définie et un nouveau <ph id="ph1">&lt;xref:System.Transactions.Transaction&gt;</ph> est ouverte, une exception est levée lors de l’exécution d’une requête ou une mise à jour.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="T:System.Data.Linq.DataContext">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Convertit un <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> existant en objets.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>Each row in the <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> is converted to an object in the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">Chaque ligne dans le <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> est convertie en un objet dans le <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>Description: This method is used to convert an existing <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> to objects.</source>
          <target state="translated">Description : Cette méthode est utilisée pour convertir un existant <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> aux objets.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source>Each row in the <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> is converted to an object in the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">Chaque ligne dans le <ph id="ph1">&lt;xref:System.Data.Common.DbDataReader&gt;</ph> est convertie en un objet dans le <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><bpt id="p1">**</bpt>Generic parameters:<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Paramètres génériques :<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">`T`</ph>: See <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteQuery%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`T`</ph>: Consultez <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteQuery%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><bpt id="p1">**</bpt>Parameters:<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Paramètres :<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">`Query`</ph>: See the description for command under <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Query`</ph>: Consultez la description de la commande sous <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">`Parameters`</ph>: See the description for parameters under <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Parameters`</ph>: Consultez la description des paramètres sous <ph id="ph2">&lt;xref:System.Data.Linq.DataContext.ExecuteCommand%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><bpt id="p1">**</bpt>Return type:<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Type de retour :<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.Linq.DataContext">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>: collection of objects returned by the conversion.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>: collection d’objets retournés par la conversion.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to be converted.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> à convertir.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Convertit un <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> existant en objets.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)">
          <source>A list of objects returned by the conversion.</source>
          <target state="translated">Liste d'objets retournés par la conversion.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The type of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> to be returned.</source>
          <target state="translated">Type de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> à retourner.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The algorithm for matching columns in the result to fields and properties in the object works as follows:</source>
          <target state="translated">L'algorithme qui fait correspondre les colonnes du résultat aux champs et aux propriétés de l'objet fonctionne comme suit :</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>If a field or property is mapped to a particular column name, that column name is expected in the resultset.</source>
          <target state="translated">Si un champ ou une propriété est mappé à un nom de colonne particulier, ce nom de colonne est attendu dans le jeu de résultats.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>If a field or property is not mapped, a column with the same name as the field or property is expected in the resultset.</source>
          <target state="translated">Si un champ ou une propriété n'est pas mappé, une colonne de même nom que le champ ou la propriété est attendue dans le jeu de résultats.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The comparison is performed by looking for a case-sensitive match first.</source>
          <target state="translated">la comparaison est effectuée en recherchant en premier une correspondance sensible à la casse.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>If this match is not found, a subsequent search is occurs for a case-insensitive match.</source>
          <target state="translated">Si cette correspondance est introuvable, une recherche ultérieure est effectuée pour une correspondance qui ne tient pas compte de la casse.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The query must return all the tracked fields and properties of the object (except those that are loaded on a deferred basis) when all the following conditions are true:</source>
          <target state="translated">La requête doit retourner tous les champs et propriétés de l'objet pour lesquels un suivi est effectué (excepté ceux qui sont chargés sur une base différée) lorsque toutes les conditions suivantes sont réalisées :</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> is an entity explicitly tracked by the <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> est une entité faisant explicitement l’objet d’un suivi par <ph id="ph1">&lt;see cref="T:System.Data.Linq.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /&gt;</ph> est <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The entity has a primary key.</source>
          <target state="translated">L'entité a une clé primaire.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>Otherwise an exception is thrown.</source>
          <target state="translated">Sinon, une exception est levée.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to be converted.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> à convertir.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Convertit un <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> existant en objets.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)">
          <source>A list of objects returned by the conversion.</source>
          <target state="translated">Liste d'objets retournés par la conversion.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>The type of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> to be returned.</source>
          <target state="translated">Type de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> à retourner.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> to be converted.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> à convertir.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>Converts an existing <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> to objects.</source>
          <target state="translated">Convertit un <ph id="ph1">&lt;see cref="T:System.Data.Common.DbDataReader" /&gt;</ph> existant en objets.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)">
          <source>A collection of objects returned by the conversion.</source>
          <target state="translated">Collection d'objets retournés par la conversion.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>