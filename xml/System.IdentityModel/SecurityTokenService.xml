<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49a0ab5f150cc09113681aed718c286d237b6643" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52603580" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Classe de base abstraite qui définit les propriétés et les méthodes d'un service d'émission de jeton de sécurité (STS).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer un STS que vous devez dériver la <xref:System.IdentityModel.SecurityTokenService> classe. Dans votre classe personnalisée vous devez, au minimum, remplacer le <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> et <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> méthodes. Avec ces remplacements, le STS créé à l’aide de l’implémentation par défaut de toutes les autres méthodes définies dans la classe est capable de délivrer des jetons de sécurité en réponse à la sécurité des demandes de jeton (RST). Autrement dit, la liaison de problème définie dans la spécification WS-Trust est implémentée. Cette liaison est implémentée dans le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode). Aucun des autres liaisons WS-Trust (renouveler, Annuler et valider) sont implémentées dans le cas par défaut et une erreur appropriée est retournée à l’appelant si une RST qui correspond à une de ces liaisons ne survient. Vous pouvez, bien sûr, substituer les méthodes appropriées (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, et <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) pour implémenter ces liaisons dans votre STS.  
  
> [!IMPORTANT]
>  Implémentation d’un STS prêt pour la production implique une planification soignée et des ressources considérables pour atténuer les risques de sécurité potentiels inhérents à suivre pour exposer un tel service. La plupart des développeurs à l’aide de Windows Identity Foundation (WIF) sera être développement d’applications qui externaliser la gestion des identités vers un service STS, au lieu de développer un service STS lui-même. WIF fournit une extension de Visual Studio, l’outil Identity and Access pour Visual Studio 2012, pour aider les développeurs de tester des solutions dans l’environnement de développement. Cet outil inclut un service STS, `LocalSTS`, que vous pouvez configurer pour servir des revendications spécifiques à l’application que vous développez. Pour plus d’informations sur l’outil identité et d’accès, consultez [Identity and Access Tool pour Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). Dans certains scénarios, `LocalSTS` peut ne pas fournir les fonctionnalités nécessaires pour tester correctement votre application ; par exemple, dans un scénario qui implique développe un gestionnaire de jetons personnalisé pour une utilisation par une application. Dans ce cas, vous pouvez dériver de <xref:System.IdentityModel.SecurityTokenService> pour créer un ou plusieurs STS simples qui peut être déployé dans votre environnement de développement et qui peut être utilisé pour tester ces fonctionnalités dans votre application. Le reste de cette section se concentre sur les méthodes exposées par la <xref:System.IdentityModel.SecurityTokenService> classe qui vous permettent d’implémenter un STS simple et étendre le pipeline d’émission de jeton.  
  
 La liste suivante fournit une vue d’ensemble des méthodes de première importance pour le développeur pour une utilisation dans un environnement de test ou de développement.  
  
-   Méthode <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> Cette méthode retourne un <xref:System.IdentityModel.Scope> objet qui contient des informations sur la partie de confiance. Cet objet est utilisé dans le reste du pipeline d’émission de jeton et inclut des informations sur la signature et chiffrement des informations d’identification à utiliser dans la réponse, ainsi que le `AppliesTo` et `ReplyTo` (si nécessaire) adresses. Vous devez substituer cette méthode.  
  
-   Méthode <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> Cette méthode retourne un <xref:System.Security.Claims.ClaimsIdentity> objet qui contient les revendications pour revenir à la partie de confiance. Vous devez substituer cette méthode.  
  
-   Méthode <xref:System.IdentityModel.SecurityTokenService.Issue%2A> Cette méthode implémente le pipeline de demande de jeton, qui traite une demande entrante sécurité jeton (RST) et retourne une réponse (RSTR) à l’appelant qui contient un jeton qui peut être utilisé pour authentifier avec un fournisseur de ressources. Un grand nombre des autres méthodes définies dans le <xref:System.IdentityModel.SecurityTokenService> classe sont appelées à partir de cette méthode, y compris le <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> et <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> méthodes. Vous n’êtes pas obligé de substituer cette méthode, mais une compréhension du pipeline de demande de jeton qu’il implémente peut-être être utile.  
  
 Un service STS est configuré via la <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> classe.  
  
   
  
## Examples  
 Les exemples de code qui sont utilisés dans le <xref:System.IdentityModel.SecurityTokenService> rubriques sont extraites de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens) et il inclut une implémentation d’un STS passif qui est capable de fournir un jeton SWT. Pour obtenir un exemple montrant comment implémenter un STS actif, vous pouvez voir le `Federation Metadata` exemple. Pour plus d’informations sur ces exemples et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant illustre l’implémentation d’un STS passif à l’aide de la <xref:System.IdentityModel.SecurityTokenService> classe.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 Le code suivant montre comment appeler un service STS passif pour traiter une demande WS-Federation en appelant le <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> (méthode) à partir du code-behind dans le `default.aspx.cs` fichier.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Vous devez substituer les deux le <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> et <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> méthodes.</para></block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration"><see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> qui contient les paramètres pour le STS.</param>
        <summary>Appelé à partir des classes dérivées pour initialiser la classe <see cref="T:System.IdentityModel.SecurityTokenService" /> à l'aide des paramètres de configuration spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour initialiser le fournisseur d’étendues et de certificat de l’émetteur du jeton.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="securityTokenServiceConfiguration" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone d'annulation.</param>
        <param name="state">Objet qui contient les informations d'état associées à l'opération d'annulation asynchrone.</param>
        <summary>En cas de substitution dans une classe dérivée, démarre une demande WS-Trust Cancel asynchrone.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui référence l'opération asynchrone de fermeture.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="scope"><see cref="T:System.IdentityModel.Scope" /> qui contient des informations sur la partie de confiance associée à la requête.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <param name="state">Objet qui contient les informations d'état associées à l'opération asynchrone.</param>
        <summary>En cas de substitution dans une classe dérivée, lance un appel asynchrone à la méthode de <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui référence l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <param name="state">Objet qui contient les informations d'état associées à l'opération asynchrone.</param>
        <summary>En cas de substitution dans une classe dérivée, lance un appel asynchrone pour la méthode de <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui référence l'opération asynchrone de fermeture.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone d'émission.</param>
        <param name="state">Objet qui contient les informations d'état associées à l'opération d'émission asynchrone.</param>
        <summary>En cas de substitution dans une classe dérivée, démarre une demande WS-Trust Issue asynchrone.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui fait référence à l'opération d'émission asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone de renouvellement.</param>
        <param name="state">Objet qui contient les informations d'état associées à l'opération de renouvellement asynchrone.</param>
        <summary>En cas de substitution dans une classe dérivée, démarre une demande WS-Trust Renew asynchrone.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui référence l'opération de renouvellement asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> délégué qui reçoit la notification de la fin de l'opération de validation asynchrone.</param>
        <param name="state">Objet qui contient les informations d'état associées à l'opération de validation asynchrone.</param>
        <summary>En cas de substitution dans une classe dérivée, démarre une demande WS-Trust Validate asynchrone.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui référence l'opération asynchrone de validation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <summary>En cas de substitution dans une classe dérivée, traite une demande WS-Trust Cancel.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Demande de jeton entrante.</param>
        <param name="scope">Objet <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> retourné par <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Crée une instance d'un <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns><see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelé lors de l’émission de jeton après <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="scope" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui est retourné par un appel à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, met fin à la demande WS-Trust Cancel asynchrone.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui est retourné par un appel à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, met fin à l'appel asynchrone à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />.</summary>
        <returns><see cref="T:System.Security.Claims.ClaimsIdentity" /> qui contient la collection des revendications qui sera placée dans le jeton de sécurité émis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui est retourné par un appel à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, met fin à l'appel asynchrone à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</summary>
        <returns><see cref="T:System.IdentityModel.Scope" /> qui encapsule les informations de partie de confiance (RP) associées à la demande (RST) spécifiée dans l'appel à la méthode de <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui est retourné par un appel à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, met fin à la demande WS-Trust Issue asynchrone.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui est retourné par un appel à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, met fin à la demande WS-Trust Renew asynchrone.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> qui est retourné par un appel à la méthode <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, met fin à la demande WS-Trust Validate asynchrone.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le nom du service de jeton de sécurité (STS).</summary>
        <returns>Nom de l'émetteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée à partir de la valeur par défaut pipeline d’émission de jeton est implémenté dans le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode).  
  
 L’implémentation par défaut retourne la <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> propriété à partir de configuration accédée via le <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <param name="scope"><see cref="T:System.IdentityModel.Scope" /> qui contient des informations sur la partie de confiance associée à la requête. Il s'agit de l'objet <see cref="T:System.IdentityModel.Scope" /> qui a été retourné par la méthode <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>En cas de substitution dans une classe dérivée, cette méthode retourne une collection de sujets de sortie à inclure dans le jeton émis.</summary>
        <returns><see cref="T:System.Security.Claims.ClaimsIdentity" /> qui contient la collection des revendications qui sera placée dans le jeton de sécurité émis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> méthode est appelée depuis le pipeline d’émission de jeton, qui est implémenté par le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode). Elle retourne un <xref:System.Security.Claims.ClaimsIdentity> qui contient les revendications à inclure dans le jeton de sécurité émis selon le demandeur du jeton (le `principal` paramètre), le RST entrant (le `request` paramètre), et la partie de confiance pour laquelle le jeton est destiné () le `scope` paramètre). La logique de cette méthode concerne principalement aux questions suivantes :  
  
-   **Types de revendication à laquelle doit figurer dans la réponse en fonction de la partie de confiance pour lequel il est prévu ?** En général, ce comportement est déterminé par partie de confiance dans les listes des types de revendication requis pour chaque partie de confiance ou sur une base par demande en examinant le <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> propriété de la demande. Toutefois, la logique et les détails pour déterminer les revendications à inclure dans la réponse dépend entièrement votre implémentation.  
  
-   **Valeurs de revendication à laquelle doit être affectée aux revendications dans la réponse ?** Pour un fournisseur d’identité (IP-STS) cela signifie généralement à l’aide d’une ou plusieurs revendications dans le demandeur <xref:System.Security.Claims.ClaimsPrincipal> (fourni par le `principal` paramètre) pour accéder à un magasin (ou autre entité) pour retourner des valeurs pour les types de revendication requis. Pour un fournisseur de fédération (R-STS) cela signifie généralement l’exécution d’une sorte de traitement sur les revendications entrantes du demandeur à répondre à la demande ; notamment pour effectuer le filtrage ou transformation sur des revendications présentées par le demandeur, en passant d’autres utilisateurs via non modifié. Bien entendu, comme dans le cas de la décision sur les revendications à inclure dans la réponse, les détails et la logique utilisée déterminer les valeurs de ces revendications est jusqu'à votre implémentation.  
  
   
  
## Examples  
 L’exemple de code qui est utilisé dans cette rubrique provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens) et il inclut une implémentation d’un STS passif qui est capable de fournir un jeton SWT. Pour obtenir un exemple montrant comment implémenter un STS actif, vous pouvez voir le `Federation Metadata` exemple. Pour plus d’informations sur ces exemples et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant montre comment substituer la <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> méthode pour retourner des revendications pour votre STS. Dans cet exemple, le message de demande de sécurité jeton (RST) est ignoré et une collection de revendications basées sur l’utilisateur comme étant authentifiés au niveau du STS est retournée.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans votre implémentation de la classe de <see cref="T:System.IdentityModel.SecurityTokenService" />.</para></block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la requête entrante de jeton (RST).</param>
        <param name="scope">Instance <see cref="T:System.IdentityModel.Scope" /> qui encapsule les informations relatives à la partie de confiance.</param>
        <summary>Obtient le jeton de preuve à inclure dans la réponse (RSTR).</summary>
        <returns><see cref="T:System.IdentityModel.Tokens.ProofDescriptor" /> qui représente le nouveau descripteur de preuve. Le descripteur de preuve peut être un descripteur de preuve asymétrique, un descripteur de preuve symétrique, ou <see langword="null" /> dans le cas d'un jeton de porteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée à partir de la valeur par défaut pipeline d’émission de jeton est implémenté dans le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode).  
  
 L’implémentation par défaut retourne un descripteur de preuve ou lève une exception appropriée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="scope" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la requête entrante de jeton (RST).</param>
        <summary>Obtient les informations d'identification de chiffrement de la preuve du demandeur.</summary>
        <returns>Objet <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> qui représente les informations d’identification de chiffrement du demandeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée à partir de la <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> (méthode).  
  
 L’implémentation par défaut effectue les opérations suivantes. Retourne `null` s’il n’existe aucun jeton de chiffrement spécifié dans la demande (le <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> propriété est `null`). Sinon, si elle peut obtenir le jeton comme un <xref:System.IdentityModel.Tokens.X509SecurityToken>, elle retourne des informations d’identification en fonction de ce jeton. Si elle ne peut pas résoudre le jeton comme un <xref:System.IdentityModel.Tokens.X509SecurityToken>, un <xref:System.IdentityModel.RequestFailedException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">RST contenant la demande de jeton.</param>
        <param name="tokenDescriptor">Descripteur de jeton qui contient les informations à utiliser pour le jeton émis.</param>
        <summary>Crée la réponse (RSTR) qui contient le jeton émis à l'aide de la requête spécifiée (RST) et du descripteur de jeton de sécurité.</summary>
        <returns>Réponse (RSTR) ou <see langword="null" /> si une réponse ne peut pas être créée à partir de la demande et du descripteur de jeton spécifiés. L'implémentation par défaut retourne <see langword="null" /> si le paramètre <paramref name="tokenDescriptor" /> a la valeur <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> méthode est appelée en tant que la dernière étape du pipeline d’émission de jeton, qui est implémentée par le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode). Il crée et retourne la réponse (RSTR) à l’aide de la demande entrante d’origine (RST) et le descripteur de jeton qui a été élaboré à l’étape précédente dans le pipeline d’émission de jeton.  
  
 L’implémentation par défaut crée la réponse RSTR en passant le RST spécifié dans le paramètre de requête à la <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> constructeur, appeler le <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> transmis à la méthode sur le descripteur de jeton dans <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> à appliquer ses propriétés pour le qui vient d’être créé RSTR, définissant le <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> propriété sur la réponse RSTR à l’aide de la <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> propriété sur le descripteur de jeton et enfin définir le <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> propriété sur la réponse RSTR conformément au tableau suivant :  
  
|Propriété`RST.ReplyTo` |Propriété <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>.|Propriété`RSTR.ReplyTo` |  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Définir|Non défini|Non défini|  
|Définir|Définir|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Non défini|Définir|Non défini|  
|Non défini|Non défini|Non défini|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> représentant le client qui effectue la requête.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la requête entrante (RST).</param>
        <summary>Obtient un objet <see cref="T:System.IdentityModel.Scope" /> qui contient des informations sur la partie de confiance (RP) associée à la demande spécifiée (RST). Vous devez substituer cette méthode dans votre implémentation de la classe de <see cref="T:System.IdentityModel.SecurityTokenService" />.</summary>
        <returns><see cref="T:System.IdentityModel.Scope" /> qui encapsule des informations de RP (partie de confiance) associées à la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> méthode est appelée depuis le pipeline d’émission de jeton après le <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> (méthode) et doit retourner un <xref:System.IdentityModel.Scope> objet configuré pour la demande entrante. (Le pipeline d’émission de jeton est implémenté dans le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> méthode.) Le <xref:System.IdentityModel.Scope> objet encapsule des informations sur la partie de confiance associé à la demande de jeton de sécurité (RST). Cela inclut des informations sur les informations d’identification de chiffrement et signatures à utiliser avec la partie de confiance et s’il faut chiffrer les jetons émis et/ou les clés symétriques dans la réponse. Certaines tâches standard exécutées dans le <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> méthode sont :  
  
-   Déterminer si le fournisseur de ressources auquel est destiné le jeton est une partie de confiance reconnue. Comment cela fonctionne dépend de votre implémentation. Si le fournisseur de ressources prévue n’est pas une partie de confiance valide pour ce STS, puis la méthode doit lever une <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Déterminer la signature des informations d’identification pour être utilisé dans la réponse (RSTR) et définir le <xref:System.IdentityModel.Scope.SigningCredentials%2A> propriété en conséquence.  
  
-   Déterminer si la réponse et/ou de toutes les clés symétriques inclus doivent être chiffrées et les informations d’identification à utiliser pour le chiffrement. Définir le <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, et <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> propriétés en conséquence.  
  
    > [!IMPORTANT]
    >  Par défaut, le <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> et <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> propriétés sont définies `true` pour empêcher l’émission de jetons qui ne sont pas sûrs de STS. Il est recommandé que ces propriétés jamais être définie sur `false` dans un environnement de production.  
  
-   Déterminer l’adresse à laquelle la réponse doit être retournée. Définir soit la <xref:System.IdentityModel.Scope.AppliesToAddress%2A> ou <xref:System.IdentityModel.Scope.ReplyToAddress%2A> propriété en conséquence.  
  
   
  
## Examples  
 L’exemple de code qui est utilisé dans cette rubrique provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens) et il inclut une implémentation d’un STS passif qui est capable de fournir un jeton SWT. Pour obtenir un exemple montrant comment implémenter un STS actif, vous pouvez voir le `Federation Metadata` exemple. Pour plus d’informations sur ces exemples et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 L'exemple de code suivant illustre une implémentation de la méthode <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>. Cette implémentation vérifie que le fournisseur de ressources est reconnu par le STS, valide le <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> adresse dans la demande et définit le <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> propriété en conséquence, et définit la signature et chiffrement des informations d’identification à utiliser avec le fournisseur de ressources en fonction de certificats requis par sont codées en dur dans le fichier.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous devez substituer cette méthode dans votre implémentation de la classe de <see cref="T:System.IdentityModel.SecurityTokenService" />.</para></block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Chaîne qui contient l'URI de type de jeton demandé.</param>
        <summary>Obtient le gestionnaire de jetons de sécurité approprié pour émettre un jeton de sécurité du type spécifié.</summary>
        <returns><see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> qui représente le gestionnaire de jetons à utiliser pour créer le jeton de sécurité émis. Retourne <see langword="null" /> si le type de jeton demandé n'est pas pris en charge (s'il n'y a aucun gestionnaire configuré pour le type de jeton spécifié).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans l’implémentation par défaut si `requestedTokenType` est `null` ou une chaîne vide, la valeur par défaut, le type de jeton à partir de la configuration est utilisé. Cela est spécifié par le <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> propriété de l’objet de configuration de STS accédé via le <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> propriété.  
  
 Cette méthode est appelée à partir de la valeur par défaut pipeline d’émission de jeton est implémenté dans le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime"><see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> représentant la durée de vie demandée.</param>
        <summary>Obtient la durée de vie du jeton émis.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> qui représente la durée de vie accordée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée normalement avec la durée de vie est arrivé dans le RST. Dans l’implémentation par défaut, la durée de vie de jeton est calculée selon le tableau suivant.  
  
|Créé (en)|Expire (in)|Créé (en)|Expire (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Cette méthode est appelée à partir de la valeur par défaut pipeline d’émission de jeton est implémenté dans le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <summary>Émet un jeton de sécurité.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui contient le jeton de sécurité émis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente la liaison de problème définie dans la spécification WS-Trust. L’implémentation par défaut de la <xref:System.IdentityModel.SecurityTokenService.Issue%2A> méthode traite la demande entrante (RST) via un pipeline d’émission de jeton (émission de revendications) et retourne une réponse (RSTR) qui contient un jeton de sécurité avec les revendications appropriées pour authentifier le demandeur avec le fournisseur de ressources ou une exception appropriée. Le pipeline d’émission de jeton dans l’implémentation par défaut est composé des appels aux méthodes suivantes (de la <xref:System.IdentityModel.SecurityTokenService> classe).  
  
1.  Le <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> méthode pour valider la demande (RST).  
  
2.  Le <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> méthode pour obtenir un <xref:System.IdentityModel.Scope> objet qui contient des informations sur la partie de confiance (RP) associée à la demande. Vous devez substituer cette méthode. Si <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> retourne `null`, un <xref:System.InvalidOperationException> est levée.  
  
3.  Le <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> méthode pour retourner un descripteur de jetons de sécurité basée sur le RST et <xref:System.IdentityModel.Scope> objet retourné à l’étape précédente. Le descripteur de jeton de sécurité (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) contient des informations sur la demande dans un formulaire qui peut être utilisé par un gestionnaire de jetons. Le <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> propriété est définie sur le descripteur retourné par l’appel. Si `null` est retourné ou si le <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> propriété du descripteur est `null`, un <xref:System.InvalidOperationException> est levée. L’exception est également levée si le <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> propriété est `true` mais le <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> propriété sur le descripteur retourné est `null`.  
  
4.  Le <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> méthode pour obtenir le Gestionnaire de jetons approprié en fonction du type de jeton demandé. Si `null` est retourné, un <xref:System.NotImplementedException> est levée.  
  
5.  Le <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> méthode pour obtenir le nom de l’émetteur du jeton. Lève une <xref:System.InvalidOperationException> si le nom est `null` ou vide ; sinon, définit le <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> le descripteur de propriété.  
  
6.  Le <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> méthode pour obtenir la durée de vie du jeton et les jeux les <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> le descripteur de propriété.  
  
7.  Le <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> méthode pour obtenir le jeton de preuve à inclure dans le jeton émis et définit le <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> le descripteur de propriété.  
  
8.  Le <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> méthode pour obtenir les revendications à inclure dans le jeton émis et définit le <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> le descripteur de propriété. Vous devez substituer cette méthode.  
  
9. Le <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> méthode pour créer une réponse (RSTR) qui contient le jeton émis.  
  
 Vous pouvez remplacer le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> méthode pour implémenter un pipeline d’émission de jeton personnalisé ; toutefois il n’est généralement pas nécessaire dans les environnements de développement et de test pour les implémentations personnalisées plus de la <xref:System.IdentityModel.SecurityTokenService> classe sont destinées. Dans de nombreux cas, vous substituez le <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> et <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> méthodes et éventuellement remplacer le <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> méthode pour fournir une pièce remplaçable par STS pour votre environnement. Si une personnalisation supplémentaire soit nécessaire vous pouvez souvent le fournir en substituant les méthodes qui implémentent chaque étape du pipeline d’émission de jetons répertorié ci-dessus par défaut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le principal associé à l'instance actuelle.</summary>
        <value><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente le principal actuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <summary>En cas de substitution dans une classe dérivée, traite une demande WS-Trust Renew.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la demande de jeton de sécurité (RST) associée à l'instance actuelle.</summary>
        <value><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui contient la demande.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la portée associée à l'instance actuelle.</summary>
        <value><see cref="T:System.IdentityModel.Scope" /> qui représente la configuration pour la demande d'émission de jeton.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> associé à l'instance actuelle.</summary>
        <value>Modèle de jeton de sécurité associé à l'instance actuelle.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il est tenté de définir la propriété sur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'instance de configuration du propriétaire.</summary>
        <value><see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> qui contient la configuration de l'instance en cours.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal"><see cref="T:System.Security.Claims.ClaimsPrincipal" /> qui représente l'identité du demandeur du jeton.</param>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande de jeton de sécurité. Cela inclut le message de demande ainsi que d'autres informations connexes clientes, telles que le contexte d'autorisation.</param>
        <summary>En cas de substitution dans une classe dérivée, traite une demande WS-Trust Validate.</summary>
        <returns><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> qui représente le RSTR pour retourner à l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode lève un <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request"><see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> qui représente la demande.</param>
        <summary>Valide la demande de jeton de sécurité (RST) encapsulée par cette instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> méthode est appelée depuis le pipeline d’émission de jeton (le <xref:System.IdentityModel.SecurityTokenService.Issue%2A> méthode) pour valider le RST entrant. Le RST est validé par rapport aux exigences (stratégie) du STS et une exception appropriée est levée s’il n’est pas valide.  
  
 L’implémentation par défaut de la <xref:System.IdentityModel.SecurityTokenService> classe prend en charge uniquement le modèle RST RSTR et uniquement la liaison de l’Issue de la spécification WS-Trust (le <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> propriété de la demande doit être définie sur <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). L’implémentation par défaut de cette méthode applique ces spécifications (et d’autres indiqué dans la section exceptions). Vous pouvez substituer cette méthode si vous devez appliquer les exigences de validation différents pour votre STS personnalisé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException"><paramref name="request" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> de la demande n'est pas définie sur <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />.  
  
- ou - 
La propriété <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> de la requête n'a pas la valeur <see langword="null" /> ou n'est pas l'une des constantes définies dans la classe <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" />.  
  
- ou - 
Le <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> de la requête est <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> et l'élément <see langword="KeySize" /> est présent, mais sa valeur n'est pas égale à zéro.</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">STS ne prend pas en charge le type de jeton de requête (basé sur la valeur de la propriété <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> de la requête).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>