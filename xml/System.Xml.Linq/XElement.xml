<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XElement.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac515213489ac8be26d6703a879772581c4b4082467.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">15213489ac8be26d6703a879772581c4b4082467</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Represents an XML element.</source>
          <target state="translated">Représente un élément XML.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>See <bpt id="p1">[</bpt>XElement Class Overview<ept id="p1">](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)</ept> and the Remarks section on this page for usage information and examples.</source>
          <target state="translated">Pour des informations d’utilisation et des exemples, consultez <bpt id="p1">[</bpt>Vue d’ensemble de la classe XElement<ept id="p1">](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)</ept> et la section Notes de cette page.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This class represents an XML element, the fundamental XML construct.</source>
          <target state="translated">Cette classe représente un élément XML, la construction XML fondamentale.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>See <bpt id="p1">[</bpt>XElement Class Overview<ept id="p1">](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)</ept> for other usage information.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>vue d’ensemble de la classe XElement<ept id="p1">](http://msdn.microsoft.com/library/d35180fe-7016-4895-9bfc-ba1e3f7875ec)</ept> pour d’autres informations sur l’utilisation.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>An element has an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, optionally one or more attributes, and can optionally contain content (for more information, see <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;</ph>).</source>
          <target state="translated">Un élément a un <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, vous pouvez éventuellement un ou plusieurs attributs et peut éventuellement contenir du contenu (pour plus d’informations, consultez <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> can contain the following types of content:</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> peut contenir les types de contenu suivants :</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For details about the valid content of an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valid d’un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> derives from <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer&gt;</ph>, which derives from <ph id="ph3">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> dérive de <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer&gt;</ph>, lequel dérive <ph id="ph3">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>Some <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> methods can be used from XAML.</source>
          <target state="translated">Certains <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> méthodes peuvent être utilisées à partir de XAML.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For more information, see <bpt id="p1">[</bpt>LINQ to XML Dynamic Properties<ept id="p1">](http://msdn.microsoft.com/library/0455f47c-4a68-4f2e-a3f8-dd1d85b99012)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Propriétés dynamiques LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/0455f47c-4a68-4f2e-a3f8-dd1d85b99012)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The following example creates an XML tree.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The content of the new element comes from a LINQ query.</source>
          <target state="translated">Le contenu du nouvel élément provient d’une requête LINQ.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The following is the same example, but in this case the XML is in a namespace.</source>
          <target state="translated">Voici le même exemple, mais dans ce cas le XML est un espace de noms.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For details about the valid content that can be passed to this constructor, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à ce constructeur, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Il existe une conversion implicite d’une chaîne en <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Lorsque vous créez un élément dans un espace de noms, l’usage consiste à utiliser la surcharge d’opérateur addition avec un <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> et une chaîne pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The following example creates an XML tree.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The content of the new element comes from a LINQ query.</source>
          <target state="translated">Le contenu du nouvel élément provient d’une requête LINQ.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> object to copy from.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir duquel effectuer la copie.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> class from another <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> object.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un autre objet <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)">
          <source>This constructor makes a deep copy of an element.</source>
          <target state="translated">Ce constructeur effectue une copie complète d’un élément.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)">
          <source>The following example creates an XML tree, creates a clone of the tree, and then calls <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.DeepEquals%2A&gt;</ph>, which tests whether the two XML trees are equal.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, crée un clone de l’arborescence, puis appelle <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.DeepEquals%2A&gt;</ph>, qui teste si les deux arborescences XML sont égales.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> that contains the name of the element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> qui contient le nom de l'élément.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> class with the specified name.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> avec le nom spécifié.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>This constructor creates an element with no content and no attributes.</source>
          <target state="translated">Ce constructeur crée un élément avec aucun contenu et aucun attribut.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Il existe une conversion implicite d’une chaîne en <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Lorsque vous créez un élément dans un espace de noms, l’usage consiste à utiliser la surcharge d’opérateur addition avec un <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> et une chaîne pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>The following example creates an element with no content.</source>
          <target state="translated">L’exemple suivant crée un élément sans contenu.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>The following example creates an element in a namespace with no content.</source>
          <target state="translated">L’exemple suivant crée un élément dans un espace de noms sans contenu.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XStreamingElement" /&gt;</ph> that contains unevaluated queries that will be iterated for the contents of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XStreamingElement" /&gt;</ph> qui contient des requêtes non évaluées qui seront itérées pour rechercher le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> class from an <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XStreamingElement" /&gt;</ph> object.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un objet <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XStreamingElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>This constructor iterates through the contents of the specified <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph>, and creates an element with its contents.</source>
          <target state="translated">Ce constructeur parcourt le contenu de l’objet <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph>et crée un élément avec son contenu.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>The following example creates a source XML tree, and then creates an <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph> from a query on the source XML tree.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML source, puis crée un <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph> à partir d’une requête sur l’arborescence XML source.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>It then serializes the <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph> to the console, adds a new element to the source XML tree, and then serializes the <ph id="ph2">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph> again.</source>
          <target state="translated">Il sérialise ensuite le <ph id="ph1">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph> à la console, ajoute un nouvel élément à l’arborescence XML source, puis la sérialise le <ph id="ph2">&lt;xref:System.Xml.Linq.XStreamingElement&gt;</ph> à nouveau.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>You can see that element newly added to the source XML tree is not included in the first serialization, but is included in the second.</source>
          <target state="translated">Vous pouvez voir cet élément qui vient d’être ajouté à l’arborescence XML source n’est pas inclus dans la première sérialisation, mais il est inclus dans la seconde.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> that contains the element name.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> qui contient le nom de l'élément.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>The contents of the element.</source>
          <target state="translated">Contenu de l'élément.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> class with the specified name and content.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> avec le nom et le contenu spécifiés.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>This constructor creates an element with the specified content and attributes.</source>
          <target state="translated">Ce constructeur crée un élément avec les attributs et le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Il existe une conversion implicite d’une chaîne en <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Lorsque vous créez un élément dans un espace de noms, l’usage consiste à utiliser la surcharge d’opérateur addition avec un <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> et une chaîne pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>For details about the valid content that can be passed to this constructor, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à ce constructeur, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>The following example creates an XML tree.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>The content of the new element comes from a LINQ query.</source>
          <target state="translated">Le contenu du nouvel élément provient d’une requête LINQ.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>The following example creates an XML tree with a variety of types of content.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML avec un large éventail de types de contenu.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>The following example creates an XML tree in a namespace.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML dans un espace de noms.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>The following example creates an XML tree with nested namespaces.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML avec des espaces de noms imbriqués.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> that contains the element name.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> qui contient le nom de l'élément.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>The initial content of the element.</source>
          <target state="translated">Contenu initial de l'élément.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> class with the specified name and content.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> avec le nom et le contenu spécifiés.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>This constructor creates an element with the specified content and attributes.</source>
          <target state="translated">Ce constructeur crée un élément avec les attributs et le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>There is an implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Il existe une conversion implicite d’une chaîne en <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>Typical use of this constructor is to specify a string as the parameter instead of creating a new <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>When creating an element in a namespace, typical use is to use the addition operator overload with an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> and a string to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Lorsque vous créez un élément dans un espace de noms, l’usage consiste à utiliser la surcharge d’opérateur addition avec un <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> et une chaîne pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>For details about the valid content that can be passed to this constructor, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à ce constructeur, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>The following example creates an XML tree.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>The content of the new element comes from a LINQ query.</source>
          <target state="translated">Le contenu du nouvel élément provient d’une requête LINQ.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>The following example creates an XML tree with a variety of types of content.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML avec un large éventail de types de contenu.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>The following example creates an XML tree in a namespace.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML dans un espace de noms.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>The following example creates an XML tree with nested namespaces.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML avec des espaces de noms imbriqués.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Returns a collection of elements that contain this element, and the ancestors of this element.</source>
          <target state="translated">Retourne une collection d'éléments contenant cet élément ainsi que ses ancêtres.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The elements in the returned collection are in reverse document order.</source>
          <target state="translated">Les éléments de la collection retournée sont dans l’ordre inverse du document.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>Returns a collection of elements that contain this element, and the ancestors of this element.</source>
          <target state="translated">Retourne une collection d'éléments contenant cet élément ainsi que ses ancêtres.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of elements that contain this element, and the ancestors of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments qui contiennent cet élément, ainsi que ses ancêtres.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>The elements in the returned collection are in reverse document order.</source>
          <target state="translated">Les éléments de la collection retournée sont dans l’ordre inverse du document.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>The following example creates an XML tree.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>It then finds the <ph id="ph1">`GrandChild`</ph> element, and then prints the ancestors of it.</source>
          <target state="translated">Il recherche ensuite le <ph id="ph1">`GrandChild`</ph> élément, puis imprime que ses ancêtres.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of elements that contain this element, and the ancestors of this element.</source>
          <target state="translated">Retourne une collection filtrée d’éléments contenant cet élément ainsi que ses ancêtres.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contain this element, and the ancestors of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient cet élément, ainsi que ses ancêtres.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>The elements in the returned collection are in reverse document order.</source>
          <target state="translated">Les éléments de la collection retournée sont dans l’ordre inverse du document.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>The following example uses this .</source>
          <target state="translated">L’exemple suivant utilise cette.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> to get.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> du <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> à obtenir.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that has the specified <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Retourne le <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui a le <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> that has the specified <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>; <ph id="ph3">&lt;see langword="null" /&gt;</ph> if there is no attribute with the specified name.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> qui a le <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> spécifié ; <ph id="ph3">&lt;see langword="null" /&gt;</ph> s'il n'existe aucun attribut avec le nom spécifié.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>Some  return collections of elements or attributes.</source>
          <target state="translated">Certaines retournent des collections d’éléments ou attributs.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>This method returns only a single attribute.</source>
          <target state="translated">Cette méthode retourne uniquement un attribut unique.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>Sometimes this is referred to as a <bpt id="p1">*</bpt>singleton<ept id="p1">*</ept> (in contrast to a <bpt id="p2">*</bpt>collection<ept id="p2">*</ept>).</source>
          <target state="translated">Cela est parfois appelée une <bpt id="p1">*</bpt>singleton<ept id="p1">*</ept> (contrairement à un <bpt id="p2">*</bpt>collection<ept id="p2">*</ept>).</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>Visual Basic users can use the integrated attribute axis to retrieve the value of an attribute with a specified name.</source>
          <target state="translated">Les utilisateurs de Visual Basic peuvent utiliser l’axe d’attribut intégrée pour récupérer la valeur d’un attribut avec un nom spécifié.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>The following example creates an element with an attribute.</source>
          <target state="translated">L’exemple suivant crée un élément avec un attribut.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>It then retrieves the attribute using this method.</source>
          <target state="translated">Il récupère ensuite l’attribut à l’aide de cette méthode.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>The following is the same example, but in this case the XML is in a namespace.</source>
          <target state="translated">Voici le même exemple, mais dans ce cas le XML est un espace de noms.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Returns a collection of attributes of this element.</source>
          <target state="translated">Retourne une collection d'attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>Returns a collection of attributes of this element.</source>
          <target state="translated">Retourne une collection d'attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> of attributes of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> d'attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>The attributes in the returned collection are in the order that they were added to the element.</source>
          <target state="translated">Les attributs de la collection retournée sont dans l’ordre qu’ils ont été ajoutés à l’élément.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>If the XML tree was parsed from XML, the attributes are returned in document order.</source>
          <target state="translated">Si l’arborescence XML a été analysée à partir de XML, les attributs sont retournés dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>The following example creates an element with two attributes.</source>
          <target state="translated">L’exemple suivant crée un élément avec deux attributs.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>It then uses this  to retrieve all attributes of the element.</source>
          <target state="translated">Il utilise pour récupérer tous les attributs de l’élément.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>The following is the same example, but in this case the XML is in a namespace.</source>
          <target state="translated">Voici le même exemple, mais dans ce cas le XML est un espace de noms.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of attributes of this element.</source>
          <target state="translated">Retourne une collection filtrée d’attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> that contains the attributes of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> qui contient les attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>Attribute names must be unique within an element.</source>
          <target state="translated">Noms d’attribut doivent être uniques au sein d’un élément.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>Therefore, this  can return either a collection that contains only one attribute, or it can return an empty collection.</source>
          <target state="translated">Par conséquent, il peut retourner une collection qui contient un seul attribut, ou elle peut retourner une collection vide.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>The following example uses this .</source>
          <target state="translated">L’exemple suivant utilise cette.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>The following is the same example, but in this case the XML is in a namespace.</source>
          <target state="translated">Voici le même exemple, mais dans ce cas le XML est un espace de noms.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>For more information, see <bpt id="p1">[</bpt>Working with XML Namespaces<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>utilisation des espaces de noms XML<ept id="p1">](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)</ept>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantNodesAndSelf">
          <source>Returns a collection of nodes that contain this element, and all descendant nodes of this element, in document order.</source>
          <target state="translated">Retourne une collection de nœuds contenant cet élément ainsi que tous ses nœuds descendants, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantNodesAndSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contain this element, and all descendant nodes of this element, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> qui contiennent cet élément, ainsi que tous ses nœuds descendants, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantNodesAndSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantNodesAndSelf">
          <source>The following example creates an XML tree, and then uses this .</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, puis l’utilise.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantNodesAndSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Returns a collection of elements that contain this element, and all descendant elements of this element, in document order.</source>
          <target state="translated">Retourne une collection d’éléments contenant cet élément ainsi que tous ses éléments descendants, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf">
          <source>Returns a collection of elements that contain this element, and all descendant elements of this element, in document order.</source>
          <target state="translated">Retourne une collection d’éléments contenant cet élément ainsi que tous ses éléments descendants, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of elements that contain this element, and all descendant elements of this element, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments qui contiennent cet élément, ainsi que tous ses éléments descendants, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf">
          <source>The following example creates an XML tree, and then uses this .</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, puis l’utilise.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of elements that contain this element, and all descendant elements of this element, in document order.</source>
          <target state="translated">Retourne une collection filtrée d’éléments contenant cet élément ainsi que tous ses éléments descendants, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contain this element, and all descendant elements of this element, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contiennent cet élément, ainsi que tous ses éléments descendants, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>The following example creates an XML tree, and then uses this .</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, puis l’utilise.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.EmptySequence">
          <source>Gets an empty collection of elements.</source>
          <target state="translated">Obtient une collection d’éléments vide.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.EmptySequence">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains an empty collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient une collection vide.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.EmptySequence">
          <source>This property is typically used by class implementers when writing a method that returns a collection of elements.</source>
          <target state="translated">Cette propriété est généralement utilisée par les implémenteurs de classes lors de l’écriture d’une méthode qui retourne une collection d’éléments.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.EmptySequence">
          <source>If the method must return no elements, it can use this property to get an empty collection of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> objects.</source>
          <target state="translated">Si la méthode ne doit retourner aucun élément, elle peut utiliser cette propriété pour obtenir une collection vide de <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.FirstAttribute">
          <source>Gets the first attribute of this element.</source>
          <target state="translated">Obtient le premier attribut de cet élément.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.FirstAttribute">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> that contains the first attribute of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> qui contient le premier attribut de cet élément.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.FirstAttribute">
          <source>Attributes are stored in the element in the order that they were added to the element.</source>
          <target state="translated">Les attributs sont stockés dans l’élément dans l’ordre qu’ils ont été ajoutés à l’élément.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.FirstAttribute">
          <source>The following example uses this property.</source>
          <target state="translated">L’exemple suivant utilise cette propriété.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.FirstAttribute">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>Gets the default <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Obtient le <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> par défaut de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> that contains the default namespace of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> qui contient l'espace de noms par défaut de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>Namespace declarations may be persisted as attributes in the XML tree.</source>
          <target state="translated">Les déclarations de Namespace peuvent être persistante en tant qu’attributs dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>These special attributes declare namespaces, including default namespaces.</source>
          <target state="translated">Ces attributs spéciaux déclarent des espaces de noms, y compris les espaces de noms par défaut.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>This method finds the namespace declaration that declares the default namespace, if there is one, and returns the <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> for the default namespace.</source>
          <target state="translated">Cette méthode trouve la déclaration d’espace de noms qui déclare l’espace de noms par défaut, le cas échéant, et retourne le <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> pour l’espace de noms par défaut.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>If there is no attribute that declares the default namespace, then this method returns <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">S’il n’existe aucun attribut qui déclare l’espace de noms par défaut, cette méthode retourne alors <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>When creating XML trees using C#, even if an XML tree would be serialized with a default namespace, if the namespace is not persisted in the XML tree as an attribute, this method will not report the namespace as the default namespace.</source>
          <target state="translated">Lorsque vous créez des arborescences XML à l’aide de c#, même si une arborescence XML est sérialisée avec un espace de noms par défaut, si l’espace de noms n’est pas persistante dans l’arborescence XML en tant qu’attribut, cette méthode ne signale pas l’espace de noms comme l’espace de noms par défaut.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>When creating XML trees using Visual Basic and XML literals, if you create the XML in a default namespace using the Imports statement, then a namespace attribute will be created in the tree by the Visual Basic compiler, and this method will report that namespace.</source>
          <target state="translated">Lorsque vous créez des arborescences XML à l’aide de Visual Basic et des littéraux XML, si vous créez le code XML dans un espace de noms par défaut à l’aide de l’instruction Imports, alors un attribut d’espace de noms est créé à l’arborescence par le compilateur Visual Basic, et cette méthode signale cet espace de noms.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>The following example creates an XML tree that has a default namespace.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML qui a un espace de noms par défaut.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>It then uses this method to retrieve the default namespace.</source>
          <target state="translated">Il utilise ensuite cette méthode pour récupérer l’espace de noms par défaut.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetDefaultNamespace">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>A string that contains the namespace prefix to look up.</source>
          <target state="translated">Chaîne contenant le préfixe d'espace de noms à rechercher.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>Gets the namespace associated with a particular prefix for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Obtient l'espace de noms associé à un préfixe particulier pour ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> for the namespace associated with the prefix for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> pour l'espace de noms associé au préfixe pour ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>This method looks through the XML tree for namespace attributes that are in scope for this element.</source>
          <target state="translated">Cette méthode parcourt l’arborescence XML pour les attributs d’espace de noms qui sont dans la portée pour cet élément.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>Namespace prefixes are specified in namespace attributes that are in the XML tree.</source>
          <target state="translated">Les préfixes Namespace sont spécifiés dans les attributs d’espace de noms qui se trouvent dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>The following example creates an XML tree that has a namespace with an associated prefix.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML qui a un espace de noms avec un préfixe associé.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>It then uses this method to retrieve the <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> for the prefix.</source>
          <target state="translated">Il utilise ensuite cette méthode pour récupérer le <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> pour le préfixe.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>When using Visual Basic, you would typically use the <bpt id="p1">[</bpt>GetXmlNamespace Operator<ept id="p1">](~/docs/visual-basic/language-reference/operators/getxmlnamespace-operator.md)</ept> operator, as follows</source>
          <target state="translated">Lorsque vous utilisez Visual Basic, vous utilisez généralement la <bpt id="p1">[</bpt>opérateur GetXmlNamespace<ept id="p1">](~/docs/visual-basic/language-reference/operators/getxmlnamespace-operator.md)</ept> (opérateur), comme suit</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> to look up.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> à rechercher.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>Gets the prefix associated with a namespace for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Obtient le préfixe associé à un espace de noms pour ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the namespace prefix.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient le préfixe d'espace de noms.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>This method looks through the XML tree for namespace attributes that are in scope for this element.</source>
          <target state="translated">Cette méthode parcourt l’arborescence XML pour les attributs d’espace de noms qui sont dans la portée pour cet élément.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>Namespace prefixes are specified in namespace attributes that are in the XML tree.</source>
          <target state="translated">Les préfixes Namespace sont spécifiés dans les attributs d’espace de noms qui se trouvent dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>If the namespace is the default namespace, and there is no prefix for the namespace, then this method returns null.</source>
          <target state="translated">Si l’espace de noms est l’espace de noms par défaut, et il n’existe pas de préfixe pour l’espace de noms, cette méthode retourne null.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>The following example creates an XML tree that contains a namespace with a prefix.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML qui contient un espace de noms avec un préfixe.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>It then uses this method to retrieve the prefix for the namespace.</source>
          <target state="translated">Il utilise ensuite cette méthode pour récupérer le préfixe pour l’espace de noms.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>Notice that this example uses the implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> when calling this method.</source>
          <target state="translated">Notez que cet exemple utilise la conversion implicite de chaîne à <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> lors de l’appel de cette méthode.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.HasAttributes">
          <source>Gets a value indicating whether this element has at least one attribute.</source>
          <target state="translated">Obtient une valeur indiquant si cet élément possède au moins un attribut.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.HasAttributes">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element has at least one attribute; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si cet élément possède au moins un attribut. Sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.HasAttributes">
          <source>The following example uses this property.</source>
          <target state="translated">L’exemple suivant utilise cette propriété.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.HasAttributes">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.HasElements">
          <source>Gets a value indicating whether this element has at least one child element.</source>
          <target state="translated">Obtient une valeur indiquant si cet élément possède au moins un élément enfant.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.HasElements">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element has at least one child element; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si cet élément a au moins un élément enfant ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.HasElements">
          <source>The following example uses this property.</source>
          <target state="translated">L’exemple suivant utilise cette propriété.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.HasElements">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source>Gets a value indicating whether this element contains no content.</source>
          <target state="translated">Obtient une valeur indiquant si cet élément ne contient aucun contenu.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element contains no content; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si cet élément ne contient aucun contenu ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source>Note that an element that contains a start and end tag with no content between the tags is not considered to be an empty element.</source>
          <target state="translated">Notez qu’un élément qui contient une balise de début et de fin sans contenu entre les balises n'est pas considéré comme un élément vide.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source>It has content with no length.</source>
          <target state="translated">Il a un contenu sans longueur.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source>Only an element that contains only a start tag, and is expressed as a terminated empty element, is considered to be empty.</source>
          <target state="translated">Seul un élément qui contient uniquement une balise de début et est exprimée sous la forme d’un élément vide terminé, est considéré comme vide.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source>The following example creates a variety of XML trees, and shows the value of this property with each tree.</source>
          <target state="translated">L’exemple suivant crée une variété d’arborescences XML et affiche la valeur de cette propriété avec chaque arborescence.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.IsEmpty">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.LastAttribute">
          <source>Gets the last attribute of this element.</source>
          <target state="translated">Obtient le dernier attribut de cet élément.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.LastAttribute">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> that contains the last attribute of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> qui contient le dernier attribut de cet élément.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.LastAttribute">
          <source>Attributes are stored in the element in the order that they were added to the element.</source>
          <target state="translated">Les attributs sont stockés dans l’élément dans l’ordre qu’ils ont été ajoutés à l’élément.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.LastAttribute">
          <source>The following example creates an XML tree with three attributes.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML avec trois attributs.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.LastAttribute">
          <source>It then writes the last attribute as output.</source>
          <target state="translated">Il écrit ensuite le dernier attribut en tant que sortie.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.LastAttribute">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a file specified by a URI, from an <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>, or from an <ph id="ph3">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un fichier spécifié par un URI, d'un <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> ou d'un <ph id="ph3">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>You can use one of the overloads of this method to load an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a file, a <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>, or an <ph id="ph3">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Vous pouvez utiliser une des surcharges de cette méthode pour charger un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir d’un fichier, un <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>, ou un <ph id="ph3">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>To create an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML, use <ph id="ph2">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph>.</source>
          <target state="translated">Pour créer un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir d’une chaîne qui contient du code XML, utilisez <ph id="ph2">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>The stream that contains the XML data.</source>
          <target state="translated">Flux contenant les données XML.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> instance by using the specified stream.</source>
          <target state="translated">Crée une nouvelle instance de <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à l'aide du flux spécifié.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> object used to read the data that is contained in the stream.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> permettant de lire les données contenues dans le flux de données.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>If you want to control load options, use the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> overload that takes <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions&gt;</ph> as a parameter.</source>
          <target state="translated">Si vous souhaitez contrôler les options de chargement, utilisez la <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> surcharge acceptant <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>If you have to modify <ph id="ph1">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph>, following these steps:</source>
          <target state="translated">Si vous devez modifier <ph id="ph1">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph>, procédez comme suit :</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>Create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by calling one of the <ph id="ph2">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> overloads that take <ph id="ph3">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph> as a parameter.</source>
          <target state="translated">Créer un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> en appelant une de le <ph id="ph2">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> surcharges qui prennent <ph id="ph3">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> to one of the <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>'s <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> overloads that takes <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> as a parameter.</source>
          <target state="translated">Passez le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> à un du <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>de <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> surcharges qui acceptent <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> that will be read for the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> content.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> qui sera lu pour le contenu <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated">Charge un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient le code XML qui a été lu à partir du <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>spécifié.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>This method reads the raw XML into the XML tree.</source>
          <target state="translated">Cette méthode lit les données XML brutes dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>It discards all insignificant white space in the file.</source>
          <target state="translated">Il ignore tous les espaces blancs non significatifs dans le fichier.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>The following example loads an element from a <ph id="ph1">&lt;xref:System.IO.StringReader&gt;</ph>.</source>
          <target state="translated">L’exemple suivant charge un élément d’un <ph id="ph1">&lt;xref:System.IO.StringReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>A URI string referencing the file to load into a new <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Chaîne d'URI faisant référence au fichier à charger dans un nouveau <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a file.</source>
          <target state="translated">Charge un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un fichier.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains the contents of the specified file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient le contenu du fichier spécifié.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>This method reads the raw XML into the XML tree.</source>
          <target state="translated">Cette méthode lit les données XML brutes dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>It discards all insignificant white space in the file.</source>
          <target state="translated">Il ignore tous les espaces blancs non significatifs dans le fichier.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>The following example creates an XML tree, saves it to a file, and then uses this method to load the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from the file.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, l’enregistre dans un fichier, puis utilise cette méthode pour charger le <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir du fichier.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that will be read for the content of the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> qui sera lu pour le contenu du <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from an <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Charge un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient le code XML qui a été lu à partir du <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>spécifié.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>By creating an <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> from a DOM document, and then using the <ph id="ph2">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> to create an <ph id="ph3">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</source>
          <target state="translated">En créant un <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> à partir d’un document DOM, puis en utilisant la <ph id="ph2">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> pour créer un <ph id="ph3">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, cette méthode peut être utilisée pour créer une copie d’un document DOM dans une arborescence LINQ to XML.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>The following example creates a DOM document, creates an <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> from the DOM document, instantiates a tree from the reader.</source>
          <target state="translated">L’exemple suivant crée un document DOM, crée un <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> à partir du document DOM, instancie une arborescence à partir du lecteur.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>This code effectively copies a DOM document into a LINQ to XML tree.</source>
          <target state="translated">Ce code copie effectivement un document DOM en LINQ à l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>The stream containing the XML data.</source>
          <target state="translated">Flux contenant les données XML.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> object that specifies whether to load base URI and line information.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> qui spécifie s'il faut charger l'URI de base et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</source>
          <target state="translated">Crée une instance <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir du flux spécifié, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> object used to read the data that the stream contains.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> permettant de lire les données contenues dans le flux de données.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>If you have to modify <ph id="ph1">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph>, following these steps:</source>
          <target state="translated">Si vous devez modifier <ph id="ph1">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph>, procédez comme suit :</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>Create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by calling one of the <ph id="ph2">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> overloads that take <ph id="ph3">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph> as a parameter.</source>
          <target state="translated">Créer un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> en appelant une de le <ph id="ph2">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> surcharges qui prennent <ph id="ph3">&lt;xref:System.Xml.XmlReaderSettings&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> to one of the <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>'s <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> overloads that takes <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> as a parameter.</source>
          <target state="translated">Passez le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> à un du <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>de <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Load%2A&gt;</ph> surcharges qui acceptent <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> that will be read for the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> content.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> qui sera lu pour le contenu <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>, optionally preserving white space and retaining line information.</source>
          <target state="translated">Charge un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>, en conservant éventuellement l'espace blanc et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient le code XML qui a été lu à partir du <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>spécifié.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to read all white space in the source XML.</source>
          <target state="translated">Si le code XML source est mis en retrait, la définition de la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> provoque le lecteur à lire tous les espaces blancs dans le XML source.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>Nodes of type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> are created for both significant and insignificant white space.</source>
          <target state="translated">Les nœuds de type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> sont créés pour les espaces blancs significatifs et non significatifs.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is indented, not setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to ignore all of the insignificant white space in the source XML.</source>
          <target state="translated">Si le code XML source est mis en retrait, ne définissez ne pas le <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> amène le lecteur à ignorer tous les espaces blancs non significatifs dans le XML source.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>The XML tree is created without any text nodes for insignificant white space.</source>
          <target state="translated">L’arborescence XML est créée sans nœud de texte pour les espaces blancs non significatifs.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is not indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> has no effect.</source>
          <target state="translated">Si la source XML n’est pas mis en retrait, la définition de la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</source>
          <target state="translated">Espace blanc significatif est conservé, et il n’y aucun étendues des espaces blancs non significatifs qui peuvent provoquer la création de plusieurs nœuds de texte d’un espace blanc.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir d’une chaîne qui contient du code XML.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> will have no effect when loading from a <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
          <target state="translated">Paramètre <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> n’aura aucun effet lors du chargement d’un <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flag.</source>
          <target state="translated">Il existe une baisse des performances si vous définissez la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>The line information is accurate immediately after loading the XML document.</source>
          <target state="translated">Les informations de ligne sont exactes immédiatement après le chargement du document XML.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>If you modify the XML tree after loading the document, the line information may become meaningless.</source>
          <target state="translated">Si vous modifiez l’arborescence XML après le chargement du document, les informations de ligne peuvent perdre leur signification.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>The following example loads an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a <ph id="ph2">&lt;xref:System.IO.StringReader&gt;</ph> in two different ways: preserving white space, and not preserving white space.</source>
          <target state="translated">L’exemple suivant charge un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> d’un <ph id="ph2">&lt;xref:System.IO.StringReader&gt;</ph> de deux façons différentes : en conservant l’espace blanc et ne conservant ne pas d’espace blanc.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>It then uses a query to determine the number of white space nodes in the resulting XML tree.</source>
          <target state="translated">Il utilise ensuite une requête pour déterminer le nombre de nœuds d’espaces blancs dans l’arborescence XML résultante.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>The following example loads the line information as it loads from the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
          <target state="translated">L’exemple suivant charge les informations de ligne tandis qu’il charge à partir de la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>It then prints the line information.</source>
          <target state="translated">Il imprime ensuite les informations de ligne.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>A URI string referencing the file to load into an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Chaîne d'URI faisant référence au fichier à charger dans un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a file, optionally preserving white space, setting the base URI, and retaining line information.</source>
          <target state="translated">Charge un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un fichier, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains the contents of the specified file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient le contenu du fichier spécifié.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to read all white space in the source XML.</source>
          <target state="translated">Si le code XML source est mis en retrait, la définition de la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> provoque le lecteur à lire tous les espaces blancs dans le XML source.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>Nodes of type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> are created for both significant and insignificant white space.</source>
          <target state="translated">Les nœuds de type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> sont créés pour les espaces blancs significatifs et non significatifs.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is indented, not setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to ignore all of the insignificant white space in the source XML.</source>
          <target state="translated">Si le code XML source est mis en retrait, ne définissez ne pas le <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> amène le lecteur à ignorer tous les espaces blancs non significatifs dans le XML source.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>The XML tree is created without any text nodes for insignificant white space.</source>
          <target state="translated">L’arborescence XML est créée sans nœud de texte pour les espaces blancs non significatifs.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is not indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> has no effect.</source>
          <target state="translated">Si la source XML n’est pas mis en retrait, la définition de la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</source>
          <target state="translated">Espace blanc significatif est conservé, et il n’y aucun étendues des espaces blancs non significatifs qui peuvent provoquer la création de plusieurs nœuds de texte d’un espace blanc.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir d’une chaîne qui contient du code XML.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flags.</source>
          <target state="translated">Il existe une baisse des performances si vous définissez la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> indicateurs.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>The base URI and the line information are accurate immediately after loading the XML document.</source>
          <target state="translated">L’URI de base et les informations de ligne sont exactes immédiatement après le chargement du document XML.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</source>
          <target state="translated">Si vous modifiez l’arborescence XML après le chargement du document, les informations d’URI et de la ligne de base peuvent perdre leur signification.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>The following example loads an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a file in two different ways: preserving white space, and not preserving white space.</source>
          <target state="translated">L’exemple suivant charge un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir d’un fichier de deux manières différentes : en conservant l’espace blanc et ne conservant ne pas d’espace blanc.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>It then uses a query to determine the number of white space nodes in the resulting XML tree.</source>
          <target state="translated">Il utilise ensuite une requête pour déterminer le nombre de nœuds d’espaces blancs dans l’arborescence XML résultante.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>The following example loads the base URI and line information as it loads the file.</source>
          <target state="translated">L’exemple suivant charge les informations d’URI et de la ligne de base, tandis qu’il charge le fichier.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>It then prints the base URI and the line information.</source>
          <target state="translated">Il imprime ensuite l’URI de base et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>This example uses the following resource file: <bpt id="p1">[</bpt>Sample XML File: Typical Purchase Order (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)</ept>.</source>
          <target state="translated">Cet exemple utilise le fichier de ressource suivant : <bpt id="p1">[</bpt>exemple de fichier XML : commande fournisseur typique (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)</ept>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that will be read for the content of the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> qui sera lu pour le contenu du <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from an <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>, optionally preserving white space, setting the base URI, and retaining line information.</source>
          <target state="translated">Charge un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'un <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> that contains the XML that was read from the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> qui contient le code XML qui a été lu à partir du <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>spécifié.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>By creating an <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> from a DOM document, and then using the <ph id="ph2">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> to create an <ph id="ph3">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</source>
          <target state="translated">En créant un <ph id="ph1">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> à partir d’un document DOM, puis en utilisant la <ph id="ph2">&lt;xref:System.Xml.XmlNodeReader&gt;</ph> pour créer un <ph id="ph3">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, cette méthode peut être utilisée pour créer une copie d’un document DOM dans une arborescence LINQ to XML.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> from a string that contains XML.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> pour créer un <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à partir d’une chaîne qui contient du code XML.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> is not valid when loading from a <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Paramètre <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> n’est pas valide lors du chargement d’un <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> will be configured to either read whitespace or not.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> sera configuré pour lire l’espace blanc ou non.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces.</source>
          <target state="translated">L’arborescence LINQ to XML est remplie avec les nœuds d’espace blanc qui les surfaces du lecteur.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>This will be the behavior regardless of whether <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> is set or not.</source>
          <target state="translated">Il s’agit du comportement, indépendamment du fait que <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> est défini ou non.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> may have a valid base URI or not.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> peut avoir un URI de base valid ou pas.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>If you set <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph>, the base URI will be set in the XML tree from the base URI that is reported by the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph>, la base de URI sera défini dans l’arborescence XML à partir de l’URI de base qui est signalée par le <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> may have a valid line information or not.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> peut avoir des informations de ligne valides ou pas.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>If you set <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph>, the line information will be set in the XML tree from the line information that is reported by the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph>, les informations de ligne seront définies dans l’arborescence XML à partir des informations de ligne qui sont signalées par le <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flag.</source>
          <target state="translated">Il existe une baisse des performances si vous définissez la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>The line information is accurate immediately after loading the XML document.</source>
          <target state="translated">Les informations de ligne sont exactes immédiatement après le chargement du document XML.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>If you modify the XML tree after loading the document, the line information may become meaningless.</source>
          <target state="translated">Si vous modifiez l’arborescence XML après le chargement du document, les informations de ligne peuvent perdre leur signification.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>The following example loads the line information that it loads from the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">L’exemple suivant charge les informations de ligne qu’il charge à partir de la <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>It then prints the line information.</source>
          <target state="translated">Il imprime ensuite les informations de ligne.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.Name">
          <source>Gets or sets the name of this element.</source>
          <target state="translated">Obtient ou définit le nom de cet élément.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Name">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> that contains the name of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> qui contient le nom de cet élément.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Name">
          <source>Setting this property will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Paramètre de cette propriété déclenche le <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> événements.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Name">
          <source>The following example uses this property to determine the name of an element.</source>
          <target state="translated">L’exemple suivant utilise cette propriété pour déterminer le nom d’un élément.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Name">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>Gets the node type for this node.</source>
          <target state="translated">Obtient le type de ce nœud.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>The node type.</source>
          <target state="translated">Type de nœud.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>For <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> objects, this value is <ph id="ph2">&lt;see cref="F:System.Xml.XmlNodeType.Element" /&gt;</ph>.</source>
          <target state="translated">Pour les objets <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>, cette valeur est <ph id="ph2">&lt;see cref="F:System.Xml.XmlNodeType.Element" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>Because all classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> contain a <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.NodeType%2A&gt;</ph> property, you can write code that operates on collections of concrete subclass of <ph id="ph3">&lt;xref:System.Xml.Linq.XObject&gt;</ph>.</source>
          <target state="translated">Étant donné que toutes les classes qui dérivent de <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> contiennent un <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.NodeType%2A&gt;</ph> propriété, vous pouvez écrire du code qui fonctionne sur des collections de la sous-classe concrète de <ph id="ph3">&lt;xref:System.Xml.Linq.XObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>Your code can then test for the node type of each node in the collection.</source>
          <target state="translated">Votre code peut ensuite tester le type de nœud de chaque nœud dans la collection.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>The following example uses this property to print the node type of an element.</source>
          <target state="translated">L’exemple suivant utilise cette propriété pour afficher le type de nœud d’un élément.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.NodeType">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>A <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>When converting to <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> from an attribute or element, allowed values are "0", "1", and any string that produces "true" or "false" after trimming and conversion to lower case.</source>
          <target state="translated">Lors de la conversion à <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> à partir d’un attribut ou un élément, valeurs autorisées sont « 0 », « 1 » et que toute chaîne qui génère « true » ou « false » après rognage et conversion en minuscules.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>The following example creates some elements with boolean values.</source>
          <target state="translated">L’exemple suivant crée des éléments avec des valeurs booléennes.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>It then casts them to <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>.</source>
          <target state="translated">Il convertit ensuite les <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.DateTime" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.DateTime" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.DateTime" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.DateTime" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>A <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>The value space of an attribute or element that contains date and time content is closely related to the dates and times described in ISO 8601.</source>
          <target state="translated">L’espace de valeur d’un attribut ou un élément qui contient la date et d’heure est étroitement lié aux dates et heures décrites dans ISO 8601.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>When creating an attribute or element that contains date and time content, the attribute or element values are formatted per the W3C specification.</source>
          <target state="translated">Lorsque vous créez un attribut ou un élément qui contient la date et d’heure, les valeurs d’attribut ou d’élément sont mis en forme conformément à la spécification W3C.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>See the W3C specification for more details.</source>
          <target state="translated">Consultez la spécification W3C pour plus de détails.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>Behavior is lax when casting to a <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> from an attribute or element.</source>
          <target state="translated">Comportement est lax lors de la conversion à un <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> à partir d’un attribut ou élément.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <ph id="ph1">&lt;xref:System.DateTime&gt;</ph>.</source>
          <target state="translated">Même si la valeur d’attribut ou d’élément n’est pas formatée exactement par la spécification W3C, la valeur est correctement convertie en un <ph id="ph1">&lt;xref:System.DateTime&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>This conversion operator uses <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> to convert from a <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</source>
          <target state="translated">Cet opérateur de conversion utilise <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> pour convertir un <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>The following example creates an element with date and time content.</source>
          <target state="translated">L’exemple suivant crée un élément avec la date et d’heure.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>It then casts it to <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> to retrieve the value.</source>
          <target state="translated">Il convertit ensuite à <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> pour récupérer la valeur.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XAttribute" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>A <ph id="ph1">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>This conversion operator uses the <ph id="ph1">&lt;xref:System.Xml.XmlConvert&gt;</ph> class to do the conversion.</source>
          <target state="translated">Cet opérateur de conversion utilise la <ph id="ph1">&lt;xref:System.Xml.XmlConvert&gt;</ph> classe pour effectuer la conversion.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>The following example creates an element with date and time content.</source>
          <target state="translated">L’exemple suivant crée un élément avec la date et d’heure.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>It then casts to <ph id="ph1">&lt;xref:System.DateTimeOffset&gt;</ph> to retrieve the value.</source>
          <target state="translated">Il convertit ensuite à <ph id="ph1">&lt;xref:System.DateTimeOffset&gt;</ph> pour récupérer la valeur.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>A <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>The following example creates an element with a decimal value.</source>
          <target state="translated">L’exemple suivant crée un élément avec une valeur décimale.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>It then retrieves the value of the attribute by casting to <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur de l’attribut en effectuant un cast à <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>A <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>The following example creates an attribute with <ph id="ph1">`double`</ph> content.</source>
          <target state="translated">L’exemple suivant crée un attribut avec <ph id="ph1">`double`</ph> contenu.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Guid" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Guid" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Guid" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Guid" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>The following example creates an element with a guid as content.</source>
          <target state="translated">L’exemple suivant crée un élément avec un guid en tant que contenu.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Guid&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Guid&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Int32" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to an <ph id="ph2">&lt;see cref="T:System.Int32" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>A <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>The following example creates an element with an integer as content.</source>
          <target state="translated">L’exemple suivant crée un élément avec un entier en tant que contenu.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Int64" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to an <ph id="ph2">&lt;see cref="T:System.Int64" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>A <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>The following example creates an element with a long integer as content.</source>
          <target state="translated">L’exemple suivant crée un élément avec un entier long en tant que contenu.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>It then retrieves the value of the element by casting to <ph id="ph1">&lt;xref:System.Int64&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur de l’élément en effectuant un cast à <ph id="ph1">&lt;xref:System.Int64&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>When converting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> from an attribute or element, allowed values are "0", "1", and any string that produces "true" or "false" after trimming and conversion to lower case.</source>
          <target state="translated">Lors de la conversion à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> à partir d’un attribut ou un élément, valeurs autorisées sont « 0 », « 1 » et que toute chaîne qui génère « true » ou « false » après rognage et conversion en minuscules.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>The following example creates an element with boolean content.</source>
          <target state="translated">L’exemple suivant crée un élément avec du contenu booléen.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Boolean&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Boolean&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.DateTime" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.DateTime" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.DateTime" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.DateTime" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.DateTime" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.DateTime" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>The value space of an attribute or element that contains date and time content is closely related to the dates and times described in ISO 8601.</source>
          <target state="translated">L’espace de valeur d’un attribut ou un élément qui contient la date et d’heure est étroitement lié aux dates et heures décrites dans ISO 8601.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>When creating an attribute or element that contains date and time content, the attribute or element values are formatted per the W3C specification.</source>
          <target state="translated">Lorsque vous créez un attribut ou un élément qui contient la date et d’heure, les valeurs d’attribut ou d’élément sont mis en forme conformément à la spécification W3C.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>See the W3C specification for more details.</source>
          <target state="translated">Consultez la spécification W3C pour plus de détails.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>The behavior is lax when casting to a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.DateTime&gt;</ph> from an attribute or element.</source>
          <target state="translated">Le comportement est lax lors de la conversion à un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.DateTime&gt;</ph> à partir d’un attribut ou élément.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</source>
          <target state="translated">Même si la valeur d’attribut ou d’élément n’est pas formatée exactement par la spécification W3C, la valeur est correctement convertie en un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>This conversion operator uses <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> to convert from a <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</source>
          <target state="translated">Cet opérateur de conversion utilise <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> pour convertir un <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>The following example creates an element with a date and time as content.</source>
          <target state="translated">L’exemple suivant crée un élément avec une date et une heure en tant que contenu.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.DateTime&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to an <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>This conversion operator uses the <ph id="ph1">&lt;xref:System.Xml.XmlConvert&gt;</ph> class to do the conversion.</source>
          <target state="translated">Cet opérateur de conversion utilise la <ph id="ph1">&lt;xref:System.Xml.XmlConvert&gt;</ph> classe pour effectuer la conversion.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>The following example creates an element with date and time content.</source>
          <target state="translated">L’exemple suivant crée un élément avec la date et d’heure.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>It then casts to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph> to retrieve the value.</source>
          <target state="translated">Il convertit ensuite en <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph> pour récupérer la valeur.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.DateTimeOffset" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>The following example creates an element with decimal content.</source>
          <target state="translated">L’exemple suivant crée un élément avec du contenu décimal.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Decimal&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Decimal&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>The following example creates an element with double precision floating point content.</source>
          <target state="translated">L’exemple suivant crée un élément avec contenu du point de flottante double précision.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Guid" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Guid" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Guid" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Guid" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Guid" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Guid" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>The following example creates an element with guid content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de type guid.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Guid&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Guid&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Int32" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Int32" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Int32" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>The following example creates an element with unsigned integer content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de l’entier non signé.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Int64" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Int64" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Int64" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Int64" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>The following example creates an element with long integer content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de l’entier long.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Int64&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Int64&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>The following example creates an element with single precision floating point content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu du point flottante simple précision.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>The value space of an attribute or element that contains time span content is closely related to duration content as described in ISO 8601.</source>
          <target state="translated">L’espace de valeur d’un attribut ou un élément qui contient le contenu d’intervalle de temps est étroitement lié au contenu de durée, comme décrit dans la norme ISO 8601.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>When creating an attribute or element that contains time span content, the attribute or element values are formatted per the W3C specification.</source>
          <target state="translated">Lorsque vous créez un attribut ou un élément qui contient le contenu d’intervalle de temps, les valeurs d’attribut ou d’élément sont mis en forme conformément à la spécification W3C.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>Please see the W3C specification for more details.</source>
          <target state="translated">Consultez la spécification W3C pour plus de détails.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>Behavior is lax when casting to a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> from an attribute or element.</source>
          <target state="translated">Comportement est lax lors de la conversion à un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> à partir d’un attribut ou élément.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>.</source>
          <target state="translated">Même si la valeur d’attribut ou d’élément n’est pas formatée exactement par la spécification W3C, la valeur est correctement convertie en un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>The following example creates an element with time span content.</source>
          <target state="translated">L’exemple suivant crée un élément avec un intervalle de temps contenu.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.UInt32" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.UInt32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.UInt32" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.UInt32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.UInt32" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.UInt32" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>The following example creates an element with unsigned integer content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de l’entier non signé.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.UInt32&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.UInt32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.UInt64" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.UInt64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph3">&lt;see cref="T:System.UInt64" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph3">&lt;see cref="T:System.UInt64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>A <ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.UInt64" /&gt;</ph> that contains the content of this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Nullable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.UInt64" /&gt;</ph> qui contient le contenu de ce <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>The following example creates an element with unsigned long integer content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de l’entier long non signé.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.UInt64&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.UInt64&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Single" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>A <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>The following example creates an element with single precision floating point content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu du point flottante simple précision.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>If the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> has children, the concatenated string value of all of the element's text and descendant's text is returned.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> a des enfants, la valeur de chaîne concaténée de tous les descendants et de texte de l’élément est retournée.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>The following example creates an element with string content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de chaîne.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>The value space of an attribute or element that contains time span content is closely related to duration content as described in ISO 8601.</source>
          <target state="translated">L’espace de valeur d’un attribut ou un élément qui contient le contenu d’intervalle de temps est étroitement lié au contenu de durée, comme décrit dans la norme ISO 8601.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>When creating an attribute or element that contains time span content, the attribute or element values are formatted per the W3C specification.</source>
          <target state="translated">Lorsque vous créez un attribut ou un élément qui contient le contenu d’intervalle de temps, les valeurs d’attribut ou d’élément sont mis en forme conformément à la spécification W3C.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>Please see the W3C specification for more details.</source>
          <target state="translated">Consultez la spécification W3C pour plus de détails.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>Behavior is lax when casting to a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> from an attribute or element.</source>
          <target state="translated">Comportement est lax lors de la conversion à un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> à partir d’un attribut ou élément.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</source>
          <target state="translated">Même si la valeur d’attribut ou d’élément n’est pas formatée exactement par la spécification W3C, la valeur est correctement convertie en un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>The following example creates an element with time span content.</source>
          <target state="translated">L’exemple suivant crée un élément avec un intervalle de temps contenu.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.UInt32" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.UInt32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.UInt32" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.UInt32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>A <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>The following example creates an element with unsigned integer content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de l’entier non signé.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.UInt32&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.UInt32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.UInt32" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to cast to <ph id="ph2">&lt;see cref="T:System.UInt64" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à caster en <ph id="ph2">&lt;see cref="T:System.UInt64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>Cast the value of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.UInt64" /&gt;</ph>.</source>
          <target state="translated">Castez la valeur de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.UInt64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>A <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph> that contains the content of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph> qui contient le contenu de ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>The following example creates an element with unsigned long integer content.</source>
          <target state="translated">L’exemple suivant crée un élément avec le contenu de l’entier long non signé.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>It then retrieves the value by casting to <ph id="ph1">&lt;xref:System.UInt64&gt;</ph>.</source>
          <target state="translated">Il récupère ensuite la valeur en effectuant un cast à <ph id="ph1">&lt;xref:System.UInt64&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>The element does not contain a valid <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph> value.</source>
          <target state="translated">L'élément ne contient pas de valeur <ph id="ph1">&lt;see cref="T:System.UInt64" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64">
          <source>The <ph id="ph1">&lt;paramref name="element" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="element" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Load an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a string that contains XML, optionally preserving white space and retaining line information.</source>
          <target state="translated">Chargez un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'une chaîne qui contient du code XML, en conservant éventuellement les espaces blancs et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient le code XML.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>Load an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a string that contains XML.</source>
          <target state="translated">Chargez un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'une chaîne qui contient le code XML.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> populated from the string that contains XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> rempli à partir de la chaîne qui contient le code XML.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>This method does not preserve white space.</source>
          <target state="translated">Cette méthode ne conserve pas les espaces blancs.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>If you want to preserve white space in the XML tree, use the overload of the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> method that takes <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions&gt;</ph> as a parameter.</source>
          <target state="translated">Si vous souhaitez conserver les espaces blancs dans l’arborescence XML, utilisez la surcharge de la <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> méthode prenant <ph id="ph2">&lt;xref:System.Xml.Linq.LoadOptions&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>The following example creates a string that contains XML.</source>
          <target state="translated">L’exemple suivant crée une chaîne qui contient du code XML.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>It then parses the string into an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
          <target state="translated">Il analyse ensuite la chaîne dans un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient le code XML.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> that specifies white space behavior, and whether to load base URI and line information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.LoadOptions" /&gt;</ph> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>Load an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> from a string that contains XML, optionally preserving white space and retaining line information.</source>
          <target state="translated">Chargez un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> à partir d'une chaîne qui contient du code XML, en conservant éventuellement les espaces blancs et les informations de ligne.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> populated from the string that contains XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> rempli à partir de la chaîne qui contient le code XML.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to read all white space in the source XML.</source>
          <target state="translated">Si le code XML source est mis en retrait, la définition de la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> provoque le lecteur à lire tous les espaces blancs dans le XML source.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>Nodes of type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> are created for both significant and insignificant white space.</source>
          <target state="translated">Les nœuds de type <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> sont créés pour les espaces blancs significatifs et non significatifs.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is indented, not setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> causes the reader to ignore all of the insignificant white space in the source XML.</source>
          <target state="translated">Si le code XML source est mis en retrait, ne définissez ne pas le <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> amène le lecteur à ignorer tous les espaces blancs non significatifs dans le XML source.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>The XML tree is created without any text nodes for insignificant white space.</source>
          <target state="translated">L’arborescence XML est créée sans nœud de texte pour les espaces blancs non significatifs.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>If the source XML is not indented, setting the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> flag in <ph id="ph2">`options`</ph> has no effect.</source>
          <target state="translated">Si la source XML n’est pas mis en retrait, la définition de la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.PreserveWhitespace&gt;</ph> indicateur dans <ph id="ph2">`options`</ph> n’a aucun effet.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</source>
          <target state="translated">Espace blanc significatif est conservé, et il n’y aucun étendues des espaces blancs non significatifs qui peuvent provoquer la création de plusieurs nœuds de texte d’un espace blanc.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> will have no effect when parsing from a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Paramètre <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> n’aura aucun effet lors de l’analyse d’un <ph id="ph2">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> may have a valid line information or not.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> peut avoir des informations de ligne valides ou pas.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>If you set <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph>, the line information will be set in the XML tree from the line information that is reported by the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Si vous définissez <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph>, les informations de ligne seront définies dans l’arborescence XML à partir des informations de ligne qui sont signalées par le <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>There is a performance penalty if you set the <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> flag.</source>
          <target state="translated">Il existe une baisse des performances si vous définissez la <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetLineInfo&gt;</ph> indicateur.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>The line information is accurate immediately after loading the XML document.</source>
          <target state="translated">Les informations de ligne sont exactes immédiatement après le chargement du document XML.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>If you modify the XML tree after loading the document, the line information may become meaningless.</source>
          <target state="translated">Si vous modifiez l’arborescence XML après le chargement du document, les informations de ligne peuvent perdre leur signification.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>LINQ to XML's loading functionality is built upon <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">LINQ à la fonctionnalité de chargement de XML repose sur <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>Therefore, you might catch any exceptions that are thrown by the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> overload methods and the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> methods that read and parse the document.</source>
          <target state="translated">Par conséquent, vous pouvez intercepter les exceptions levées par le <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType&gt;</ph> surcharger des méthodes et les <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> les méthodes qui lisent et analysent le document.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>The following example parses a string into an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> in two different ways: preserving white space, and not preserving white space.</source>
          <target state="translated">L’exemple suivant analyse une chaîne dans un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> de deux façons différentes : en conservant l’espace blanc et ne conservant ne pas d’espace blanc.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>It then uses a query to determine the number of white space nodes in the resulting XML tree.</source>
          <target state="translated">Il utilise ensuite une requête pour déterminer le nombre de nœuds d’espaces blancs dans l’arborescence XML résultante.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>The following example retains line information as it parses the string.</source>
          <target state="translated">L’exemple suivant conserve les informations de ligne tandis qu’il analyse la chaîne.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.RemoveAll">
          <source>Removes nodes and attributes from this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Supprime des nœuds et des attributs de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAll">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAll">
          <source>The following example creates an element with attributes and child elements.</source>
          <target state="translated">L’exemple suivant crée un élément avec des attributs et éléments enfants.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAll">
          <source>It then calls this method to remove both the attributes and the child elements.</source>
          <target state="translated">Il appelle ensuite cette méthode pour supprimer les attributs et les éléments enfants.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAll">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.RemoveAttributes">
          <source>Removes the attributes of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</source>
          <target state="translated">Supprime les attributs de ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAttributes">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAttributes">
          <source>The following example creates an element with attributes and child elements.</source>
          <target state="translated">L’exemple suivant crée un élément avec des attributs et éléments enfants.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAttributes">
          <source>It then calls this method to remove the attributes.</source>
          <target state="translated">Il appelle ensuite cette méthode pour supprimer les attributs.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAttributes">
          <source>The child elements remain.</source>
          <target state="translated">Les éléments enfants restent.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.RemoveAttributes">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Replaces the child nodes and the attributes of this element with the specified content.</source>
          <target state="translated">Remplace les nœuds enfants et les attributs de cet élément par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This method uses snapshot semantics—that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</source>
          <target state="translated">Cette méthode utilise la sémantique des instantanés, autrement dit, il crée une copie distincte du nouveau contenu avant de remplacer le contenu de l’élément actuel par le nouveau contenu.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This means that you can query the contents of the current element and use the results of the query as the specified new content.</source>
          <target state="translated">Cela signifie que vous pouvez interroger le contenu de l’élément actuel et utiliser les résultats de la requête en tant que nouveau contenu spécifié.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The following example passes the results of a LINQ query to this method, replacing the contents of an element with the query results.</source>
          <target state="translated">L’exemple suivant passe les résultats d’une requête LINQ à cette méthode, en remplaçant le contenu d’un élément avec les résultats de requête.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>It queries the element that is having its contents replaced.</source>
          <target state="translated">Elle interroge l’élément qui a son contenu remplacé.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>The content that will replace the child nodes and attributes of this element.</source>
          <target state="translated">Contenu qui remplacera les nœuds enfants et les attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>Replaces the child nodes and the attributes of this element with the specified content.</source>
          <target state="translated">Remplace les nœuds enfants et les attributs de cet élément par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>This method first removes existing content and attributes.</source>
          <target state="translated">Cette méthode supprime tout d’abord les attributs et le contenu existant.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
          <target state="translated">Il ajoute ensuite l’objet <ph id="ph1">`content`</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>This method uses snapshot semantics—that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</source>
          <target state="translated">Cette méthode utilise la sémantique des instantanés, autrement dit, il crée une copie distincte du nouveau contenu avant de remplacer le contenu de l’élément actuel par le nouveau contenu.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>This means that you can query the contents of the current element and use the results of the query as the specified new content.</source>
          <target state="translated">Cela signifie que vous pouvez interroger le contenu de l’élément actuel et utiliser les résultats de la requête en tant que nouveau contenu spécifié.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>The following example uses this method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">Liste de paramètres d'objets de contenu.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>Replaces the child nodes and the attributes of this element with the specified content.</source>
          <target state="translated">Remplace les nœuds enfants et les attributs de cet élément par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>This method first removes existing content and attributes.</source>
          <target state="translated">Cette méthode supprime tout d’abord les attributs et le contenu existant.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
          <target state="translated">Il ajoute ensuite l’objet <ph id="ph1">`content`</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>This method uses snapshot semantics—that is, it creates a separate copy of the new content before replacing the contents of the current element with the new content.</source>
          <target state="translated">Cette méthode utilise la sémantique des instantanés, autrement dit, il crée une copie distincte du nouveau contenu avant de remplacer le contenu de l’élément actuel par le nouveau contenu.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>This means that you can query the contents of the current element and use the results of the query as the specified new content.</source>
          <target state="translated">Cela signifie que vous pouvez interroger le contenu de l’élément actuel et utiliser les résultats de la requête en tant que nouveau contenu spécifié.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>The following example passes the results of a LINQ query to this method, replacing the contents of an element with the query results.</source>
          <target state="translated">L’exemple suivant passe les résultats d’une requête LINQ à cette méthode, en remplaçant le contenu d’un élément avec les résultats de requête.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Replaces the attributes of this element with the specified content.</source>
          <target state="translated">Remplace les attributs de cet élément par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>The following example creates an element with three attributes.</source>
          <target state="translated">L’exemple suivant crée un élément avec trois attributs.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>It then uses this method to replace all of the attributes of the element with a single attribute.</source>
          <target state="translated">Il utilise ensuite cette méthode pour remplacer tous les attributs de l’élément avec un seul attribut.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XElement">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>The content that will replace the attributes of this element.</source>
          <target state="translated">Contenu qui remplacera les attributs de cet élément.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>Replaces the attributes of this element with the specified content.</source>
          <target state="translated">Remplace les attributs de cet élément par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>This method first removes existing attributes.</source>
          <target state="translated">Cette méthode supprime d’abord les attributs existants.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
          <target state="translated">Il ajoute ensuite l’objet <ph id="ph1">`content`</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>The following example creates an element with three attributes.</source>
          <target state="translated">L’exemple suivant crée un élément avec trois attributs.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>It then uses this method to replace all of the attributes of the element with a single attribute.</source>
          <target state="translated">Il utilise ensuite cette méthode pour remplacer tous les attributs de l’élément avec un seul attribut.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">Liste de paramètres d'objets de contenu.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>Replaces the attributes of this element with the specified content.</source>
          <target state="translated">Remplace les attributs de cet élément par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>This method first removes existing attributes.</source>
          <target state="translated">Cette méthode supprime d’abord les attributs existants.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>It then adds the specified <ph id="ph1">`content`</ph>.</source>
          <target state="translated">Il ajoute ensuite l’objet <ph id="ph1">`content`</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>For details about the valid content that can be passed to this function, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>The following example creates an element with three attributes.</source>
          <target state="translated">L’exemple suivant crée un élément avec trois attributs.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>It then replaces the attributes with other attributes.</source>
          <target state="translated">Il remplace les attributs à d’autres attributs.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Serialize this element's underlying XML tree.</source>
          <target state="translated">Sérialisez l’arborescence XML sous-jacente de cet élément.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>The output can be saved to a file, an <ph id="ph1">&lt;see cref="T:System.Xml.XmlTextWriter" /&gt;</ph>, a <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>, or an <ph id="ph3">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">La sortie peut être enregistrée vers un fichier, un <ph id="ph1">&lt;see cref="T:System.Xml.XmlTextWriter" /&gt;</ph>, un <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> ou un <ph id="ph3">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XElement">
          <source>Optionally, formatting (indenting) can be disabled.</source>
          <target state="translated">Éventuellement, la mise en forme (mise en retrait) peut être désactivée.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>The stream to output this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to.</source>
          <target state="translated">Flux vers lequel générer ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>Outputs this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Renvoie ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> vers le <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>The serialized XML will be indented.</source>
          <target state="translated">Le code XML sérialisé est en retrait.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</source>
          <target state="translated">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>The behavior of this method is that insignificant white space will not be preserved.</source>
          <target state="translated">Le comportement de cette méthode est que l’espace blanc non significatif ne sera pas préservé.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>If you want to control white space, use the overload of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> that takes <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> as a parameter.</source>
          <target state="translated">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> qui accepte <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> option to save unindented XML.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> option pour enregistrer le code XML.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>This will cause the writer to write all white spaces exactly as represented in the XML tree.</source>
          <target state="translated">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces&gt;</ph> option if you want to remove duplicate namespace declarations.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces&gt;</ph> option si vous souhaitez supprimer les déclarations d’espace de noms en double.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> will be written to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> dans lequel le <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> sera écrit.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>Serialize this element to a <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">Sérialisez cet élément vers un <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>The serialized XML will be indented.</source>
          <target state="translated">Le code XML sérialisé est en retrait.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</source>
          <target state="translated">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>The behavior of this method is that white space will not be preserved.</source>
          <target state="translated">Le comportement de cette méthode est que l’espace blanc ne sera pas préservé.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>If you want to control white space, use the overload of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> that allows you to specify <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> as a parameter.</source>
          <target state="translated">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> qui vous permet de spécifier <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, saves the document to a <ph id="ph2">&lt;xref:System.IO.StringWriter&gt;</ph>, and then prints the string to the console.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, enregistre le document à un <ph id="ph2">&lt;xref:System.IO.StringWriter&gt;</ph>, puis imprime la chaîne dans la console.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the name of the file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient le nom du fichier.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>Serialize this element to a file.</source>
          <target state="translated">Sérialisez cet élément dans un fichier.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>The serialized XML will be indented.</source>
          <target state="translated">Le code XML sérialisé est en retrait.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</source>
          <target state="translated">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</source>
          <target state="translated">Le comportement de cette méthode est que les nœuds dans l’arborescence XML ne seront pas préservés espaces non significatifs.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>If you want to control white space, use the overload of <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> that allows you to specify <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> as a parameter.</source>
          <target state="translated">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> qui vous permet de spécifier <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions&gt;</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, saves the document to a file, and then prints the file to the console.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, enregistre le document dans un fichier, puis imprime le fichier dans la console.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> will be written to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> dans lequel le <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> sera écrit.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)">
          <source>Serialize this element to an <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Sérialisez cet élément vers un <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)">
          <source>The following example shows how to save an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> to an <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>.</source>
          <target state="translated">L'exemple suivant montre comment enregistrer un objet <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> dans un objet <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>The stream to output this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to.</source>
          <target state="translated">Flux vers lequel générer ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> object that specifies formatting behavior.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> qui spécifie le comportement de mise en forme.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>Outputs this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> to the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>, optionally specifying formatting behavior.</source>
          <target state="translated">Génère ce <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> vers le <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié, en précisant le cas échéant le comportement de mise en forme.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>By default the <ph id="ph1">`options`</ph> are set to <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions.None&gt;</ph>.</source>
          <target state="translated">Par défaut le <ph id="ph1">`options`</ph> ont la valeur <ph id="ph2">&lt;xref:System.Xml.Linq.SaveOptions.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</source>
          <target state="translated">Cette option supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>If you want to save unindented XML, specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
          <target state="translated">Si vous souhaitez enregistrer le code XML, spécifiez la <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> indicateur pour <ph id="ph2">`options`</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>This will cause the writer to write all white spaces exactly as represented in the XML tree.</source>
          <target state="translated">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)">
          <source>Use <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces&gt;</ph> option if you want to remove duplicate namespace declarations.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces&gt;</ph> option si vous souhaitez supprimer les déclarations d’espace de noms en double.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> to output the XML to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> vers lequel exporter le code XML.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> that specifies formatting behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> qui spécifie le comportement de mise en forme.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>Serialize this element to a <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>, optionally disabling formatting.</source>
          <target state="translated">Sérialisez cet élément vers un <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>, en désactivant éventuellement la mise en forme.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>If you want to save unindented XML, specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
          <target state="translated">Si vous souhaitez enregistrer le code XML, spécifiez la <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> indicateur pour <ph id="ph2">`options`</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>This will cause the writer to write all white space exactly as represented in the XML tree.</source>
          <target state="translated">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>If you want to save indented XML, do not specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
          <target state="translated">Si vous souhaitez enregistrer le code XML mis en retrait, ne spécifiez pas le <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> indicateur pour <ph id="ph2">`options`</ph>.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</source>
          <target state="translated">Cela supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>This is the default behavior, and the behavior of the overloads of the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> methods that do not take <ph id="ph2">`options`</ph> as a parameter.</source>
          <target state="translated">Il s’agit du comportement par défaut et le comportement des surcharges de la <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> les méthodes qui ne prennent pas <ph id="ph2">`options`</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>The following example shows two uses of this method.</source>
          <target state="translated">L’exemple suivant montre deux utilisations de cette méthode.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>The first use preserves white space.</source>
          <target state="translated">La première utilisation conserve l’espace blanc.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>The second serializes the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> with formatting.</source>
          <target state="translated">La seconde sérialise le <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> avec mise en forme.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>Because the document has no white space in it as constructed, preserving white space outputs the XML without any indenting.</source>
          <target state="translated">Étant donné que le document ne comporte aucun espace blanc comme construit, conservation des espaces blancs génère le XML sans mise en retrait.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the name of the file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient le nom du fichier.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> that specifies formatting behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> qui spécifie le comportement de mise en forme.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>Serialize this element to a file, optionally disabling formatting.</source>
          <target state="translated">Sérialisez cet élément dans un fichier, en désactivant éventuellement la mise en forme.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>If you want to save unindented XML, specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
          <target state="translated">Si vous souhaitez enregistrer le code XML, spécifiez la <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> indicateur pour <ph id="ph2">`options`</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>This will cause the writer to write all white space exactly as represented in the XML tree.</source>
          <target state="translated">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>If you want to save indented XML, do not specify the <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> flag for <ph id="ph2">`options`</ph>.</source>
          <target state="translated">Si vous souhaitez enregistrer le code XML mis en retrait, ne spécifiez pas le <ph id="ph1">&lt;xref:System.Xml.Linq.SaveOptions.DisableFormatting&gt;</ph> indicateur pour <ph id="ph2">`options`</ph>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</source>
          <target state="translated">Cela supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>This is the default behavior, and the behavior of the overloads of the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> methods that do not take <ph id="ph2">`options`</ph> as a parameter.</source>
          <target state="translated">Il s’agit du comportement par défaut et le comportement des surcharges de la <ph id="ph1">&lt;xref:System.Xml.Linq.XElement.Save%2A&gt;</ph> les méthodes qui ne prennent pas <ph id="ph2">`options`</ph> en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Preserving White Space while Loading or Parsing XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> and <bpt id="p2">[</bpt>Preserving White Space While Serializing<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>conserver les espaces lors du chargement ou de l’analyse de XML<ept id="p1">](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)</ept> et <bpt id="p2">[</bpt>conserver un espace blanc tandis que sérialisation<ept id="p2">](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)</ept>.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>The following example shows two uses of this method.</source>
          <target state="translated">L’exemple suivant montre deux utilisations de cette méthode.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>The first use preserves white space.</source>
          <target state="translated">La première utilisation conserve l’espace blanc.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>The second one serializes the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> with formatting.</source>
          <target state="translated">La seconde sérialise le <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> avec mise en forme.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> that contains the name of the attribute to change.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> qui contient le nom de l'attribut à modifier.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>The value to assign to the attribute.</source>
          <target state="translated">Valeur à assigner à l'attribut.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>The attribute is removed if the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'attribut est supprimé si la valeur est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>Otherwise, the value is converted to its string representation and assigned to the <ph id="ph1">&lt;see cref="P:System.Xml.Linq.XAttribute.Value" /&gt;</ph> property of the attribute.</source>
          <target state="translated">Sinon, la valeur est convertie en sa représentation sous forme de chaîne et assignée à la propriété <ph id="ph1">&lt;see cref="P:System.Xml.Linq.XAttribute.Value" /&gt;</ph> de l'attribut.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>Sets the value of an attribute, adds an attribute, or removes an attribute.</source>
          <target state="translated">Définit la valeur d'un attribut, ajoute un attribut ou supprime un attribut.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>This method is designed to make it easy to maintain a list of name/value pairs as a set of attributes.</source>
          <target state="translated">Cette méthode est conçue pour faciliter la gestion d’une liste de paires nom/valeur sous la forme d’un ensemble d’attributs.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>When maintaining the list, you need to add pairs, modify pairs, or delete pairs.</source>
          <target state="translated">Lors de la maintenance de la liste, vous devez ajouter des paires, paires de modifier ou supprimer des paires de.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>If you call this method passing a name that does not exist as an attribute, this method creates an attribute for you.</source>
          <target state="translated">Si vous appelez cette méthode en passant un nom qui n’existe pas en tant qu’attribut, cette méthode crée un attribut pour vous.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>If you call this method passing the name of an existing attribute, this method modifies the value of the attribute to the value that you specify.</source>
          <target state="translated">Si vous appelez cette méthode en passant le nom d’un attribut existant, cette méthode modifie la valeur de l’attribut à la valeur que vous spécifiez.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`value`</ph>, this method removes the attribute.</source>
          <target state="translated">Si vous passez <ph id="ph1">`null`</ph> pour <ph id="ph2">`value`</ph>, cette méthode supprime l’attribut.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>The value is assigned to the attribute with the specified name.</source>
          <target state="translated">La valeur est assignée à l’attribut avec le nom spécifié.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>If no attribute with the specified name exists, a new attribute is added.</source>
          <target state="translated">Si aucun attribut avec le nom spécifié existe, un nouvel attribut est ajouté.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>If the value is <ph id="ph1">`null`</ph>, the attribute with the specified name, if any, is deleted.</source>
          <target state="translated">Si la valeur est <ph id="ph1">`null`</ph>, l’attribut avec le nom spécifié, le cas échéant, est supprimé.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Maintaining Name/Value Pairs<ept id="p1">](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>en conservant les paires nom/valeur<ept id="p1">](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)</ept>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>The following example creates an element with an attribute.</source>
          <target state="translated">L’exemple suivant crée un élément avec un attribut.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>It then uses this method to replace the content of the attribute.</source>
          <target state="translated">Il utilise ensuite cette méthode pour remplacer le contenu de l’attribut.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">La <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est une instance de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> that contains the name of the child element to change.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> qui contient le nom de l'élément enfant à modifier.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>The value to assign to the child element.</source>
          <target state="translated">Valeur à assigner à l'élément enfant.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>The child element is removed if the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'élément enfant est supprimé si la valeur est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>Otherwise, the value is converted to its string representation and assigned to the <ph id="ph1">&lt;see cref="P:System.Xml.Linq.XElement.Value" /&gt;</ph> property of the child element.</source>
          <target state="translated">Sinon, la valeur est convertie en sa représentation sous forme de chaîne et assignée à la propriété <ph id="ph1">&lt;see cref="P:System.Xml.Linq.XElement.Value" /&gt;</ph> de l'élément enfant.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>Sets the value of a child element, adds a child element, or removes a child element.</source>
          <target state="translated">Définit la valeur d'un élément enfant, ajoute un élément enfant ou supprime un élément enfant.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>This method is designed to make it easy to maintain a list of name/value pairs as a set of children elements.</source>
          <target state="translated">Cette méthode est conçue pour faciliter la gestion une liste de paires nom/valeur sous la forme d’un jeu d’éléments enfants.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>When maintaining the list, you need to add pairs, modify pairs, or delete pairs.</source>
          <target state="translated">Lors de la maintenance de la liste, vous devez ajouter des paires, paires de modifier ou supprimer des paires de.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>If you call this method passing a name that does not exist as a child element, this method creates a child element for you.</source>
          <target state="translated">Si vous appelez cette méthode en passant un nom qui n’existe pas comme un élément enfant, cette méthode crée un élément enfant pour vous.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>If you call this method passing the name of an existing child element, this method modifies the value of the child element to the value that you specify.</source>
          <target state="translated">Si vous appelez cette méthode en passant le nom d’un élément enfant existant, cette méthode modifie la valeur de l’élément enfant à la valeur que vous spécifiez.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>If you pass <ph id="ph1">`null`</ph> for <ph id="ph2">`value`</ph>, this method removes the child element.</source>
          <target state="translated">Si vous passez <ph id="ph1">`null`</ph> pour <ph id="ph2">`value`</ph>, cette méthode supprime l’élément enfant.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>This method will raise events.</source>
          <target state="translated">Cette méthode déclenchera des événements.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>The value is assigned to the first child element with the specified name.</source>
          <target state="translated">La valeur est assignée au premier élément enfant avec le nom spécifié.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>If no child element with the specified name exists, a new child element is added.</source>
          <target state="translated">Si aucun élément enfant avec le nom spécifié existe, un nouvel élément enfant est ajouté.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>If the value is null, the first child element with the specified name, if any, is deleted.</source>
          <target state="translated">Si la valeur est null, le premier élément enfant avec le nom spécifié, le cas échéant, est supprimé.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>This method does not add child nodes or attributes to the specified child element.</source>
          <target state="translated">Cette méthode n’ajoute pas de nœuds enfants ou des attributs à l’élément enfant spécifié.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>This method throws an exception if any object that derives from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> is passed as <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Cette méthode lève une exception si un objet qui dérive de <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> est passé en tant que <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Maintaining Name/Value Pairs<ept id="p1">](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>en conservant les paires nom/valeur<ept id="p1">](http://msdn.microsoft.com/library/fe9798bf-b5e2-4a3c-a86c-7f8638912691)</ept>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>The following example creates an element with a child element.</source>
          <target state="translated">L’exemple suivant crée un élément avec un élément enfant.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>It then uses this method to set the value of the child element.</source>
          <target state="translated">Il utilise ensuite cette méthode pour définir la valeur de l’élément enfant.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">La <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est une instance de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>The value to assign to this element.</source>
          <target state="translated">Valeur à assigner à cet élément.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>The value is converted to its string representation and assigned to the <ph id="ph1">&lt;see cref="P:System.Xml.Linq.XElement.Value" /&gt;</ph> property.</source>
          <target state="translated">La valeur est convertie en sa représentation sous forme de chaîne et assignée à la propriété <ph id="ph1">&lt;see cref="P:System.Xml.Linq.XElement.Value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>Sets the value of this element.</source>
          <target state="translated">Définit la valeur de cet élément.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>It is invalid to pass an instance of a class that derives from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>, such as <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
          <target state="translated">Il n’est pas valide pour transmettre une instance d’une classe qui dérive de <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>, tel que <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>The following example creates an element that contains a child element.</source>
          <target state="translated">L’exemple suivant crée un élément qui contient un élément enfant.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>It then sets the value of the element using this method.</source>
          <target state="translated">Il définit ensuite la valeur de l’élément à l’aide de cette méthode.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.SetValue(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">La <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est un <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>Gets an XML schema definition that describes the XML representation of this object.</source>
          <target state="translated">Obtient une définition de schéma XML qui décrit la représentation XML de cet objet.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchema" /&gt;</ph> that describes the XML representation of the object that is produced by the <ph id="ph2">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph> method and consumed by the <ph id="ph3">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchema" /&gt;</ph> qui décrit la représentation XML de l'objet qui est généré par la méthode <ph id="ph2">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph> et utilisé par la méthode <ph id="ph3">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>This method is part of implementation of the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Cette méthode fait partie de l’implémentation de la <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>This method is used internally for serializing object graphs that contain LINQ to XML objects.</source>
          <target state="translated">Cette méthode est utilisée en interne pour la sérialisation de graphiques d’objets qui contiennent des LINQ to objets XML.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>For an example of serializing an object graph that contains LINQ to XML objects, see <bpt id="p1">[</bpt>Serializing Object Graphs that Contain XElement Objects<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</source>
          <target state="translated">Pour obtenir un exemple de la sérialisation d’un graphique d’objet qui contient LINQ to objets XML, consultez <bpt id="p1">[</bpt>objet de sérialisation graphiques qui contiennent des objets XElement<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which the object is deserialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> à partir duquel l'objet est désérialisé.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>Generates an object from its XML representation.</source>
          <target state="translated">Génère un objet à partir de sa représentation XML.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>This method is part of implementation of the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Cette méthode fait partie de l’implémentation de la <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>This method is used internally for serializing object graphs that contain LINQ to XML objects.</source>
          <target state="translated">Cette méthode est utilisée en interne pour la sérialisation de graphiques d’objets qui contiennent des LINQ to objets XML.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>For an example of serializing an object graph that contains LINQ to XML objects, see <bpt id="p1">[</bpt>Serializing Object Graphs that Contain XElement Objects<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</source>
          <target state="translated">Pour obtenir un exemple de la sérialisation d’un graphique d’objet qui contient LINQ to objets XML, consultez <bpt id="p1">[</bpt>objet de sérialisation graphiques qui contiennent des objets XElement<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> to which this object is serialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> vers lequel cet objet est sérialisé.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>Converts an object into its XML representation.</source>
          <target state="translated">Convertit un objet en sa représentation XML.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>This method is used internally for marshaling object graphs that contain LINQ to XML objects.</source>
          <target state="translated">Cette méthode est utilisée en interne pour le marshaling de graphiques d’objets qui contiennent des LINQ to objets XML.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>For an example of serializing an object graph that contains LINQ to XML objects, see <bpt id="p1">[</bpt>Serializing Object Graphs that Contain XElement Objects<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</source>
          <target state="translated">Pour obtenir un exemple de la sérialisation d’un graphique d’objet qui contient LINQ to objets XML, consultez <bpt id="p1">[</bpt>objet de sérialisation graphiques qui contiennent des objets XElement<ept id="p1">](http://msdn.microsoft.com/library/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)</ept>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XElement.Value">
          <source>Gets or sets the concatenated text contents of this element.</source>
          <target state="translated">Obtient ou définit le texte concaténé de cet élément.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains all of the text content of this element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contient tout le contenu de texte de cet élément.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>If there are multiple text nodes, they will be concatenated.</source>
          <target state="translated">S'il existe plusieurs nœuds de texte, ils seront concaténés.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>Using this property, you can get or set the value of an element.</source>
          <target state="translated">À l’aide de cette propriété, vous pouvez obtenir ou définir la valeur d’un élément.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>Setting this property will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Paramètre de cette propriété déclenche le <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> événements.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>If you want to get the value of an element but you are not sure that it exists, it is more convenient to use the explicit conversion operators, and assign the element to a nullable type such as <ph id="ph1">`string`</ph> or <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> of <ph id="ph3">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Si vous voulez obtenir la valeur d’un élément, mais vous n’êtes pas sûr qu’il existe, il est plus pratique d’utiliser les opérateurs de conversion explicite et affecter l’élément à un type nullable tel que <ph id="ph1">`string`</ph> ou <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> de <ph id="ph3">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>If the element does not exist, the nullable type is set to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Si l’élément n’existe pas, le type nullable a la valeur <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>By contrast, if you want to use this property, you must make sure that the <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer.Element%2A&gt;</ph> method does not return <ph id="ph2">`null`</ph> before you access this property.</source>
          <target state="translated">En revanche, si vous souhaitez utiliser cette propriété, vous devez vous assurer que le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer.Element%2A&gt;</ph> méthode ne retourne pas <ph id="ph2">`null`</ph> avant d’accéder à cette propriété.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>The following example uses this property to retrieve the text of an element with mixed content.</source>
          <target state="translated">L’exemple suivant utilise cette propriété pour récupérer le texte d’un élément avec du contenu mixte.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XElement.Value">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> into which this method will write.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> dans lequel cette méthode écrira.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)">
          <source>Write this element to an <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Écrivez cet élément vers un <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)">
          <source>The following example shows how to write an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> to an <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>.</source>
          <target state="translated">L’exemple suivant montre comment écrire un <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> à un <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)">
          <source>Note that the example did not write an XML declaration.</source>
          <target state="translated">Notez que l’exemple n’a pas écrit de déclaration XML.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>