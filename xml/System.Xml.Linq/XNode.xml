<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XNode.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5f001654247344cf25b9ac07d23e7fb08ac4c201a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f001654247344cf25b9ac07d23e7fb08ac4c201a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</source>
          <target state="translated">Représente le concept abstrait d’un nœud (élément, commentaire, type de document, instruction de traitement ou nœud de texte) dans l’arborescence XML.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> is an abstract common base class for the following types:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> est une classe de base commune abstraite pour les types suivants :</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> is an abstract common base class for the following types:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> est une classe de base commune abstraite pour les types suivants :</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Objects of classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> can contain child nodes.</source>
          <target state="translated">Les objets des classes qui dérivent de <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> peut contenir des nœuds enfants.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> is not an <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> n’est pas un <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Attributes are maintained as a list of name/value pairs on an element.</source>
          <target state="translated">Les attributs sont conservés sous forme de paires nom/valeur sur un élément de liste.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</source>
          <target state="translated">Si vous écrivez une application XML complexe, comme un éditeur XML ou un traitement de texte qui stocke le contenu au format XML, vous allez souvent travailler au niveau du nœud.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</source>
          <target state="translated">Les activités standards lors de l’utilisation au niveau du nœud incluent l’ajout de nœuds, suppression de nœuds, leur transformation et l’itération sur les axes qui retournent des collections de nœuds.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">Ajoute le contenu spécifié immédiatement après ce nœud.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">L’exemple suivant utilise une requête LINQ pour créer un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, qu’il passe ensuite à cette méthode.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Cela ajoute les résultats d’une requête à l’arborescence à l’emplacement souhaité.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>A content object that contains simple content or a collection of content objects to be added after this node.</source>
          <target state="translated">Objet de contenu qui contient du contenu simple ou une collection d’objets de contenu à ajouter après ce nœud.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">Ajoute le contenu spécifié immédiatement après ce nœud.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Événements <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>The following example uses this method to add an element into the tree.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour ajouter un élément dans l’arborescence.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le parent est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">Liste de paramètres d'objets de contenu.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>Adds the specified content immediately after this node.</source>
          <target state="translated">Ajoute le contenu spécifié immédiatement après ce nœud.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">L’exemple suivant utilise une requête LINQ pour créer un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, qu’il passe ensuite à cette méthode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Cela ajoute les résultats d’une requête à l’arborescence à l’emplacement souhaité.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le parent est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">Ajoute le contenu spécifié immédiatement avant ce nœud.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child notes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Therefore, using this method might  affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">L’exemple suivant utilise une requête LINQ pour créer un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, qu’il passe ensuite à cette méthode.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Cela ajoute les résultats d’une requête à l’arborescence à l’emplacement souhaité.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>A content object that contains simple content or a collection of content objects to be added before this node.</source>
          <target state="translated">Objet de contenu qui contient du contenu simple ou une collection d’objets de contenu à ajouter avant ce nœud.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">Ajoute le contenu spécifié immédiatement avant ce nœud.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>Therefore, using this method might  affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The following example uses this method to add an element into the tree.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour ajouter un élément dans l’arborescence.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le parent est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>A parameter list of content objects.</source>
          <target state="translated">Liste de paramètres d'objets de contenu.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>Adds the specified content immediately before this node.</source>
          <target state="translated">Ajoute le contenu spécifié immédiatement avant ce nœud.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>Therefore, using this function might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette fonction peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The following example uses a LINQ query to create an <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, which it then passes to this method.</source>
          <target state="translated">L’exemple suivant utilise une requête LINQ pour créer un <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, qu’il passe ensuite à cette méthode.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This adds the results of a query to the tree in the desired location.</source>
          <target state="translated">Cela ajoute les résultats d’une requête à l’arborescence à l’emplacement souhaité.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le parent est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the ancestor elements of this node.</source>
          <target state="translated">Retourne une collection des éléments ancêtres de ce nœud.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Optionally a node name can be specified to filter for ancestor elements with a specific name.</source>
          <target state="translated">Un nom de nœud peut éventuellement être spécifié pour filtrer les éléments ancêtres avec un nom spécifique.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">Les nœuds de la collection retournée sont dans l’ordre inverse du document.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>Returns a collection of the ancestor elements of this node.</source>
          <target state="translated">Retourne une collection des éléments ancêtres de ce nœud.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the ancestor elements of this node.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments ancêtres de ce nœud.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This method does not return itself in the results.</source>
          <target state="translated">Cette méthode ne retourne pas elle-même dans les résultats.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">Les nœuds de la collection retournée sont dans l'ordre inverse du document.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>The following example uses this method to enumerate the ancestors of a node.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour énumérer les ancêtres d’un nœud.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the ancestor elements of this node.</source>
          <target state="translated">Retourne une collection filtrée des éléments ancêtres de ce nœud.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the ancestor elements of this node.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments ancêtres de ce nœud.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The nodes in the returned collection are in reverse document order.</source>
          <target state="translated">Les nœuds de la collection retournée sont dans l’ordre inverse du document.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This method will not return itself in the results.</source>
          <target state="translated">Cette méthode ne se retournera pas elle-même dans les résultats.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>The following example uses this method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>First <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Premier <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à comparer.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à comparer.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Compares two nodes to determine their relative XML document order.</source>
          <target state="translated">Compare deux nœuds pour déterminer leur ordre respectif dans le document XML.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>An <ph id="ph1">&lt;see langword="int" /&gt;</ph> containing 0 if the nodes are equal; -1 if <ph id="ph2">&lt;paramref name="n1" /&gt;</ph> is before <ph id="ph3">&lt;paramref name="n2" /&gt;</ph>; 1 if <ph id="ph4">&lt;paramref name="n1" /&gt;</ph> is after <ph id="ph5">&lt;paramref name="n2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="int" /&gt;</ph> contenant 0 si les nœuds sont égaux ; -1 si <ph id="ph2">&lt;paramref name="n1" /&gt;</ph> est avant <ph id="ph3">&lt;paramref name="n2" /&gt;</ph> ; 1 si <ph id="ph4">&lt;paramref name="n1" /&gt;</ph> est après <ph id="ph5">&lt;paramref name="n2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> méthode doit parcourir les ancêtres des deux nœuds comparés jusqu'à ce qu’elle trouve le parent commun.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">Ensuite, il doit parcourir la liste de nœuds d’enfants du parent commun pour déterminer l’ordre des deux nœuds qui sont comparés.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The two nodes do not share a common ancestor.</source>
          <target state="translated">Les deux nœuds ne partagent pas d'ancêtre commun.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this node.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> pour ce nœud.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this node.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> pour ce nœud.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that can be used to read this node and its descendants.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> qui peut être utilisé pour lire ce nœud et ses descendants.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>You typically use this method when you have to supply another component with an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">Vous utilisez généralement cette méthode lorsque vous devez fournir un autre composant avec un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>For example, you can create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from a <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> tree, and then pass that reader to <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>.</source>
          <target state="translated">Par exemple, vous pouvez créer un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> d’un <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> d’arborescence, puis passer à <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>All of the readers returned by <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> are normalizing readers.</source>
          <target state="translated">Tous les lecteurs retournés par <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> sont normalisation des lecteurs.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>They always perform line break normalization and full normalization of attributes.</source>
          <target state="translated">Ils effectuent toujours la normalisation de saut de ligne et la normalisation complète d’attributs.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> is not a normalizing reader.</source>
          <target state="translated">En revanche, le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> retourné par <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> n’est pas un lecteur de la normalisation.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>It does not transform any white space.</source>
          <target state="translated">Il ne transforme pas tout espace blanc.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>It also returns attributes in the order that they were added, not in attribute name order.</source>
          <target state="translated">Il renvoie également les attributs dans l’ordre qu’ils ont été ajoutés, pas dans l’ordre de nom d’attribut.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> does not keep information about whether attributes are default attributes.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> ne conserve pas les informations que les attributs sont des attributs par défaut.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> will always return false regardless of whether the attribute was populated from a default value or not.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> Retourne toujours false, indique si l’attribut a été rempli à partir d’une valeur par défaut ou non.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The <ph id="ph1">`PUBLIC`</ph> and <ph id="ph2">`SYSTEM`</ph> pseudo attributes on <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> are not available through the <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">`PUBLIC`</ph> et <ph id="ph2">`SYSTEM`</ph> pseudo attributs sur <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> ne sont pas disponibles via la <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>They are only available through the <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> method that takes the qualified name of the attribute as a parameter.</source>
          <target state="translated">Ils sont uniquement disponibles via la <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> méthode qui prend le nom qualifié de l’attribut en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>If you have to retrieve the <ph id="ph1">`PUBLIC`</ph> or <ph id="ph2">`SYSTEM`</ph> attributes, you should use the <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si vous devez extraire le <ph id="ph1">`PUBLIC`</ph> ou <ph id="ph2">`SYSTEM`</ph> attributs, vous devez utiliser le <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Base64 and BinHex data are not supported.</source>
          <target state="translated">Les données au format Base64 et BinHex ne sont pas pris en charge.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>If you attempt to retrieve these types of data (for example, by calling <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), the reader will throw <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si vous essayez de récupérer ces types de données (par exemple, en appelant <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), le lecteur lèvera <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The <ph id="ph1">`xml`</ph> declaration is not surfaced by the reader.</source>
          <target state="translated">Le <ph id="ph1">`xml`</ph> déclaration n’est pas visible par le lecteur.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>While reading, you will not encounter a node of type <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>.</source>
          <target state="translated">Lors de la lecture, vous ne rencontrerez pas un nœud de type <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>The following example creates an XML tree, creates an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> method, and creates an <ph id="ph3">&lt;xref:System.Xml.XmlDocument&gt;</ph> by using the reader.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, crée un <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> (méthode) et crée un <ph id="ph3">&lt;xref:System.Xml.XmlDocument&gt;</ph> à l’aide du lecteur.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Another use for this method is to do an XSLT transformation.</source>
          <target state="translated">Une autre utilisation de cette méthode doit effectuer une transformation XSLT.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>You can create an XML tree, create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from the XML tree, create a new document, and create an <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> that will write into the new document.</source>
          <target state="translated">Vous pouvez créer une arborescence XML, créer un objet <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> à partir de l'arborescence XML, créer un nouveau document, puis créer un objet <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> qui écrira dans le nouveau document.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>Then, you can invoke the XSLT transformation, passing the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> to the transformation.</source>
          <target state="translated">Ensuite, vous pouvez appeler la transformation XSLT, en passant le <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> et le <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> à la transformation.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>After the transformation successfully completes, the new XML tree is populated with the results of the transform.</source>
          <target state="translated">Une fois la transformation terminée avec succès, la nouvelle arborescence XML est remplie avec les résultats de la transformation.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.CreateReader">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.ReaderOptions" /&gt;</ph> object that specifies whether to omit duplicate namespaces.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.Linq.ReaderOptions" /&gt;</ph> qui spécifie s'il faut omettre des espaces de noms en double.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> with the options specified by the <ph id="ph2">&lt;paramref name="readerOptions" /&gt;</ph> parameter.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> avec les options spécifiées par le paramètre <ph id="ph2">&lt;paramref name="readerOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Premier <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à comparer.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare.</source>
          <target state="translated">Deuxième <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à comparer.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Compares the values of two nodes, including the values of all descendant nodes.</source>
          <target state="translated">Compare les valeurs de deux nœuds, y compris les valeurs de tous les nœuds descendants.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the nodes are equal; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si les nœuds sont égaux ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following criteria determine whether two nodes are equal:</source>
          <target state="translated">Les critères suivants déterminent si deux nœuds sont égaux :</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>A <ph id="ph1">`null`</ph> node is equal to another <ph id="ph2">`null`</ph> node but unequal to a non-<ph id="ph3">`null`</ph> node.</source>
          <target state="translated">A <ph id="ph1">`null`</ph> nœud est égal à un autre <ph id="ph2">`null`</ph> nœud mais différent d’un non -<ph id="ph3">`null`</ph> nœud.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects of different types are never equal.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets de types différents ne sont jamais égaux.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> nodes are equal if they contain the same text.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> nœuds sont égaux s’ils contiennent le même texte.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> nœuds sont égales si elles ont le même nom de balise, le même jeu d’attributs avec les mêmes valeurs, et (hormis les commentaires et instructions de traitement) contiennent deux séquences de longueur égales de nœuds de contenu.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> nodes are equal if their root nodes are equal.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> nœuds sont égales si leurs nœuds racines sont égaux.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> nodes are equal if they contain the same comment text.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> nœuds sont égaux s’ils contiennent le même texte de commentaire.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> nodes are equal if they have the same target and data.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> nœuds sont égales si elles ont la même cible et les données.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> nodes are equal if the have the same name, public ID, system ID, and internal subset.</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> nœuds sont égales si l’ont le même nom, ID public, ID système et sous-ensemble interne.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>The following example uses this method to compare two XML trees.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour comparer deux arborescences XML.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>Gets a comparer that can compare the relative position of two nodes.</source>
          <target state="translated">Obtient un comparateur qui peut comparer la position relative de deux nœuds.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /&gt;</ph> that can compare the relative position of two nodes.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /&gt;</ph> qui peut comparer la position relative de deux nœuds.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>This property is primarily used internally for implementing the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> extension method.</source>
          <target state="translated">Cette propriété est principalement utilisée en interne pour l’implémentation de la <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> méthode d’extension.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>The recommended approach is to use that extension method instead of using this property directly.</source>
          <target state="translated">L’approche recommandée consiste à utiliser cette méthode d’extension au lieu d’utiliser cette propriété directement.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>The following example creates an XML tree with some elements.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML avec des éléments.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>It then creates a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> that contains some elements from the XML tree at random.</source>
          <target state="translated">Elle crée ensuite un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> qui contient des éléments de l’arborescence XML de manière aléatoire.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>It sorts the list, using this property to retrieve a <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeDocumentOrderComparer&gt;</ph>, which implements the <ph id="ph2">&lt;xref:System.Collections.IComparer?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</source>
          <target state="translated">Il trie la liste, à l’aide de cette propriété pour récupérer un <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeDocumentOrderComparer&gt;</ph>, qui implémente le <ph id="ph2">&lt;xref:System.Collections.IComparer?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.DocumentOrderComparer">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
          <target state="translated">Retourne une collection des éléments frères après ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
          <target state="translated">Retourne une collection des éléments frères après ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements after this node, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments frères après ce nœud, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Cette méthode inclut uniquement des frères dans la collection retournée.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>It does not include descendants.</source>
          <target state="translated">Il n’inclut pas de descendants.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>The following example creates an element with some complex content.</source>
          <target state="translated">L’exemple suivant crée un élément avec du contenu complexe.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>It then uses this method to retrieve the nodes in document order.</source>
          <target state="translated">Il utilise ensuite cette méthode pour récupérer les nœuds dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the sibling elements after this node, in document order.</source>
          <target state="translated">Retourne une collection filtrée des éléments frères après ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements after this node, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments frères après ce nœud, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Cette méthode inclut uniquement des frères dans la collection retournée.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>It does not include descendants.</source>
          <target state="translated">Il n’inclut pas de descendants.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>The following example creates an element with some complex content.</source>
          <target state="translated">L’exemple suivant crée un élément avec du contenu complexe.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>It then uses this method to retrieve the sibling elements, in document order.</source>
          <target state="translated">Il utilise ensuite cette méthode pour récupérer les éléments frères, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
          <target state="translated">Retourne une collection des éléments frères avant ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
          <target state="translated">Retourne une collection des éléments frères avant ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements before this node, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments frères avant ce nœud, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Cette méthode inclut uniquement des frères dans la collection retournée.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>It does not include descendants.</source>
          <target state="translated">Il n’inclut pas de descendants.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>The following example uses this axis method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode d’axe.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to match.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> à mettre en correspondance.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Returns a filtered collection of the sibling elements before this node, in document order.</source>
          <target state="translated">Retourne une collection filtrée des éléments frères avant ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of the sibling elements before this node, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> des éléments frères avant ce nœud, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>Only elements that have a matching <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are included in the collection.</source>
          <target state="translated">Seuls les éléments avec un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> correspondant sont inclus dans la collection.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Cette méthode inclut uniquement des frères dans la collection retournée.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>It does not include descendants.</source>
          <target state="translated">Il n’inclut pas de descendants.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>The following example uses this method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>Gets a comparer that can compare two nodes for value equality.</source>
          <target state="translated">Obtient un comparateur qui peut comparer deux nœuds pour vérifier l'égalité de leur valeur.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeEqualityComparer" /&gt;</ph> that can compare two nodes for value equality.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNodeEqualityComparer" /&gt;</ph> qui peut comparer deux nœuds pour vérifier l'égalité de leur valeur.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>The following example uses this property to retrieve an <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeEqualityComparer&gt;</ph>, which implements the <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</source>
          <target state="translated">L’exemple suivant utilise cette propriété pour récupérer un <ph id="ph1">&lt;xref:System.Xml.Linq.XNodeEqualityComparer&gt;</ph>, qui implémente le <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType&gt;</ph> interfaces.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>It creates a dictionary that uses this property.</source>
          <target state="translated">Il crée un dictionnaire qui utilise cette propriété.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.EqualityComparer">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare for document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à comparer par rapport à l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Determines if the current node appears after a specified node in terms of document order.</source>
          <target state="translated">Détermine si le nœud actuel apparaît après un nœud spécifié dans l'ordre du document.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this node appears after the specified node; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce nœud apparaît après le nœud spécifié ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> méthode doit parcourir les ancêtres des deux nœuds comparés jusqu'à ce qu’elle trouve le parent commun.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">Ensuite, il doit parcourir la liste de nœuds d’enfants du parent commun pour déterminer l’ordre des deux nœuds qui sont comparés.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> to compare for document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à comparer par rapport à l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Determines if the current node appears before a specified node in terms of document order.</source>
          <target state="translated">Détermine si le nœud actuel apparaît avant un nœud spécifié dans l'ordre du document.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this node appears before the specified node; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si ce nœud apparaît avant le nœud spécifié ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> méthode doit parcourir les ancêtres des deux nœuds comparés jusqu'à ce qu’elle trouve le parent commun.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
          <target state="translated">Ensuite, il doit parcourir la liste de nœuds d’enfants du parent commun pour déterminer l’ordre des deux nœuds qui sont comparés.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>The following example uses this method.</source>
          <target state="translated">L’exemple suivant utilise cette méthode.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>Gets the next sibling node of this node.</source>
          <target state="translated">Obtient le nœud frère suivant de ce nœud.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the next sibling node.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> qui contient le nœud frère suivant.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no next node, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si cette <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> est dépourvu de parent, ou s’il n’existe aucun nœud suivant, cette propriété retourne <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>The following example uses this property to loop through nodes.</source>
          <target state="translated">L’exemple suivant utilise cette propriété pour parcourir les nœuds.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.NextNode">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>Returns a collection of the sibling nodes after this node, in document order.</source>
          <target state="translated">Retourne une collection des nœuds frères après ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> of the sibling nodes after this node, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> des nœuds frères après ce nœud, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Cette méthode inclut uniquement des frères dans la collection retournée.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>It does not include descendants.</source>
          <target state="translated">Il n’inclut pas de descendants.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>The following example creates an XML tree, and then queries the tree using this axis method.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, puis interroge l’arborescence à l’aide de cette méthode d’axe.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesAfterSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>Returns a collection of the sibling nodes before this node, in document order.</source>
          <target state="translated">Retourne une collection des nœuds frères avant ce nœud, dans l’ordre du document.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> of the sibling nodes before this node, in document order.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> de <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> des nœuds frères avant ce nœud, dans l'ordre des documents.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This method only includes siblings in the returned collection.</source>
          <target state="translated">Cette méthode inclut uniquement des frères dans la collection retournée.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>It does not include descendants.</source>
          <target state="translated">Il n’inclut pas de descendants.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This method uses deferred execution.</source>
          <target state="translated">Cette méthode utilise l'exécution différée.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>The following example creates an XML tree, and then queries the tree using this axis method.</source>
          <target state="translated">L’exemple suivant crée une arborescence XML, puis interroge l’arborescence à l’aide de cette méthode d’axe.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.NodesBeforeSelf">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>Gets the previous sibling node of this node.</source>
          <target state="translated">Obtient le nœud frère précédent de ce nœud.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the previous sibling node.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> qui contient le nœud frère précédent.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no previous node, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si cette <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> est dépourvu de parent, ou s’il n’existe aucun nœud précédent, cette propriété retourne <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> property must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que le <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> propriété doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>Therefore, using this property might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette propriété peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>The following example uses this property to loop through nodes.</source>
          <target state="translated">L’exemple suivant utilise cette propriété pour parcourir les nœuds.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XNode.PreviousNode">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> positioned at the node to read into this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> positionné au niveau du nœud pour lire dans ce <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> from an <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Crée un <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> à partir d'un <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> that contains the node and its descendant nodes that were read from the reader.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNode" /&gt;</ph> qui contient le nœud et ses nœuds descendants qui ont été lus par le lecteur.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The runtime type of the node is determined by the node type (<ph id="ph1">&lt;see cref="P:System.Xml.Linq.XObject.NodeType" /&gt;</ph>) of the first node encountered in the reader.</source>
          <target state="translated">Le type au moment de l'exécution du nœud est déterminé par le type de nœud (<ph id="ph1">&lt;see cref="P:System.Xml.Linq.XObject.NodeType" /&gt;</ph>) du premier nœud rencontré dans le lecteur.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</source>
          <target state="translated">Vous pouvez utiliser cette méthode pour écrire une méthode qui retourne une collection de nœuds, produisant chaque nœud que le nœud est en lecture à partir du lecteur.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This method enables you to process arbitrarily large XML files with a very small memory footprint.</source>
          <target state="translated">Cette méthode vous permet de traiter des fichiers XML arbitrairement volumineux avec un très faible encombrement mémoire.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The reader that you pass to this method might throw exceptions.</source>
          <target state="translated">Le lecteur que vous passez à cette méthode peut lever des exceptions.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> ne pas intercepter toutes les exceptions levées par le lecteur ; les exceptions non gérées se propagent dans du code qui a appelé <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>In particular, your code should be prepared to handle <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>.</source>
          <target state="translated">En particulier, votre code doit être préparé à gérer <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>For an example of how to stream a more complex document, see <bpt id="p1">[</bpt>How to: Stream XML Fragments with Access to Header Information<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>.</source>
          <target state="translated">Pour obtenir un exemple montrant comment diffuser un document plus complexe, consultez <bpt id="p1">[</bpt>Comment : diffuser des fragments XML en continu avec accès aux informations d’en-tête<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Certain standard query operators, such as <ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</source>
          <target state="translated">Certains opérateurs de requête standard, tels que <ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>, itèrent au sein de leur source, recueillent toutes les données, les trient, puis produisent le premier élément de la séquence.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</source>
          <target state="translated">Si vous utilisez un opérateur de requête qui matérialise sa source avant de produire le premier élément, vous ne conserverez pas un faible encombrement mémoire.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>For an example of using <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> to transform extremely large XML documents while maintaining a small memory footprint, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
          <target state="translated">Pour obtenir un exemple d’utilisation de <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> pour transformer des documents XML extrêmement volumineux tout en conservant un faible encombrement mémoire, consultez <bpt id="p1">[</bpt>Comment : effectuer de diffusion en continu transformer des Documents XML volumineux<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example uses the following XML file, named Source.xml:</source>
          <target state="translated">Cet exemple utilise le fichier XML suivant, nommé Source.xml :</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example creates a custom axis method that uses <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
          <target state="translated">Cet exemple crée une méthode d’axe personnalisée qui utilise <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>You can query the custom axis by using a LINQ query.</source>
          <target state="translated">Vous pouvez interroger l’axe personnalisé à l’aide d’une requête LINQ.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The following example uses the yield return construct of C#.</source>
          <target state="translated">L’exemple suivant utilise la construction yield return de c#.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>Because there is no equivalent feature in <ph id="ph1">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph>, this example is provided only in C#.</source>
          <target state="translated">Étant donné qu'il n'y a aucune fonctionnalité équivalente en <ph id="ph1">[!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)]</ph>, cet exemple est fourni uniquement en C#.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>This example produces the following output.</source>
          <target state="translated">Cet exemple produit la sortie suivante.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> is not positioned on a recognized node type.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> n'est pas positionné sur un type de nœud reconnu.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)">
          <source>The underlying <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> throws an exception.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> sous-jacent lève une exception.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Removes this node from its parent.</source>
          <target state="translated">Supprime ce nœud de son parent.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>In <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</source>
          <target state="translated">Dans <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> de programmation, vous ne devez pas manipuler ou modifier un ensemble de nœuds tandis que vous demandez des nœuds dans ce jeu.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>In practical terms, this means that you should not iterate over a set of nodes and remove them.</source>
          <target state="translated">En pratique, cela signifie que vous ne devez pas itérer sur un ensemble de nœuds et les supprimer.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Instead, you should materialize them into a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> extension method.</source>
          <target state="translated">Au lieu de cela, vous devez les matérialiser dans une <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> méthode d’extension.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Then, you can iterate over the list to remove the nodes.</source>
          <target state="translated">Ensuite, vous pouvez parcourir la liste pour supprimer les nœuds.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>For more information, see <bpt id="p1">[</bpt>Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Mixed Declarative Code/impératif Code Bugs (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Alternatively, if you want to remove a set of nodes, it is recommended that you use the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également, si vous souhaitez supprimer un jeu de nœuds, il est recommandé que vous utilisez le <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This method copies the nodes to a list, and then iterates over the list to remove the nodes.</source>
          <target state="translated">Cette méthode copie les nœuds dans une liste, puis effectue une itération sur la liste pour supprimer les nœuds.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The following example removes a node from its parent.</source>
          <target state="translated">L’exemple suivant supprime un nœud de son parent.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.Remove">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.Remove">
          <source>The parent is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le parent est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">Remplace ce nœud par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must  traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>The following example uses this method to replace the contents of a node with different content.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour remplacer le contenu d’un nœud avec un contenu différent.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XNode">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Content that replaces this node.</source>
          <target state="translated">Contenu qui remplace ce nœud.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">Remplace ce nœud par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
          <target state="translated">Cette méthode supprime d’abord ce nœud de son parent, puis ajoute le contenu spécifié au parent de ce nœud, à la place de ce nœud.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>The following example uses this method to replace the contents of a node with different content.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour remplacer le contenu d’un nœud avec un contenu différent.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>A parameter list of the new content.</source>
          <target state="translated">Liste de paramètres du nouveau contenu.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>Replaces this node with the specified content.</source>
          <target state="translated">Remplace ce nœud par le contenu spécifié.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
          <target state="translated">Cette méthode supprime d’abord ce nœud de son parent, puis ajoute le contenu spécifié au parent de ce nœud, à la place de ce nœud.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stocke ses nœuds enfants sous la forme d’une liste liée de <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
          <target state="translated">Cela signifie que la <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> méthode doit parcourir la liste de nœuds enfants directs sous le conteneur parent.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>Therefore, using this method might affect your performance.</source>
          <target state="translated">Par conséquent, à l’aide de cette méthode peut affecter les performances.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le contenu valide qui peut être passé à cette méthode, consultez <bpt id="p1">[</bpt>valide le contenu des objets XElement et XDocument<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
          <target state="translated">Cette méthode lève la <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> et <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> les événements.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>The following example shows using the results of a <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> query as the input to this method.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation des résultats d’une <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> requête comme entrée pour cette méthode.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XNode">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
          <target state="translated">Retourne le code XML pour ce nœud, en désactivant éventuellement la mise en forme.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString">
          <source>Returns the indented XML for this node.</source>
          <target state="translated">Retourne le code XML mis en retrait pour ce nœud.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the indented XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant le code XML mis en retrait.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString">
          <source>The following example uses this method to retrieve indented XML.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour récupérer le code XML.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> that specifies formatting behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.SaveOptions" /&gt;</ph> qui spécifie le comportement de mise en forme.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
          <target state="translated">Retourne le code XML pour ce nœud, en désactivant éventuellement la mise en forme.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the XML.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant le code XML.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>The following example uses this method to retrieve unformatted and formatted XML.</source>
          <target state="translated">L’exemple suivant utilise cette méthode pour récupérer XML sans mise en forme et de mise en forme.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> into which this method will write.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> dans lequel cette méthode écrira.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>Writes this node to an <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Écrit ce nœud vers un <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>You can use this method to write code that does a streaming transform of a very large document.</source>
          <target state="translated">Vous pouvez utiliser cette méthode pour écrire du code qui effectue une transformation de diffusion en continu d’un document très volumineux.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Comment : effectuer de diffusion en continu transformer des Documents XML volumineux<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.XmlWriter&gt;</ph> that writes to a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Xml.XmlWriter&gt;</ph> qui écrit dans un <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>It then uses this method to write two XML trees to the writer.</source>
          <target state="translated">Il utilise ensuite cette méthode pour écrire deux arborescences XML vers le writer.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)">
          <source>This example produces the following output:</source>
          <target state="translated">Cet exemple génère la sortie suivante :</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>