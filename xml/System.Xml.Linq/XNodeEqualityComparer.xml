<Type Name="XNodeEqualityComparer" FullName="System.Xml.Linq.XNodeEqualityComparer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1331933f9ee261860aea966c53d6fe632cba7fe1" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39809456" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class XNodeEqualityComparer : System.Collections.Generic.IEqualityComparer&lt;System.Xml.Linq.XNode&gt;, System.Collections.IEqualityComparer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit XNodeEqualityComparer extends System.Object implements class System.Collections.Generic.IEqualityComparer`1&lt;class System.Xml.Linq.XNode&gt;, class System.Collections.IEqualityComparer" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNodeEqualityComparer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XNodeEqualityComparer&#xA;Implements IEqualityComparer, IEqualityComparer(Of XNode)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XNodeEqualityComparer sealed : System::Collections::Generic::IEqualityComparer&lt;System::Xml::Linq::XNode ^&gt;, System::Collections::IEqualityComparer" />
  <TypeSignature Language="F#" Value="type XNodeEqualityComparer = class&#xA;    interface IEqualityComparer&#xA;    interface IEqualityComparer&lt;XNode&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEqualityComparer&lt;System.Xml.Linq.XNode&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEqualityComparer</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="4654f-101">Compare des nœuds pour déterminer s'ils sont égaux.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4654f-101">Compares nodes to determine whether they are equal.</span>
      </span>
      <span data-ttu-id="4654f-102">Cette classe ne peut pas être héritée.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4654f-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4654f-103">L’objectif de cette classe consiste à implémenter <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> et <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4654f-103">The purpose of this class is to implement <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4654f-104">Les classes qui requièrent l’identité (tel que <xref:System.Collections.Generic.Dictionary%602> ) requièrent une instance d’une classe qui implémente l’une de ces interfaces.</span><span class="sxs-lookup"><span data-stu-id="4654f-104">Classes that require identity (such as <xref:System.Collections.Generic.Dictionary%602> ) require an instance of a class that implements one of these interfaces.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XNodeEqualityComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNodeEqualityComparer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XNodeEqualityComparer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4654f-105">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XNodeEqualityComparer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-105">Initializes a new instance of the <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4654f-106">L’exemple suivant utilise cette classe pour déterminer si deux nœuds sont égaux.</span><span class="sxs-lookup"><span data-stu-id="4654f-106">The following example uses this class to determine whether two nodes are equal.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XNodeEqualityComparer equalityComparer = new XNodeEqualityComparer();  
Console.WriteLine(equalityComparer.Equals(xmlTree1, xmlTree2));  
xmlTree2.Add(new XElement("NewChild", "new content"));  
Console.WriteLine(equalityComparer.Equals(xmlTree1, xmlTree2));  
```  
  
 <span data-ttu-id="4654f-107">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="4654f-107">This example produces the following output:</span></span>  
  
```  
True  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xml.Linq.XNode x, System.Xml.Linq.XNode y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xml.Linq.XNode x, class System.Xml.Linq.XNode y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNodeEqualityComparer.Equals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (x As XNode, y As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xml::Linq::XNode ^ x, System::Xml::Linq::XNode ^ y);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; bool" Usage="xNodeEqualityComparer.Equals (x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Xml.Linq.XNode" />
        <Parameter Name="y" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="x">
          <span data-ttu-id="4654f-108">Premier <see cref="T:System.Xml.Linq.XNode" /> à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-108">The first <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <param name="y">
          <span data-ttu-id="4654f-109">Deuxième <see cref="T:System.Xml.Linq.XNode" /> à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-109">The second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4654f-110">Compare les valeurs de deux nœuds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-110">Compares the values of two nodes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4654f-111">
            <see cref="T:System.Boolean" /> indiquant si les nœuds sont égaux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-111">A <see cref="T:System.Boolean" /> indicating if the nodes are equal.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4654f-112">Les critères suivants déterminent si les deux nœuds sont égaux :</span><span class="sxs-lookup"><span data-stu-id="4654f-112">The following criteria determine whether two nodes are equal:</span></span>  
  
-   <span data-ttu-id="4654f-113">Un `null` nœud est égal à un autre `null` nœud, mais pas égale à une non -`null` nœud.</span><span class="sxs-lookup"><span data-stu-id="4654f-113">A `null` node is equal to another `null` node but unequal to a non-`null` node.</span></span>  
  
-   <span data-ttu-id="4654f-114">Deux <xref:System.Xml.Linq.XNode> objets de types différents ne sont jamais égaux.</span><span class="sxs-lookup"><span data-stu-id="4654f-114">Two <xref:System.Xml.Linq.XNode> objects of different types are never equal.</span></span>  
  
-   <span data-ttu-id="4654f-115">Deux <xref:System.Xml.Linq.XText> nœuds sont égaux s’ils contiennent le même texte.</span><span class="sxs-lookup"><span data-stu-id="4654f-115">Two <xref:System.Xml.Linq.XText> nodes are equal if they contain the same text.</span></span>  
  
-   <span data-ttu-id="4654f-116">Deux <xref:System.Xml.Linq.XElement> nœuds sont égaux s’ils ont le même nom de balise, le même ensemble d’attributs avec les mêmes valeurs, et (hormis les commentaires et instructions de traitement), contiennent deux séquences de longueur égale d’égaux par paire nœuds de contenu.</span><span class="sxs-lookup"><span data-stu-id="4654f-116">Two <xref:System.Xml.Linq.XElement> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions), contain two equal-length sequences of pairwise equal content nodes.</span></span>  
  
-   <span data-ttu-id="4654f-117">Deux <xref:System.Xml.Linq.XDocument> objets sont égaux si leurs nœuds racines sont égaux.</span><span class="sxs-lookup"><span data-stu-id="4654f-117">Two <xref:System.Xml.Linq.XDocument> objects are equal if their root nodes are equal.</span></span>  
  
-   <span data-ttu-id="4654f-118">Deux <xref:System.Xml.Linq.XComment> nœuds sont égaux s’ils contiennent le même texte de commentaire.</span><span class="sxs-lookup"><span data-stu-id="4654f-118">Two <xref:System.Xml.Linq.XComment> nodes are equal if they contain the same comment text.</span></span>  
  
-   <span data-ttu-id="4654f-119">Deux <xref:System.Xml.Linq.XProcessingInstruction> nœuds sont égaux s’ils ont la même cible et les données.</span><span class="sxs-lookup"><span data-stu-id="4654f-119">Two <xref:System.Xml.Linq.XProcessingInstruction> nodes are equal if they have the same target and data.</span></span>  
  
-   <span data-ttu-id="4654f-120">Deux <xref:System.Xml.Linq.XDocumentType> nœuds sont égaux si les ont le même nom, ID public, ID système et sous-ensemble interne.</span><span class="sxs-lookup"><span data-stu-id="4654f-120">Two <xref:System.Xml.Linq.XDocumentType> nodes are equal if the have the same name, public ID, system ID, and internal subset.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4654f-121">L’exemple suivant utilise cette classe pour comparer deux nœuds.</span><span class="sxs-lookup"><span data-stu-id="4654f-121">The following example uses this class to compare two nodes.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XNodeEqualityComparer equalityComparer = new XNodeEqualityComparer();  
Console.WriteLine(equalityComparer.Equals(xmlTree1, xmlTree2));  
xmlTree2.Add(new XElement("NewChild", "new content"));  
Console.WriteLine(equalityComparer.Equals(xmlTree1, xmlTree2));  
```  
  
 <span data-ttu-id="4654f-122">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="4654f-122">This example produces the following output:</span></span>  
  
```  
True  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (System.Xml.Linq.XNode obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(class System.Xml.Linq.XNode obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNodeEqualityComparer.GetHashCode(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (obj As XNode) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode(System::Xml::Linq::XNode ^ obj);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : System.Xml.Linq.XNode -&gt; int" Usage="xNodeEqualityComparer.GetHashCode obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="4654f-123">
            <see cref="T:System.Xml.Linq.XNode" /> à hacher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-123">The <see cref="T:System.Xml.Linq.XNode" /> to hash.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4654f-124">Retourne un code de hachage reposant sur un <see cref="T:System.Xml.Linq.XNode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-124">Returns a hash code based on an <see cref="T:System.Xml.Linq.XNode" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4654f-125">
            <see cref="T:System.Int32" /> qui contient un code de hachage reposant sur une valeur pour le nœud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-125">A <see cref="T:System.Int32" /> that contains a value-based hash code for the node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4654f-126">Le <xref:System.Xml.Linq.XNode> implémentation de <xref:System.Object.GetHashCode%2A> repose sur l’identité référentielle du nœud.</span><span class="sxs-lookup"><span data-stu-id="4654f-126">The <xref:System.Xml.Linq.XNode> implementation of  <xref:System.Object.GetHashCode%2A> is based on the referential identity of the node.</span></span> <span data-ttu-id="4654f-127">Cette méthode calcule un code de hachage complexe basé sur la valeur du nœud et tous ses descendants.</span><span class="sxs-lookup"><span data-stu-id="4654f-127">This method computes a deep hash code based on the value of the node and all descendants.</span></span> <span data-ttu-id="4654f-128">Le code de hachage reflète tous les attributs et tous les nœuds descendants.</span><span class="sxs-lookup"><span data-stu-id="4654f-128">The hash code reflects all attributes and all descendent nodes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4654f-129">L’exemple suivant utilise cette méthode pour obtenir un code de hachage complexe pour une arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="4654f-129">The following example uses this method to get a deep hash code for an XML tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XNodeEqualityComparer equalityComparer = new XNodeEqualityComparer();  
Console.WriteLine("HashCode: {0}", equalityComparer.GetHashCode(xmlTree).ToString("X"));  
xmlTree.Add(new XElement("NewChild", "new content"));  
Console.WriteLine("HashCode: {0}", equalityComparer.GetHashCode(xmlTree).ToString("X"));  
```  
  
 <span data-ttu-id="4654f-130">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="4654f-130">This example produces the following output:</span></span>  
  
```  
HashCode: 958CCD0  
HashCode: AD26516B  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEqualityComparer.Equals">
      <MemberSignature Language="C#" Value="bool IEqualityComparer.Equals (object x, object y);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IEqualityComparer.Equals(object x, object y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNodeEqualityComparer.System#Collections#IEqualityComparer#Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (x As Object, y As Object) As Boolean Implements IEqualityComparer.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IEqualityComparer.Equals(System::Object ^ x, System::Object ^ y) = System::Collections::IEqualityComparer::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Object" />
        <Parameter Name="y" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="x">
          <span data-ttu-id="4654f-131">Premier <see cref="T:System.Xml.Linq.XNode" /> à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-131">The first <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <param name="y">
          <span data-ttu-id="4654f-132">Deuxième <see cref="T:System.Xml.Linq.XNode" /> à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-132">The second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4654f-133">Compare les valeurs de deux nœuds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-133">Compares the values of two nodes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4654f-134">
            <see langword="true" /> si les nœuds sont égaux ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-134">
              <see langword="true" /> if the nodes are equal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4654f-135">Les critères suivants déterminent si les deux nœuds sont égaux :</span><span class="sxs-lookup"><span data-stu-id="4654f-135">The following criteria determine whether two nodes are equal:</span></span>  
  
-   <span data-ttu-id="4654f-136">Un `null` nœud est égal à un autre `null` nœud, mais pas égale à une non -`null` nœud.</span><span class="sxs-lookup"><span data-stu-id="4654f-136">A `null` node is equal to another `null` node but unequal to a non-`null` node.</span></span>  
  
-   <span data-ttu-id="4654f-137">Deux <xref:System.Xml.Linq.XNode> objets de types différents ne sont jamais égaux.</span><span class="sxs-lookup"><span data-stu-id="4654f-137">Two <xref:System.Xml.Linq.XNode> objects of different types are never equal.</span></span>  
  
-   <span data-ttu-id="4654f-138">Deux <xref:System.Xml.Linq.XText> nœuds sont égaux s’ils contiennent le même texte.</span><span class="sxs-lookup"><span data-stu-id="4654f-138">Two <xref:System.Xml.Linq.XText> nodes are equal if they contain the same text.</span></span>  
  
-   <span data-ttu-id="4654f-139">Deux <xref:System.Xml.Linq.XElement> nœuds sont égaux s’ils ont le même nom de balise, le même ensemble d’attributs avec les mêmes valeurs, et (hormis les commentaires et instructions de traitement), contiennent deux séquences-longueur de l’égalité par paire nœuds de contenu.</span><span class="sxs-lookup"><span data-stu-id="4654f-139">Two <xref:System.Xml.Linq.XElement> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions), contain two equa-length sequences of pairwise equal content nodes.</span></span>  
  
-   <span data-ttu-id="4654f-140">Deux <xref:System.Xml.Linq.XDocument> objets sont égaux si leurs nœuds racines sont égaux.</span><span class="sxs-lookup"><span data-stu-id="4654f-140">Two <xref:System.Xml.Linq.XDocument> objects are equal if their root nodes are equal.</span></span>  
  
-   <span data-ttu-id="4654f-141">Deux <xref:System.Xml.Linq.XComment> nœuds sont égaux s’ils contiennent le même texte de commentaire.</span><span class="sxs-lookup"><span data-stu-id="4654f-141">Two <xref:System.Xml.Linq.XComment> nodes are equal if they contain the same comment text.</span></span>  
  
-   <span data-ttu-id="4654f-142">Deux <xref:System.Xml.Linq.XProcessingInstruction> nœuds sont égaux s’ils ont la même cible et les données.</span><span class="sxs-lookup"><span data-stu-id="4654f-142">Two <xref:System.Xml.Linq.XProcessingInstruction> nodes are equal if they have the same target and data.</span></span>  
  
-   <span data-ttu-id="4654f-143">Deux <xref:System.Xml.Linq.XDocumentType> nœuds sont égaux si les ont le même nom, ID public, ID système et sous-ensemble interne.</span><span class="sxs-lookup"><span data-stu-id="4654f-143">Two <xref:System.Xml.Linq.XDocumentType> nodes are equal if the have the same name, public ID, system ID, and internal subset.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEqualityComparer.GetHashCode">
      <MemberSignature Language="C#" Value="int IEqualityComparer.GetHashCode (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IEqualityComparer.GetHashCode(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNodeEqualityComparer.System#Collections#IEqualityComparer#GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (obj As Object) As Integer Implements IEqualityComparer.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IEqualityComparer.GetHashCode(System::Object ^ obj) = System::Collections::IEqualityComparer::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEqualityComparer.GetHashCode(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="4654f-144">Nœud à hacher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-144">The node to hash.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4654f-145">Retourne un code de hachage basé sur la valeur d'un nœud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-145">Returns a hash code based on the value of a node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4654f-146">
            <see cref="T:System.Int32" /> qui contient un code de hachage reposant sur une valeur pour le nœud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4654f-146">A <see cref="T:System.Int32" /> that contains a value-based hash code for the node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4654f-147">Le <xref:System.Xml.Linq.XNode> implémentation de <xref:System.Object.GetHashCode%2A> repose sur l’identité référentielle du nœud.</span><span class="sxs-lookup"><span data-stu-id="4654f-147">The <xref:System.Xml.Linq.XNode> implementation of <xref:System.Object.GetHashCode%2A> is based on the referential identity of the node.</span></span> <span data-ttu-id="4654f-148">Cette méthode calcule un code de hachage complexe basé sur la valeur du nœud, ses attributs et ses descendants.</span><span class="sxs-lookup"><span data-stu-id="4654f-148">This method computes a deep hash code based on the value of the node, its attributes, and its descendants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>