<Type Name="XDocument" FullName="System.Xml.Linq.XDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d79ed174f5e5f1d678e11f3ea4857185ee811f59" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XDocument : System.Xml.Linq.XContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XDocument extends System.Xml.Linq.XContainer" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XDocument&#xA;Inherits XContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XDocument : System::Xml::Linq::XContainer" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="f7931-101">Représente un document XML.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f7931-101">Represents an XML document.</span>
      </span>
      <span data-ttu-id="f7931-102">Pour les composants et l’utilisation d’un objet <see cref="T:System.Xml.Linq.XDocument" />, consultez <see href="http://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467">Vue d’ensemble de la classe XDocument</see>.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f7931-102">For the components and usage of an <see cref="T:System.Xml.Linq.XDocument" /> object, see <see href="http://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467">XDocument Class Overview</see>.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-103">Pour plus d’informations sur le contenu valid d’un <xref:System.Xml.Linq.XDocument>, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="f7931-103">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-104">L’exemple suivant crée un document, puis ajoute un commentaire et un élément.</span><span class="sxs-lookup"><span data-stu-id="f7931-104">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="f7931-105">Il compose ensuite un autre document en utilisant les résultats d’une requête.</span><span class="sxs-lookup"><span data-stu-id="f7931-105">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-106">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-106">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Linq.XNamespace" />
    <altmember cref="T:System.Xml.Linq.XDeclaration" />
    <altmember cref="T:System.Xml.Linq.XElement" />
    <altmember cref="T:System.Xml.Linq.XNode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-107">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-107">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-108">Constructeurs surchargés permettent de créer un nouveau vide <xref:System.Xml.Linq.XDocument>; pour créer un <xref:System.Xml.Linq.XDocument> avec du contenu initial spécifié ; et pour créer un <xref:System.Xml.Linq.XDocument> en tant que copie d’un autre <xref:System.Xml.Linq.XDocument> objet.</span><span class="sxs-lookup"><span data-stu-id="f7931-108">Overloaded constructors enable you to create a new empty <xref:System.Xml.Linq.XDocument>; to create an <xref:System.Xml.Linq.XDocument> with some specified initial content; and to create an <xref:System.Xml.Linq.XDocument> as a copy of another <xref:System.Xml.Linq.XDocument> object.</span></span>  
  
 <span data-ttu-id="f7931-109">Il n'existe pas beaucoup de scénarios qui requièrent la création d'un objet <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-109">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="f7931-110">Au lieu de cela, vous pouvez généralement créer vos arborescences XML avec un nœud racine <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="f7931-110">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="f7931-111">À moins que la création d'un document ne soit spécifiquement requise (par exemple si vous devez créer des instructions de traitement et des commentaires au niveau supérieur ou si vous devez prendre en charge des types de documents), il est souvent plus commode d'utiliser <xref:System.Xml.Linq.XElement> comme nœud racine.</span><span class="sxs-lookup"><span data-stu-id="f7931-111">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="f7931-112">Pour plus d’informations sur le contenu valid d’un <xref:System.Xml.Linq.XDocument>, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="f7931-112">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-113">L’exemple suivant crée un document, puis ajoute un commentaire et un élément.</span><span class="sxs-lookup"><span data-stu-id="f7931-113">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="f7931-114">Il compose ensuite un autre document en utilisant les résultats d’une requête.</span><span class="sxs-lookup"><span data-stu-id="f7931-114">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-115">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-115">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7931-116">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-116">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-117">Il n'existe pas beaucoup de scénarios qui requièrent la création d'un objet <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-117">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="f7931-118">Au lieu de cela, vous pouvez généralement créer vos arborescences XML avec un nœud racine <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="f7931-118">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="f7931-119">À moins que la création d'un document ne soit spécifiquement requise (par exemple si vous devez créer des instructions de traitement et des commentaires au niveau supérieur ou si vous devez prendre en charge des types de documents), il est souvent plus commode d'utiliser <xref:System.Xml.Linq.XElement> comme nœud racine.</span><span class="sxs-lookup"><span data-stu-id="f7931-119">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="f7931-120">Pour plus d’informations sur le contenu valid d’un <xref:System.Xml.Linq.XDocument>, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="f7931-120">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-121">L’exemple suivant crée un nouveau document, puis ajoute un commentaire et un élément.</span><span class="sxs-lookup"><span data-stu-id="f7931-121">The following example creates a new document, and then adds a comment and an element to it.</span></span>  
  
```csharp  
XDocument doc = new XDocument();  
doc.Add(new XComment("This is a comment"));  
doc.Add(new XElement("Root", "content"));  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = New XDocument()  
doc.Add(<!--This is a comment-->)  
doc.Add(<Root>content</Root>)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-122">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-122">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f7931-123">Liste de paramètres d'objets de contenu à ajouter à ce document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-123">A parameter list of content objects to add to this document.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-124">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XDocument" /> avec le contenu spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-124">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-125">Il n'existe pas beaucoup de scénarios qui requièrent la création d'un objet <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-125">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="f7931-126">Au lieu de cela, vous pouvez généralement créer vos arborescences XML avec un nœud racine <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="f7931-126">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="f7931-127">À moins que la création d'un document ne soit spécifiquement requise (par exemple si vous devez créer des instructions de traitement et des commentaires au niveau supérieur ou si vous devez prendre en charge des types de documents), il est souvent plus commode d'utiliser <xref:System.Xml.Linq.XElement> comme nœud racine.</span><span class="sxs-lookup"><span data-stu-id="f7931-127">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="f7931-128">Pour plus d’informations sur le contenu valid d’un <xref:System.Xml.Linq.XDocument>, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="f7931-128">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-129">L’exemple suivant crée un document, puis ajoute un commentaire et un élément.</span><span class="sxs-lookup"><span data-stu-id="f7931-129">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="f7931-130">Il compose ensuite un autre document en utilisant les résultats d’une requête.</span><span class="sxs-lookup"><span data-stu-id="f7931-130">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-131">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-131">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDocument other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDocument other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDocument ^ other);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XDocument" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="f7931-132">Objet <see cref="T:System.Xml.Linq.XDocument" /> qui sera copié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-132">The <see cref="T:System.Xml.Linq.XDocument" /> object that will be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-133">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un objet <see cref="T:System.Xml.Linq.XDocument" /> existant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-133">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class from an existing <see cref="T:System.Xml.Linq.XDocument" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-134">Ce constructeur vous permet d’effectuer une copie complète d’un <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-134">You use this constructor to make a deep copy of an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 <span data-ttu-id="f7931-135">Ce constructeur parcourt tous les nœuds et les attributs dans le document spécifié dans le `other` paramètre et crée des copies de tous les nœuds tandis qu’il assemble récemment initialisé <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-135">This constructor traverses all nodes and attributes in the document specified in the `other` parameter, and creates copies of all nodes as it assembles the newly initialized <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDeclaration declaration, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDeclaration declaration, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDeclaration,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaration As XDeclaration, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDeclaration ^ declaration, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="declaration" Type="System.Xml.Linq.XDeclaration" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="declaration">
          <span data-ttu-id="f7931-136">
            <see cref="T:System.Xml.Linq.XDeclaration" /> pour le document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-136">An <see cref="T:System.Xml.Linq.XDeclaration" /> for the document.</span>
          </span>
        </param>
        <param name="content">
          <span data-ttu-id="f7931-137">Contenu du document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-137">The content of the document.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-138">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XDocument" /> avec la <see cref="T:System.Xml.Linq.XDeclaration" /> et le contenu spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-138">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class with the specified <see cref="T:System.Xml.Linq.XDeclaration" /> and content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-139">Il n'existe pas beaucoup de scénarios qui requièrent la création d'un objet <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-139">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="f7931-140">Au lieu de cela, vous pouvez généralement créer vos arborescences XML avec un nœud racine <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="f7931-140">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="f7931-141">À moins que la création d'un document ne soit spécifiquement requise (par exemple si vous devez créer des instructions de traitement et des commentaires au niveau supérieur ou si vous devez prendre en charge des types de documents), il est souvent plus commode d'utiliser <xref:System.Xml.Linq.XElement> comme nœud racine.</span><span class="sxs-lookup"><span data-stu-id="f7931-141">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="f7931-142">Pour plus d’informations sur le contenu valid d’un <xref:System.Xml.Linq.XDocument>, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="f7931-142">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-143">L’exemple suivant utilise ce constructeur pour créer un document.</span><span class="sxs-lookup"><span data-stu-id="f7931-143">The following example uses this constructor to create a document.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a new comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
doc.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a new comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
doc.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="f7931-144">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-144">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
<!--This is a new comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName="Declaration">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDeclaration Declaration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDeclaration Declaration" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Declaration" />
      <MemberSignature Language="VB.NET" Value="Public Property Declaration As XDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDeclaration ^ Declaration { System::Xml::Linq::XDeclaration ^ get(); void set(System::Xml::Linq::XDeclaration ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDeclaration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-145">Obtient ou définit la déclaration XML pour ce document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-145">Gets or sets the XML declaration for this document.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7931-146">
            <see cref="T:System.Xml.Linq.XDeclaration" /> qui contient la déclaration XML pour ce document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-146">An <see cref="T:System.Xml.Linq.XDeclaration" /> that contains the XML declaration for this document.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-147">Parfois, vous devez créer une déclaration XML pour un document.</span><span class="sxs-lookup"><span data-stu-id="f7931-147">Sometimes you have to create an XML declaration for a document.</span></span> <span data-ttu-id="f7931-148">Si vous souhaitez indiquer qu’un document est autonome, vous devez utiliser cette propriété.</span><span class="sxs-lookup"><span data-stu-id="f7931-148">If you want to indicate that a document is standalone, you must use this property.</span></span> <span data-ttu-id="f7931-149">Si vous souhaitez encoder votre document avec un encodage autre qu’utf-8, vous pouvez spécifier un encodage par le biais du <xref:System.Xml.Linq.XDeclaration>.</span><span class="sxs-lookup"><span data-stu-id="f7931-149">If you want to encode your document with an encoding other than utf-8, you can specify an encoding through the <xref:System.Xml.Linq.XDeclaration>.</span></span> <span data-ttu-id="f7931-150">Une autre approche pour l’encodage d’un document consiste à spécifier l’encodage sur un <xref:System.Xml.XmlWriter> que vous passez à LINQ to XML pour l’écriture.</span><span class="sxs-lookup"><span data-stu-id="f7931-150">Another approach for encoding a document is to specify the encoding on an <xref:System.Xml.XmlWriter> that you pass to LINQ to XML for writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-151">L’exemple suivant utilise cette propriété pour récupérer la déclaration XML d’un document.</span><span class="sxs-lookup"><span data-stu-id="f7931-151">The following example uses this property to retrieve the XML declaration of a document.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a comment"),  
    new XElement("Root", "content")  
);  
  
Console.WriteLine(doc.Declaration);  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>content</Root>  
  
Console.WriteLine(doc.Declaration)  
```  
  
 <span data-ttu-id="f7931-152">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-152">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentType As XDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDocumentType ^ DocumentType { System::Xml::Linq::XDocumentType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-153">Obtient la définition de type de document (DTD) pour ce document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-153">Gets the Document Type Definition (DTD) for this document.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7931-154">
            <see cref="T:System.Xml.Linq.XDocumentType" /> qui contient la DTD pour ce document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-154">A <see cref="T:System.Xml.Linq.XDocumentType" /> that contains the DTD for this document.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]<span data-ttu-id="f7931-155"> Fournit une prise en charge limitée des DTD.</span><span class="sxs-lookup"><span data-stu-id="f7931-155"> provides limited support for DTDs.</span></span>  
  
 <span data-ttu-id="f7931-156">Vous pouvez remplir une arborescence XML avec un document XML qui contient une DTD.</span><span class="sxs-lookup"><span data-stu-id="f7931-156">You can populate an XML tree with an XML document that contains a DTD.</span></span> <span data-ttu-id="f7931-157">L’arborescence XML contiendra un <xref:System.Xml.Linq.XDocument.DocumentType%2A> nœud.</span><span class="sxs-lookup"><span data-stu-id="f7931-157">The XML tree will then contain a <xref:System.Xml.Linq.XDocument.DocumentType%2A> node.</span></span> <span data-ttu-id="f7931-158">Lorsque vous sérialisez ou enregistrez l’arborescence, la DTD doivent également être sérialisée.</span><span class="sxs-lookup"><span data-stu-id="f7931-158">When you serialize or save the tree, the DTD will also be serialized.</span></span> [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]<span data-ttu-id="f7931-159"> Développe toutes les entités dans la DTD.</span><span class="sxs-lookup"><span data-stu-id="f7931-159"> will expand any entities in the DTD.</span></span> <span data-ttu-id="f7931-160">Lorsque vous sérialisez ou enregistrez l’arborescence XML, les références d’entité ne sont pas enregistrées ; au lieu de cela, les nœuds sont enregistrés avec les références d’entité remplacées par le texte de l’entité.</span><span class="sxs-lookup"><span data-stu-id="f7931-160">When you serialize or save the XML tree, the entity references are not saved; instead, the nodes are saved with the entity references replaced by the text of the entity.</span></span>  
  
 <span data-ttu-id="f7931-161">Si la DTD comporte des attributs par défaut, les attributs sont créés dans l’arborescence XML en tant qu’attributs ordinaires.</span><span class="sxs-lookup"><span data-stu-id="f7931-161">If the DTD contains default attributes, the attributes are created in the XML tree as ordinary attributes.</span></span>  
  
 <span data-ttu-id="f7931-162">Par défaut, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] ne valide pas un document basé sur sa DTD.</span><span class="sxs-lookup"><span data-stu-id="f7931-162">By default, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] does not validate a document based on its DTD.</span></span> <span data-ttu-id="f7931-163">Pour valider un document basé sur une DTD, créez un <xref:System.Xml.XmlReader> qui validera selon une DTD, puis créez une arborescence XML à partir du <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-163">To validate a document based on a DTD, create an <xref:System.Xml.XmlReader> that will validate based on a DTD, and then create an XML tree from the <xref:System.Xml.XmlReader>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-164">L’exemple suivant crée un document qui contient un <xref:System.Xml.Linq.XDocumentType>.</span><span class="sxs-lookup"><span data-stu-id="f7931-164">The following example creates a document that contains an <xref:System.Xml.Linq.XDocumentType>.</span></span>  
  
 <span data-ttu-id="f7931-165">Visual Basic ne prend pas en charge les types de documents dans les littéraux XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-165">Visual Basic does not support document types within XML literals.</span></span> <span data-ttu-id="f7931-166">Toutefois, il est possible de créer un document qui contient un type de document en créant d’abord le document à l’aide de littéraux XML, puis en créant et en ajoutant un <xref:System.Xml.Linq.XDocumentType> nœud dans l’emplacement approprié dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-166">However, it is possible to create a document that contains a document type by first creating the document using XML literals, and then creating and adding an <xref:System.Xml.Linq.XDocumentType> node in the appropriate place in the XML tree.</span></span>  
  
```csharp  
string internalSubset = @"<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>";  
  
string target = "xml-stylesheet";  
string data = "href='mystyle.css' title='Compact' type='text/css'";  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XProcessingInstruction(target, data),  
    new XDocumentType("Pubs", null, null, internalSubset),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
doc.Declaration = new XDeclaration("1.0", "utf-8", "true");  
Console.WriteLine(doc);  
  
doc.Save("test.xml");  
```  
  
```vb  
Dim internalSubset = _  
        "<!ELEMENT Pubs (Book+)>" & Environment.NewLine & _  
        "<!ELEMENT Book (Title, Author)>" & Environment.NewLine & _  
        "<!ELEMENT Title (#PCDATA)>" & Environment.NewLine & _  
        "<!ELEMENT Author (#PCDATA)>"  
  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
    </Pubs>  
    <!--This is another comment.-->  
  
doc.Nodes().Skip(1).First().AddAfterSelf(New XDocumentType("Pubs", Nothing, Nothing, internalSubset))  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-167">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-167">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment.-->  
<?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
<!DOCTYPE Pubs [<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>]>  
<Pubs>  
  <Book>  
    <Title>Artifacts of Roman Civilization</Title>  
    <Author>Moreno, Jordao</Author>  
  </Book>  
  <Book>  
    <Title>Midieval Tools and Implements</Title>  
    <Author>Gazit, Inbar</Author>  
  </Book>  
</Pubs>  
<!--This is another comment.-->  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDocumentType" />
        <altmember cref="P:System.Xml.Linq.XDocument.NodeType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-168">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un fichier spécifié par un URI, d'un <see cref="T:System.IO.TextReader" /> ou d'un <see cref="T:System.Xml.XmlReader" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-168">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file specified by a URI, from an <see cref="T:System.IO.TextReader" />, or from an <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-169">En utilisant l’une des surcharges de cette méthode, vous pouvez charger un <xref:System.Xml.Linq.XDocument> à partir d’un fichier, un <xref:System.IO.TextReader>, ou un <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-169">Using one of the overloads of this method, you can load an <xref:System.Xml.Linq.XDocument> from a file, a <xref:System.IO.TextReader>, or an <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="f7931-170">Pour créer un <xref:System.Xml.Linq.XDocument> à partir d’une chaîne qui contient du code XML, utilisez <xref:System.Xml.Linq.XDocument.Parse%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7931-170">To create an <xref:System.Xml.Linq.XDocument> from a string that contains XML, use <xref:System.Xml.Linq.XDocument.Parse%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="f7931-171">Flux contenant les données XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-171">The stream that contains the XML data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-172">Crée une nouvelle instance de <see cref="T:System.Xml.Linq.XDocument" /> à l'aide du flux spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-172">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> instance by using the specified stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-173">Objet <see cref="T:System.Xml.Linq.XDocument" /> permettant de lire les données contenues dans le flux de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-173">An <see cref="T:System.Xml.Linq.XDocument" /> object that reads the data that is contained in the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-174">Si vous souhaitez contrôler les options de chargement, utilisez la <xref:System.Xml.Linq.XDocument.Load%2A> surcharge acceptant <xref:System.Xml.Linq.LoadOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-174">If you want to control load options, use the <xref:System.Xml.Linq.XDocument.Load%2A> overload that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="f7931-175">La fonctionnalité de chargement de LINQ to XML est basée sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-175">The loading functionality of LINQ to XML is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-176">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-176">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="f7931-177">Si vous devez modifier <xref:System.Xml.XmlReaderSettings>, procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="f7931-177">If you have to modify <xref:System.Xml.XmlReaderSettings>, follow these steps:</span></span>  
  
1.  <span data-ttu-id="f7931-178">Créer un <xref:System.Xml.XmlReader> en appelant une de le <xref:System.Xml.XmlReader.Create%2A> surcharges qui prennent <xref:System.Xml.XmlReaderSettings> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-178">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that take <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="f7931-179">Passez le <xref:System.Xml.XmlReader> à un de la <xref:System.Xml.Linq.XDocument.Load%2A> des surcharges de <xref:System.Xml.Linq.XDocument> qui accepte <xref:System.Xml.XmlReader> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-179">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XDocument.Load%2A> overloads of <xref:System.Xml.Linq.XDocument> that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <span data-ttu-id="f7931-180">
            <see cref="T:System.IO.TextReader" /> qui contient le contenu pour le <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-180">A <see cref="T:System.IO.TextReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-181">Crée <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un <see cref="T:System.IO.TextReader" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-181">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a <see cref="T:System.IO.TextReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-182">
            <see cref="T:System.Xml.Linq.XDocument" /> qui contient le contenu du <see cref="T:System.IO.TextReader" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-182">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified <see cref="T:System.IO.TextReader" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-183">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-183">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-184">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-184">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-185">L’exemple suivant crée un document issu d’un <xref:System.IO.StringReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-185">The following example creates a document from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader tr = new StringReader("<Root>Content</Root>");  
XDocument doc = XDocument.Load(tr);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim tr As TextReader = New StringReader("<Root>Content</Root>")  
Dim doc As XDocument = XDocument.Load(tr)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-186">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-186">This example produces the following output:</span></span>  
  
```xml  
<Root>Content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <span data-ttu-id="f7931-187">Chaîne d'URI qui référence le fichier à charger dans un nouveau <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-187">A URI string that references the file to load into a new <see cref="T:System.Xml.Linq.XDocument" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-188">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-188">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-189">
            <see cref="T:System.Xml.Linq.XDocument" /> qui contient le contenu du fichier spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-189">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-190">Cette méthode utilise un sous-jacent <xref:System.Xml.XmlReader> pour lire le document XML dans une arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-190">This method uses an underlying <xref:System.Xml.XmlReader> to read the XML into an XML tree.</span></span>  
  
 <span data-ttu-id="f7931-191">Utilisez <xref:System.Xml.Linq.XDocument.Parse%2A> pour créer un <xref:System.Xml.Linq.XDocument> à partir d’une chaîne qui contient du code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-191">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="f7931-192">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-192">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-193">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-193">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-194">L’exemple suivant montre comment charger un <xref:System.Xml.Linq.XDocument> à partir d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="f7931-194">The following example shows how to load an <xref:System.Xml.Linq.XDocument> from a file.</span></span>  
  
 <span data-ttu-id="f7931-195">Cet exemple utilise le document XML suivant :</span><span class="sxs-lookup"><span data-stu-id="f7931-195">This example uses the following XML document:</span></span>  
  
 [<span data-ttu-id="f7931-196">Exemple de fichier XML : commande fournisseur typique (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="f7931-196">Sample XML File: Typical Purchase Order (LINQ to XML)</span></span>](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc = XDocument.Load("PurchaseOrder.xml");  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = XDocument.Load("PurchaseOrder.xml")  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-197">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-197">This example produces the following output:</span></span>  
  
```  
<PurchaseOrder PurchaseOrderNumber="99503" OrderDate="1999-10-20">  
  <Address Type="Shipping">  
    <Name>Ellen Adams</Name>  
    <Street>123 Maple Street</Street>  
    <City>Mill Valley</City>  
    <State>CA</State>  
    <Zip>10999</Zip>  
    <Country>USA</Country>  
  </Address>  
  <Address Type="Billing">  
    <Name>Tai Yee</Name>  
    <Street>8 Oak Avenue</Street>  
    <City>Old Town</City>  
    <State>PA</State>  
    <Zip>95819</Zip>  
    <Country>USA</Country>  
  </Address>  
  <DeliveryNotes>Please leave packages in shed by driveway.</DeliveryNotes>  
  <Items>  
    <Item PartNumber="872-AA">  
      <ProductName>Lawnmower</ProductName>  
      <Quantity>1</Quantity>  
      <USPrice>148.95</USPrice>  
      <Comment>Confirm this is electric</Comment>  
    </Item>  
    <Item PartNumber="926-AA">  
      <ProductName>Baby Monitor</ProductName>  
      <Quantity>2</Quantity>  
      <USPrice>39.98</USPrice>  
      <ShipDate>1999-05-21</ShipDate>  
    </Item>  
  </Items>  
</PurchaseOrder>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="f7931-198">
            <see cref="T:System.Xml.XmlReader" /> qui contient le contenu pour le <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-198">A <see cref="T:System.Xml.XmlReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-199">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un <see cref="T:System.Xml.XmlReader" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-199">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from an <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-200">
            <see cref="T:System.Xml.Linq.XDocument" /> qui contient le contenu du <see cref="T:System.Xml.XmlReader" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-200">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-201">Une utilisation possible de cette méthode doit créer une copie d’un document DOM dans une arborescence LINQ to XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-201">One possible use for this method is to create a copy of a DOM document in a LINQ to XML tree.</span></span> <span data-ttu-id="f7931-202">Pour ce faire, vous créez un <xref:System.Xml.XmlNodeReader> à partir d’un document DOM et utiliser ensuite le <xref:System.Xml.XmlNodeReader> pour créer un <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-202">To do this, you create an <xref:System.Xml.XmlNodeReader> from a DOM document, and then use the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 <span data-ttu-id="f7931-203">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-203">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-204">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-204">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-205">L’exemple suivant crée un document DOM, crée un <xref:System.Xml.XmlNodeReader> à partir du document DOM, crée un <xref:System.Xml.Linq.XDocument> à l’aide de la <xref:System.Xml.XmlNodeReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-205">The following example creates a DOM document, creates an <xref:System.Xml.XmlNodeReader> from the DOM document, creates an <xref:System.Xml.Linq.XDocument> using the <xref:System.Xml.XmlNodeReader>.</span></span>  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// create a reader and move to the content  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' create a reader and move to the content  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
```  
  
 <span data-ttu-id="f7931-206">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-206">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="f7931-207">Flux contenant les données XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-207">The stream containing the XML data.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-208">
            <see cref="T:System.Xml.Linq.LoadOptions" /> qui spécifie s'il faut charger l'URI de base et les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-208">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies whether to load base URI and line information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-209">Crée une instance <see cref="T:System.Xml.Linq.XDocument" /> à partir du flux spécifié, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-209">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-210">Objet <see cref="T:System.Xml.Linq.XDocument" /> permettant de lire les données contenues dans le flux de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-210">An <see cref="T:System.Xml.Linq.XDocument" /> object that reads the data that is contained in the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-211">La fonctionnalité de chargement de LINQ to XML est basée sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-211">The loading functionality of LINQ to XML is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-212">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-212">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="f7931-213">Si vous devez modifier <xref:System.Xml.XmlReaderSettings>, procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="f7931-213">If you have to modify <xref:System.Xml.XmlReaderSettings>, follow these steps:</span></span>  
  
1.  <span data-ttu-id="f7931-214">Créer un <xref:System.Xml.XmlReader> en appelant une de le <xref:System.Xml.XmlReader.Create%2A> surcharges qui acceptent <xref:System.Xml.XmlReaderSettings> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-214">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that takes <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="f7931-215">Passez le <xref:System.Xml.XmlReader> à un de la <xref:System.Xml.Linq.XDocument.Load%2A> des surcharges de <xref:System.Xml.Linq.XDocument> qui accepte <xref:System.Xml.XmlReader> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-215">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XDocument.Load%2A> overloads of <xref:System.Xml.Linq.XDocument> that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <span data-ttu-id="f7931-216">
            <see cref="T:System.IO.TextReader" /> qui contient le contenu pour le <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-216">A <see cref="T:System.IO.TextReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-217">
            <see cref="T:System.Xml.Linq.LoadOptions" /> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-217">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-218">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un <see cref="T:System.IO.TextReader" />, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-218">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a <see cref="T:System.IO.TextReader" />, optionally preserving white space, setting the base URI, and retaining line information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-219">
            <see cref="T:System.Xml.Linq.XDocument" /> qui contient le code XML qui a été lu à partir du <see cref="T:System.IO.TextReader" />spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-219">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the XML that was read from the specified <see cref="T:System.IO.TextReader" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-220">Si le code XML source est mis en retrait, la définition de la <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` provoque le lecteur à lire tous les espaces blancs dans le XML source.</span><span class="sxs-lookup"><span data-stu-id="f7931-220">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="f7931-221">Les nœuds de type <xref:System.Xml.Linq.XText> sont créés pour les espaces blancs significatifs et non significatifs.</span><span class="sxs-lookup"><span data-stu-id="f7931-221">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="f7931-222">Si le code XML source est mis en retrait, ne définissez ne pas le <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` amène le lecteur à ignorer tous les espaces blancs non significatifs dans le XML source.</span><span class="sxs-lookup"><span data-stu-id="f7931-222">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="f7931-223">L’arborescence XML est créée sans nœud de texte pour les espaces blancs non significatifs.</span><span class="sxs-lookup"><span data-stu-id="f7931-223">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="f7931-224">Si la source XML n’est pas mis en retrait, la définition de la <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="f7931-224">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="f7931-225">Espace blanc significatif est conservé, et il n’y aucun étendues des espaces blancs non significatifs qui peuvent provoquer la création de plusieurs nœuds de texte d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="f7931-225">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="f7931-226">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-226">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="f7931-227">Utilisez <xref:System.Xml.Linq.XDocument.Parse%2A> pour créer un <xref:System.Xml.Linq.XElement> à partir d’une chaîne qui contient du code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-227">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XElement> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="f7931-228">Paramètre <xref:System.Xml.Linq.LoadOptions.SetBaseUri> n’est pas valide lors du chargement d’un <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-228">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> is not valid when loading from a <xref:System.IO.TextReader>.</span></span>  
  
 <span data-ttu-id="f7931-229">Il existe une baisse des performances si vous définissez la <xref:System.Xml.Linq.LoadOptions.SetLineInfo> indicateur.</span><span class="sxs-lookup"><span data-stu-id="f7931-229">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="f7931-230">Les informations de ligne sont exactes immédiatement après le chargement du document XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-230">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="f7931-231">Si vous modifiez l’arborescence XML après le chargement du document, les informations de ligne peuvent perdre leur signification.</span><span class="sxs-lookup"><span data-stu-id="f7931-231">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="f7931-232">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-232">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-233">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-233">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-234">L’exemple suivant crée un document issu d’un <xref:System.IO.StringReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-234">The following example creates a document from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree1 = XDocument.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree2 = XDocument.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XDocument = XDocument.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XDocument = XDocument.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 <span data-ttu-id="f7931-235">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-235">This example produces the following output:</span></span>  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri">
          <span data-ttu-id="f7931-236">Chaîne d'URI qui référence le fichier à charger dans un nouveau <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-236">A URI string that references the file to load into a new <see cref="T:System.Xml.Linq.XDocument" />.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-237">
            <see cref="T:System.Xml.Linq.LoadOptions" /> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-237">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-238">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un fichier, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-238">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file, optionally preserving white space, setting the base URI, and retaining line information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-239">
            <see cref="T:System.Xml.Linq.XDocument" /> qui contient le contenu du fichier spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-239">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-240">Si le code XML source est mis en retrait, la définition de la <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` provoque le lecteur à lire tous les espaces blancs dans le XML source.</span><span class="sxs-lookup"><span data-stu-id="f7931-240">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="f7931-241">Les nœuds de type <xref:System.Xml.Linq.XText> sont créés pour les espaces blancs significatifs et non significatifs.</span><span class="sxs-lookup"><span data-stu-id="f7931-241">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="f7931-242">Si le code XML source est mis en retrait, ne définissez ne pas le <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` amène le lecteur à ignorer tous les espaces blancs non significatifs dans le XML source.</span><span class="sxs-lookup"><span data-stu-id="f7931-242">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="f7931-243">L’arborescence XML est créée sans nœud de texte pour les espaces blancs non significatifs.</span><span class="sxs-lookup"><span data-stu-id="f7931-243">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="f7931-244">Si la source XML n’est pas mis en retrait, la définition de la <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="f7931-244">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="f7931-245">Espace blanc significatif est conservé, et il n’y aucun étendues des espaces blancs non significatifs qui peuvent provoquer la création de plusieurs nœuds de texte d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="f7931-245">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="f7931-246">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-246">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="f7931-247">Utilisez <xref:System.Xml.Linq.XDocument.Parse%2A> pour créer un <xref:System.Xml.Linq.XDocument> à partir d’une chaîne qui contient du code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-247">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="f7931-248">Il existe une baisse des performances si vous définissez la <xref:System.Xml.Linq.LoadOptions.SetBaseUri> et <xref:System.Xml.Linq.LoadOptions.SetLineInfo> indicateurs.</span><span class="sxs-lookup"><span data-stu-id="f7931-248">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetBaseUri> and the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flags.</span></span>  
  
 <span data-ttu-id="f7931-249">L’URI de base et les informations de ligne sont exactes immédiatement après le chargement du document XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-249">The base URI and the line information are accurate immediately after loading the XML document.</span></span> <span data-ttu-id="f7931-250">Si vous modifiez l’arborescence XML après le chargement du document, les informations d’URI et de la ligne de base peuvent perdre leur signification.</span><span class="sxs-lookup"><span data-stu-id="f7931-250">If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</span></span>  
  
 <span data-ttu-id="f7931-251">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-251">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-252">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-252">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-253">L’exemple suivant montre comment charger un <xref:System.Xml.Linq.XDocument> à partir d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="f7931-253">The following example shows how to load an <xref:System.Xml.Linq.XDocument> from a file.</span></span>  
  
 <span data-ttu-id="f7931-254">Cet exemple utilise le document XML suivant :</span><span class="sxs-lookup"><span data-stu-id="f7931-254">This example uses the following XML document:</span></span>  
  
 [<span data-ttu-id="f7931-255">Exemple de fichier XML : commande fournisseur typique (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="f7931-255">Sample XML File: Typical Purchase Order (LINQ to XML)</span></span>](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc1 = XDocument.Load("PurchaseOrder.xml", LoadOptions.None);  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count());  
  
XDocument doc2 = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim doc1 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.None)  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count())  
  
Dim doc2 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 <span data-ttu-id="f7931-256">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-256">This example produces the following output:</span></span>  
  
```  
nodes if not preserving whitespace: 48  
nodes if preserving whitespace: 82  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="f7931-257">
            <see cref="T:System.Xml.XmlReader" /> qui sera lu pour le contenu du <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-257">A <see cref="T:System.Xml.XmlReader" /> that will be read for the content of the <see cref="T:System.Xml.Linq.XDocument" />.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-258">
            <see cref="T:System.Xml.Linq.LoadOptions" /> qui spécifie s'il faut charger l'URI de base et les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-258">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies whether to load base URI and line information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-259">Charge un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'un <see cref="T:System.Xml.XmlReader" />, en définissant éventuellement l'URI de base, et en conservant les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-259">Loads an <see cref="T:System.Xml.Linq.XDocument" /> from an <see cref="T:System.Xml.XmlReader" />, optionally setting the base URI, and retaining line information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-260">
            <see cref="T:System.Xml.Linq.XDocument" /> qui contient le code XML qui a été lu à partir du <see cref="T:System.Xml.XmlReader" />spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-260">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the XML that was read from the specified <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-261">En créant un <xref:System.Xml.XmlNodeReader> à partir d’un document DOM, puis en utilisant la <xref:System.Xml.XmlNodeReader> pour créer un <xref:System.Xml.Linq.XElement>, cette méthode peut être utilisée pour créer une copie d’un document DOM dans une arborescence LINQ to XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-261">By creating an <xref:System.Xml.XmlNodeReader> from a DOM document, and then using the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XElement>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</span></span>  
  
 <span data-ttu-id="f7931-262">Utilisez <xref:System.Xml.Linq.XDocument.Parse%2A> pour créer un <xref:System.Xml.Linq.XDocument> à partir d’une chaîne qui contient du code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-262">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="f7931-263">Paramètre <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> n’est pas valide lors du chargement d’un <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-263">Setting <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is not valid when loading from a <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-264">Le <xref:System.Xml.XmlReader> sera configuré pour lire l’espace blanc ou non.</span><span class="sxs-lookup"><span data-stu-id="f7931-264">The <xref:System.Xml.XmlReader> will be configured to either read whitespace or not.</span></span> <span data-ttu-id="f7931-265">L’arborescence LINQ to XML est remplie avec les nœuds d’espace blanc qui les surfaces du lecteur.</span><span class="sxs-lookup"><span data-stu-id="f7931-265">The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces.</span></span> <span data-ttu-id="f7931-266">Il s’agit du comportement, indépendamment du fait que <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> est défini ou non.</span><span class="sxs-lookup"><span data-stu-id="f7931-266">This will be the behavior regardless of whether <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is set or not.</span></span>  
  
 <span data-ttu-id="f7931-267">Le <xref:System.Xml.XmlReader> peut avoir un URI de base valid ou pas.</span><span class="sxs-lookup"><span data-stu-id="f7931-267">The <xref:System.Xml.XmlReader> may have a valid base URI or not.</span></span> <span data-ttu-id="f7931-268">Si vous définissez <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, la base de URI sera défini dans l’arborescence XML à partir de l’URI de base qui est signalée par le <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-268">If you set <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, the base URI will be set in the XML tree from the base URI that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="f7931-269">Le <xref:System.Xml.XmlReader> peut avoir des informations de ligne valides ou pas.</span><span class="sxs-lookup"><span data-stu-id="f7931-269">The <xref:System.Xml.XmlReader> may have a valid line information or not.</span></span> <span data-ttu-id="f7931-270">Si vous définissez <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, les informations de ligne seront définies dans l’arborescence XML à partir des informations de ligne qui sont signalées par le <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-270">If you set <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, the line information will be set in the XML tree from the line information that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="f7931-271">Il existe une baisse des performances si vous définissez la <xref:System.Xml.Linq.LoadOptions.SetLineInfo> indicateur.</span><span class="sxs-lookup"><span data-stu-id="f7931-271">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="f7931-272">Les informations de ligne sont exactes immédiatement après le chargement du document XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-272">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="f7931-273">Si vous modifiez l’arborescence XML après le chargement du document, les informations de ligne peuvent perdre leur signification.</span><span class="sxs-lookup"><span data-stu-id="f7931-273">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="f7931-274">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-274">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-275">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-275">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-276">L’exemple suivant charge les informations de ligne qu’il charge à partir de la <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-276">The following example loads the line information that it loads from the <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-277">Il imprime ensuite les informations de ligne.</span><span class="sxs-lookup"><span data-stu-id="f7931-277">It then prints the line information.</span></span>  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.Elements("Root").DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' The reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.Elements("Root").DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 <span data-ttu-id="f7931-278">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-278">This example produces the following output:</span></span>  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textReader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-279">Obtient le type de ce nœud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-279">Gets the node type for this node.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7931-280">Type de nœud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-280">The node type.</span>
          </span>
          <span data-ttu-id="f7931-281">Pour les objets <see cref="T:System.Xml.Linq.XDocument" />, cette valeur est <see cref="F:System.Xml.XmlNodeType.Document" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-281">For <see cref="T:System.Xml.Linq.XDocument" /> objects, this value is <see cref="F:System.Xml.XmlNodeType.Document" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-282">Étant donné que toutes les classes qui dérivent de <xref:System.Xml.Linq.XObject> contiennent un <xref:System.Xml.Linq.XObject.NodeType%2A> propriété, vous pouvez écrire du code qui fonctionne sur des collections d’objets dans lequel le type de chacun est une sous-classe de <xref:System.Xml.Linq.XObject>.</span><span class="sxs-lookup"><span data-stu-id="f7931-282">Because all classes that derive from <xref:System.Xml.Linq.XObject> contain a <xref:System.Xml.Linq.XObject.NodeType%2A> property, you can write code that operates on collections of objects where the type of each is a subclass of <xref:System.Xml.Linq.XObject>.</span></span> <span data-ttu-id="f7931-283">Votre code peut ensuite tester le type de nœud de chaque objet dans la collection.</span><span class="sxs-lookup"><span data-stu-id="f7931-283">Your code can then test for the node type of each object in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-284">L’exemple suivant illustre l’utilisation de cette propriété.</span><span class="sxs-lookup"><span data-stu-id="f7931-284">The following example shows the use of this property.</span></span>  
  
```csharp  
// Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
XDocument xmlTree = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement("Root", "content")  
);  
Console.WriteLine(xmlTree.NodeType);  
```  
  
```vb  
' Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
Dim xmlTree As XDocument = _  
    <?xml version='1.0' encoding='utf-8' standalone='yes'?>  
        <Root>content</Root>  
Console.WriteLine("{0}", xmlTree.NodeType)  
```  
  
 <span data-ttu-id="f7931-285">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-285">This example produces the following output:</span></span>  
  
```  
Document  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
        <altmember cref="P:System.Xml.Linq.XDocument.DocumentType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-286">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'une chaîne, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-286">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string, optionally preserving white space, setting the base URI, and retaining line information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-287">Cette méthode analyse une chaîne et crée une arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-287">This method parses a string and creates an XML tree.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-288">L’exemple suivant crée une chaîne qui contient du code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-288">The following example creates a string that contains XML.</span></span> <span data-ttu-id="f7931-289">Il analyse ensuite la chaîne dans un <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-289">It then parses the string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-290">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-290">This example produces the following output:</span></span>  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">
          <span data-ttu-id="f7931-291">Chaîne qui contient le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-291">A string that contains XML.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-292">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'une chaîne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-292">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-293">
            <see cref="T:System.Xml.Linq.XDocument" /> rempli à partir de la chaîne qui contient le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-293">An <see cref="T:System.Xml.Linq.XDocument" /> populated from the string that contains XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-294">Cette méthode ne conserve pas les espaces blancs.</span><span class="sxs-lookup"><span data-stu-id="f7931-294">This method does not preserve white space.</span></span> <span data-ttu-id="f7931-295">Si vous souhaitez conserver les espaces blancs dans l’arborescence XML, utilisez la surcharge de <xref:System.Xml.Linq.XDocument.Parse%2A> qui accepte <xref:System.Xml.Linq.LoadOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-295">If you want to preserve white space in the XML tree, use the overload of <xref:System.Xml.Linq.XDocument.Parse%2A> that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="f7931-296">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-296">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="f7931-297">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-297">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-298">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-298">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-299">L’exemple suivant crée une chaîne qui contient du code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-299">The following example creates a string that contains XML.</span></span> <span data-ttu-id="f7931-300">Il analyse ensuite la chaîne dans un <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-300">It then parses the string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="f7931-301">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-301">This example produces the following output:</span></span>  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text">
          <span data-ttu-id="f7931-302">Chaîne qui contient le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-302">A string that contains XML.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-303">
            <see cref="T:System.Xml.Linq.LoadOptions" /> qui spécifie le comportement pour les espaces blancs et détermine s'il faut charger l'URI de base et les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-303">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-304">Crée un <see cref="T:System.Xml.Linq.XDocument" /> à partir d'une chaîne, en conservant éventuellement l'espace blanc, en définissant l'URI de base, et en conservant les informations de ligne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-304">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string, optionally preserving white space, setting the base URI, and retaining line information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7931-305">
            <see cref="T:System.Xml.Linq.XDocument" /> rempli à partir de la chaîne qui contient le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-305">An <see cref="T:System.Xml.Linq.XDocument" /> populated from the string that contains XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-306">Si le code XML source est mis en retrait, la définition de la <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` provoque le lecteur à lire tous les espaces blancs dans le XML source.</span><span class="sxs-lookup"><span data-stu-id="f7931-306">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="f7931-307">Les nœuds de type <xref:System.Xml.Linq.XText> sont créés pour les espaces blancs significatifs et non significatifs.</span><span class="sxs-lookup"><span data-stu-id="f7931-307">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="f7931-308">Si le code XML source est mis en retrait, ne définissez ne pas le <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` amène le lecteur à ignorer tous les espaces blancs non significatifs dans le XML source.</span><span class="sxs-lookup"><span data-stu-id="f7931-308">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="f7931-309">L’arborescence XML est créée sans nœud de texte pour les espaces blancs non significatifs.</span><span class="sxs-lookup"><span data-stu-id="f7931-309">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="f7931-310">Si la source XML n’est pas mis en retrait, la définition de la <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> indicateur dans `options` n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="f7931-310">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="f7931-311">Espace blanc significatif est conservé, et il n’y aucun étendues des espaces blancs non significatifs qui peuvent provoquer la création de plusieurs nœuds de texte d’un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="f7931-311">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="f7931-312">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-312">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="f7931-313">Paramètre <xref:System.Xml.Linq.LoadOptions.SetBaseUri> n’est pas valide lors de l’analyse d’un <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="f7931-313">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> is not valid when parsing from a <xref:System.String>.</span></span>  
  
 <span data-ttu-id="f7931-314">Il existe une baisse des performances si vous définissez la <xref:System.Xml.Linq.LoadOptions.SetLineInfo> indicateur.</span><span class="sxs-lookup"><span data-stu-id="f7931-314">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="f7931-315">Les informations de ligne sont exactes immédiatement après le chargement du document XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-315">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="f7931-316">Si vous modifiez l’arborescence XML après le chargement du document, les informations de ligne peuvent perdre leur signification.</span><span class="sxs-lookup"><span data-stu-id="f7931-316">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="f7931-317">LINQ à la fonctionnalité de chargement de XML repose sur <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="f7931-317">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f7931-318">Par conséquent, vous pouvez intercepter les exceptions levées par le <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> surcharger des méthodes et les <xref:System.Xml.XmlReader> les méthodes qui lisent et analysent le document.</span><span class="sxs-lookup"><span data-stu-id="f7931-318">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-319">L’exemple suivant analyse une chaîne dans un <xref:System.Xml.Linq.XDocument>.</span><span class="sxs-lookup"><span data-stu-id="f7931-319">The following example parses a string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc1 = XDocument.Parse(str, LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count());  
XDocument doc2 = XDocument.Parse(str, LoadOptions.None);  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim str As String = _  
"<?xml version= '1.0'?>" & Environment.NewLine & _  
"<!-- comment at the root level -->" & Environment.NewLine & _  
"<Root>" & Environment.NewLine & _  
"    <Child>Content</Child>"  & Environment.NewLine & _  
"</Root>"  
  
Dim doc1 As XDocument = XDocument.Parse(str, LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count())  
Dim doc2 As XDocument = XDocument.Parse(str, LoadOptions.None)  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 <span data-ttu-id="f7931-320">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-320">This example produces the following output:</span></span>  
  
```  
nodes when preserving whitespace: 8  
nodes when not preserving whitespace: 4  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XElement Root" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XElement ^ Root { System::Xml::Linq::XElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-321">Obtient l’élément racine de l’arborescence XML pour ce document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-321">Gets the root element of the XML Tree for this document.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7931-322">
            <see cref="T:System.Xml.Linq.XElement" /> racine de l'arborescence XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-322">The root <see cref="T:System.Xml.Linq.XElement" /> of the XML tree.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-323">Cette propriété est utile lorsque vous souhaitez composer [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] requêtes dans le même contexte que lorsque vous les composez pour une arborescence enracinée dans <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="f7931-323">This property is useful when you want to compose [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries in the same context as when composing them for a tree rooted in <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="f7931-324">Consultez [interrogation d’un XDocument et. Interrogation d’un XElement](http://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a) pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="f7931-324">See [Querying an XDocument vs. Querying an XElement](http://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a) for more details.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-325">L’exemple suivant utilise cette propriété pour obtenir l’élément racine d’un document.</span><span class="sxs-lookup"><span data-stu-id="f7931-325">The following example uses this property to get the root element of a document.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
Console.WriteLine(doc.Root.Name.ToString());  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
        <!--This is another comment.-->  
    </Pubs>  
  
Console.WriteLine(doc.Root.Name.ToString())  
```  
  
 <span data-ttu-id="f7931-326">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-326">This example produces the following output:</span></span>  
  
```  
Pubs  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7931-327">Sérialise ce <see cref="T:System.Xml.Linq.XDocument" /> vers un fichier, un <see cref="T:System.IO.TextWriter" /> ou un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-327">Serializes this <see cref="T:System.Xml.Linq.XDocument" /> to a file, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="f7931-328">Flux vers lequel générer ce <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-328">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-329">Renvoie ce <see cref="T:System.Xml.Linq.XDocument" /> vers le <see cref="T:System.IO.Stream" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-329">Outputs this <see cref="T:System.Xml.Linq.XDocument" /> to the specified <see cref="T:System.IO.Stream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-330">Le code XML sérialisé est en retrait.</span><span class="sxs-lookup"><span data-stu-id="f7931-330">The serialized XML will be indented.</span></span> <span data-ttu-id="f7931-331">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="f7931-331">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="f7931-332">Le comportement de cette méthode est que l’espace blanc non significatif ne sera pas préservé.</span><span class="sxs-lookup"><span data-stu-id="f7931-332">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="f7931-333">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <xref:System.Xml.Linq.XDocument.Save%2A> qui accepte <xref:System.Xml.Linq.SaveOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-333">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="f7931-334">Utilisez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option pour enregistrer le code XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-334">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="f7931-335">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-335">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="f7931-336">Utilisez <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option si vous souhaitez supprimer les déclarations d’espace de noms en double.</span><span class="sxs-lookup"><span data-stu-id="f7931-336">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <span data-ttu-id="f7931-337">
            <see cref="T:System.IO.TextWriter" /> dans lequel le <see cref="T:System.Xml.Linq.XDocument" /> sera écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-337">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XDocument" /> will be written to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-338">Sérialise ce <see cref="T:System.Xml.Linq.XDocument" /> vers un <see cref="T:System.IO.TextWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-338">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-339">Le code XML sérialisé est en retrait.</span><span class="sxs-lookup"><span data-stu-id="f7931-339">The serialized XML will be indented.</span></span> <span data-ttu-id="f7931-340">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="f7931-340">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="f7931-341">Le comportement de cette méthode est que l’espace blanc non significatif ne sera pas préservé.</span><span class="sxs-lookup"><span data-stu-id="f7931-341">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="f7931-342">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <xref:System.Xml.Linq.XDocument.Save%2A> qui accepte <xref:System.Xml.Linq.SaveOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-342">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="f7931-343">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-343">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-344">L’exemple suivant crée un <xref:System.Xml.Linq.XDocument>, enregistre le document à un <xref:System.IO.StringWriter>, puis imprime la chaîne dans la console.</span><span class="sxs-lookup"><span data-stu-id="f7931-344">The following example creates an <xref:System.Xml.Linq.XDocument>, saves the document to a <xref:System.IO.StringWriter>, and then prints the string to the console.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
TextWriter tr = new StringWriter(sb);  
doc.Save(tr);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim tr As TextWriter = New StringWriter(sb)  
doc.Save(tr)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="f7931-345">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-345">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="f7931-346">Chaîne qui contient le nom du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-346">A string that contains the name of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-347">Sérialise ce <see cref="T:System.Xml.Linq.XDocument" /> dans un fichier, en remplaçant un fichier existant, le cas échéant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-347">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a file, overwriting an existing file, if it exists.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-348">Le code XML sérialisé est en retrait.</span><span class="sxs-lookup"><span data-stu-id="f7931-348">The serialized XML will be indented.</span></span> <span data-ttu-id="f7931-349">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="f7931-349">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="f7931-350">Le comportement de cette méthode est que l’espace blanc non significatif ne sera pas préservé.</span><span class="sxs-lookup"><span data-stu-id="f7931-350">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="f7931-351">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <xref:System.Xml.Linq.XDocument.Save%2A> qui accepte <xref:System.Xml.Linq.SaveOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-351">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="f7931-352">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-352">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-353">L’exemple suivant crée un <xref:System.Xml.Linq.XDocument>, enregistre le document dans un fichier, puis imprime le fichier dans la console.</span><span class="sxs-lookup"><span data-stu-id="f7931-353">The following example creates an <xref:System.Xml.Linq.XDocument>, saves the document to a file, and then prints the file to the console.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root.xml");  
Console.WriteLine(File.ReadAllText("Root.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root.xml")  
Console.WriteLine(File.ReadAllText("Root.xml"))  
```  
  
 <span data-ttu-id="f7931-354">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-354">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="f7931-355">
            <see cref="T:System.Xml.XmlWriter" /> dans lequel le <see cref="T:System.Xml.Linq.XDocument" /> sera écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-355">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XDocument" /> will be written to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-356">Sérialise ce <see cref="T:System.Xml.Linq.XDocument" /> vers un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-356">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7931-357">L'exemple suivant montre comment enregistrer un objet <xref:System.Xml.Linq.XDocument> dans un objet <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="f7931-357">The following example shows how to save an <xref:System.Xml.Linq.XDocument> to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.Save(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.Save(xw)  
  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="f7931-358">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-358">This example produces the following output:</span></span>  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="f7931-359">Flux vers lequel générer ce <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-359">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-360">
            <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-360">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-361">Génère ce <see cref="T:System.Xml.Linq.XDocument" /> vers le <see cref="T:System.IO.Stream" /> spécifié, en précisant le cas échéant le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-361">Outputs this <see cref="T:System.Xml.Linq.XDocument" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-362">Par défaut le `options` ont la valeur <xref:System.Xml.Linq.SaveOptions.None>.</span><span class="sxs-lookup"><span data-stu-id="f7931-362">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="f7931-363">Cette option supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="f7931-363">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="f7931-364">Si vous souhaitez enregistrer le code XML, spécifiez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="f7931-364">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="f7931-365">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-365">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="f7931-366">Utilisez <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option si vous souhaitez supprimer les déclarations d’espace de noms en double.</span><span class="sxs-lookup"><span data-stu-id="f7931-366">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <span data-ttu-id="f7931-367">
            <see cref="T:System.IO.TextWriter" /> vers lequel exporter le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-367">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-368">
            <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-368">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-369">Sérialise ce <see cref="T:System.Xml.Linq.XDocument" /> vers un <see cref="T:System.IO.TextWriter" />, en désactivant éventuellement la mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-369">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-370">Si vous souhaitez enregistrer le code XML, spécifiez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="f7931-370">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="f7931-371">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-371">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="f7931-372">Si vous souhaitez enregistrer le code XML mis en retrait, ne spécifiez pas le <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="f7931-372">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="f7931-373">Cela supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="f7931-373">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="f7931-374">Il s’agit du comportement par défaut et le comportement des surcharges de la <xref:System.Xml.Linq.XDocument.Save%2A> les méthodes qui ne prennent pas `options` en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-374">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XDocument.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="f7931-375">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-375">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-376">L’exemple suivant montre deux utilisations de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f7931-376">The following example shows two uses of this method.</span></span> <span data-ttu-id="f7931-377">La première utilisation sérialise le <xref:System.Xml.Linq.XDocument> avec mise en forme.</span><span class="sxs-lookup"><span data-stu-id="f7931-377">The first use serializes the <xref:System.Xml.Linq.XDocument> with formatting.</span></span> <span data-ttu-id="f7931-378">La seconde conserve l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="f7931-378">The second preserves white space.</span></span> <span data-ttu-id="f7931-379">Étant donné que le document ne comporte aucun espace blanc comme construit, conservation des espaces blancs génère le XML sans mise en retrait.</span><span class="sxs-lookup"><span data-stu-id="f7931-379">Because the document has no white space in it as constructed, preserving white space outputs the XML without any indenting.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
StringBuilder sb1 = new StringBuilder();  
using (StringWriter sr1 = new StringWriter(sb1)) {  
    doc.Save(sr1, SaveOptions.None);  
    Console.WriteLine(sb1.ToString());  
}  
  
StringBuilder sb2 = new StringBuilder();  
using (StringWriter sr2 = new StringWriter(sb2)) {  
    doc.Save(sr2, SaveOptions.DisableFormatting);  
    Console.WriteLine(sb2.ToString());  
}  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim sb1 As StringBuilder = New StringBuilder()  
  
Using sr1 = New StringWriter(sb1)  
    doc.Save(sr1, SaveOptions.None)  
    Console.WriteLine(sb1.ToString())  
End Using  
  
Dim sb2 As StringBuilder = New StringBuilder()  
  
Using sr2 = New StringWriter(sb2)  
    doc.Save(sr2, SaveOptions.DisableFormatting)  
    Console.WriteLine(sb2.ToString())  
End Using  
```  
  
 <span data-ttu-id="f7931-380">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-380">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
<?xml version="1.0" encoding="utf-16"?><Root><Child>content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="f7931-381">Chaîne qui contient le nom du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-381">A string that contains the name of the file.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="f7931-382">
            <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-382">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-383">Sérialise ce <see cref="T:System.Xml.Linq.XDocument" /> vers un fichier, en désactivant éventuellement la mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-383">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a file, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7931-384">Si vous souhaitez enregistrer le code XML, spécifiez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="f7931-384">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="f7931-385">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-385">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="f7931-386">Si vous souhaitez enregistrer le code XML mis en retrait, ne spécifiez pas le <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="f7931-386">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="f7931-387">Cela supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="f7931-387">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="f7931-388">Il s’agit du comportement par défaut et le comportement des surcharges de la <xref:System.Xml.Linq.XDocument.Save%2A> les méthodes qui ne prennent pas `options` en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="f7931-388">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XDocument.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="f7931-389">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="f7931-389">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7931-390">L’exemple suivant montre deux utilisations de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f7931-390">The following example shows two uses of this method.</span></span> <span data-ttu-id="f7931-391">La première utilisation conserve l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="f7931-391">The first use preserves white space.</span></span> <span data-ttu-id="f7931-392">La seconde sérialise le <xref:System.Xml.Linq.XDocument> avec mise en retrait.</span><span class="sxs-lookup"><span data-stu-id="f7931-392">The second one serializes the <xref:System.Xml.Linq.XDocument> with indenting.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root1.xml", SaveOptions.DisableFormatting);  
Console.WriteLine(File.ReadAllText("Root1.xml"));  
doc.Save("Root2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Root2.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root1.xml", SaveOptions.DisableFormatting)  
Console.WriteLine(File.ReadAllText("Root1.xml"))  
doc.Save("Root2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Root2.xml"))  
```  
  
 <span data-ttu-id="f7931-393">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-393">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><Root><Child>content</Child></Root>  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textWriter">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="f7931-394">
            <see cref="T:System.Xml.XmlWriter" /> dans lequel cette méthode écrira.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-394">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7931-395">Écrivez ce document vers un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7931-395">Write this document to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7931-396">L’exemple suivant montre comment écrire un <xref:System.Xml.Linq.XDocument> à un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="f7931-396">The following example shows how to write an <xref:System.Xml.Linq.XDocument> to an <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="f7931-397">Notez que l’exemple n’a pas écrit de déclaration XML.</span><span class="sxs-lookup"><span data-stu-id="f7931-397">Note that the example did not write an XML declaration.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.WriteTo(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.WriteTo(xw)  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="f7931-398">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="f7931-398">This example produces the following output:</span></span>  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>