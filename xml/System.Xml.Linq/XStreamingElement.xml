<Type Name="XStreamingElement" FullName="System.Xml.Linq.XStreamingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a860d5aaf67164c2d82b51f8917f71556dbf07cf" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36443300" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XStreamingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XStreamingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XStreamingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XStreamingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class XStreamingElement" />
  <TypeSignature Language="F#" Value="type XStreamingElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="292bd-101">Représente les éléments d’une arborescence XML qui prend en charge la sortie de diffusion en continu différée.</span>
      <span class="sxs-lookup">
        <span data-stu-id="292bd-101">Represents elements in an XML tree that supports deferred streaming output.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-102">Cette classe vous permet de créer une arborescence XML qui prend en charge la sortie de diffusion en continu différée.</span><span class="sxs-lookup"><span data-stu-id="292bd-102">This class allows you to create an XML tree that supports deferred streaming output.</span></span> <span data-ttu-id="292bd-103">Cette classe vous permet de créer une arborescence XML de façon très similaire à la création d’une arborescence XML à l’aide <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-103">You use this class to create an XML tree in a very similar fashion to creating an XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="292bd-104">Toutefois, il est d’une différence fondamentale.</span><span class="sxs-lookup"><span data-stu-id="292bd-104">However, there is a fundamental difference.</span></span> <span data-ttu-id="292bd-105">Lorsque vous utilisez une requête LINQ pour spécifier le contenu lors de la création d’un document XML à l’aide d’une arborescence <xref:System.Xml.Linq.XElement>, la variable de requête est parcourue au moment de la construction de l’arborescence XML, et les résultats de la requête sont ajoutés à l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="292bd-105">When you use a LINQ query to specify content when creating an XML tree using <xref:System.Xml.Linq.XElement>, the query variable is iterated at the time of construction of the XML tree, and the results of the query are added to the XML tree.</span></span> <span data-ttu-id="292bd-106">En revanche, lorsque vous créez une arborescence XML à l’aide <xref:System.Xml.Linq.XStreamingElement>, une référence à la variable de requête est stockée dans l’arborescence XML sans être parcourue.</span><span class="sxs-lookup"><span data-stu-id="292bd-106">In contrast, when you create an XML tree using <xref:System.Xml.Linq.XStreamingElement>, a reference to the query variable is stored in the XML tree without being iterated.</span></span> <span data-ttu-id="292bd-107">Les requêtes sont parcourues uniquement lors de la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="292bd-107">Queries are iterated only upon serialization.</span></span> <span data-ttu-id="292bd-108">Cela vous permet de vous permet de créer de plus grandes arborescences XML tout en conservant un encombrement mémoire.</span><span class="sxs-lookup"><span data-stu-id="292bd-108">This allows you to create larger XML trees while maintaining a smaller memory footprint.</span></span>  
  
 <span data-ttu-id="292bd-109">Si vous diffusiez en continu à partir d’une source d’entrée, tels qu’un fichier texte, vous pouvez lire un fichier texte très volumineux et générer un document XML très volumineux tout en conservant un faible encombrement mémoire.</span><span class="sxs-lookup"><span data-stu-id="292bd-109">If you are streaming from an input source, such as a text file, then you can read a very large text file, and generate a very large XML document while maintaining a small memory footprint.</span></span>  
  
 <span data-ttu-id="292bd-110">Un autre scénario est que vous avez une grande arborescence XML qui a été chargée en mémoire, et que vous souhaitez créer une version transformée du document.</span><span class="sxs-lookup"><span data-stu-id="292bd-110">Another scenario is that you have a large XML tree that has been loaded into memory, and you want to create a transformed version of the document.</span></span> <span data-ttu-id="292bd-111">Si vous créez un document à l’aide <xref:System.Xml.Linq.XElement>, vous aurez deux grandes arborescences XML en mémoire à l’achèvement de la transformation.</span><span class="sxs-lookup"><span data-stu-id="292bd-111">If you create a new document using <xref:System.Xml.Linq.XElement>, then you will have two large XML trees in memory upon completion of the transformation.</span></span> <span data-ttu-id="292bd-112">Toutefois, si vous créez la nouvelle arborescence XML à l’aide <xref:System.Xml.Linq.XStreamingElement>, puis votre jeu de travail sera effectivement diminuer de moitié.</span><span class="sxs-lookup"><span data-stu-id="292bd-112">However, if you create the new XML tree using <xref:System.Xml.Linq.XStreamingElement>, then your working set will be effectively cut in half.</span></span>  
  
 <span data-ttu-id="292bd-113">Notez que lors du débogage d’un programme qui utilise <xref:System.Xml.Linq.XStreamingElement>, affichage de la valeur d’un objet entraîne son <xref:System.Xml.Linq.XStreamingElement.ToString%2A> méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="292bd-113">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="292bd-114">Ainsi, le code XML à sérialiser.</span><span class="sxs-lookup"><span data-stu-id="292bd-114">This causes the XML to be serialized.</span></span> <span data-ttu-id="292bd-115">Si la sémantique de votre requête d’élément diffusion en continu est telles que l’élément de diffusion en continu peut être diffusé uniquement une fois, cela peut entraîner un comportement indésirable dans votre expérience de débogage.</span><span class="sxs-lookup"><span data-stu-id="292bd-115">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-116">L’exemple suivant crée d’abord une arborescence XML source.</span><span class="sxs-lookup"><span data-stu-id="292bd-116">The following example first creates a source XML tree.</span></span> <span data-ttu-id="292bd-117">Il crée ensuite une transformation de l’arborescence de la source XML à l’aide <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-117">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="292bd-118">Cette transformation crée une nouvelle arborescence dans la mémoire.</span><span class="sxs-lookup"><span data-stu-id="292bd-118">This transform creates a new tree in memory.</span></span> <span data-ttu-id="292bd-119">Il crée ensuite une transformation de l’arborescence de la source XML à l’aide <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-119">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="292bd-120">Cette transformation n’exécute pas la requête jusqu'à ce que l’arborescence transformée est sérialisée vers la console.</span><span class="sxs-lookup"><span data-stu-id="292bd-120">This transform doesn't execute the query until the transformed tree is serialized to the console.</span></span> <span data-ttu-id="292bd-121">Son utilisation de la mémoire est inférieure.</span><span class="sxs-lookup"><span data-stu-id="292bd-121">Its memory usage is less.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XElement dstTree1 = new XElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
XStreamingElement dstTree2 = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree1);  
Console.WriteLine("------");  
Console.WriteLine(dstTree2);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree1 As XElement = _  
    <NewRoot>  
        <%= From el In srcTree.Elements _  
            Where (el.Value >= 3) _  
            Select <DifferentChild><%= el.Value %></DifferentChild> %>  
    </NewRoot>  
  
Dim dstTree2 As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree1)  
Console.WriteLine("------")  
Console.WriteLine(dstTree2)  
```  
  
 <span data-ttu-id="292bd-122">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-122">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 <span data-ttu-id="292bd-123">L'une des façons de traiter un fichier texte consiste à écrire une méthode d'extension qui diffuse en continu le fichier texte une ligne à la fois à l'aide de la construction `yield return`.</span><span class="sxs-lookup"><span data-stu-id="292bd-123">One approach to processing a text file is to write an extension method that streams the text file a line at a time using the `yield return` construct.</span></span> <span data-ttu-id="292bd-124">Vous pouvez alors écrire une requête LINQ qui traite le fichier texte de manière différée.</span><span class="sxs-lookup"><span data-stu-id="292bd-124">You then can write a LINQ query that processes the text file in a lazy deferred fashion.</span></span> <span data-ttu-id="292bd-125">Si vous utilisez ensuite le <xref:System.Xml.Linq.XStreamingElement> pour diffuser la sortie, vous pouvez ensuite créer une transformation du fichier texte en XML qui utilise une quantité minimale de mémoire, quelle que soit la taille du fichier texte source.</span><span class="sxs-lookup"><span data-stu-id="292bd-125">If you then use the <xref:System.Xml.Linq.XStreamingElement> to stream output, you then can create a transform from the text file to XML that uses a minimal amount of memory, regardless of the size of the source text file.</span></span>  
  
 <span data-ttu-id="292bd-126">Le fichier texte suivant, People.txt, est la source pour cet exemple.</span><span class="sxs-lookup"><span data-stu-id="292bd-126">The following text file, People.txt, is the source for this example.</span></span>  
  
```  
#This is a comment  
1,Tai,Yee,Writer  
2,Nikolay,Grachev,Programmer  
3,David,Wright,Inventor  
```  
  
 <span data-ttu-id="292bd-127">Le code suivant contient une méthode d'extension qui diffuse en continu les lignes du fichier texte de manière différée.</span><span class="sxs-lookup"><span data-stu-id="292bd-127">The following code contains an extension method that streams the lines of the text file in a deferred fashion.</span></span>  
  
```csharp  
public static class StreamReaderSequence  
{  
    public static IEnumerable<string> Lines(this StreamReader source)  
    {  
        String line;  
  
        if (source == null)  
            throw new ArgumentNullException("source");  
        while ((line = source.ReadLine()) != null)  
        {  
            yield return line;  
        }  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        StreamReader sr = new StreamReader("People.txt");  
        XStreamingElement xmlTree = new XStreamingElement("Root",  
            from line in sr.Lines()  
            let items = line.Split(',')  
            where !line.StartsWith("#")  
            select new XElement("Person",  
                       new XAttribute("ID", items[0]),  
                       new XElement("First", items[1]),  
                       new XElement("Last", items[2]),  
                       new XElement("Occupation", items[3])  
                   )  
        );  
        Console.WriteLine(xmlTree);  
        sr.Close();  
    }  
}  
```  
  
```vb  
Module StreamReaderSequence  
  
    <Runtime.CompilerServices.Extension>  
    Public Iterator Function Lines(source As IO.StreamReader) As IEnumerable(Of String)  
        If source Is Nothing Then Throw New ArgumentNullException("source")  
        Dim line As String = source.ReadLine()  
        While (line <> Nothing)  
            Yield line  
            line = source.ReadLine()  
        End While  
    End Function  
  
End Module  
  
Module Module1  
    Sub Main()  
        Dim sr As New IO.StreamReader("People.txt")  
        Dim xmlTree As New XStreamingElement("Root",  
            From line In sr.Lines()  
            Let items = line.Split(","c)  
            Where Not line.StartsWith("#")  
            Select <Person ID=<%= items(0) %>>  
                       <First><%= items(1) %></First>  
                       <Last><%= items(2) %></Last>  
                       <Occupation><%= items(3) %></Occupation>  
                   </Person>)  
        Console.WriteLine(xmlTree)  
        sr.Close()  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="292bd-128">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-128">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Person ID="1">  
    <First>Tai</First>  
    <Last>Yee</Last>  
    <Occupation>Writer</Occupation>  
  </Person>  
  <Person ID="2">  
    <First>Nikolay</First>  
    <Last>Grachev</Last>  
    <Occupation>Programmer</Occupation>  
  </Person>  
  <Person ID="3">  
    <First>David</First>  
    <Last>Wright</Last>  
    <Occupation>Inventor</Occupation>  
  </Person>  
</Root>  
```  
  
 <span data-ttu-id="292bd-129">Vous devez parfois transformer des fichiers XML volumineux et écrire votre application de sorte que son encombrement mémoire soit prévisible.</span><span class="sxs-lookup"><span data-stu-id="292bd-129">Sometimes you have to transform large XML files, and write your application so that the memory footprint of the application is predictable.</span></span> <span data-ttu-id="292bd-130">Si vous tentez de remplir une arborescence XML avec un très grand fichier XML, l'utilisation de la mémoire sera proportionnelle à la taille du fichier (c'est-à-dire excessive).</span><span class="sxs-lookup"><span data-stu-id="292bd-130">If you try to populate an XML tree with a very large XML file, your memory usage will be proportional to the size of the file (that is, excessive).</span></span> <span data-ttu-id="292bd-131">Par conséquent, vous devez utiliser une technique de diffusion en continu à la place.</span><span class="sxs-lookup"><span data-stu-id="292bd-131">Therefore, you should use a streaming technique instead.</span></span>  
  
 <span data-ttu-id="292bd-132">Certains opérateurs de requête standard, tels que <xref:System.Linq.Enumerable.OrderBy%2A>, itèrent au sein de leur source, recueillent toutes les données, les trient, puis produisent le premier élément de la séquence.</span><span class="sxs-lookup"><span data-stu-id="292bd-132">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="292bd-133">Notez que si vous utilisez un opérateur de requête qui matérialise sa source avant de produire le premier élément, vous ne conserverez pas un faible encombrement mémoire pour votre application.</span><span class="sxs-lookup"><span data-stu-id="292bd-133">Note that if you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint for your application.</span></span>  
  
 <span data-ttu-id="292bd-134">Même si vous utilisez la technique décrite dans, si vous tentez d’assembler une arborescence XML qui contient le document transformé, l’utilisation de mémoire peut être trop importante.</span><span class="sxs-lookup"><span data-stu-id="292bd-134">Even if you use the technique described in , if you try to assemble an XML tree that contains the transformed document, memory usage may be too great.</span></span>  
  
 <span data-ttu-id="292bd-135">L’exemple suivant s’appuie sur l’exemple de [Comment : diffuser des fragments XML en continu avec accès aux informations d’en-tête](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span><span class="sxs-lookup"><span data-stu-id="292bd-135">The following example builds on the example in [How to: Stream XML Fragments with Access to Header Information](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="292bd-136">Il utilise les capacités d'exécution différée de <xref:System.Xml.Linq.XStreamingElement> pour diffuser la sortie en continu.</span><span class="sxs-lookup"><span data-stu-id="292bd-136">This example uses the deferred execution capabilities of <xref:System.Xml.Linq.XStreamingElement> to stream the output.</span></span>  
  
 <span data-ttu-id="292bd-137">Notez que l'axe personnalisé (`StreamCustomerItem`) est spécifiquement écrit de sorte qu'il s'attende à recevoir un document possédant des éléments `Customer`, `Name` et `Item`, et que ces éléments seront disposés comme dans le document  Source.xml suivant.</span><span class="sxs-lookup"><span data-stu-id="292bd-137">Note that the custom axis (`StreamCustomerItem`) is specifically written so that it expects a document that has `Customer`, `Name`, and `Item` elements, and that those elements will be arranged as in the following Source.xml document.</span></span> <span data-ttu-id="292bd-138">Une implémentation plus robuste, toutefois, validerait le document source avec un fichier XSD ou serait préparée à analyser un document non valide.</span><span class="sxs-lookup"><span data-stu-id="292bd-138">A more robust implementation, however, would either validate the source document with an XSD, or would be prepared to parse an invalid document.</span></span>  
  
 <span data-ttu-id="292bd-139">Voici le document source, Source.xml :</span><span class="sxs-lookup"><span data-stu-id="292bd-139">The following is the source document, Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Customer>  
    <Name>A. Datum Corporation</Name>  
    <Item>  
      <Key>0001</Key>  
    </Item>  
    <Item>  
      <Key>0002</Key>  
    </Item>  
    <Item>  
      <Key>0003</Key>  
    </Item>  
    <Item>  
      <Key>0004</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Fabrikam, Inc.</Name>  
    <Item>  
      <Key>0005</Key>  
    </Item>  
    <Item>  
      <Key>0006</Key>  
    </Item>  
    <Item>  
      <Key>0007</Key>  
    </Item>  
    <Item>  
      <Key>0008</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Southridge Video</Name>  
    <Item>  
      <Key>0009</Key>  
    </Item>  
    <Item>  
      <Key>0010</Key>  
    </Item>  
  </Customer>  
</Root>  
```  
  
 <span data-ttu-id="292bd-140">Le code suivant contient une méthode qui utilise un <xref:System.Xml.XmlReader> pour diffuser du code XML source.</span><span class="sxs-lookup"><span data-stu-id="292bd-140">The following code contains a method that uses an <xref:System.Xml.XmlReader> to stream the source XML.</span></span> <span data-ttu-id="292bd-141">Il utilise <xref:System.Xml.Linq.XStreamingElement> pour transmettre le nouveau code XML en continu.</span><span class="sxs-lookup"><span data-stu-id="292bd-141">It uses <xref:System.Xml.Linq.XStreamingElement> to stream the new XML.</span></span>  
  
```csharp  
static IEnumerable<XElement> StreamCustomerItem(string uri)  
{  
    using (XmlReader reader = XmlReader.Create(uri))  
    {  
        XElement name = null;  
        XElement item = null;  
  
        reader.MoveToContent();  
  
        // Parse the file, save header information when encountered, and yield the  
        // Item XElement objects as they are created.  
  
        // loop through Customer elements  
        while (reader.Read())  
        {  
            if (reader.NodeType == XmlNodeType.Element  
                && reader.Name == "Customer")  
            {  
                // move to Name element  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.Element &&  
                        reader.Name == "Name")  
                    {  
                        name = XElement.ReadFrom(reader) as XElement;  
                        break;  
                    }  
                }  
  
                // loop through Item elements  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.EndElement)  
                        break;  
                    if (reader.NodeType == XmlNodeType.Element  
                        && reader.Name == "Item")  
                    {  
                        item = XElement.ReadFrom(reader) as XElement;  
                        if (item != null)  
                        {  
                            XElement tempRoot = new XElement("Root",  
                                new XElement(name)  
                            );  
                            tempRoot.Add(item);  
                            yield return item;  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
  
static void Main(string[] args)  
{  
    XStreamingElement root = new XStreamingElement("Root",  
        from el in StreamCustomerItem("Source.xml")  
        select new XElement("Item",  
            new XElement("Customer", (string)el.Parent.Element("Name")),  
            new XElement(el.Element("Key"))  
        )  
    );  
    root.Save("Test.xml");  
    Console.WriteLine(File.ReadAllText("Test.xml"));  
}  
```  
  
```vb  
Iterator Function StreamCustomerItem(uri As String) As IEnumerable(Of XElement)  
  
    Dim name As XElement = Nothing  
    Dim item As XElement = Nothing  
  
    Dim reader As XmlReader = XmlReader.Create(uri)  
    reader.MoveToContent()  
  
    ' Parse the file, save header information when encountered, and yield the  
    ' Item XElement objects as they are created.  
  
    ' Loop through Customer elements.  
    While (reader.Read())  
        If (reader.NodeType = XmlNodeType.Element And reader.Name = "Customer") Then  
            While (reader.Read())  
                ' Move to Name element  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Name") Then  
                    name = CType(XElement.ReadFrom(reader), XElement)  
                    Exit While  
                End If  
            End While  
  
            ' Loop through Item elements  
            While (reader.Read())  
                If (reader.NodeType = XmlNodeType.EndElement) Then  
                    Exit While  
                End If  
  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Item") Then  
                    item = CType(XElement.ReadFrom(reader), XElement)  
                    If (Not (item Is Nothing)) Then  
                        Dim tempRoot = New XElement("Root",  
                            New XElement(name)  
                        )  
                        tempRoot.Add(item)  
                        Yield item  
                     End If  
                End If  
            End While  
        End If  
     End While  
    reader.Close()  
End Function  
  
Sub Main()  
    Dim root As New XStreamingElement("Root",  
        From el In StreamCustomerItem("c:\trash\Source.xml")  
        Select New XElement("Item",  
            New XElement("Customer", CStr(el.Parent.Element("Name"))),  
            New XElement(el.Element("Key"))))  
    root.Save("c:\trash\Test.xml")  
    Console.WriteLine(System.IO.File.ReadAllText("c:\trash\Test.xml"))  
End Sub  
```  
  
 <span data-ttu-id="292bd-142">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-142">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0001</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0002</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0003</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0004</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0005</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0006</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0007</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0008</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0009</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0010</Key>  
  </Item>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="292bd-143">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-143">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-144">Les requêtes ne sont pas parcourues tant que le <xref:System.Xml.Linq.XStreamingElement> est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-144">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="292bd-145">Cette approche s’oppose à l’aide de requêtes pour le contenu pour un <xref:System.Xml.Linq.XElement>, où les requêtes sont parcourues au moment de la construction de la nouvelle <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-145">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="292bd-146">Pour plus d’informations sur le contenu valide qui peut être passé à ce constructeur, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="292bd-146">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="292bd-147">
            <see cref="T:System.Xml.Linq.XName" /> qui contient le nom de l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-147">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-148">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XElement" /> à partir du <see cref="T:System.Xml.Linq.XName" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-148">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class from the specified <see cref="T:System.Xml.Linq.XName" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-149">Ce constructeur crée un élément de diffusion en continu avec aucun contenu et aucun attribut.</span><span class="sxs-lookup"><span data-stu-id="292bd-149">This constructor creates a streaming element with no content and no attributes.</span></span>  
  
 <span data-ttu-id="292bd-150">Il existe une conversion implicite d’une chaîne en <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="292bd-150">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="292bd-151">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="292bd-151">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
   
  
## Examples  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="292bd-152">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-152">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="292bd-153">
            <see cref="T:System.Xml.Linq.XName" /> qui contient le nom de l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-153">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span>
          </span>
        </param>
        <param name="content">
          <span data-ttu-id="292bd-154">Contenu de l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-154">The contents of the element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-155">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XStreamingElement" /> avec le nom et le contenu spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-155">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-156">Ce constructeur crée un élément de diffusion en continu avec les attributs et le contenu spécifié.</span><span class="sxs-lookup"><span data-stu-id="292bd-156">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="292bd-157">Il existe une conversion implicite d’une chaîne en <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="292bd-157">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="292bd-158">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="292bd-158">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="292bd-159">Les requêtes ne sont pas parcourues tant que le <xref:System.Xml.Linq.XStreamingElement> est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-159">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="292bd-160">Cette approche s’oppose à l’aide de requêtes pour le contenu pour un <xref:System.Xml.Linq.XElement>, où les requêtes sont parcourues au moment de la construction de la nouvelle <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-160">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="292bd-161">Pour plus d’informations sur le contenu valide qui peut être passé à ce constructeur, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="292bd-161">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-162">Cet exemple utilise le fichier XML suivant, nommé Source.xml :</span><span class="sxs-lookup"><span data-stu-id="292bd-162">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj[] -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="292bd-163">
            <see cref="T:System.Xml.Linq.XName" /> qui contient le nom de l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-163">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span>
          </span>
        </param>
        <param name="content">
          <span data-ttu-id="292bd-164">Contenu de l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-164">The contents of the element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-165">Initialise une nouvelle instance de la classe <see cref="T:System.Xml.Linq.XStreamingElement" /> avec le nom et le contenu spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-165">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-166">Ce constructeur crée un élément de diffusion en continu avec les attributs et le contenu spécifié.</span><span class="sxs-lookup"><span data-stu-id="292bd-166">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="292bd-167">Il existe une conversion implicite d’une chaîne en <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="292bd-167">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="292bd-168">Une utilisation typique de ce constructeur consiste à spécifier une chaîne comme paramètre au lieu de créer un nouveau <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="292bd-168">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="292bd-169">Les requêtes ne sont pas parcourues tant que le <xref:System.Xml.Linq.XStreamingElement> est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-169">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="292bd-170">Cette approche s’oppose à l’aide de requêtes pour le contenu pour un <xref:System.Xml.Linq.XElement>, où les requêtes sont parcourues au moment de la construction de la nouvelle <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-170">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="292bd-171">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="292bd-171">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-172">Cet exemple utilise le fichier XML suivant, nommé Source.xml :</span><span class="sxs-lookup"><span data-stu-id="292bd-172">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="292bd-173">Ajoute le contenu spécifié en tant qu'enfants à ce <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-173">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="292bd-174">Contenu à ajouter à l'élément de diffusion en continu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-174">Content to be added to the streaming element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-175">Ajoute le contenu spécifié en tant qu'enfants à ce <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-175">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-176">Ce constructeur ajoute le contenu spécifié et les attributs dans le <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-176">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="292bd-177">Alors qu’il est souvent possible de construire le <xref:System.Xml.Linq.XStreamingElement> dans une instruction unique, il est parfois plus pratique d’ajouter du contenu à l’élément de diffusion en continu incrémentielle.</span><span class="sxs-lookup"><span data-stu-id="292bd-177">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="292bd-178">Les requêtes ne sont pas parcourues tant que le <xref:System.Xml.Linq.XStreamingElement> est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-178">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="292bd-179">Cette approche s’oppose à l’aide de requêtes pour le contenu pour un <xref:System.Xml.Linq.XElement>, où les requêtes sont parcourues au moment de la construction de la nouvelle <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-179">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="292bd-180">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="292bd-180">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-181">L’exemple suivant crée un nouveau <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-181">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="292bd-182">Il ajoute ensuite deux requêtes à l’élément de diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="292bd-182">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="292bd-183">Les requêtes ne sont pas parcourues jusqu'à ce que l’élément de diffusion en continu est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-183">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="292bd-184">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-184">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj[] -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="292bd-185">Contenu à ajouter à l'élément de diffusion en continu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-185">Content to be added to the streaming element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-186">Ajoute le contenu spécifié en tant qu'enfants à ce <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-186">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-187">Ce constructeur ajoute le contenu spécifié et les attributs dans le <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-187">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="292bd-188">Alors qu’il est souvent possible de construire le <xref:System.Xml.Linq.XStreamingElement> dans une instruction unique, il est parfois plus pratique d’ajouter du contenu à l’élément de diffusion en continu incrémentielle.</span><span class="sxs-lookup"><span data-stu-id="292bd-188">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="292bd-189">Les requêtes ne sont pas parcourues tant que le <xref:System.Xml.Linq.XStreamingElement> est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-189">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="292bd-190">Cette approche s’oppose à l’aide de requêtes pour le contenu pour un <xref:System.Xml.Linq.XElement>, où les requêtes sont parcourues au moment de la construction de la nouvelle <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-190">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="292bd-191">Pour plus d’informations sur le contenu valide qui peut être passé à cette fonction, consultez [valide le contenu des objets XElement et XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="292bd-191">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-192">L’exemple suivant crée un nouveau <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-192">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="292bd-193">Il ajoute ensuite deux requêtes à l’élément de diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="292bd-193">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="292bd-194">Les requêtes ne sont pas parcourues jusqu'à ce que l’élément de diffusion en continu est sérialisé.</span><span class="sxs-lookup"><span data-stu-id="292bd-194">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="292bd-195">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-195">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XStreamingElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : System.Xml.Linq.XName with get, set" Usage="System.Xml.Linq.XStreamingElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="292bd-196">Obtient ou définit le nom de cet élément de diffusion en continu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-196">Gets or sets the name of this streaming element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="292bd-197">
            <see cref="T:System.Xml.Linq.XName" /> qui contient le nom de cet élément de diffusion en continu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-197">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of this streaming element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="292bd-198">Cet exemple crée un nouvel élément de diffusion en continu, puis imprime le nom de l’élément.</span><span class="sxs-lookup"><span data-stu-id="292bd-198">This example creates a new streaming element, and then prints the name of the element.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.Name);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree.Name)  
```  
  
 <span data-ttu-id="292bd-199">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-199">This example produces the following output:</span></span>  
  
```  
NewRoot  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="292bd-200">Sérialiser cet élément de diffusion en continu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-200">Serialize this streaming element.</span>
          </span>
          <span data-ttu-id="292bd-201">La sortie peut être enregistrée vers un fichier, un <see cref="T:System.Xml.XmlTextWriter" />, un <see cref="T:System.IO.TextWriter" /> ou un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-201">The output can be saved to a file, an <see cref="T:System.Xml.XmlTextWriter" />, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
          <span data-ttu-id="292bd-202">Éventuellement, la mise en forme (mise en retrait) peut être désactivée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-202">Optionally, formatting (indenting) can be disabled.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xStreamingElement.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="292bd-203">Flux vers lequel générer ce <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-203">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-204">Renvoie ce <see cref="T:System.Xml.Linq.XStreamingElement" /> vers le <see cref="T:System.IO.Stream" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-204">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-205">Le code XML sérialisé est en retrait.</span><span class="sxs-lookup"><span data-stu-id="292bd-205">The serialized XML will be indented.</span></span> <span data-ttu-id="292bd-206">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="292bd-206">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="292bd-207">Le comportement de cette méthode est que l’espace blanc non significatif ne sera pas préservé.</span><span class="sxs-lookup"><span data-stu-id="292bd-207">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="292bd-208">Si vous souhaitez contrôler les espaces blancs, utilisez la surcharge de <xref:System.Xml.Linq.XStreamingElement.Save%2A> qui accepte <xref:System.Xml.Linq.SaveOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="292bd-208">If you want to control white space, use the overload of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="292bd-209">Utilisez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option pour enregistrer le code XML.</span><span class="sxs-lookup"><span data-stu-id="292bd-209">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="292bd-210">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="292bd-210">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="292bd-211">Utilisez <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option si vous souhaitez supprimer les déclarations d’espace de noms en double.</span><span class="sxs-lookup"><span data-stu-id="292bd-211">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xStreamingElement.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <span data-ttu-id="292bd-212">
            <see cref="T:System.IO.TextWriter" /> dans lequel le <see cref="T:System.Xml.Linq.XStreamingElement" /> sera écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-212">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XStreamingElement" /> will be written to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-213">Sérialiser cet élément de diffusion en continu vers un <see cref="T:System.IO.TextWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-213">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-214">Le code XML sérialisé est en retrait.</span><span class="sxs-lookup"><span data-stu-id="292bd-214">The serialized XML will be indented.</span></span> <span data-ttu-id="292bd-215">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="292bd-215">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="292bd-216">Le comportement de cette méthode est que les nœuds dans l’arborescence XML ne seront pas préservés espaces non significatifs.</span><span class="sxs-lookup"><span data-stu-id="292bd-216">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="292bd-217">Si vous souhaitez contrôler les espaces blancs, utilisez une des surcharges de <xref:System.Xml.Linq.XStreamingElement.Save%2A> acceptant <xref:System.Xml.Linq.SaveOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="292bd-217">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="292bd-218">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="292bd-218">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-219">L’exemple suivant crée une arborescence XML source, puis instancie un <xref:System.Xml.Linq.XStreamingElement> à l’aide d’une requête sur l’arborescence XML source.</span><span class="sxs-lookup"><span data-stu-id="292bd-219">The following example creates a source XML tree, then instantiates an <xref:System.Xml.Linq.XStreamingElement> using a query on the source XML tree.</span></span> <span data-ttu-id="292bd-220">Il écrit ensuite l’élément de diffusion en continu à un <xref:System.IO.StringWriter>.</span><span class="sxs-lookup"><span data-stu-id="292bd-220">It then writes the streaming element to a <xref:System.IO.StringWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb));  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb))  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="292bd-221">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-221">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xStreamingElement.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="292bd-222">
            <see cref="T:System.String" /> qui contient le nom du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-222">A <see cref="T:System.String" /> that contains the name of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-223">Sérialiser cet élément de diffusion en continu vers un fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-223">Serialize this streaming element to a file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-224">Le code XML sérialisé est en retrait.</span><span class="sxs-lookup"><span data-stu-id="292bd-224">The serialized XML will be indented.</span></span> <span data-ttu-id="292bd-225">Tous les espaces blancs non significatifs sera supprimé et un espace supplémentaire sera ajouté afin que le code XML mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="292bd-225">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="292bd-226">Le comportement de cette méthode est que les nœuds dans l’arborescence XML ne seront pas préservés espaces non significatifs.</span><span class="sxs-lookup"><span data-stu-id="292bd-226">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="292bd-227">Si vous souhaitez contrôler les espaces blancs, utilisez une des surcharges de <xref:System.Xml.Linq.XStreamingElement.Save%2A> acceptant <xref:System.Xml.Linq.SaveOptions> en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="292bd-227">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="292bd-228">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="292bd-228">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-229">L’exemple suivant crée une arborescence XML en continu.</span><span class="sxs-lookup"><span data-stu-id="292bd-229">The following example creates a streaming XML tree.</span></span> <span data-ttu-id="292bd-230">Il sérialise ensuite l’arborescence XML en continu vers un fichier.</span><span class="sxs-lookup"><span data-stu-id="292bd-230">It then serializes the streaming XML tree to a file.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="292bd-231">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-231">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="292bd-232">
            <see cref="T:System.Xml.XmlWriter" /> dans lequel le <see cref="T:System.Xml.Linq.XElement" /> sera écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-232">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XElement" /> will be written to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-233">Sérialiser cet élément de diffusion en continu vers un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-233">Serialize this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="292bd-234">L’exemple suivant crée un <xref:System.Xml.Linq.XStreamingElement> et écrit dans un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="292bd-234">The following example creates an <xref:System.Xml.Linq.XStreamingElement> and writes it to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                            from el in srcTree.Elements()  
                            where (int)el == 5  
                            select new XElement("DifferentChild", (int)el)  
                        );  
  
    dstTree.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                            From el In srcTree.Elements() _  
                            Where el.Value = 5 _  
                            Select <DifferentChild><%= el.Value %></DifferentChild> _  
                        )  
    dstTree.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="292bd-235">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-235">This example produces the following output:</span></span>  
  
```xml  
<NewRoot><DifferentChild>5</DifferentChild></NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="292bd-236">Flux vers lequel générer ce <see cref="T:System.Xml.Linq.XDocument" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-236">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="292bd-237">Objet <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-237">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-238">Génère ce <see cref="T:System.Xml.Linq.XStreamingElement" /> vers le <see cref="T:System.IO.Stream" /> spécifié, en précisant le cas échéant le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-238">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-239">Par défaut le `options` ont la valeur <xref:System.Xml.Linq.SaveOptions.None>.</span><span class="sxs-lookup"><span data-stu-id="292bd-239">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="292bd-240">Cette option supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="292bd-240">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="292bd-241">Si vous souhaitez enregistrer le code XML, spécifiez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="292bd-241">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="292bd-242">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="292bd-242">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="292bd-243">Utilisez <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option si vous souhaitez supprimer les déclarations d’espace de noms en double.</span><span class="sxs-lookup"><span data-stu-id="292bd-243">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <span data-ttu-id="292bd-244">
            <see cref="T:System.IO.TextWriter" /> vers lequel exporter le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-244">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="292bd-245">
            <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-245">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-246">Sérialiser cet élément de diffusion en continu vers un <see cref="T:System.IO.TextWriter" />, en désactivant éventuellement la mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-246">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-247">Si vous souhaitez enregistrer le code XML, spécifiez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="292bd-247">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="292bd-248">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="292bd-248">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="292bd-249">Si vous souhaitez enregistrer le code XML mis en retrait, ne spécifiez pas le <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="292bd-249">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="292bd-250">Cela supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="292bd-250">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="292bd-251">Il s’agit du comportement par défaut et le comportement des surcharges de la <xref:System.Xml.Linq.XElement.Save%2A> les méthodes qui ne prennent pas `options` en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="292bd-251">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="292bd-252">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="292bd-252">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-253">L’exemple suivant montre deux utilisations de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="292bd-253">The following example shows two uses of this method.</span></span> <span data-ttu-id="292bd-254">La première utilisation conserve l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="292bd-254">The first use preserves white space.</span></span> <span data-ttu-id="292bd-255">La seconde sérialise le <xref:System.Xml.Linq.XStreamingElement> avec mise en forme.</span><span class="sxs-lookup"><span data-stu-id="292bd-255">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.DisableFormatting);  
Console.WriteLine(sb.ToString());  
Console.WriteLine("------");  
sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.None);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.DisableFormatting)  
Console.WriteLine(sb.ToString())  
Console.WriteLine("------")  
sb = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.None)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="292bd-256">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-256">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="292bd-257">
            <see cref="T:System.String" /> qui contient le nom du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-257">A <see cref="T:System.String" /> that contains the name of the file.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="292bd-258">Objet <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-258">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-259">Sérialiser cet élément de diffusion en continu vers un fichier, en désactivant éventuellement la mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-259">Serialize this streaming element to a file, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-260">Si vous souhaitez enregistrer le code XML, spécifiez la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="292bd-260">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="292bd-261">Cela entraîne le writer à écrire tous les espaces blancs exactement comme représenté dans l’arborescence XML.</span><span class="sxs-lookup"><span data-stu-id="292bd-261">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="292bd-262">Si vous souhaitez enregistrer le code XML mis en retrait, ne spécifiez pas le <xref:System.Xml.Linq.SaveOptions.DisableFormatting> indicateur pour `options`.</span><span class="sxs-lookup"><span data-stu-id="292bd-262">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="292bd-263">Cela supprime tous les espaces non significatifs superflus et ajouter des espaces blancs non significatifs approprié afin que le code XML est mis en retrait correctement.</span><span class="sxs-lookup"><span data-stu-id="292bd-263">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="292bd-264">Il s’agit du comportement par défaut et le comportement des surcharges de la <xref:System.Xml.Linq.XElement.Save%2A> les méthodes qui ne prennent pas `options` en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="292bd-264">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="292bd-265">Pour plus d’informations, consultez [conserver les espaces lors du chargement ou de l’analyse de XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) et [conserver un espace blanc tandis que sérialisation](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="292bd-265">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-266">L’exemple suivant montre deux utilisations de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="292bd-266">The following example shows two uses of this method.</span></span> <span data-ttu-id="292bd-267">La première utilisation conserve l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="292bd-267">The first use preserves white space.</span></span> <span data-ttu-id="292bd-268">La seconde sérialise le <xref:System.Xml.Linq.XStreamingElement> avec mise en forme.</span><span class="sxs-lookup"><span data-stu-id="292bd-268">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting);  
dstTree.Save("Test2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Test1.xml"));  
Console.WriteLine("------");  
Console.WriteLine(File.ReadAllText("Test2.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting)  
dstTree.Save("Test2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Test1.xml"))  
Console.WriteLine("------")  
Console.WriteLine(File.ReadAllText("Test2.xml"))  
```  
  
 <span data-ttu-id="292bd-269">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-269">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="292bd-270">Retourne le code XML pour cet élément de diffusion en continu, en désactivant éventuellement la mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-270">Returns the XML for this streaming element, optionally disabling formatting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-271">Notez que lors du débogage d’un programme qui utilise <xref:System.Xml.Linq.XStreamingElement>, affichage de la valeur d’un objet entraîne son <xref:System.Xml.Linq.XStreamingElement.ToString%2A> méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="292bd-271">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="292bd-272">Ainsi, le code XML à sérialiser.</span><span class="sxs-lookup"><span data-stu-id="292bd-272">This causes the XML to be serialized.</span></span> <span data-ttu-id="292bd-273">Si la sémantique de votre requête d’élément diffusion en continu est telles que l’élément de diffusion en continu peut être diffusé uniquement une fois, cela peut entraîner un comportement indésirable dans votre expérience de débogage.</span><span class="sxs-lookup"><span data-stu-id="292bd-273">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xStreamingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="292bd-274">Retourne le code XML mis en forme (en retrait) pour cet élément de diffusion en continu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-274">Returns the formatted (indented) XML for this streaming element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="292bd-275">
            <see cref="T:System.String" /> contenant le code XML mis en retrait.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-275">A <see cref="T:System.String" /> containing the indented XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-276">Notez que lors du débogage d’un programme qui utilise <xref:System.Xml.Linq.XStreamingElement>, affichage de la valeur d’un objet entraîne son <xref:System.Xml.Linq.XStreamingElement.ToString%2A> méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="292bd-276">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="292bd-277">Ainsi, le code XML à sérialiser.</span><span class="sxs-lookup"><span data-stu-id="292bd-277">This causes the XML to be serialized.</span></span> <span data-ttu-id="292bd-278">Si la sémantique de votre requête d’élément diffusion en continu est telles que l’élément de diffusion en continu peut être diffusé uniquement une fois, cela peut entraîner un comportement indésirable dans votre expérience de débogage.</span><span class="sxs-lookup"><span data-stu-id="292bd-278">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-279">L’exemple suivant montre deux utilisations de <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="292bd-279">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="292bd-280">La première utilisation conserve l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="292bd-280">The first use preserves white space.</span></span> <span data-ttu-id="292bd-281">La seconde sérialise le <xref:System.Xml.Linq.XStreamingElement> avec mise en forme.</span><span class="sxs-lookup"><span data-stu-id="292bd-281">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="292bd-282">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-282">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xStreamingElement.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="292bd-283">
            <see cref="T:System.Xml.Linq.SaveOptions" /> qui spécifie le comportement de mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-283">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-284">Retourne le code XML pour cet élément de diffusion en continu, en désactivant éventuellement la mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-284">Returns the XML for this streaming element, optionally disabling formatting.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="292bd-285">
            <see cref="T:System.String" /> contenant le code XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-285">A <see cref="T:System.String" /> containing the XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="292bd-286">Notez que lors du débogage d’un programme qui utilise <xref:System.Xml.Linq.XStreamingElement>, affichage de la valeur d’un objet entraîne son <xref:System.Xml.Linq.XStreamingElement.ToString%2A> méthode à appeler.</span><span class="sxs-lookup"><span data-stu-id="292bd-286">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="292bd-287">Ainsi, le code XML à sérialiser.</span><span class="sxs-lookup"><span data-stu-id="292bd-287">This causes the XML to be serialized.</span></span> <span data-ttu-id="292bd-288">Si la sémantique de votre requête d’élément diffusion en continu est telles que l’élément de diffusion en continu peut être diffusé uniquement une fois, cela peut entraîner un comportement indésirable dans votre expérience de débogage.</span><span class="sxs-lookup"><span data-stu-id="292bd-288">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="292bd-289">L’exemple suivant montre deux utilisations de <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="292bd-289">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="292bd-290">La première utilisation conserve l’espace blanc.</span><span class="sxs-lookup"><span data-stu-id="292bd-290">The first use preserves white space.</span></span> <span data-ttu-id="292bd-291">La seconde sérialise le <xref:System.Xml.Linq.XStreamingElement> avec mise en forme.</span><span class="sxs-lookup"><span data-stu-id="292bd-291">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="292bd-292">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-292">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="292bd-293">
            <see cref="T:System.Xml.XmlWriter" /> dans lequel cette méthode écrira.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-293">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="292bd-294">Écrit cet élément de diffusion en continu vers un <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="292bd-294">Writes this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="292bd-295">L’exemple suivant crée une arborescence XML à l’aide <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="292bd-295">The following example creates an XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="292bd-296">Il écrit ensuite l’élément de diffusion en continu à un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="292bd-296">It then writes the streaming element to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    dstTree.WriteTo(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = _   
    New XStreamingElement("NewRoot", _  
        From el In srcTree.Elements() _  
        Where el.Value = 3 _  
        Select <DifferentChild><%= el.Value %></DifferentChild> )  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    dstTree.WriteTo(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="292bd-297">Cet exemple génère la sortie suivante :</span><span class="sxs-lookup"><span data-stu-id="292bd-297">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>