<Type Name="InPlaceHostingManager" FullName="System.Deployment.Application.InPlaceHostingManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="37a2d5acb62923ae574d83fa0e8f1aa751bfbd07" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51866125" /></Metadata><TypeSignature Language="C#" Value="public class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InPlaceHostingManager extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.InPlaceHostingManager" />
  <TypeSignature Language="VB.NET" Value="Public Class InPlaceHostingManager&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="F#" Value="type InPlaceHostingManager = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Installe ou met à jour un déploiement ClickOnce sur un ordinateur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser <xref:System.Deployment.Application.InPlaceHostingManager> pour écrire des programmes qui installent [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] applications par programmation. Par exemple, vous pouvez utiliser cette classe dans un environnement de logiciel (SMS) de gestion système contrôlé ou dans des situations où vous avez besoin d’une installation complexe qui exécute un nombre d’opérations de pré-installation ou de post-installation sur l’ordinateur local. En règle générale, vous devez utiliser les membres de cette classe dans un ordre spécifique :  
  
1.  Créez une nouvelle instance de <xref:System.Deployment.Application.InPlaceHostingManager>.  
  
2.  Télécharger le manifeste de déploiement à l’aide de <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A>.  
  
3.  Vérifiez que l’application peut être exécutée avec les autorisations appropriées à l’aide de <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
4.  Téléchargez et installez l’application à l’aide de <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
-   Si vous appelez une de ces paramètres en désordre, ils lève une exception.  
  
 <xref:System.Deployment.Application.InPlaceHostingManager> peut installer un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application, mais ne peut pas l’exécuter. Certaines méthodes de cette classe, telle que <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A>, sont réservés pour une utilisation lors du téléchargement d’une application Windows Presentation Foundation qui s’exécute dans un navigateur Web.  
  
 Pour utiliser <xref:System.Deployment.Application.InPlaceHostingManager> pour télécharger et installer des applications, vous devez vous assurer que le certificat pour signer le [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] applications que vous envisagez d’installer est déjà installé sur les ordinateurs clients en tant qu’un éditeur approuvé. Pour plus d’informations sur les éditeurs approuvés, consultez [Trusted Application Deployment Overview](https://msdn.microsoft.com/library/b24a1702-8fbe-45b1-87a0-9618a0708f1d).  
  
> [!NOTE]
>  Il existe actuellement une limitation de produit qui empêche <xref:System.Deployment.Application.InPlaceHostingManager> de fonctionner correctement lorsque vous déboguez votre code à l’aide de Visual Studio. Si vous déboguez votre application dans Visual Studio à l’aide de la touche F5, l’exemple lève des exceptions mystérieuses lorsque vous appelez <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>. Pour déboguer à l’aide de Visual Studio, démarrez l’application sans débogage, puis attacher le débogueur. Vous pouvez également utiliser un autre débogueur, tel que WinDbg.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Deployment.Application.InPlaceHostingManager> pour installer un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application par programmation sur un ordinateur client.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#1)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une nouvelle instance de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pour télécharger et installer l'application spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest);" />
      <MemberSignature Language="F#" Value="new System.Deployment.Application.InPlaceHostingManager : Uri -&gt; System.Deployment.Application.InPlaceHostingManager" Usage="new System.Deployment.Application.InPlaceHostingManager deploymentManifest" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">Identificateur URI (Uniform Resource Identifier) (<see cref="T:System.Uri" />) vers le manifeste de déploiement d'une application [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</param>
        <summary>Crée une nouvelle instance de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pour télécharger et installer l'application hébergée par le navigateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est utilisé lorsque vous souhaitez télécharger une application Windows Presentation Foundation qui est hébergée dans un navigateur Web. Pour télécharger des applications Windows Forms qui sont déployées à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], utilisez le <xref:System.Deployment.Application.InPlaceHostingManager.%23ctor%2A> constructeur avec le `launchInHostProcess` paramètre défini sur `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.Deployment.Application.InPlaceHostingManager" /> peut être utilisé uniquement dans Windows XP ou dans les versions ultérieures du système d'exploitation Windows.</exception>
        <exception cref="T:System.ArgumentNullException">Impossible de passer <see langword="null" /> pour l'argument <paramref name="deploymentManifest" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="deploymentManifest" /> utilise un modèle URI qui n'est pas pris en charge par [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest, bool launchInHostProcess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri, launchInHostProcess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="F#" Value="new System.Deployment.Application.InPlaceHostingManager : Uri * bool -&gt; System.Deployment.Application.InPlaceHostingManager" Usage="new System.Deployment.Application.InPlaceHostingManager (deploymentManifest, launchInHostProcess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
        <Parameter Name="launchInHostProcess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">URI (Uniform Resource Identifier) vers le manifeste de déploiement de l'application qui sera installée.</param>
        <param name="launchInHostProcess">Si cette application est exécutée sur un hôte, comme un navigateur Web. Pour une application autonome, affectez <see langword="false" /> à cette valeur.</param>
        <summary>Crée une nouvelle instance de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pour télécharger et installer l'application spécifiée, qui peut être une application Windows Forms autonome ou une application hébergée dans un navigateur Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment créer une instance de <xref:System.Deployment.Application.InPlaceHostingManager> qui vous permet de télécharger des applications Windows Forms déployées à l’aide [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="T:System.Deployment.Application.InPlaceHostingManager" /> peut être utilisé uniquement dans Windows XP ou dans les versions ultérieures du système d'exploitation Windows.</exception>
        <exception cref="T:System.ArgumentNullException">Impossible de passer <see langword="null" /> pour l'argument <paramref name="deploymentManifest" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="deploymentManifest" /> utilise un modèle URI qui n'est pas pris en charge par [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AssertApplicationRequirements">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si l’application ClickOnce a les autorisations et les dépendances de plateforme nécessaires pour fonctionner sur l’ordinateur local.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements();" />
      <MemberSignature Language="F#" Value="member this.AssertApplicationRequirements : unit -&gt; unit" Usage="inPlaceHostingManager.AssertApplicationRequirements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Détermine si l'application [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] a les autorisations et les dépendances de plateforme requises pour fonctionner sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> après <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> retournée avec succès. Vous ne devez pas appeler <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A> , sauf si vous appelez <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, et elle retourne sans erreur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, qu’il appelle dans le corps d’un bon <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> Gestionnaire d’événements.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Déclenché si cette méthode est appelée avant la méthode <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements (bool grantApplicationTrust);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements(bool grantApplicationTrust) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements (grantApplicationTrust As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements(bool grantApplicationTrust);" />
      <MemberSignature Language="F#" Value="member this.AssertApplicationRequirements : bool -&gt; unit" Usage="inPlaceHostingManager.AssertApplicationRequirements grantApplicationTrust" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="grantApplicationTrust" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="grantApplicationTrust">Si la valeur est <see langword="true" />, l'application tentera d'élever ses autorisations au niveau requis.</param>
        <summary>Détermine si l'application [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] a les autorisations et les dépendances de plateforme requises pour fonctionner sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `grantApplicationTrust` est `true`, <xref:System.Deployment.Application.InPlaceHostingManager> accordera à l’application si elle en requiert des autorisations élevées. Cela est possible uniquement si <xref:System.Deployment.Application.InPlaceHostingManager> est en mesure d’accorder ces autorisations. Par exemple, si un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application est installée dans le cadre d’un package plus volumineux et le programme d’installation a été accordé une confiance totale, <xref:System.Deployment.Application.InPlaceHostingManager> sera en mesure d’accorder le [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application une confiance totale. Si `grantApplicationTrust` est `false`, l’application ne recevra pas les autorisations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="inPlaceHostingManager.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule une opération de téléchargement asynchrone.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="inPlaceHostingManager.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Deployment.Application.InPlaceHostingManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Deployment.Application.InPlaceHostingManager>. La méthode <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> rend le <xref:System.Deployment.Application.InPlaceHostingManager> inutilisable. Après avoir appelé <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A>, vous devez libérer toutes les références à la <xref:System.Deployment.Application.InPlaceHostingManager> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Deployment.Application.InPlaceHostingManager> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> avant de libérer votre dernière référence à <xref:System.Deployment.Application.InPlaceHostingManager>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Deployment.Application.InPlaceHostingManager> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationAsync">
      <MemberSignature Language="C#" Value="public void DownloadApplicationAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadApplicationAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadApplicationAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadApplicationAsync();" />
      <MemberSignature Language="F#" Value="member this.DownloadApplicationAsync : unit -&gt; unit" Usage="inPlaceHostingManager.DownloadApplicationAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Télécharge une mise à jour d'application en arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler cette méthode après avoir appelé <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>, qu’il appelle à la fin de la réussite <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> Gestionnaire d’événements.  
  
 Les exemples de code suivants supposent que vous avez déjà défini et créé une instance de <xref:System.Deployment.Application.InPlaceHostingManager> nommé `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Déclenché si cette méthode est appelée avant les méthodes <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> et <see cref="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadApplicationCompleted As EventHandler(Of DownloadApplicationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadApplicationCompletedEventArgs ^&gt; ^ DownloadApplicationCompleted;" />
      <MemberSignature Language="F#" Value="member this.DownloadApplicationCompleted : EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; " Usage="member this.DownloadApplicationCompleted : System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'application a terminé de télécharger sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous installez une application basée sur des Windows Forms, vous devez demander aux utilisateurs de lancer l’application eux-mêmes ; Impossible de démarrer des applications Windows Forms par programmation à l’aide de la <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre un gestionnaire pour le <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted> événement.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#7)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadProgressChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadProgressChanged As EventHandler(Of DownloadProgressChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadProgressChangedEventArgs ^&gt; ^ DownloadProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.DownloadProgressChanged : EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; " Usage="member this.DownloadProgressChanged : System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'il y a une modification dans l'état du téléchargement d'une application ou d'un manifeste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans une application console, les événements sont assignés aux threads à partir d’un pool de threads. Par conséquent, vous pouvez recevoir des événements de mise à jour de la progression en désordre, un événement suivant montrant une baisse par rapport à un événement précédent. Vous ne verrez pas ce type de comportement dans une application basée sur des Windows Forms, étant donné que les événements dans les Windows Forms sont traitées de manière séquentielle en dehors de la file d’attente de messages du thread d’interface (UI) utilisateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment mettre à jour un <xref:System.Windows.Forms.ToolStripProgressBar> qui est contenue dans un <xref:System.Windows.Forms.StatusStrip>.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#6)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle Execute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle Execute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Execute" />
      <MemberSignature Language="VB.NET" Value="Public Function Execute () As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ Execute();" />
      <MemberSignature Language="F#" Value="member this.Execute : unit -&gt; System.Runtime.Remoting.ObjectHandle" Usage="inPlaceHostingManager.Execute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lance l'application [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], si et seulement s'il s'agit d'une application Windows Presentation Foundation s'exécutant dans un navigateur Web.</summary>
        <returns><see cref="T:System.Runtime.Remoting.ObjectHandle" /> correspondant à l'application lancée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est valide uniquement pour les applications Windows Presentation Foundation qui peuvent être hébergées dans un navigateur Web (autrement dit, leurs manifestes de déploiement définissent le `hostInBrowser` élément XML).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestAsync">
      <MemberSignature Language="C#" Value="public void GetManifestAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetManifestAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetManifestAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetManifestAsync();" />
      <MemberSignature Language="F#" Value="member this.GetManifestAsync : unit -&gt; unit" Usage="inPlaceHostingManager.GetManifestAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Télécharge en arrière-plan le manifeste de déploiement de l'application de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], et déclenche un événement lorsque l'opération est terminée ou a rencontré une erreur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour recevoir la notification de fin de cet événement de, créez un gestionnaire d’événements pour le <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> événement. Si cet événement est appelé, et aucune erreur n’est indiqué par <xref:System.Deployment.Application.GetManifestCompletedEventArgs>, vous devez ensuite appeler <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> pour vérifier que l’application aura l’autorisation d’exécuter sur l’ordinateur local.  
  
   
  
## Examples  
 Les exemples de code suivants montrent comment appeler le <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> (méthode). Le gestionnaire pour le <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> événement rappel vérifie si le téléchargement du manifeste a réussi et si tel est le cas, invite l’utilisateur avec des informations supplémentaires sur l’application. Si l’utilisateur accepte de poursuivre l’installation, le gestionnaire appelle <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 Les exemples de code suivants supposent que vous avez déjà défini et créé une instance de <xref:System.Deployment.Application.InPlaceHostingManager> nommé `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event GetManifestCompleted As EventHandler(Of GetManifestCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::GetManifestCompletedEventArgs ^&gt; ^ GetManifestCompleted;" />
      <MemberSignature Language="F#" Value="member this.GetManifestCompleted : EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; " Usage="member this.GetManifestCompleted : System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le manifeste de déploiement a été téléchargé sur l'ordinateur local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriété du <xref:System.Deployment.Application.GetManifestCompletedEventArgs> pour vérifier si <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> a réussi ou a retourné une erreur. Si <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> a la valeur null, <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> s’est terminée correctement, et vous pouvez appeler <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 Les exemples de code suivants montrent comment appeler le <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> (méthode). Le gestionnaire pour le <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> événement rappel vérifie si le téléchargement du manifeste a réussi et si tel est le cas, invite l’utilisateur avec des informations supplémentaires sur l’application. Si l’utilisateur accepte de poursuivre l’installation, le gestionnaire appelle <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 Les exemples de code suivants supposent que vous avez déjà défini et créé une instance de <xref:System.Deployment.Application.InPlaceHostingManager> nommé `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomAddIn">
      <MemberSignature Language="C#" Value="public static void UninstallCustomAddIn (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomAddIn(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomAddIn (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomAddIn(System::String ^ subscriptionId);" />
      <MemberSignature Language="F#" Value="static member UninstallCustomAddIn : string -&gt; unit" Usage="System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn subscriptionId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Chaîne contenant un identificateur d'abonnement qui indique le complément à supprimer.</param>
        <summary>Supprime un composant défini par l'utilisateur installé précédemment d'application.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="subscriptionId" /> ne correspond pas à une identité d'abonnement valide ou ne contient pas de nom, de jeton de clé publique, d'architecture de processeur et de numéro de version.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subscriptionId" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomUXApplication">
      <MemberSignature Language="C#" Value="public static void UninstallCustomUXApplication (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomUXApplication(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomUXApplication (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomUXApplication(System::String ^ subscriptionId);" />
      <MemberSignature Language="F#" Value="static member UninstallCustomUXApplication : string -&gt; unit" Usage="System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication subscriptionId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Chaîne contenant un identificateur d'abonnement qui indique l'application [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] à supprimer.</param>
        <summary>Supprime une application [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] qui inclut l’élément &lt;customUX&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode désinstalle un précédemment installées [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application qui utilise le `<customUX>` élément dans le [ &lt;entryPoint&gt; élément](/visualstudio/deployment/entrypoint-element-clickonce-application).  
  
 Programmes d’installation personnalisés qui ne créent pas une entrée Ajout / Suppression de programmes pour le [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application doit stocker l’identificateur d’abonnement trouvé dans le <xref:System.Deployment.Application.GetManifestCompletedEventArgs.SubscriptionIdentity%2A> propriété pendant l’installation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>