<Type Name="ProfileOptimization" FullName="System.Runtime.ProfileOptimization">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bd86c9e8585771817dff9c403cde415163613389" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30488273" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ProfileOptimization" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ProfileOptimization extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ProfileOptimization" />
  <TypeSignature Language="VB.NET" Value="Public Class ProfileOptimization" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProfileOptimization abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Améliore les performances de démarrage des domaines d'application dans les applications qui requièrent le compilateur juste-à-temps (JIT) lors de la compilation d'arrière-plan des méthodes susceptibles d'être exécutées, en fonction des profils créés lors des compilations précédentes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Optimisation de profil nécessite un ordinateur multicœur. Les méthodes sont ignorés sur d’autres ordinateurs.  
  
 Chaque fois que vous lancez l’optimisation de profil dans un domaine d’application, le profil a été créé lors de l’utilisation précédente est en lecture. Les informations contenues dans le profil sont utilisés pour guider la compilation en arrière-plan en identifiant les méthodes qui sont plus susceptibles d’être exécutée lors du démarrage. Sur les ordinateurs multicœurs, cela augmente le risque qu’une méthode est déjà compilés au moment où qu'il est nécessaire afin que le thread d’application principal ne dispose pas d’appeler le compilateur JIT.  
  
 Le fichier de profil est remplacé à chaque utilisation, afin qu’il contienne toujours les informations les plus récentes sur les méthodes sont utilisées lors du démarrage.  
  
 Profils de l’optimisation ne sont pas limitées à démarrage de domaine d’application. Ils peuvent être utilisés pour toute activité qui nécessite une utilisation intensive du compilateur JIT. Vous pouvez gérer plusieurs profils pour un domaine d’application afin que chaque activité de ce type possède son propre profil.  
  
 Pour utiliser des profils de l’optimisation dans un domaine d’application, vous devez appeler la <xref:System.Runtime.ProfileOptimization.SetProfileRoot%2A> (méthode) et spécifiez le dossier où sont stockés les profils. Le dossier doit déjà exister. Pour commencer à l’aide d’un profil, appelez le <xref:System.Runtime.ProfileOptimization.StartProfile%2A> (méthode) et spécifiez le nom de fichier du profil. Si le fichier n’a pas été enregistré auparavant, il est créé à la première utilisation. Est aucun performances avantage le premier un profil est créé.  
  
 Optimisation de profil ne modifie pas l’ordre dans lequel les méthodes sont exécutées. Méthodes ne sont pas exécutées sur le thread d’arrière-plan ; Si une méthode est compilée, mais jamais appelée, il est tout simplement pas utilisé. Si un fichier de profil est endommagé ou ne peut pas être écrit dans le dossier spécifié (par exemple, étant donné que le dossier n’existe pas), l’exécution du programme se poursuit sans optimisation du profilage.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="SetProfileRoot">
      <MemberSignature Language="C#" Value="public static void SetProfileRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetProfileRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ProfileOptimization.SetProfileRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetProfileRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetProfileRoot(System::String ^ directoryPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">Chemin d'accès complet au dossier dans lequel les fichiers de profil sont enregistrés pour le domaine d'application en cours.</param>
        <summary>Active le profilage d'optimisation pour le domaine d'application actif, et définit le dossier dans lequel les fichiers de profils d'optimisation sont enregistrés. Sur les ordinateurs à cœur unique, la méthode est ignorée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler cette méthode avant d’appeler le <xref:System.Runtime.ProfileOptimization.StartProfile%2A> méthode pour la première fois dans le domaine d’application actuel. Si vous appelez <xref:System.Runtime.ProfileOptimization.SetProfileRoot%2A> plusieurs fois dans le même domaine d’application, tous les appels après la première sont ignorées.  
  
 Le dossier spécifié doit déjà exister. Si elle n’existe pas, cette méthode ne crée pas et aucun profilage se produit.  
  
 Sur les ordinateurs qui n’ont pas de plusieurs cœurs, cette méthode est ignorée.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartProfile">
      <MemberSignature Language="C#" Value="public static void StartProfile (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StartProfile(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ProfileOptimization.StartProfile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StartProfile (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StartProfile(System::String ^ profile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">Nom de fichier du profil à utiliser.</param>
        <summary>Démarre la compilation juste-à-temps (JIT) des méthodes qui ont été précédemment enregistrées dans le fichier de profil spécifié, sur un thread d'arrière-plan. Démarre le processus d'enregistrement de l'utilisation de méthode actuelle, qui remplace ultérieurement le fichier de profil spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le profil spécifié existe dans le dossier spécifié par la <xref:System.Runtime.ProfileOptimization.SetProfileRoot%2A> méthode, les informations qu’il contient est utilisée pour déterminer l’ordre dans lequel les méthodes sont compilés sur le thread d’arrière-plan. Le <xref:System.Runtime.ProfileOptimization.StartProfile%2A> méthode crée le profil s’il n’existe pas déjà et lance l’enregistrement d’utilisation de la méthode.  
  
 Seules les méthodes qui sont appelées en réalité sont enregistrés, indépendamment de si elles ont été compilées sur le thread d’arrière-plan ou sur le thread d’application principal. Une méthode est compilée sur le thread d’application principal, si l’application doit appeler avant le thread d’arrière-plan a compilé.  
  
 Le code qui effectue l’enregistrement effectue le suivi de la vitesse à laquelle les méthodes sont compilées, y compris les méthodes qui sont compilés sur le thread d’arrière-plan et sur le thread principal. Lorsque le taux tombe au-dessous du niveau prédéterminé, enregistrement s’arrête. L’enregistrement s’arrête également si le taux de compilation JIT dépasse une limite prédéterminée.  
  
 Si le <xref:System.Runtime.ProfileOptimization.SetProfileRoot%2A> méthode n’a pas été appelée pour le domaine d’application actuel, ou si l’ordinateur n’a pas de plusieurs cœurs, la <xref:System.Runtime.ProfileOptimization.StartProfile%2A> méthode n’a aucun effet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
  </Members>
</Type>