<Type Name="MemoryFailPoint" FullName="System.Runtime.MemoryFailPoint">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="61e44bc871caa29f826e0555271beb6a45d2de1c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30489353" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MemoryFailPoint : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MemoryFailPoint extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.MemoryFailPoint" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MemoryFailPoint&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryFailPoint sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Contrôle que les ressources mémoire sont suffisantes avant d'exécuter une opération. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette classe est destinée à être utilisée dans le développement avancé.  
  
 Création d’une instance de la <xref:System.Runtime.MemoryFailPoint> classe crée une porte de mémoire. Une porte de mémoire vérifie les ressources suffisantes avant d’initier une activité nécessitant une grande quantité de mémoire. Échec de la vérification des résultats dans un <xref:System.InsufficientMemoryException> levée d’exception. Cette exception empêche une opération en cours de démarrage et réduit le risque d’échec en raison d’un manque de ressources. Ainsi, vous diminuez les performances pour éviter un <xref:System.OutOfMemoryException> exception et toute altération d’état qui peut être dû à une gestion incorrecte de l’exception dans des emplacements arbitraires dans votre code.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
 En levant une <xref:System.InsufficientMemoryException> exception, une application peut faire la distinction entre une opération ne sera pas en mesure d’effectuer une estimation et une opération partiellement terminée qui a peut-être endommagé l’état de l’application. Cela permet à une application afin de réduire la fréquence d’une stratégie de hiérarchie pessimiste, ce qui peut nécessiter le déchargement actuel <xref:System.AppDomain> ou de recyclage du processus.  
  
 <xref:System.Runtime.MemoryFailPoint> vérifie si le système d’exploitation sont disponibles dans tous les garbage collection de segments de mémoire suffisamment de mémoire et espace d’adressage virtuel consécutifs et qu’il peuvent augmenter la taille du fichier d’échange.  <xref:System.Runtime.MemoryFailPoint> aucune garantie en ce qui concerne la disponibilité à long terme de la mémoire pendant la durée de vie de la grille, mais les appelants ne doit-elle toujours utilise le <xref:System.Runtime.MemoryFailPoint.Dispose%2A> pour s’assurer que les ressources associées <xref:System.Runtime.MemoryFailPoint> sont libérés.  
  
 Pour utiliser une porte de mémoire, vous devez créer un <xref:System.Runtime.MemoryFailPoint> de l’objet et spécifier le nombre de mégaoctets (Mo) de mémoire que l’opération suivante est supposée utiliser. Si suffisamment de mémoire n’est pas disponible, un <xref:System.InsufficientMemoryException> exception est levée.  
  
 Le paramètre du constructeur doit être un entier positif. Une valeur négative lève une <xref:System.ArgumentOutOfRangeException> exception.  
  
 <xref:System.Runtime.MemoryFailPoint> fonctionne à un niveau de granularité de 16 Mo. Toute valeur inférieure à 16 Mo est assimilées à 16 Mo, et les autres valeurs sont traitées comme la plus grande prochain multiple de 16 Mo.  
  
   
  
## Examples  
 <xref:System.Runtime.MemoryFailPoint> permet à une application de ralentir afin de ne pas manquer de mémoire entraînerait une altération.  Elle doit être utilisée dans une portée lexicale.  L’exemple suivant lance des threads pour traiter les éléments dans une file d’attente de travail.  Avant de lancer chaque thread, les ressources mémoire disponibles sont vérifiées à l’aide de <xref:System.Runtime.MemoryFailPoint>.  Si une exception est levée, la méthode principale attend jusqu'à ce que la mémoire est disponible avant de lancer le thread suivant.  
  
 [!code-csharp[MemoryFailPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR/MemoryFailPoint/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryFailPoint (int sizeInMegabytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 sizeInMegabytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.MemoryFailPoint.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (sizeInMegabytes As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryFailPoint(int sizeInMegabytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="sizeInMegabytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sizeInMegabytes">Taille de mémoire requise, en mégaoctets. Cette valeur doit être positive.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.MemoryFailPoint" />, en spécifiant la quantité de mémoire requise pour réussir une exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La quantité de mémoire utilisée par votre application pour traiter un élément de travail peut être déterminée de manière empirique.  Pour estimer la quantité de mémoire de votre application doit traiter une demande, envisagez d’utiliser le <xref:System.GC.GetTotalMemory%2A?displayProperty=nameWithType> méthode pour déterminer la quantité de mémoire disponible avant et après l’appel de la méthode qui traite l’élément de travail. Consultez le <xref:System.Runtime.MemoryFailPoint> classe pour obtenir un exemple de code qui détermine dynamiquement la valeur pour le `sizeInMegabytes` paramètre.  
  
   
  
## Examples  
 L’exemple suivant montre comment déterminer la quantité de mémoire, qu'une méthode exige de lors de l’exécution. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.MemoryFailPoint> classe.  
  
 [!code-csharp[MemoryFailPoint#2](~/samples/snippets/csharp/VS_Snippets_CLR/MemoryFailPoint/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La taille de mémoire spécifiée est négative.</exception>
        <exception cref="T:System.InsufficientMemoryException">Mémoire insuffisante pour commencer l’exécution du code protégé par la porte.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.MemoryFailPoint.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Runtime.MemoryFailPoint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Runtime.MemoryFailPoint.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Runtime.MemoryFailPoint>. La méthode <xref:System.Runtime.MemoryFailPoint.Dispose%2A> rend le <xref:System.Runtime.MemoryFailPoint> inutilisable. Après avoir appelé <xref:System.Runtime.MemoryFailPoint>, vous devez libérer toutes les références à la <xref:System.Runtime.MemoryFailPoint> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Runtime.MemoryFailPoint> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours <xref:System.Runtime.MemoryFailPoint.Dispose%2A> avant de libérer votre dernière référence à <xref:System.Runtime.MemoryFailPoint>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.MemoryFailPoint> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MemoryFailPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.MemoryFailPoint.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MemoryFailPoint ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <see cref="T:System.Runtime.MemoryFailPoint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le garbage collector appelle la <xref:System.Runtime.MemoryFailPoint.Finalize%2A> méthode lorsque l’objet actuel est prêt à être finalisé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
  </Members>
</Type>