<Type Name="GCSettings" FullName="System.Runtime.GCSettings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8ec6350c6c19f45b4b097a5ec933a1a05725cb84" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36533169" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GCSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GCSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.GCSettings" />
  <TypeSignature Language="VB.NET" Value="Public Class GCSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class GCSettings abstract sealed" />
  <TypeSignature Language="F#" Value="type GCSettings = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Specifies the garbage collection settings for the current process.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.GCSettings.IsServerGC%2A> propriété pour déterminer si le garbage collection côté serveur est activé pour le processus actuel.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsServerGC">
      <MemberSignature Language="C#" Value="public static bool IsServerGC { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsServerGC" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.IsServerGC" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsServerGC As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsServerGC { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServerGC : bool" Usage="System.Runtime.GCSettings.IsServerGC" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether server garbage collection is enabled.</summary>
        <value>
          <see langword="true" /> si le garbage collection du serveur est activé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur le garbage collection côté serveur, consultez la section « Poste de travail et de Garbage Collection côté serveur » dans [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).  
  
 Si le garbage collection côté serveur n’est pas activé, le garbage collection de station de travail est en vigueur (avec ou sans collection simultanée). Garbage collection côté serveur est disponible uniquement sur les ordinateurs multiprocesseurs.  
  
 Un hôte non managé peut demander le garbage collection côté serveur et fichier de configuration substitue à la demande de l’ordinateur hôte. Si l’ordinateur hôte ne spécifie pas le type de garbage collection, vous pouvez utiliser une fichier de configuration pour spécifier le garbage collection côté serveur. Ce paramètre est valide uniquement dans le fichier de configuration d’application, pas dans le fichier de configuration machine (consultez [configuration des applications](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)). L’exemple suivant montre le contenu d’un fichier de configuration d’application exemple qui active le garbage collection côté serveur.  
  
```  
<configuration>  
  <runtime>  
    <gcServer enabled="true" />  
  </runtime>  
</configuration>  
```  
  
   
  
## Examples  
 L’exemple suivant indique si l’ordinateur hôte est à l’aide de serveur ou le garbage collection de station de travail.  
  
 [!code-csharp[Environment.IsServerGC#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.IsServerGC/CS/isg.cs#1)]
 [!code-vb[Environment.IsServerGC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.IsServerGC/VB/isg.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LargeObjectHeapCompactionMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargeObjectHeapCompactionMode As GCLargeObjectHeapCompactionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { System::Runtime::GCLargeObjectHeapCompactionMode get(); void set(System::Runtime::GCLargeObjectHeapCompactionMode value); };" />
      <MemberSignature Language="F#" Value="member this.LargeObjectHeapCompactionMode : System.Runtime.GCLargeObjectHeapCompactionMode with get, set" Usage="System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLargeObjectHeapCompactionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supported in the .NET Framework 4.5.1 and later versions]  Gets or sets a value that indicates whether a full blocking garbage collection compacts the large object heap (LOH).</summary>
        <value>L’une des valeurs d’énumération indiquant si un garbage collection de blocage complet compacte le tas d’objets volumineux (LOH).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le LOH est utilisé pour allouer de la mémoire pour les objets volumineux (tels que les tableaux) qui nécessitent plus de 85 000 octets. En raison de l’impact sur les performances de copie de grands blocs de mémoire, le garbage collector balaye habituellement LOH, ce qui implique la création d’une liste des emplacements de mémoire qui ont été occupé par les objets morts et qui peut être réutilisé pour satisfaire les demandes ultérieures pour allocation de mémoire pour les objets volumineux. Toutefois, dans les applications qui font une large utilisation du LOH pour stocker des objets temporaires, la fragmentation peut également nuire aux performances de mémoire. Dans ce cas, il est possible d’utiliser le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propriété permet de compacter le LOH plutôt que simplement balayage pendant un garbage collection.  
  
 La valeur par défaut de la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propriété est <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>, ce qui signifie que le LOH n’est pas compacté pendant un garbage collection. Si vous affectez à la propriété une valeur de <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>le LOH est compacté pendant la prochain garbage collection de blocage et la valeur de propriété est réinitialisée à <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nettoyages en arrière-plan ne sont pas bloquées. Cela signifie que, si vous définissez la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propriété <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, toute génération arrière-plan 2 collections qui se produisent par la suite compacte pas le LOH. Uniquement la première génération blocage collection 2 compacte le LOH.  
  
 Après le <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> est définie sur <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, le prochain garbage collection de blocage (et le compactage du LOH) se produit pendant une heure futures indéterminée. Vous pouvez compresser le LOH immédiatement à l’aide de code semblable au suivant :  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.GCLargeObjectHeapCompactionMode" />
      </Docs>
    </Member>
    <Member MemberName="LatencyMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLatencyMode LatencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLatencyMode LatencyMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LatencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LatencyMode As GCLatencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLatencyMode LatencyMode { System::Runtime::GCLatencyMode get(); void set(System::Runtime::GCLatencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.LatencyMode : System.Runtime.GCLatencyMode with get, set" Usage="System.Runtime.GCSettings.LatencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLatencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current latency mode for garbage collection.</summary>
        <value>L'une des valeurs d'énumération qui spécifie le mode de latence.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez réduire le niveau d’intrusion du garbage collection dans votre application en définissant le <xref:System.Runtime.GCLatencyMode> à <xref:System.Runtime.GCLatencyMode.LowLatency> pendant les opérations critiques. Une fois ces opérations terminées, revenir à un mode de latence plus élevé afin que plusieurs objets peuvent être récupérées pour augmenter la mémoire.  
  
 En règle générale, vous définissez la valeur de la <xref:System.Runtime.GCSettings.LatencyMode%2A> propriété pour définir le mode de latence du garbage collector. Toutefois, vous ne peut pas définir le mode sans région GC latence en assignant le <xref:System.Runtime.GCLatencyMode.NoGCRegion?displayProperty=nameWithType> valeur d’énumération pour la <xref:System.Runtime.GCSettings.LatencyMode%2A> propriété. Au lieu de cela, vous appelez le <xref:System.GC.TryStartNoGCRegion%2A?displayProperty=nameWithType> appel d’une méthode pour lancer le mode sans région GC latence et que vous la <xref:System.GC.EndNoGCRegion%2A?displayProperty=nameWithType> terminer.  
  
 Consultez [Modes de latence](~/docs/standard/garbage-collection/latency.md) pour une présentation de la façon dont les paramètres de configuration d’exécution pour le garbage collection affectent la valeur par défaut de la <xref:System.Runtime.GCLatencyMode> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property is being set to an invalid value.  -or-  The <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property cannot be set to <see cref="F:System.Runtime.GCLatencyMode.NoGCRegion" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
  </Members>
</Type>