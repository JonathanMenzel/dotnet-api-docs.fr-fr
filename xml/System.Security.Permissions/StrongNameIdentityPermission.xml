<Type Name="StrongNameIdentityPermission" FullName="System.Security.Permissions.StrongNameIdentityPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee4f344e4ca4ab61ae8542b36961c7d51ae5ea42" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36623880" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StrongNameIdentityPermission : System.Security.CodeAccessPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StrongNameIdentityPermission extends System.Security.CodeAccessPermission" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.StrongNameIdentityPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StrongNameIdentityPermission&#xA;Inherits CodeAccessPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class StrongNameIdentityPermission sealed : System::Security::CodeAccessPermission" />
  <TypeSignature Language="F#" Value="type StrongNameIdentityPermission = class&#xA;    inherit CodeAccessPermission" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Defines the identity permission for strong names. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], les autorisations d’identité ne sont pas utilisées.  
>   
>  Dans les versions 1.0 et 1.1 du .NET Framework, les autorisations d’identité ne peut pas avoir un <xref:System.Security.Permissions.PermissionState.Unrestricted> valeur d’état d’autorisation. Dans le .NET Framework version 2.0 et ultérieure, les autorisations d’identité peuvent avoir n’importe quel valeur état d’autorisation.  Cela signifie que dans la version 2.0 et versions ultérieures, les autorisations d’identité ont le même comportement que les autorisations qui implémentent le <xref:System.Security.Permissions.IUnrestrictedPermission> interface. Autrement dit, une demande pour une identité toujours réussit, quelle que soit l’identité de l’assembly, si l’assembly a été accordé à une confiance totale.  
  
 Utilisez <xref:System.Security.Permissions.StrongNameIdentityPermission> pour confirmer que le code appelant est dans un assembly de code à nom fort particulier. Demandes complètes de <xref:System.Security.Permissions.StrongNameIdentityPermission> n’aboutit que si tous les assemblys de la pile disposent des preuves correctes pour satisfaire la demande. Demandes de liaison qui utilisent la <xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute> attribut n’aboutit que si l’appelant immédiat possède la preuve correcte.  
  
 Une identité de nom fort est basée sur une clé de chiffrement publique appelée un objet binaire volumineux (BLOB), éventuellement combinée avec le nom et la version d’un assembly spécifique. La clé définit un espace de noms unique et assure une vérification rigoureuse que le nom est authentique, car la définition du nom doit être dans un assembly est signé par la clé privée correspondante.  
  
 Notez que la validité de la clé de nom fort n’est pas dépendante sur une relation d’approbation ou sur n’importe quel certificat émis obligatoirement pour la clé.  
  
 Dans les versions 1.0 et 1.1 du .NET Framework, les demandes sur les autorisations d’identité sont efficaces même lorsque l’assembly appelant est entièrement fiable. Autrement dit, même si l’assembly appelant bénéficie d’une confiance totale, une demande pour une autorisation d’identité échoue si l’assembly ne répond pas aux critères demandés. Dans le .NET Framework version 2.0 et ultérieures, les demandes d’autorisations d’identité sont inefficaces si l’assembly appelant bénéficie d’une confiance totale. Cela garantit la cohérence pour toutes les autorisations et évite le traitement des autorisations d’identité comme un cas particulier.  
  
 Pour obtenir une description complète des noms forts, consultez le <xref:System.Security.Policy.StrongName> page de référence. Pour plus d’informations sur les assemblys avec nom fort, consultez [assemblys avec nom fort](~/docs/framework/app-domains/strong-named-assemblies.md).  
  
 La <xref:System.Security.Permissions.StrongNameIdentityPermission> classe est utilisée pour définir des spécifications de nom fort pour l’accès aux membres publics d’un type. Le <xref:System.Security.Permissions.StrongNameIdentityPermissionAttribute> attribut peut être utilisé pour définir des exigences de nom fort au niveau de l’assembly. Dans le .NET Framework version 2.0 et versions ultérieure, vous pouvez également utiliser le <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribut pour spécifier que tous les types non publics dans cet assembly sont visibles à un autre assembly. Pour plus d’informations, consultez [Assemblys friend](http://msdn.microsoft.com/library/df0c70ea-2c2a-4bdc-9526-df951ad2d055).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.Permissions.StrongNameIdentityPermission" />
    <altmember cref="T:System.Security.Permissions.StrongNamePublicKeyBlob" />
    <altmember cref="T:System.Security.Policy.StrongName" />
    <altmember cref="T:System.Security.Policy.StrongNameMembershipCondition" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StrongNameIdentityPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StrongNameIdentityPermission(System::Security::Permissions::PermissionState state);" />
      <MemberSignature Language="F#" Value="new System.Security.Permissions.StrongNameIdentityPermission : System.Security.Permissions.PermissionState -&gt; System.Security.Permissions.StrongNameIdentityPermission" Usage="new System.Security.Permissions.StrongNameIdentityPermission state" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> class with the specified <see cref="T:System.Security.Permissions.PermissionState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un entièrement restreint (`None`) ou `Unrestricted` autorisation.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, les autorisations d’identité ne peut pas avoir un <xref:System.Security.Permissions.PermissionState.Unrestricted> valeur d’état d’autorisation. Dans le .NET Framework version 2.0 et ultérieure, les autorisations d’identité peuvent avoir n’importe quel valeur état d’autorisation.  Cela signifie que dans la version 2.0 et versions ultérieures, les autorisations d’identité ont le même comportement que les autorisations qui implémentent le <xref:System.Security.Permissions.IUnrestrictedPermission> interface. Autrement dit, une demande pour une identité toujours réussit, quelle que soit l’identité de l’assembly, si l’assembly a été accordé à une confiance totale.  
  
 Dans les versions 1.0 et 1.1 du .NET Framework, les demandes sur les autorisations d’identité sont efficaces, même lorsque l’assembly appelant est entièrement fiable. Autrement dit, bien que l’assembly appelant bénéficie d’une confiance totale, une demande pour une autorisation d’identité échoue si l’assembly ne répond pas aux critères demandés. Dans le .NET Framework version 2.0 et ultérieures, les demandes d’autorisations d’identité sont inefficaces si l’assembly appelant bénéficie d’une confiance totale. Cela garantit la cohérence entre toutes les autorisations, en éliminant le traitement des autorisations d’identité comme un cas particulier.  
  
 Utilisez ce constructeur avec une valeur d’état d’autorisation <xref:System.Security.Permissions.PermissionState.None> pour créer une autorisation d’identité qui correspond à aucun nom fort. Si vous définissez ultérieurement le <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> et <xref:System.Security.Permissions.StrongNameIdentityPermission.Version%2A> propriétés, une identité de nom fort spécifique peuvent être représentées par l’autorisation.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.Permissions.StrongNameIdentityPermission.%23ctor%2A> constructeur.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#7)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#7)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="state" /> parameter is not a valid value of <see cref="T:System.Security.Permissions.PermissionState" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StrongNameIdentityPermission (System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.#ctor(System.Security.Permissions.StrongNamePublicKeyBlob,System.String,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StrongNameIdentityPermission(System::Security::Permissions::StrongNamePublicKeyBlob ^ blob, System::String ^ name, Version ^ version);" />
      <MemberSignature Language="F#" Value="new System.Security.Permissions.StrongNameIdentityPermission : System.Security.Permissions.StrongNamePublicKeyBlob * string * Version -&gt; System.Security.Permissions.StrongNameIdentityPermission" Usage="new System.Security.Permissions.StrongNameIdentityPermission (blob, name, version)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="blob" Type="System.Security.Permissions.StrongNamePublicKeyBlob" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="blob">The public key defining the strong name identity namespace.</param>
        <param name="name">The simple name part of the strong name identity. This corresponds to the name of the assembly.</param>
        <param name="version">The version number of the identity.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" /> class for the specified strong name identity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `name` et `version` les paramètres peuvent être `null` uniquement lorsque la clé publique est utilisée pour identifier l’assembly. Une chaîne vide (« ») ne doit pas être utilisé à la place de `null`. Si `name` est une chaîne vide, un <xref:System.ArgumentException> est levée.  
  
 Pour plus d’informations sur les noms et numéros de version des assemblys, consultez [assemblys avec nom fort](~/docs/framework/app-domains/strong-named-assemblies.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Security.Permissions.StrongNameIdentityPermission.%23ctor%2A> constructeur.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#8)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#8)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="blob" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="name" /> parameter is an empty string ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="override this.Copy : unit -&gt; System.Security.IPermission" Usage="strongNameIdentityPermission.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates and returns an identical copy of the current permission.</summary>
        <returns>A copy of the current permission.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie d’une autorisation représente le même accès aux ressources que l’autorisation d’origine.  
  
   
  
## Examples  
 L’exemple de code suivant montre le comportement de la <xref:System.Security.Permissions.StrongNameIdentityPermission.Copy%2A> (méthode). Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.Permissions.StrongNameIdentityPermission> classe. Le meilleur parti de cet exemple consiste à générer et exécuter l’exemple entier et afficher sa sortie.  
  
> [!NOTE]
>  L’exemple de code vise à montrer le comportement de la méthode, ne pas à son utilisation. En règle générale, les méthodes des classes d’autorisation sont utilisées par l’infrastructure de sécurité ; ils ne sont généralement pas utilisées dans les applications.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#5)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#5)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXml (e As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ e);" />
      <MemberSignature Language="F#" Value="override this.FromXml : System.Security.SecurityElement -&gt; unit" Usage="strongNameIdentityPermission.FromXml e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="e">The XML encoding to use to reconstruct the permission.</param>
        <summary>Reconstructs a permission with a specified state from an XML encoding.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas utilisée par le code d’application.  
  
   
  
## Examples  
 L’exemple de code suivant montre le comportement de la <xref:System.Security.Permissions.StrongNameIdentityPermission.FromXml%2A> (méthode). Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.Permissions.StrongNameIdentityPermission> classe. Le meilleur parti de cet exemple consiste à générer et exécuter l’exemple entier et afficher sa sortie.  
  
> [!NOTE]
>  L’exemple de code vise à montrer le comportement de la méthode, ne pas à son utilisation. En règle générale, les méthodes des classes d’autorisation sont utilisées par l’infrastructure de sécurité ; ils ne sont généralement pas utilisées dans les applications.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#6)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#6)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="e" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="e" /> parameter is not a valid permission element.  -or-  The <paramref name="e" /> parameter's version number is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="strongNameIdentityPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">A permission to intersect with the current permission. It must be of the same type as the current permission.</param>
        <summary>Creates and returns a permission that is the intersection of the current permission and the specified permission.</summary>
        <returns>A new permission that represents the intersection of the current permission and the specified permission, or <see langword="null" /> if the intersection is empty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’intersection de deux autorisations est une autorisation qui décrit l’ensemble des opérations qu’elles décrivent en commun. Seule une demande qui passe les deux autorisations d’origine passera l’intersection.  
  
 L’intersection de deux autorisations d’identité de nom fort identiques est la même autorisation. L’intersection de deux (non génériques) des expressions est une autorisation vide. L’intersection d’une expression générique et un nom fort correspondant est le nom fort. L’intersection de deux expressions génériques qui correspondent aux est la plus longue, plus spécifique des deux expressions.  
  
   
  
## Examples  
 L’exemple de code suivant montre les résultats de l’utilisation de la <xref:System.Security.Permissions.StrongNameIdentityPermission.Intersect%2A> (méthode), pas l’utilisation de la méthode. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.Permissions.StrongNameIdentityPermission> classe. Le meilleur parti de cet exemple consiste à générer et exécuter l’exemple entier et afficher sa sortie.  
  
> [!NOTE]
>  L’exemple de code vise à montrer le comportement de la méthode, ne pas à son utilisation. En règle générale, les méthodes des classes d’autorisation sont utilisées par l’infrastructure de sécurité ; ils ne sont généralement pas utilisées dans les applications.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#4)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#4)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="strongNameIdentityPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission.</param>
        <summary>Determines whether the current permission is a subset of the specified permission.</summary>
        <returns>
          <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée si l’autorisation actuelle spécifie un ensemble d’opérations qui est entièrement contenu par l’autorisation spécifiée. Par exemple, les autres propriétés étant égales, une identité avec le <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> propriété contenant l’expression générique MaSociété.MonService est identifiée comme un sous-ensemble d’une identité avec le <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> propriété est MaSociété.MonService.MonFichier .  
  
   
  
## Examples  
 L’exemple de code suivant montre les résultats de l’utilisation de la <xref:System.Security.Permissions.StrongNameIdentityPermission.IsSubsetOf%2A> (méthode), pas l’utilisation de la méthode. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.Permissions.StrongNameIdentityPermission> classe. Le meilleur parti de cet exemple consiste à générer et exécuter l’exemple entier et afficher sa sortie.  
  
> [!NOTE]
>  L’exemple de code vise à montrer le comportement de la méthode, ne pas à son utilisation. En règle générale, les méthodes des classes d’autorisation sont utilisées par l’infrastructure de sécurité ; ils ne sont généralement pas utilisées dans les applications.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#2)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#2)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.StrongNameIdentityPermission.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Security.Permissions.StrongNameIdentityPermission.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the simple name portion of the strong name identity.</summary>
        <value>Nom simple de l’identité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> propriété peut être un nom exact, ou peut être modifiée par un caractère générique à la dernière position ; par exemple, MaSociété.MonService.MonFichier et MaSociété.MonService sont des noms valides. Si vous essayez de définir la <xref:System.Security.Permissions.StrongNameIdentityPermission.Name%2A> propriété à une chaîne vide (« »), un <xref:System.ArgumentException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is an empty string ("").</exception>
        <exception cref="T:System.NotSupportedException">The property value cannot be retrieved because it contains an ambiguous identity.</exception>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public System.Security.Permissions.StrongNamePublicKeyBlob PublicKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Permissions.StrongNamePublicKeyBlob PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.StrongNameIdentityPermission.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PublicKey As StrongNamePublicKeyBlob" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Permissions::StrongNamePublicKeyBlob ^ PublicKey { System::Security::Permissions::StrongNamePublicKeyBlob ^ get(); void set(System::Security::Permissions::StrongNamePublicKeyBlob ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Permissions.StrongNamePublicKeyBlob with get, set" Usage="System.Security.Permissions.StrongNameIdentityPermission.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Permissions.StrongNamePublicKeyBlob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the public key blob that defines the strong name identity namespace.</summary>
        <value>A <see cref="T:System.Security.Permissions.StrongNamePublicKeyBlob" /> qui contient la clé publique de l’identité, ou <see langword="null" /> s’il n’existe aucune clé.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The property value is set to <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The property value cannot be retrieved because it contains an ambiguous identity.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="strongNameIdentityPermission.ToXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an XML encoding of the permission and its current state.</summary>
        <returns>An XML encoding of the permission, including any state information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, cette méthode n’est pas utilisée par code d’application.  
  
   
  
## Examples  
 L’exemple de code suivant montre le comportement de la <xref:System.Security.Permissions.StrongNameIdentityPermission.ToXml%2A> (méthode).  
  
> [!NOTE]
>  L’exemple de code vise à montrer le comportement de la méthode, ne pas à son utilisation. En règle générale, les méthodes des classes d’autorisation sont utilisées par l’infrastructure de sécurité ; ils ne sont généralement pas utilisées dans les applications.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#6)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#6)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.StrongNameIdentityPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="strongNameIdentityPermission.Union target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">A permission to combine with the current permission. It must be of the same type as the current permission.</param>
        <summary>Creates a permission that is the union of the current permission and the specified permission.</summary>
        <returns>A new permission that represents the union of the current permission and the specified permission.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat d’un appel à <xref:System.Security.Permissions.StrongNameIdentityPermission.Union%2A> est une autorisation qui représente toutes les opérations représentées par l’autorisation actuelle et l’autorisation spécifiée. Toute demande qui transmet une autorisation passe leur union.  
  
 L’union d’une autorisation et `null` est l’autorisation qui n’est pas `null`. L’union d’une autorisation et un sous-ensemble de cette autorisation sont l’autorisation qui contient l’autre. Toute autre combinaison entraîne une <xref:System.ArgumentException> levée d’exception.  
  
   
  
## Examples  
 L’exemple de code suivant montre les résultats de l’utilisation de la <xref:System.Security.Permissions.StrongNameIdentityPermission.Union%2A> (méthode), pas l’utilisation de la méthode. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Security.Permissions.StrongNameIdentityPermission> classe. Le meilleur parti de cet exemple consiste à générer et exécuter l’exemple entier et afficher sa sortie.  
  
> [!NOTE]
>  L’exemple de code vise à montrer le comportement de la méthode, ne pas à son utilisation. En règle générale, les méthodes des classes d’autorisation sont utilisées par l’infrastructure de sécurité ; ils ne sont généralement pas utilisées dans les applications.  
  
 [!code-cpp[System.Security.Permissions.StrongNameIdentityPermission#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CPP/strongnameidentity.cpp#3)]
 [!code-csharp[System.Security.Permissions.StrongNameIdentityPermission#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/CS/strongnameidentity.cs#3)]
 [!code-vb[System.Security.Permissions.StrongNameIdentityPermission#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.StrongNameIdentityPermission/VB/strongnameidentity.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.  -or-  The two permissions are not equal and one is a subset of the other.</exception>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.StrongNameIdentityPermission.Version" />
      <MemberSignature Language="VB.NET" Value="Public Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ Version { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version with get, set" Usage="System.Security.Permissions.StrongNameIdentityPermission.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version number of the identity.</summary>
        <value>Version de l’identité.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">The property value cannot be retrieved because it contains an ambiguous identity.</exception>
      </Docs>
    </Member>
  </Members>
</Type>