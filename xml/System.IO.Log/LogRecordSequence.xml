<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7156e4e610a9d14909a701b75c25fcdefeaf4c8c" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37655522" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="c40c3-101">Représente une séquence d'enregistrement stockée dans un <see cref="T:System.IO.Log.LogStore" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-101">Represents a record sequence stored in a <see cref="T:System.IO.Log.LogStore" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-102">La classe <xref:System.IO.Log.LogRecordSequence> fournit une implémentation de l'interface de séquence d'enregistrement sur un journal CLFS (Common Log File System).</span><span class="sxs-lookup"><span data-stu-id="c40c3-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="c40c3-103">Outre les fonctionnalités orientées par enregistrement standard, elle fournit un modèle de stratégie pour éviter des conditions de journal saturé et pour multiplexer des clients sur le même fichier physique.</span><span class="sxs-lookup"><span data-stu-id="c40c3-103">In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</span></span> <span data-ttu-id="c40c3-104">Cela fonctionne avec la classe <xref:System.IO.Log.LogStore> qui fournit une interface pour manipuler et gérer directement un fichier journal CLFS.</span><span class="sxs-lookup"><span data-stu-id="c40c3-104">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="c40c3-105">La relation entre la classe <xref:System.IO.Log.LogStore> et la classe <xref:System.IO.Log.LogRecordSequence> est similaire à la relation entre un fichier sur un disque et un objet <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-105">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="c40c3-106">Le fichier sur disque fournit la mémoire physique et a des attributs tels que la longueur et le dernier temps d'accès, alors que l'objet <xref:System.IO.FileStream> fournit une vue sur le fichier qui peut être utilisée pour la lecture et l'écriture.</span><span class="sxs-lookup"><span data-stu-id="c40c3-106">The disk file provides the concrete storage, and has attributes such as length and last access time; while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="c40c3-107">De la même façon, la classe <xref:System.IO.Log.LogStore> a des attributs tels qu'une stratégie et une collection d'étendues de disque, et la classe <xref:System.IO.Log.LogRecordSequence> fournit un mécanisme orienté enregistrement pour lire et écrire des données.</span><span class="sxs-lookup"><span data-stu-id="c40c3-107">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents; and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-108">Cet exemple indique comme utiliser la classe <xref:System.IO.Log.LogRecordSequence> :</span><span class="sxs-lookup"><span data-stu-id="c40c3-108">This example shows how to use the <xref:System.IO.Log.LogRecordSequence> class:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-109">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-109">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore"><span data-ttu-id="c40c3-110"><see cref="T:System.IO.Log.LogStore" /> que cette séquence d'enregistrement doit utiliser.</span><span class="sxs-lookup"><span data-stu-id="c40c3-110">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span></span></param>
        <summary><span data-ttu-id="c40c3-111">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec le magasin de journaux spécifié.</span><span class="sxs-lookup"><span data-stu-id="c40c3-111">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-112">La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</span><span class="sxs-lookup"><span data-stu-id="c40c3-112">The buffer size determines the maximum size of the record that can be appended or read.</span></span> <span data-ttu-id="c40c3-113">Dans ce constructeur, une valeur par défaut de 64 est définie.</span><span class="sxs-lookup"><span data-stu-id="c40c3-113">In this constructor, a default value of 64 is set.</span></span> <span data-ttu-id="c40c3-114">Le nombre désiré de mémoires tampons est définie à 10.</span><span class="sxs-lookup"><span data-stu-id="c40c3-114">The desired number of buffers is set to 10.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-115"><paramref name="logStore" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-115"><paramref name="logStore" /> is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c40c3-116">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c40c3-116">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="c40c3-117">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</span><span class="sxs-lookup"><span data-stu-id="c40c3-117">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <summary><span data-ttu-id="c40c3-118">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès au magasin de journaux et un mode d'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-118">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-119">Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès et le mode spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-119">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path and mode.</span></span> <span data-ttu-id="c40c3-120">Elle reçoit un accès en lecture/écriture au magasin, et le magasin est ouvert en partageant l'accès en lecture.</span><span class="sxs-lookup"><span data-stu-id="c40c3-120">It is given read/write access to the store, and the store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-121"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-121"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-122">Le <paramref name="path" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="c40c3-122"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="c40c3-123">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-123">-or-</span></span> 
 <span data-ttu-id="c40c3-124"><paramref name="path" /> contient l'espace blanc uniquement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-124"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="c40c3-125">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-125">-or-</span></span> 
 <span data-ttu-id="c40c3-126">Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-126"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-127"><paramref name="mode" /> contient une valeur non valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-127"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c40c3-128">Impossible de trouver le fichier.</span><span class="sxs-lookup"><span data-stu-id="c40c3-128">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-129">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</span><span class="sxs-lookup"><span data-stu-id="c40c3-129">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-130">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-130">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-131">Cette opération n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="c40c3-131">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-132">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-132">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c40c3-133"><see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-133"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="c40c3-134">Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-134">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore"><span data-ttu-id="c40c3-135"><see cref="T:System.IO.Log.LogStore" /> que cette séquence d'enregistrement doit utiliser.</span><span class="sxs-lookup"><span data-stu-id="c40c3-135">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="c40c3-136">Taille de la mémoire tampon voulue en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-136">The desired buffer size in bytes.</span></span> <span data-ttu-id="c40c3-137">La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</span><span class="sxs-lookup"><span data-stu-id="c40c3-137">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="c40c3-138">Nombre voulu de mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="c40c3-138">The desired number of buffers.</span></span></param>
        <summary><span data-ttu-id="c40c3-139">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec le magasin de journaux, la taille de mémoire tampon pour chaque enregistrement et le nombre de mémoires tampons spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-139">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store, buffer size for each record, and buffer number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-140">Utilisez ce constructeur si vous souhaitez spécifier des valeurs pour `bufferSize` et `bufferCount` et ne souhaitez pas utiliser la valeur par défaut de 64 pour `bufferSize` ou 10 pour `bufferCount`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-140">Use this constructor if you want to specify values for `bufferSize` and `bufferCount` and do not want to use the default value of 64 for `bufferSize` and 10 for `bufferCount`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-141"><paramref name="logStore" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-141"><paramref name="logStore" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-142"><paramref name="bufferSize" /> est négatif ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="c40c3-142"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="c40c3-143">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-143">-or-</span></span> 
 <span data-ttu-id="c40c3-144"><paramref name="bufferCount" /> est négatif ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="c40c3-144"><paramref name="bufferCount" /> is negative or zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c40c3-145">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c40c3-145">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="c40c3-146">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</span><span class="sxs-lookup"><span data-stu-id="c40c3-146">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="c40c3-147">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-147">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <summary><span data-ttu-id="c40c3-148">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès spécifié au magasin de journaux et les modes d'accès et de partage.</span><span class="sxs-lookup"><span data-stu-id="c40c3-148">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access and share modes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-149">Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-149">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="c40c3-150">Le magasin est ouvert en partageant l'accès en lecture.</span><span class="sxs-lookup"><span data-stu-id="c40c3-150">The store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-151"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-151"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-152">Le <paramref name="path" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="c40c3-152"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="c40c3-153">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-153">-or-</span></span> 
 <span data-ttu-id="c40c3-154"><paramref name="path" /> contient l'espace blanc uniquement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-154"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="c40c3-155">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-155">-or-</span></span> 
 <span data-ttu-id="c40c3-156">Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-156"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-157"><paramref name="mode" /> contient une valeur non valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-157"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c40c3-158">Impossible de trouver le fichier.</span><span class="sxs-lookup"><span data-stu-id="c40c3-158">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-159">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</span><span class="sxs-lookup"><span data-stu-id="c40c3-159">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-160">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-160">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-161">Cette opération n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="c40c3-161">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-162">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-162">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c40c3-163"><see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-163"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="c40c3-164">Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-164">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c40c3-165">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c40c3-165">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="c40c3-166">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</span><span class="sxs-lookup"><span data-stu-id="c40c3-166">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="c40c3-167">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-167">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="c40c3-168">L'une des valeurs <see cref="T:System.IO.FileShare" /> qui détermine comment le magasin de journaux sera partagé parmi les processus.</span><span class="sxs-lookup"><span data-stu-id="c40c3-168">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <summary><span data-ttu-id="c40c3-169">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès au magasin de journaux et un mode d'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-169">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-170">Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-170">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="c40c3-171">Le magasin est ouvert avec le partage d'accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="c40c3-171">The store is opened sharing the specified access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-172">L'exemple suivant montre comment utiliser le constructeur de <xref:System.IO.Log.LogRecordSequence> :</span><span class="sxs-lookup"><span data-stu-id="c40c3-172">This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-173"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-173"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-174">Le <paramref name="path" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="c40c3-174"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="c40c3-175">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-175">-or-</span></span> 
 <span data-ttu-id="c40c3-176"><paramref name="path" /> contient l'espace blanc uniquement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-176"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="c40c3-177">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-177">-or-</span></span> 
 <span data-ttu-id="c40c3-178">Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-178"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-179"><paramref name="mode" /> contient une valeur non valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-179"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c40c3-180">Impossible de trouver le fichier.</span><span class="sxs-lookup"><span data-stu-id="c40c3-180">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-181">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</span><span class="sxs-lookup"><span data-stu-id="c40c3-181">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-182">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-182">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-183">Cette opération n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="c40c3-183">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-184">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-184">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c40c3-185"><see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-185"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="c40c3-186">Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-186">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c40c3-187">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c40c3-187">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="c40c3-188">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</span><span class="sxs-lookup"><span data-stu-id="c40c3-188">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="c40c3-189">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-189">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="c40c3-190">L'une des valeurs <see cref="T:System.IO.FileShare" /> qui détermine comment le magasin de journaux sera partagé parmi les processus.</span><span class="sxs-lookup"><span data-stu-id="c40c3-190">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="c40c3-191">Taille de la mémoire tampon voulue en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-191">The desired buffer size in bytes.</span></span> <span data-ttu-id="c40c3-192">La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</span><span class="sxs-lookup"><span data-stu-id="c40c3-192">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="c40c3-193">Nombre voulu de mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="c40c3-193">The desired number of buffers.</span></span></param>
        <summary><span data-ttu-id="c40c3-194">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès spécifié au magasin de journaux, une autorisation d'accès aux fichiers, des modes d'accès et de partage, ainsi que la taille de la mémoire tampon et le compte des enregistrements.</span><span class="sxs-lookup"><span data-stu-id="c40c3-194">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-195">Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-195">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="c40c3-196">Le magasin est ouvert avec le partage d'accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="c40c3-196">The store is opened sharing the specified access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-197"><paramref name="path" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-197"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-198">Le <paramref name="path" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="c40c3-198"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="c40c3-199">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-199">-or-</span></span> 
 <span data-ttu-id="c40c3-200"><paramref name="path" /> contient l'espace blanc uniquement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-200"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="c40c3-201">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-201">-or-</span></span> 
 <span data-ttu-id="c40c3-202">Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-202"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-203"><paramref name="mode" /> contient une valeur non valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-203"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c40c3-204">Impossible de trouver le fichier.</span><span class="sxs-lookup"><span data-stu-id="c40c3-204">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-205">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</span><span class="sxs-lookup"><span data-stu-id="c40c3-205">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-206">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-206">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-207">Cette opération n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="c40c3-207">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-208">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-208">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c40c3-209"><see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-209"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="c40c3-210">Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-210">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c40c3-211">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c40c3-211">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="c40c3-212">Valeur <see cref="T:System.IO.FileMode" /> valide qui détermine le mode d'ouverture ou de création du magasin.</span><span class="sxs-lookup"><span data-stu-id="c40c3-212">A valid <see cref="T:System.IO.FileMode" /> value that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="c40c3-213">Valeur <see cref="T:System.IO.FileAccess" /> valide qui détermine comment accéder au magasin de journaux.</span><span class="sxs-lookup"><span data-stu-id="c40c3-213">A valid <see cref="T:System.IO.FileAccess" /> value that determines how the log store can be accessed.</span></span></param>
        <param name="share"><span data-ttu-id="c40c3-214">Valeur <see cref="T:System.IO.FileShare" /> valide qui détermine comment le magasin de journaux sera partagé parmi les processus.</span><span class="sxs-lookup"><span data-stu-id="c40c3-214">A valid <see cref="T:System.IO.FileShare" /> value that determines how the log store will be shared among processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="c40c3-215">Taille de la mémoire tampon voulue en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-215">The desired buffer size in bytes.</span></span> <span data-ttu-id="c40c3-216">La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</span><span class="sxs-lookup"><span data-stu-id="c40c3-216">The buffer size determines the maximum size of the record that can be appended or read.</span></span></param>
        <param name="bufferCount"><span data-ttu-id="c40c3-217">Nombre voulu de mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="c40c3-217">The desired number of buffers.</span></span></param>
        <param name="fileSecurity"><span data-ttu-id="c40c3-218">Valeur <see cref="T:System.Security.AccessControl.FileSecurity" /> valide qui spécifie la sécurité à définir sur le magasin créé récemment si le magasin doit être créé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-218">A valid <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span></span></param>
        <summary><span data-ttu-id="c40c3-219">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-219">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-220">Le fichier spécifié par <paramref name="path" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-220">The file specified by <paramref name="path" /> is not valid.</span></span>  
  
<span data-ttu-id="c40c3-221">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-221">-or-</span></span> 
<span data-ttu-id="c40c3-222">Le nom de fichier du magasin de journaux spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-222">The specified log store file name is not valid.</span></span>  
  
<span data-ttu-id="c40c3-223">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-223">-or-</span></span> 
 <span data-ttu-id="c40c3-224"><paramref name="mode" /> a une valeur de <see cref="F:System.IO.FileMode.CreateNew" />et ne peut pas être utilisé sans accès en écriture.</span><span class="sxs-lookup"><span data-stu-id="c40c3-224"><paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.CreateNew" />, and cannot be used without write access.</span></span>  
  
<span data-ttu-id="c40c3-225">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-225">-or-</span></span> 
 <span data-ttu-id="c40c3-226"><paramref name="mode" /> a une valeur de <see cref="F:System.IO.FileMode.OpenOrCreate" />et ne peut pas être utilisé sans accès en écriture.</span><span class="sxs-lookup"><span data-stu-id="c40c3-226"><paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.OpenOrCreate" />, and cannot be used without write access.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-227">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-227">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-228">Un ou plusieurs des arguments sont hors limite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-228">One or more of the arguments are out of range.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c40c3-229">Le fichier spécifié par <paramref name="path" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="c40c3-229">The file specified by <paramref name="path" /> cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-230">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-230">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-231">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-231">-or-</span></span> 
<span data-ttu-id="c40c3-232">Impossible d'accéder au fichier spécifié par le <paramref name="path" /> parce qu'il est utilisé par un autre processus.</span><span class="sxs-lookup"><span data-stu-id="c40c3-232">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span></span>  
  
<span data-ttu-id="c40c3-233">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-233">-or-</span></span> 
<span data-ttu-id="c40c3-234">Le fichier spécifié par le <paramref name="path" /> ne peut pas être créé parce que le fichier ou le répertoire existe déjà.</span><span class="sxs-lookup"><span data-stu-id="c40c3-234">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span></span>  
  
<span data-ttu-id="c40c3-235">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-235">-or-</span></span> 
<span data-ttu-id="c40c3-236">Le handle de journal n'a pas pu être lié au pool de threads.</span><span class="sxs-lookup"><span data-stu-id="c40c3-236">The log handle could not be bound to the thread pool.</span></span>  
  
<span data-ttu-id="c40c3-237">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-237">-or-</span></span> 
<span data-ttu-id="c40c3-238">Le format ou la version de fichier journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-238">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-239">Cette opération n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="c40c3-239">This operation is not supported.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-240">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-240">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-241">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-241">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="c40c3-242"><see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-242"><see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="c40c3-243">Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-243">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-244">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-244">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-245">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-245">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber"><span data-ttu-id="c40c3-246">Spécifie le nouveau <see cref="T:System.IO.Log.SequenceNumber" /> de base pour le journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-246">Specifies the new base <see cref="T:System.IO.Log.SequenceNumber" /> for the log.</span></span> <span data-ttu-id="c40c3-247">Il doit être compris entre le numéro de séquence de base actuel et le dernier numéro de séquence du journal, inclus.</span><span class="sxs-lookup"><span data-stu-id="c40c3-247">This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</span></span></param>
        <summary><span data-ttu-id="c40c3-248">Avance le numéro de séquence de base du journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-248">Moves the base sequence number of the log forward.</span></span> <span data-ttu-id="c40c3-249">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-249">This method cannot be inherited.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-250">Cette méthode est souvent utilisée avec l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> pour libérer de l'espace dans un enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-250">This method is often used with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a record.</span></span> <span data-ttu-id="c40c3-251">L'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> indique que la fin de la séquence (c'est-à-dire, le numéro de séquence de base) doit être avancée pour libérer de l'espace.</span><span class="sxs-lookup"><span data-stu-id="c40c3-251">The <xref:System.IO.Log.LogRecordSequence.TailPinned> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</span></span> <span data-ttu-id="c40c3-252">Libérer de l'espace peut se faire soit en écrivant des zones de reprise à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, soit en tronquant le journal et en utilisant la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> pour avancer le numéro de séquence de base d'un journal à celui spécifié par le paramètre `newBaseSequenceNumber`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-252">Freeing space can be done by either writing restart areas using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to advance the base sequence number of a log to the one specified by the `newBaseSequenceNumber` parameter.</span></span> <span data-ttu-id="c40c3-253">L'exemple de code de la section Exemple illustre la deuxième approche.</span><span class="sxs-lookup"><span data-stu-id="c40c3-253">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="c40c3-254">Notez qu'appeler cette méthode revient à définir un nouveau numéro de séquence de base à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, à ceci près qu'aucun enregistrement de reprise n'est écrit dans le journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-254">Note that calling this method is the same as setting a new base sequence number using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, except that no restart record is written to the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-255">Cet exemple montre comment utiliser la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> avec l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> pour libérer de l'espace dans une séquence de journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-255">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-256"><paramref name="newBaseSequenceNumber" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-256"><paramref name="newBaseSequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-257">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-257">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="c40c3-258">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-258">-or-</span></span> 
 <span data-ttu-id="c40c3-259"><paramref name="newBaseSequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-259"><paramref name="newBaseSequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-260">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-260">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-261">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-261">-or-</span></span> 
<span data-ttu-id="c40c3-262">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-262">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-263">Le journal spécifié n'a pas d'étendues.</span><span class="sxs-lookup"><span data-stu-id="c40c3-263">The specified log does not have any extents.</span></span> <span data-ttu-id="c40c3-264">Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-264">One or more extents must be created before a record sequence may be used.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-265">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-265">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-266">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-266">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-267">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-267">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-268">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-268">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-269">Écrit un enregistrement de journal dans l'interface <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-269">Writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c40c3-270">Cet exemple montre comment utiliser le membre <xref:System.IO.Log.LogRecordSequence.Append%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-270">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.Append%2A> member</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-271">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-271">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="c40c3-272">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-272">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-273">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-273">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-274">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-274">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="c40c3-275">Écrit un enregistrement de journal dans l'interface <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-275">Writes a log record to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="c40c3-276">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-276">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-277">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-277">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-278">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-278">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-279">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-279">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-280">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-280">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-281">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-281">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-282">L'exemple suivant montre comment utiliser cette méthode pour ajouter un enregistrement à une séquence dans le journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-282">The following example demonstrates how to use this method to append a log record to the sequence.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-283"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-283"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-284">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-284">-or-</span></span> 
 <span data-ttu-id="c40c3-285"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-285"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-286">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-286">-or-</span></span> 
 <span data-ttu-id="c40c3-287"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-287"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-288">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-288">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-289"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-289"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-290">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-290">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-291">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-291">-or-</span></span> 
<span data-ttu-id="c40c3-292">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-292">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-293">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-293">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-294">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-294">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-295">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-295">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-296">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-296">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-297">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-297">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-298">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-298">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="c40c3-299">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-299">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-300">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-300">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-301">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-301">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <summary><span data-ttu-id="c40c3-302">Ajoute un enregistrement de journal à l'interface <see cref="T:System.IO.Log.IRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-302">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span></span> <span data-ttu-id="c40c3-303">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-303">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-304">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-304">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-305">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-305">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-306">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-306">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-307">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-307">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-308">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-308">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-309"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-309"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-310">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-310">-or-</span></span> 
 <span data-ttu-id="c40c3-311"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-311"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-312">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-312">-or-</span></span> 
 <span data-ttu-id="c40c3-313"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-313"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-314">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-314">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-315"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-315"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-316">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-316">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-317">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-317">-or-</span></span> 
<span data-ttu-id="c40c3-318">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-318">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-319">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-319">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-320">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-320">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-321">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-321">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-322">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-322">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-323">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-323">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-324">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-324">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="c40c3-325">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-325">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-326">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-326">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-327">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-327">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-328"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-328">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="c40c3-329">Ajoute un enregistrement de journal à l'interface <see cref="T:System.IO.Log.IRecordSequence" />, en utilisant l'espace précédemment réservé dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-329">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span> <span data-ttu-id="c40c3-330">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-330">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-331">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-331">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-332">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-332">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-333">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-333">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-334">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-334">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="c40c3-335">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-335">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-336">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-336">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-337">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-337">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-338"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-338"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-339">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-339">-or-</span></span> 
 <span data-ttu-id="c40c3-340"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-340"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-341">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-341">-or-</span></span> 
 <span data-ttu-id="c40c3-342"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-342"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-343">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-343">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-344"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-344"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-345">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-345">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-346">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-346">-or-</span></span> 
<span data-ttu-id="c40c3-347">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-347">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-348">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-348">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-349">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-349">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-350">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-350">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-351">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-351">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-352">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-352">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-353">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-353">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-354">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-354">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="c40c3-355">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-355">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-356">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-356">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-357">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-357">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-358"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-358">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <summary><span data-ttu-id="c40c3-359">Ajoute un enregistrement de journal à l'interface <see cref="T:System.IO.Log.IRecordSequence" />, en utilisant l'espace précédemment réservé dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-359">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span></span> <span data-ttu-id="c40c3-360">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-360">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-361">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-361">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-362">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-362">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-363">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-363">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-364">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-364">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="c40c3-365">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-365">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-366">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-366">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-367">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-367">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-368"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-368"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-369">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-369">-or-</span></span> 
 <span data-ttu-id="c40c3-370"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-370"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-371">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-371">-or-</span></span> 
 <span data-ttu-id="c40c3-372"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-372"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-373">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-373">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-374"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-374"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-375">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-375">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-376">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-376">-or-</span></span> 
<span data-ttu-id="c40c3-377">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-377">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-378">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-378">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-379">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-379">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-380">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-380">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-381">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-381">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-382">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-382">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-383">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-383">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-384">Obtient le numéro de séquence du premier enregistrement valide dans la séquence <see cref="T:System.IO.Log.LogRecordSequence" /> courante.</span><span class="sxs-lookup"><span data-stu-id="c40c3-384">Gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <value><span data-ttu-id="c40c3-385">Numéro de séquence le plus bas qui correspond à un enregistrement valide dans la <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-385">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-386">Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-386">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="c40c3-387">La valeur de cette propriété peut être modifiée en appelant la méthode <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> ou la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-387">The value of this property can be changed by calling the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method or <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-388">Cet exemple montre comment utiliser le membre <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-388">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> member in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-389">L'accès à la propriété a été effectué après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-389">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-390">Commence une opération d'ajout asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-390">Begins an asynchronous append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-391">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-391">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="c40c3-392">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-392">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-393">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-393">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-394">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-394">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-395">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-395">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-396">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-396">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-397">Commence une opération d'ajout asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-397">Begins an asynchronous append operation.</span></span> <span data-ttu-id="c40c3-398">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-398">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-399"><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-399">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-400">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-400">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-401">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-401">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-402">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-402">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-403">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-403">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-404">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-404">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-405">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-405">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-406"><paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-406"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-407">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-407">-or-</span></span> 
 <span data-ttu-id="c40c3-408"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-408"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-409">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-409">-or-</span></span> 
 <span data-ttu-id="c40c3-410"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-410"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-411">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-411">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-412"><paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-412"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-413">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-413">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-414">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-414">-or-</span></span> 
<span data-ttu-id="c40c3-415">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-415">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-416">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-416">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-417">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-417">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-418">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-418">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-419">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-419">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-420">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-420">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-421">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-421">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="c40c3-422">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-422">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-423">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-423">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-424">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-424">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-425">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-425">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-426">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-426">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-427">Commence une opération d'ajout asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-427">Begins an asynchronous append operation.</span></span> <span data-ttu-id="c40c3-428">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-428">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-429"><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-429">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-430">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-430">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-431">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-431">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-432">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-432">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-433">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-433">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-434">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-434">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-435">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-435">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-436"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-436"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-437">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-437">-or-</span></span> 
 <span data-ttu-id="c40c3-438"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-438"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-439">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-439">-or-</span></span> 
 <span data-ttu-id="c40c3-440"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-440"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-441">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-441">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-442"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-442"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-443">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-443">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-444">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-444">-or-</span></span> 
<span data-ttu-id="c40c3-445">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-445">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-446">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-446">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-447">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-447">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-448">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-448">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-449">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-449">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-450">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-450">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-451">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-451">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="c40c3-452">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-452">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-453">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-453">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-454">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-454">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-455"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-455">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-456">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-456">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-457">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-457">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-458">Commence une opération d'ajout asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-458">Begins an asynchronous append operation.</span></span> <span data-ttu-id="c40c3-459">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-459">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-460"><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-460">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-461">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-461">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-462">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-462">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-463">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-463">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-464">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-464">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-465">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-465">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="c40c3-466">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-466">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-467">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-467">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-468">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-468">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-469"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-469"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-470">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-470">-or-</span></span> 
 <span data-ttu-id="c40c3-471"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-471"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-472">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-472">-or-</span></span> 
 <span data-ttu-id="c40c3-473"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-473"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-474">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-474">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-475"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-475"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-476">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-476">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-477">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-477">-or-</span></span> 
<span data-ttu-id="c40c3-478">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-478">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-479">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-479">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-480">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-480">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-481">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-481">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-482">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-482">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-483">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-483">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-484">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-484">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-485">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-485">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="c40c3-486">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-486">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-487">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-487">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-488">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-488">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-489"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-489">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-490">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-490">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-491">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-491">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-492">Commence une opération d'ajout asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-492">Begins an asynchronous append operation.</span></span> <span data-ttu-id="c40c3-493">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-493">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-494"><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-494">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-495">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-495">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-496">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-496">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-497">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-497">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-498">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-498">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-499">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-499">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="c40c3-500">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-500">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-501">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-501">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="c40c3-502">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-502">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-503"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-503"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-504">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-504">-or-</span></span> 
 <span data-ttu-id="c40c3-505"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-505"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-506">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-506">-or-</span></span> 
 <span data-ttu-id="c40c3-507"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-507"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-508">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-508">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-509"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-509"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-510">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-510">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-511">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-511">-or-</span></span> 
<span data-ttu-id="c40c3-512">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-512">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-513">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-513">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-514">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-514">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-515">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-515">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-516">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-516">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-517">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-517">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-518">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-518">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="c40c3-519">Le numéro de séquence de l'enregistrement le plus récent doit être écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-519">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="c40c3-520">Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</span><span class="sxs-lookup"><span data-stu-id="c40c3-520">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-521">Rappel asynchrone facultatif à appeler lorsque le vidage est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-521">An optional asynchronous callback, to be called when the flush is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-522">Objet fourni par l'utilisateur qui distingue cette requête de vidage asynchrone particulière des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-522">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-523">Commence une opération de vidage asynchrone, en utilisant l'espace précédemment réservé dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-523">Begins an asynchronous flush operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="c40c3-524">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-524">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-525">Objet <see cref="T:System.IAsyncResult" /> qui représente l'opération de vidage asynchrone qui pourrait être toujours en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-525">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-526">Vous devez passer l'objet <xref:System.IAsyncResult> retourné par la méthode actuelle à la méthode <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> pour vous assurer de la fin du vidage et de la libération appropriée des ressources.</span><span class="sxs-lookup"><span data-stu-id="c40c3-526">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="c40c3-527">Si une erreur se produit pendant un vidage asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-527">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-528">L'appel de cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.LogRecordSequence> sont écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="c40c3-528">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="c40c3-529">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-529">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-530">Lorsque des erreurs se sont produites pendant une requête de vidage asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-530">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-531"><paramref name="sequenceNumber" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-531"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-532"><paramref name="sequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-532"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-533">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-533">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-534">Le journal spécifié n'a pas d'étendues.</span><span class="sxs-lookup"><span data-stu-id="c40c3-534">The specified log does not have any extents.</span></span> <span data-ttu-id="c40c3-535">Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-535">One or more extents must be created before a record sequence can be used.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-536">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-536">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-537">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-537">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-538">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-538">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-539">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-539">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-540">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-540">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-541">Commence une réserve asynchrone et ajoute l'opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-541">Begins an asynchronous reserve and append operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-542">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-542">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="c40c3-543">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-543">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-544">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-544">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-545">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-545">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="c40c3-546">Collection de réservations dans laquelle les réservations sont effectuées.</span><span class="sxs-lookup"><span data-stu-id="c40c3-546">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-547">Réservations à effectuer, en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-547">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-548">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-548">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-549">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-549">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-550">Commence une réserve asynchrone et ajoute l'opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-550">Begins an asynchronous reserve and append operation.</span></span> <span data-ttu-id="c40c3-551">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-551">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-552"><see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-552">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-553">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-553">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-554">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-554">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-555">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-555">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-556">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-556">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-557">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-557">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="c40c3-558">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-558">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="c40c3-559">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-559">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="c40c3-560">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-560">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-561">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-561">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-562">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-562">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-563"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-563"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-564">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-564">-or-</span></span> 
 <span data-ttu-id="c40c3-565"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-565"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-566">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-566">-or-</span></span> 
 <span data-ttu-id="c40c3-567"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-567"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-568">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-568">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-569"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-569"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-570">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-570">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-571">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-571">-or-</span></span> 
<span data-ttu-id="c40c3-572">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-572">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-573">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-573">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-574">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-574">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-575">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-575">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-576">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-576">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-577">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-577">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-578">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-578">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-579">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-579">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="c40c3-580">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-580">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-581">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-581">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-582">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-582">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="c40c3-583">Collection de réservations dans laquelle les réservations sont effectuées.</span><span class="sxs-lookup"><span data-stu-id="c40c3-583">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-584">Réservations à effectuer, en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-584">The reservations to make, in bytes.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-585">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-585">An optional asynchronous callback, to be called when the append is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-586">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-586">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-587">Commence une réserve asynchrone et ajoute l'opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-587">Begins an asynchronous reserve and append operation.</span></span> <span data-ttu-id="c40c3-588">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-588">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-589"><see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-589">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-590">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-590">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-591">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-591">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-592">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-592">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-593">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-593">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-594">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-594">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="c40c3-595">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-595">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="c40c3-596">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-596">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="c40c3-597">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-597">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-598">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-598">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-599">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-599">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-600">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-600">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-601">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-601">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-602">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-602">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-603">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-603">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-604">Commence une opération asynchrone d'écriture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-604">Begins an asynchronous restart area write operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-605">Segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-605">Byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="c40c3-606">Nouveau numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-606">The new base sequence number.</span></span> <span data-ttu-id="c40c3-607">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span><span class="sxs-lookup"><span data-stu-id="c40c3-607">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservation"><span data-ttu-id="c40c3-608"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-608">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-609">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-609">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-610">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-610">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-611">Commence une opération asynchrone d'écriture de la zone de reprise en utilisant l'espace précédemment réservé dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-611">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="c40c3-612">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-612">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-613"><see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-613">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-614">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-614">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-615">Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-615">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-616">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-616">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-617">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-617">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-618">Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="c40c3-618">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="c40c3-619">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-619">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="c40c3-620">Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l'espace qui a été réservé précédemment, à l'aide d'une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-620">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="c40c3-621">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-621">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-622">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-622">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-623">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-623">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-624"><paramref name="newBaseSeqNum" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-624"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-625">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-625">-or-</span></span> 
<span data-ttu-id="c40c3-626">Le numéro de séquence de démarrage de l'énumération du journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-626">The specified log enumeration start sequence number is invalid.</span></span>  
  
<span data-ttu-id="c40c3-627">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-627">-or-</span></span> 
 <span data-ttu-id="c40c3-628"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-628"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-629">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-629">-or-</span></span> 
 <span data-ttu-id="c40c3-630"><paramref name="reservation" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-630"><paramref name="reservation" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-631">Un ou plusieurs paramètres ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-631">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-632">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-632">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="c40c3-633">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-633">-or-</span></span> 
 <span data-ttu-id="c40c3-634"><paramref name="newBaseSeqNum" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-634"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-635">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-635">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-636">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-636">-or-</span></span> 
<span data-ttu-id="c40c3-637">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-637">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-638">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-638">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-639">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-639">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-640">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-640">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-641">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-641">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-642">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-642">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="c40c3-643">Nouveau numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-643">The new base sequence number.</span></span> <span data-ttu-id="c40c3-644">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span><span class="sxs-lookup"><span data-stu-id="c40c3-644">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="c40c3-645"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-645">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <param name="callback"><span data-ttu-id="c40c3-646">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-646">An optional asynchronous callback, to be called when the restart area write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="c40c3-647">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</span><span class="sxs-lookup"><span data-stu-id="c40c3-647">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span></span></param>
        <summary><span data-ttu-id="c40c3-648">Commence une opération asynchrone d'écriture de la zone de reprise en utilisant l'espace précédemment réservé dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-648">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span></span> <span data-ttu-id="c40c3-649">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-649">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-650"><see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-650">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-651">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-651">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="c40c3-652">Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="c40c3-652">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="c40c3-653">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-653">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-654">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-654">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-655">Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="c40c3-655">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="c40c3-656">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-656">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="c40c3-657">Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l'espace qui a été réservé précédemment, à l'aide d'une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-657">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="c40c3-658">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-658">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-659">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-659">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-660">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-660">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-661"><paramref name="newBaseSeqNum" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-661"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-662">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-662">-or-</span></span> 
<span data-ttu-id="c40c3-663">Le numéro de séquence de démarrage de l'énumération du journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-663">The specified log enumeration start sequence number is invalid.</span></span>  
  
<span data-ttu-id="c40c3-664">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-664">-or-</span></span> 
 <span data-ttu-id="c40c3-665"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-665"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-666">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-666">-or-</span></span> 
 <span data-ttu-id="c40c3-667"><paramref name="reservationCollection" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-667"><paramref name="reservationCollection" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-668">Un ou plusieurs paramètres ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-668">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-669">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-669">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="c40c3-670">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-670">-or-</span></span> 
 <span data-ttu-id="c40c3-671"><paramref name="newBaseSeqNum" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-671"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-672">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-672">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-673">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-673">-or-</span></span> 
<span data-ttu-id="c40c3-674">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-674">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-675">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-675">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-676">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-676">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-677">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-677">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-678">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-678">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c40c3-679">Crée un <see cref="T:System.IO.Log.ReservationCollection" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-679">Creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span></span> <span data-ttu-id="c40c3-680">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-680">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-681">Objet <see cref="T:System.IO.Log.ReservationCollection" /> nouvellement créé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-681">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c40c3-682">Les réservations peuvent être exécutées de deux manières, comme le montrent les exemples suivants.</span><span class="sxs-lookup"><span data-stu-id="c40c3-682">Reservations can be performed in two ways as shown in the following examples.</span></span> <span data-ttu-id="c40c3-683">Vous pouvez adopter ces pratiques dans les exemples pour un traitement fiable.</span><span class="sxs-lookup"><span data-stu-id="c40c3-683">You can adopt the practices in the samples for robust processing.</span></span> <span data-ttu-id="c40c3-684">Notez que cette tâche ne peut être effectuée que lors de l'utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.</span><span class="sxs-lookup"><span data-stu-id="c40c3-684">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-685">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-685">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c40c3-686">Libère les ressources utilisées par le composant.</span><span class="sxs-lookup"><span data-stu-id="c40c3-686">Releases the resources used by the component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c40c3-687">Cet exemple montre comment utiliser <xref:System.IO.Log.LogRecordSequence.Dispose%2A> pour libérer les ressources :</span><span class="sxs-lookup"><span data-stu-id="c40c3-687">This example shows how to use <xref:System.IO.Log.LogRecordSequence.Dispose%2A> to release resources:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-688">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-688">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-689">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-689">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="c40c3-690">Référence à la requête d'E/S asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-690">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="c40c3-691">Termine une opération d'ajout asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-691">Ends an asynchronous append operation.</span></span> <span data-ttu-id="c40c3-692">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-692">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-693">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-693">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-694">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-694">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="c40c3-695">Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-695">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="c40c3-696">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-696">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-697"><paramref name="result" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-697"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-698">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-698">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-699">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-699">-or-</span></span> 
<span data-ttu-id="c40c3-700">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-700">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-701"><see langword="End" /> a déjà été appelé pour l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-701"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-702">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-702">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-703">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-703">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-704">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-704">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-705">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-705">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-706">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-706">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="c40c3-707">Référence à la requête d'E/S asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-707">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="c40c3-708">Termine une opération de vidage asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-708">Ends an asynchronous flush operation.</span></span> <span data-ttu-id="c40c3-709">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-709">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-710">Numéro de séquence du dernier enregistrement écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-710">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-711">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-711">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="c40c3-712">Les erreurs qui se produisent pendant une requête de vidage asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-712">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="c40c3-713">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-713">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-714"><paramref name="result" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-714"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-715">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-715">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-716"><see langword="End" /> a déjà été appelé pour l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-716"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-717">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-717">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-718">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-718">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-719">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-719">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-720">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-720">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-721">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-721">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="c40c3-722">Référence à la requête d'E/S asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-722">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="c40c3-723">Termine une réserve asynchrone et ajoute l'opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-723">Ends an asynchronous reserve and append operation.</span></span> <span data-ttu-id="c40c3-724">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-724">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-725">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-725">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-726">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-726">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="c40c3-727">Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-727">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="c40c3-728">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-728">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-729"><paramref name="result" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-729"><paramref name="result" /> is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-730">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-730">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-731">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-731">-or-</span></span> 
<span data-ttu-id="c40c3-732">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-732">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-733"><see langword="End" /> a déjà été appelé pour l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-733"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-734">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-734">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-735">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-735">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-736">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-736">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-737">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-737">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-738">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-738">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><span data-ttu-id="c40c3-739">Référence à la requête d'E/S asynchrone en attente.</span><span class="sxs-lookup"><span data-stu-id="c40c3-739">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="c40c3-740">Termine une opération d'écriture de la zone de reprise asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-740">Ends an asynchronous restart area write operation.</span></span> <span data-ttu-id="c40c3-741">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-741">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-742">Numéro de séquence de l'enregistrement du journal écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-742">The sequence number of the written log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-743">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-743">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="c40c3-744">Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-744">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="c40c3-745">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-745">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-746"><paramref name="result" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-746"><paramref name="result" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-747">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-747">A new or existing archive tail or base of the active log is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-748">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-748">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-749"><see langword="End" /> a déjà été appelé pour l'opération asynchrone.</span><span class="sxs-lookup"><span data-stu-id="c40c3-749"><see langword="End" /> has already been called for this asynchronous operation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-750">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-750">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-751">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-751">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-752">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-752">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-753">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-753">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-754">Écrit les enregistrements ajoutés de façon durable</span><span class="sxs-lookup"><span data-stu-id="c40c3-754">Writes appended records durably</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c40c3-755">Vérifie que tous les enregistrements ajoutés ont été écrits.</span><span class="sxs-lookup"><span data-stu-id="c40c3-755">Ensures that all appended records have been written.</span></span> <span data-ttu-id="c40c3-756">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-756">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-757">Numéro de séquence du dernier enregistrement écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-757">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-758">L'appel à cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.LogRecordSequence> sont écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="c40c3-758">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-759">Une erreur d'E/S s'est produite lors du vidage des données.</span><span class="sxs-lookup"><span data-stu-id="c40c3-759">An I/O error occurred while flushing the data.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-760">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-760">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-761">Cette opération n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="c40c3-761">This operation is not supported.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-762">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-762">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-763">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-763">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-764">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-764">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-765">Le journal spécifié n'a pas d'étendues.</span><span class="sxs-lookup"><span data-stu-id="c40c3-765">The specified log does not have any extents.</span></span> <span data-ttu-id="c40c3-766">Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-766">One or more extents must be created before a record sequence can be used.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="c40c3-767">Le numéro de séquence de l'enregistrement le plus récent doit être écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-767">The sequence number of the latest record that must be written.</span></span> <span data-ttu-id="c40c3-768">Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</span><span class="sxs-lookup"><span data-stu-id="c40c3-768">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span></span></param>
        <summary><span data-ttu-id="c40c3-769">Veille à ce que tous les enregistrements ajoutés jusqu'à l'enregistrement du numéro de séquence spécifié inclus ont été écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="c40c3-769">Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span></span> <span data-ttu-id="c40c3-770">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-770">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-771">Numéro de séquence du dernier enregistrement écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-771">The sequence number of the last record written.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-772">L'appel à cette méthode garantit que tous les enregistrements avec les numéros de séquence jusqu'à et y compris le numéro de séquence spécifié ont été écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="c40c3-772">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-773"><paramref name="sequenceNumber" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-773"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-774"><paramref name="sequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-774"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-775">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-775">The request could not be performed because of an unexpected I/O exception.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-776">Le journal spécifié n'a pas d'étendues.</span><span class="sxs-lookup"><span data-stu-id="c40c3-776">The specified log does not have any extents.</span></span> <span data-ttu-id="c40c3-777">Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-777">One or more extents must be created before a record sequence can be used.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-778">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-778">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-779">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-779">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-780">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-780">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-781">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-781">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-782">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-782">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-783">Obtient le numéro de séquence supérieur au dernier enregistrement ajouté</span><span class="sxs-lookup"><span data-stu-id="c40c3-783">Gets the sequence number which is greater than the last record appended</span></span></summary>
        <value><span data-ttu-id="c40c3-784">Numéro de séquence supérieur au dernier enregistrement ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-784">A sequence number which is greater than the last record appended.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-785">Cette propriété contient un numéro de séquence dont la supériorité au numéro de séquence du dernier enregistrement ajouté est garantie.</span><span class="sxs-lookup"><span data-stu-id="c40c3-785">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="c40c3-786">Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-786">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span> <span data-ttu-id="c40c3-787">Tous les autres numéros de séquence ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-787">All other sequence numbers are invalid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-788">L'accès à la propriété a été effectué après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-788">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-789">Obtient la classe <see cref="T:System.IO.Log.LogStore" /> qui contient les données pour cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-789">Gets the <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span></span> <span data-ttu-id="c40c3-790">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-790">This method cannot be inherited.</span></span></summary>
        <value><span data-ttu-id="c40c3-791">Classe <see cref="T:System.IO.Log.LogStore" /> qui contient les données pour cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-791">The <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c40c3-792">Cet exemple indique comment utiliser le membre <xref:System.IO.Log.LogRecordSequence.LogStore%2A> pour ajouter les étendues.</span><span class="sxs-lookup"><span data-stu-id="c40c3-792">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.LogStore%2A> member to add extents.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-793">Obtient la taille maximale d'un enregistrement pouvant être ajouté à cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-793">Gets the maximum size of a record that can be added to this record sequence.</span></span></summary>
        <value><span data-ttu-id="c40c3-794">Taille maximale d'un enregistrement pouvant être ajouté à cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-794">The maximum size of a record that can be added to this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="c40c3-795">Numéro de séquence du premier enregistrement à partir duquel démarre la lecture.</span><span class="sxs-lookup"><span data-stu-id="c40c3-795">The sequence number of the first record where the reading starts.</span></span></param>
        <param name="logRecordEnum"><span data-ttu-id="c40c3-796">Valeur <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valide qui spécifie le sens de lecture (c'est-à-dire, vers l'avant ou l'arrière) des enregistrements à partir d'une <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-796">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></param>
        <summary><span data-ttu-id="c40c3-797">Retourne une collection dénombrable des enregistrements de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-797">Returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="c40c3-798">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-798">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-799">Collection dénombrable des enregistrements de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-799">An enumerable collection of records in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-800">Cette méthode retourne une collection dénombrable d’enregistrements dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-800">This method returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="c40c3-801">L'ordre des enregistrements énumérés dépend de la valeur du paramètre `logRecordEnum`.</span><span class="sxs-lookup"><span data-stu-id="c40c3-801">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-802">Cet exemple montre comment utiliser <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-802">This example shows how to use <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-803"><paramref name="start" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-803"><paramref name="start" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-804">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-804">-or-</span></span> 
 <span data-ttu-id="c40c3-805"><paramref name="logRecordEnum" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-805"><paramref name="logRecordEnum" /> is invalid.</span></span>  
  
<span data-ttu-id="c40c3-806">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-806">-or-</span></span> 
<span data-ttu-id="c40c3-807">L’élément spécifié était introuvable dans la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-807">The specified element was not found in the collection.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-808"><paramref name="start" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-808"><paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-809">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-809">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-810">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-810">-or-</span></span> 
<span data-ttu-id="c40c3-811">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-811">The request could not be performed because of an I/O device error.</span></span>  
  
<span data-ttu-id="c40c3-812">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-812">-or</span></span> 
<span data-ttu-id="c40c3-813">La taille de la mémoire tampon utilisée pour écrire l'enregistrement du journal est plus grand que la taille de la mémoire tampon utilisée pour le lire.</span><span class="sxs-lookup"><span data-stu-id="c40c3-813">The buffer size used to write the log record is larger than the buffer size being used to read it.</span></span>  
  
<span data-ttu-id="c40c3-814">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-814">-or-</span></span> 
<span data-ttu-id="c40c3-815">La séquence d'enregistrement est endommagée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-815">The record sequence is corrupted.</span></span>  
  
<span data-ttu-id="c40c3-816">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-816">-or-</span></span> 
<span data-ttu-id="c40c3-817">Le format ou la version de fichier journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-817">The specified log file format or version is invalid.</span></span>  
  
<span data-ttu-id="c40c3-818">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-818">-or-</span></span> 
<span data-ttu-id="c40c3-819">L'enregistrement a été écrit avec une version incompatible de la séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-819">The record was written with an incompatible version of the record sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-820">L'opération n'est pas valide car l'énumération n'a pas été démarrée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-820">The operation is invalid because the enumeration has not been started.</span></span> <span data-ttu-id="c40c3-821">Un appel à <see cref="M:System.Collections.IEnumerator.MoveNext" /> doit être fait.</span><span class="sxs-lookup"><span data-stu-id="c40c3-821">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-822">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-822">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-823">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-823">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-824">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-824">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c40c3-825">Retourne une collection dénombrable des zones de reprise dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-825">Returns an enumerable collection of the restart areas in the sequence.</span></span> <span data-ttu-id="c40c3-826">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-826">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-827">Collection dénombrable des zones de reprise dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-827">An enumerable collection of the restart areas in the sequence.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-828">Les zones de reprise sont énumérées en ordre de numéro de séquence inverse, autrement dit, du numéro de séquence le plus élevé au numéro de séquence le plus bas.</span><span class="sxs-lookup"><span data-stu-id="c40c3-828">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="c40c3-829">Seules les zones de reprise avec des numéros de séquence compris entre le dernier numéro de séquence et le numéro de séquence de base sont énumérées.</span><span class="sxs-lookup"><span data-stu-id="c40c3-829">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-830"><paramref name="start" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-830"><paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-831">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-831">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-832">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-832">-or-</span></span> 
<span data-ttu-id="c40c3-833">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-833">The request could not be performed because of an I/O device error.</span></span>  
  
<span data-ttu-id="c40c3-834">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-834">-or</span></span> 
<span data-ttu-id="c40c3-835">La taille de la mémoire tampon utilisée pour écrire l'enregistrement du journal est plus grand que la taille de la mémoire tampon utilisée pour le lire.</span><span class="sxs-lookup"><span data-stu-id="c40c3-835">The buffer size used to write the log record is larger than the buffer size being used to read it.</span></span>  
  
<span data-ttu-id="c40c3-836">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-836">-or-</span></span> 
<span data-ttu-id="c40c3-837">La séquence d'enregistrement est endommagée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-837">The record sequence is corrupted.</span></span>  
  
<span data-ttu-id="c40c3-838">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-838">-or-</span></span> 
<span data-ttu-id="c40c3-839">Le format ou la version de fichier journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-839">The specified log file format or version is invalid.</span></span>  
  
<span data-ttu-id="c40c3-840">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-840">-or-</span></span> 
<span data-ttu-id="c40c3-841">L'enregistrement a été écrit avec une version incompatible de la séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-841">The record was written with an incompatible version of the record sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c40c3-842">L'opération n'est pas valide car l'énumération n'a pas été démarrée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-842">The operation is invalid because the enumeration has not been started.</span></span> <span data-ttu-id="c40c3-843">Un appel à <see cref="M:System.Collections.IEnumerator.MoveNext" /> doit être fait.</span><span class="sxs-lookup"><span data-stu-id="c40c3-843">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span>  
  
<span data-ttu-id="c40c3-844">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-844">-or</span></span> 
<span data-ttu-id="c40c3-845">L'énumération est terminée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-845">The enumeration has ended.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-846">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-846">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-847">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-847">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-848">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-848">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-849">Fait automatiquement une réservation unique et ajoute un enregistrement à la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-849">Automatically makes a single reservation and appends a record to the sequence.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-850">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-850">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="nextUndoRecord"><span data-ttu-id="c40c3-851">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-851">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-852">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-852">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-853">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-853">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="c40c3-854"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la collection dans laquelle sont effectuées les réservations.</span><span class="sxs-lookup"><span data-stu-id="c40c3-854">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-855">Réservations à effectuer, en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-855">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="c40c3-856">Fait automatiquement une réservation unique et ajoute un enregistrement à la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-856">Automatically makes a single reservation and appends a record to the sequence.</span></span> <span data-ttu-id="c40c3-857">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-857">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-858">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-858">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-859">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-859">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-860">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-860">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-861">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-861">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="c40c3-862">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-862">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="c40c3-863">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-863">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="c40c3-864">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-864">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-865">L'exemple suivant montre comment utiliser cette méthode pour faire des réservations.</span><span class="sxs-lookup"><span data-stu-id="c40c3-865">The following example shows how to use this method to make reservations.</span></span> <span data-ttu-id="c40c3-866">Notez que cette tâche ne peut être effectuée que lors de l'utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.</span><span class="sxs-lookup"><span data-stu-id="c40c3-866">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-867"><paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-867"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-868">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-868">-or-</span></span> 
 <span data-ttu-id="c40c3-869"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-869"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-870">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-870">-or-</span></span> 
 <span data-ttu-id="c40c3-871"><paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-871"><paramref name="reservations" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-872">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-872">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-873"><paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-873"><paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-874">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-874">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-875">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-875">-or-</span></span> 
<span data-ttu-id="c40c3-876">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-876">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-877">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-877">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-878">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-878">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-879">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-879">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-880">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-880">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-881">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-881">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-882">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-882">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-883">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-883">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="userRecord"><span data-ttu-id="c40c3-884">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c40c3-884">The sequence number of the next record in the user-specified order.</span></span></param>
        <param name="previousRecord"><span data-ttu-id="c40c3-885">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span><span class="sxs-lookup"><span data-stu-id="c40c3-885">The sequence number of the next record in Previous order.</span></span></param>
        <param name="recordAppendOptions"><span data-ttu-id="c40c3-886">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span><span class="sxs-lookup"><span data-stu-id="c40c3-886">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="c40c3-887">Collection de réservations dans laquelle les réservations sont effectuées.</span><span class="sxs-lookup"><span data-stu-id="c40c3-887">The reservation collection to make reservations in.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-888">Réservations à effectuer, en octets.</span><span class="sxs-lookup"><span data-stu-id="c40c3-888">The reservations to make, in bytes.</span></span></param>
        <summary><span data-ttu-id="c40c3-889">Fait automatiquement une réservation unique et ajoute un enregistrement à la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-889">Automatically makes a single reservation and appends a record to the sequence.</span></span> <span data-ttu-id="c40c3-890">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-890">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-891">Numéro de séquence de l'enregistrement du journal ajouté.</span><span class="sxs-lookup"><span data-stu-id="c40c3-891">The sequence number of the appended log record.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-892">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-892">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-893">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-893">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="c40c3-894">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-894">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="c40c3-895">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="c40c3-895">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="c40c3-896">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="c40c3-896">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="c40c3-897">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-897">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-898">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-898">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-899">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-899">An I/O error occurred while appending the record.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-900">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-900">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-901">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-901">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-902">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-902">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-903"><paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-903"><paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c40c3-904">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="c40c3-904">The operation cannot be performed because the record sequence was opened with read-only access.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-905">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-905">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-906">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-906">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException"><span data-ttu-id="c40c3-907">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-907">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-908">Obtient le nombre total d'octets ayant été réservés.</span><span class="sxs-lookup"><span data-stu-id="c40c3-908">Gets the total number of bytes that have been reserved.</span></span></summary>
        <value><span data-ttu-id="c40c3-909">Taille totale de toutes les réservations effectuées dans cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-909">The total size of all reservations made in this record sequence.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-910">L'accès à la propriété a été effectué après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-910">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-911">Obtient le numéro de séquence de la zone de reprise plus proche de la fin du journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-911">Gets the sequence number of the restart area closest to the end of the log.</span></span></summary>
        <value><span data-ttu-id="c40c3-912">Numéro de séquence de la zone de reprise plus proche de la fin du journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-912">The sequence number of the restart area closest to the end of the log.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-913">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-913">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-914">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-914">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-915">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-915">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-916">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-916">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-917">À l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>, vous pouvez supprimer la zone de reprise la plus récemment écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-917">Using the <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> method, you can remove the most recently written restart area.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-918">L'accès à la propriété a été effectué après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-918">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-919">Obtient ou définit une valeur qui indique si les opérations d'ajout sont réitérées automatiquement ou non, lorsque le journal est complet.</span><span class="sxs-lookup"><span data-stu-id="c40c3-919">Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</span></span></summary>
        <value><span data-ttu-id="c40c3-920"><see langword="true" /> si les opérations d'ajout sont réitérées automatiquement si le journal est complet ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-920"><see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c40c3-921">La valeur par défaut est <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-921">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-922">Si la valeur de cette propriété est `true` et qu'un appel <xref:System.IO.Log.LogRecordSequence.Append%2A> échoue parce qu'il n'y a pas suffisamment d'espace dans la séquence, la séquence d'enregistrement essaie de libérer de l'espace et réitère l'opération d'ajout.</span><span class="sxs-lookup"><span data-stu-id="c40c3-922">If the value of this property is `true`, and an <xref:System.IO.Log.LogRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-923">L'exemple suivant indique comment utiliser la propriété <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-923">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> property.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-924">L'accès à la propriété a été effectué après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-924">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber"><span data-ttu-id="c40c3-925">Le nouveau dernier numéro de séquence dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-925">The new last sequence number in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span>  
  
<span data-ttu-id="c40c3-926">Il doit faire référence à un enregistrement valide actuellement présent dans le journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-926">This should refer to a current valid record   currently in the log.</span></span></param>
        <summary><span data-ttu-id="c40c3-927">Définit le dernier enregistrement dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-927">Sets the last record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-928">Le numéro de séquence spécifié doit être supérieur au numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-928">The specified sequence number must be larger than the base sequence number.</span></span>  
  
 <span data-ttu-id="c40c3-929">À l'issue de cette méthode, tous les enregistrements précédemment ajoutés avec des numéros de séquence supérieurs à celui du numéro de séquence spécifié sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-929">When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-930"><paramref name="sequenceNumber" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-930"><paramref name="sequenceNumber" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-931">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-931">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="c40c3-932">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-932">-or-</span></span> 
 <span data-ttu-id="c40c3-933"><paramref name="sequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-933"><paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-934">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-934">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-935">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-935">-or-</span></span> 
<span data-ttu-id="c40c3-936">La fin du journal a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="c40c3-936">The end of the log has been reached.</span></span>  
  
<span data-ttu-id="c40c3-937">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-937">-or-</span></span> 
<span data-ttu-id="c40c3-938">Le format ou la version de fichier journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-938">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-939">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-939">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-940">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-940">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-941">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-941">Access for the specified log sequence is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c40c3-942">Signale la nécessité de déplacer la fin de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-942">Signals the need to move the tail of the sequence.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-943">Vous pouvez déclencher cet événement lorsque la séquence d'enregistrement n'a plus d'espace disponible.</span><span class="sxs-lookup"><span data-stu-id="c40c3-943">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="c40c3-944">Lorsque cet événement est déclenché, la fin de la séquence (c'est-à-dire, le numéro de séquence de base) est avancée pour libérer de l'espace.</span><span class="sxs-lookup"><span data-stu-id="c40c3-944">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 <span data-ttu-id="c40c3-945">L'événement peut être déclenché à n'importe quel moment lorsque la séquence d'enregistrement décide qu'elle doit libérer de l'espace, pour une raison quelconque.</span><span class="sxs-lookup"><span data-stu-id="c40c3-945">The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</span></span> <span data-ttu-id="c40c3-946">Par exemple, le moteur de stratégie CLFS peut décider de déclencher l'événement lorsqu'il détermine que les fins de deux clients de journal qui partagent le même fichier journal sont trop éloignées.</span><span class="sxs-lookup"><span data-stu-id="c40c3-946">For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</span></span> <span data-ttu-id="c40c3-947">La libération de l'espace peut se faire par écriture de zones de reprise ou par troncation du journal et utilisation de la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> pour supprimer de l'espace.</span><span class="sxs-lookup"><span data-stu-id="c40c3-947">Freeing space can be done by either writing restart areas, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to clear space.</span></span> <span data-ttu-id="c40c3-948">L'exemple de code de la section Exemple illustre la deuxième approche.</span><span class="sxs-lookup"><span data-stu-id="c40c3-948">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="c40c3-949">Vous pouvez également appeler la méthode <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> en dehors de l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> pour libérer de l'espace.</span><span class="sxs-lookup"><span data-stu-id="c40c3-949">You can also call the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> method outside of the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free space.</span></span> <span data-ttu-id="c40c3-950">Une zone de reprise est semblable à un point de contrôle dans d'autres systèmes de traitement de journal.</span><span class="sxs-lookup"><span data-stu-id="c40c3-950">A restart area is similar to a checkpoint in other log processing systems.</span></span> <span data-ttu-id="c40c3-951">L'appel de cette méthode indique que l'application considère tous les enregistrements antérieurs avant la zone de reprise comme entièrement terminés et utilisables pour de futurs ajouts d'enregistrements.</span><span class="sxs-lookup"><span data-stu-id="c40c3-951">Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</span></span> <span data-ttu-id="c40c3-952">Tout comme pour les autres enregistrements, l'enregistrement écrit par cette méthode requiert de l'espace libre réel dans le journal pour fonctionner.</span><span class="sxs-lookup"><span data-stu-id="c40c3-952">Similar to any other records, the record written by this method requires actual free space in the log to function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c40c3-953">Cet exemple indique comme utiliser l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> :</span><span class="sxs-lookup"><span data-stu-id="c40c3-953">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.TailPinned> event.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c40c3-954">Écrit une zone de reprise dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-954">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-955">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-955">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-956">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-956">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-957">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-957">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-958">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-958">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-959">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-959">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-960">Segment de tableau qui sera concaténé et ajouté en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-960">An array segment that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="c40c3-961">Écrit une zone de reprise dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-961">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="c40c3-962">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-962">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-963">Numéro de séquence de la zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-963">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-964">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-964">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-965">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-965">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-966">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-966">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-967">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-967">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-968">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-968">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-969">Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-969">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-970">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-970">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-971">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-971">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-972">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-972">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-973">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-973">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-974">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-974">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-975">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-975">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-976">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-976">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-977">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-977">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-978">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-978">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <summary><span data-ttu-id="c40c3-979">Écrit une zone de reprise dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-979">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span></span> <span data-ttu-id="c40c3-980">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-980">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-981">Numéro de séquence de la zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-981">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-982">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-982">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-983">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-983">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-984">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-984">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-985">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-985">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-986">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-986">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-987">Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-987">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-988">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-988">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-989">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-989">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-990">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-990">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-991">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-991">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-992">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-992">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-993">Un ou plusieurs arguments ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-993">One or more of the arguments are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-994">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-994">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-995">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-995">There is not enough memory to continue the execution of the program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-996">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-996">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="c40c3-997">Nouveau numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-997">The new base sequence number.</span></span> <span data-ttu-id="c40c3-998">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span><span class="sxs-lookup"><span data-stu-id="c40c3-998">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="c40c3-999">Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> et met à jour le numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-999">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span></span> <span data-ttu-id="c40c3-1000">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1000">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-1001">Numéro de séquence de la zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1001">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-1002">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1002">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1003">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1003">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-1004">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1004">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1005">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1005">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-1006">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1006">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-1007">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1007">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-1008">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1008">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="c40c3-1009">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1009">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="c40c3-1010">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1010">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="c40c3-1011">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1011">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-1012">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1012">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-1013">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1013">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-1014">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1014">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-1015">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1015">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-1016">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1016">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-1017">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1017">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="c40c3-1018">Nouveau numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1018">The new base sequence number.</span></span> <span data-ttu-id="c40c3-1019">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1019">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <summary><span data-ttu-id="c40c3-1020">Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> et met à jour le numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1020">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span></span> <span data-ttu-id="c40c3-1021">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1021">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-1022">Numéro de séquence de la zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1022">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-1023">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1023">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1024">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1024">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-1025">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1025">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1026">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1026">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-1027">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1027">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-1028">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1028">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-1029">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1029">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="c40c3-1030">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1030">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="c40c3-1031">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1031">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="c40c3-1032">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1032">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-1033">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1033">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-1034">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1034">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-1035">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1035">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-1036">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1036">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-1037">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1037">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-1038">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1038">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="c40c3-1039">Nouveau numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1039">The new base sequence number.</span></span> <span data-ttu-id="c40c3-1040">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1040">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservations"><span data-ttu-id="c40c3-1041"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1041">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="c40c3-1042">Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> à l'aide d'une réservation, et met à jour le numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1042">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span></span> <span data-ttu-id="c40c3-1043">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1043">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-1044">Numéro de séquence de la zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1044">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-1045">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1045">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1046">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1046">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-1047">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1047">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1048">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1048">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-1049">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1049">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-1050">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1050">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-1051">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1051">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="c40c3-1052">Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1052">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="c40c3-1053">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1053">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-1054">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1054">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="c40c3-1055">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1055">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="c40c3-1056">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1056">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-1057">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1057">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-1058">Un ou plusieurs arguments ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1058">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-1059">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1059">An I/O error occurred while writing the restart area.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-1060">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1060">The record sequence could not make enough free space to contain the new restart area.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-1061">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1061">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data"><span data-ttu-id="c40c3-1062">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1062">A list of byte array segments that will be concatenated and appended as the record.</span></span></param>
        <param name="newBaseSeqNum"><span data-ttu-id="c40c3-1063">Nouveau numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1063">The new base sequence number.</span></span> <span data-ttu-id="c40c3-1064">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1064">The specified sequence number must be greater than or equal to the current base sequence number.</span></span></param>
        <param name="reservationCollection"><span data-ttu-id="c40c3-1065"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1065">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span></span></param>
        <summary><span data-ttu-id="c40c3-1066">Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> à l'aide d'une réservation, et met à jour le numéro de séquence de base.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1066">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span></span> <span data-ttu-id="c40c3-1067">Cette méthode ne peut pas être héritée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1067">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="c40c3-1068">Numéro de séquence de la zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1068">The sequence number of the written restart area.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c40c3-1069">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1069">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1070">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1070">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="c40c3-1071">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1071">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="c40c3-1072">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1072">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="c40c3-1073">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1073">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="c40c3-1074">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1074">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="c40c3-1075">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1075">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="c40c3-1076">Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1076">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="c40c3-1077">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1077">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="c40c3-1078">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1078">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="c40c3-1079">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1079">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="c40c3-1080">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1080">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="c40c3-1081">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1081">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c40c3-1082"><paramref name="newBaseSeqNum" /> n'est pas valide pour cette séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1082"><paramref name="newBaseSeqNum" /> is not valid for this sequence.</span></span>  
  
<span data-ttu-id="c40c3-1083">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-1083">-or-</span></span> 
<span data-ttu-id="c40c3-1084">Le numéro de séquence de démarrage de l'énumération du journal spécifié n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1084">The specified log enumeration start sequence number is invalid.</span></span>  
  
<span data-ttu-id="c40c3-1085">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-1085">-or-</span></span> 
 <span data-ttu-id="c40c3-1086"><paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1086"><paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span></span>  
  
<span data-ttu-id="c40c3-1087">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-1087">-or-</span></span> 
 <span data-ttu-id="c40c3-1088"><paramref name="reservationCollection" /> n'a pas été créé par cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1088"><paramref name="reservationCollection" /> was not created by this record sequence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c40c3-1089">Un ou plusieurs paramètres ont la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1089">One or more of the parameters is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c40c3-1090">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1090">A new or existing archive tail or base of the active log is invalid.</span></span>  
  
<span data-ttu-id="c40c3-1091">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-1091">-or-</span></span> 
 <span data-ttu-id="c40c3-1092"><paramref name="newBaseSeqNum" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1092"><paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c40c3-1093">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1093">The request could not be performed because of an unexpected I/O exception.</span></span>  
  
<span data-ttu-id="c40c3-1094">- ou -</span><span class="sxs-lookup"><span data-stu-id="c40c3-1094">-or-</span></span> 
<span data-ttu-id="c40c3-1095">La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1095">The request could not be performed because of an I/O device error.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c40c3-1096">La méthode a été appelée après la suppression de la séquence.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1096">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="c40c3-1097">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1097">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c40c3-1098">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1098">Access for the specified log sequence is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="c40c3-1099">La séquence d'enregistrement est complète.</span><span class="sxs-lookup"><span data-stu-id="c40c3-1099">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>