<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7156e4e610a9d14909a701b75c25fcdefeaf4c8c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37655522" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente une séquence d'enregistrement stockée dans un <see cref="T:System.IO.Log.LogStore" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.Log.LogRecordSequence> fournit une implémentation de l'interface de séquence d'enregistrement sur un journal CLFS (Common Log File System). Outre les fonctionnalités orientées par enregistrement standard, elle fournit un modèle de stratégie pour éviter des conditions de journal saturé et pour multiplexer des clients sur le même fichier physique. Cela fonctionne avec la classe <xref:System.IO.Log.LogStore> qui fournit une interface pour manipuler et gérer directement un fichier journal CLFS. La relation entre la classe <xref:System.IO.Log.LogStore> et la classe <xref:System.IO.Log.LogRecordSequence> est similaire à la relation entre un fichier sur un disque et un objet <xref:System.IO.FileStream>. Le fichier sur disque fournit la mémoire physique et a des attributs tels que la longueur et le dernier temps d'accès, alors que l'objet <xref:System.IO.FileStream> fournit une vue sur le fichier qui peut être utilisée pour la lecture et l'écriture. De la même façon, la classe <xref:System.IO.Log.LogStore> a des attributs tels qu'une stratégie et une collection d'étendues de disque, et la classe <xref:System.IO.Log.LogRecordSequence> fournit un mécanisme orienté enregistrement pour lire et écrire des données.  
  
   
  
## Examples  
 Cet exemple indique comme utiliser la classe <xref:System.IO.Log.LogRecordSequence> :  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <see cref="T:System.IO.Log.LogStore" /> que cette séquence d'enregistrement doit utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec le magasin de journaux spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu. Dans ce constructeur, une valeur par défaut de 64 est définie. Le nombre désiré de mémoires tampons est définie à 10.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logStore" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès au magasin de journaux et un mode d'accès spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès et le mode spécifiés. Elle reçoit un accès en lecture/écriture au magasin, et le magasin est ouvert en partageant l'accès en lecture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="path" /> est une chaîne vide ("").  
  
- ou - 
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
- ou - 
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n'est pas prise en charge.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <see cref="T:System.IO.Log.LogStore" /> que cette séquence d'enregistrement doit utiliser.</param>
        <param name="bufferSize">Taille de la mémoire tampon voulue en octets. La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</param>
        <param name="bufferCount">Nombre voulu de mémoires tampons.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec le magasin de journaux, la taille de mémoire tampon pour chaque enregistrement et le nombre de mémoires tampons spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si vous souhaitez spécifier des valeurs pour `bufferSize` et `bufferCount` et ne souhaitez pas utiliser la valeur par défaut de 64 pour `bufferSize` ou 10 pour `bufferCount`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="logStore" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est négatif ou égal à zéro.  
  
- ou - 
 <paramref name="bufferCount" /> est négatif ou égal à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès spécifié au magasin de journaux et les modes d'accès et de partage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés. Le magasin est ouvert en partageant l'accès en lecture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="path" /> est une chaîne vide ("").  
  
- ou - 
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
- ou - 
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n'est pas prise en charge.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">L'une des valeurs <see cref="T:System.IO.FileShare" /> qui détermine comment le magasin de journaux sera partagé parmi les processus.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès au magasin de journaux et un mode d'accès spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés. Le magasin est ouvert avec le partage d'accès spécifié.  
  
   
  
## Examples  
 L'exemple suivant montre comment utiliser le constructeur de <xref:System.IO.Log.LogRecordSequence> :  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="path" /> est une chaîne vide ("").  
  
- ou - 
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
- ou - 
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n'est pas prise en charge.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">L'une des valeurs <see cref="T:System.IO.FileShare" /> qui détermine comment le magasin de journaux sera partagé parmi les processus.</param>
        <param name="bufferSize">Taille de la mémoire tampon voulue en octets. La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</param>
        <param name="bufferCount">Nombre voulu de mémoires tampons.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" /> avec un chemin d'accès spécifié au magasin de journaux, une autorisation d'accès aux fichiers, des modes d'accès et de partage, ainsi que la taille de la mémoire tampon et le compte des enregistrements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise une nouvelle classe <xref:System.IO.Log.LogRecordSequence> sur un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés. Le magasin est ouvert avec le partage d'accès spécifié.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="path" /> est une chaîne vide ("").  
  
- ou - 
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
- ou - 
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n'est pas prise en charge.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">Valeur <see cref="T:System.IO.FileMode" /> valide qui détermine le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Valeur <see cref="T:System.IO.FileAccess" /> valide qui détermine comment accéder au magasin de journaux.</param>
        <param name="share">Valeur <see cref="T:System.IO.FileShare" /> valide qui détermine comment le magasin de journaux sera partagé parmi les processus.</param>
        <param name="bufferSize">Taille de la mémoire tampon voulue en octets. La taille de la mémoire tampon détermine la taille maximale de l'enregistrement pouvant être ajouté ou lu.</param>
        <param name="bufferCount">Nombre voulu de mémoires tampons.</param>
        <param name="fileSecurity">Valeur <see cref="T:System.Security.AccessControl.FileSecurity" /> valide qui spécifie la sécurité à définir sur le magasin créé récemment si le magasin doit être créé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le fichier spécifié par <paramref name="path" /> n'est pas valide.  
  
- ou - 
Le nom de fichier du magasin de journaux spécifié n'est pas valide.  
  
- ou - 
 <paramref name="mode" /> a une valeur de <see cref="F:System.IO.FileMode.CreateNew" />et ne peut pas être utilisé sans accès en écriture.  
  
- ou - 
 <paramref name="mode" /> a une valeur de <see cref="F:System.IO.FileMode.OpenOrCreate" />et ne peut pas être utilisé sans accès en écriture.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un ou plusieurs des arguments sont hors limite.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
Impossible d'accéder au fichier spécifié par le <paramref name="path" /> parce qu'il est utilisé par un autre processus.  
  
- ou - 
Le fichier spécifié par le <paramref name="path" /> ne peut pas être créé parce que le fichier ou le répertoire existe déjà.  
  
- ou - 
Le handle de journal n'a pas pu être lié au pool de threads.  
  
- ou - 
Le format ou la version de fichier journal spécifié n'est pas valide.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n'est pas prise en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogRecordSequence" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS, s'il est disponible pour votre plateforme, ou utilisez la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Spécifie le nouveau <see cref="T:System.IO.Log.SequenceNumber" /> de base pour le journal. Il doit être compris entre le numéro de séquence de base actuel et le dernier numéro de séquence du journal, inclus.</param>
        <summary>Avance le numéro de séquence de base du journal. Cette méthode ne peut pas être héritée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est souvent utilisée avec l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> pour libérer de l'espace dans un enregistrement. L'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> indique que la fin de la séquence (c'est-à-dire, le numéro de séquence de base) doit être avancée pour libérer de l'espace. Libérer de l'espace peut se faire soit en écrivant des zones de reprise à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, soit en tronquant le journal et en utilisant la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> pour avancer le numéro de séquence de base d'un journal à celui spécifié par le paramètre `newBaseSequenceNumber`. L'exemple de code de la section Exemple illustre la deuxième approche.  
  
 Notez qu'appeler cette méthode revient à définir un nouveau numéro de séquence de base à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>, à ceci près qu'aucun enregistrement de reprise n'est écrit dans le journal.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> avec l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> pour libérer de l'espace dans une séquence de journal.  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> n'est pas valide pour cette séquence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.  
  
- ou - 
 <paramref name="newBaseSequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.InvalidOperationException">Le journal spécifié n'a pas d'étendues. Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit un enregistrement de journal dans l'interface <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre comment utiliser le membre <xref:System.IO.Log.LogRecordSequence.Append%2A>.  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <summary>Écrit un enregistrement de journal dans l'interface <see cref="T:System.IO.Log.LogRecordSequence" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 L'exemple suivant montre comment utiliser cette méthode pour ajouter un enregistrement à une séquence dans le journal.  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="userRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <summary>Ajoute un enregistrement de journal à l'interface <see cref="T:System.IO.Log.IRecordSequence" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <summary>Ajoute un enregistrement de journal à l'interface <see cref="T:System.IO.Log.IRecordSequence" />, en utilisant l'espace précédemment réservé dans la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="userRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <summary>Ajoute un enregistrement de journal à l'interface <see cref="T:System.IO.Log.IRecordSequence" />, en utilisant l'espace précédemment réservé dans la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le numéro de séquence du premier enregistrement valide dans la séquence <see cref="T:System.IO.Log.LogRecordSequence" /> courante.</summary>
        <value>Numéro de séquence le plus bas qui correspond à un enregistrement valide dans la <see cref="T:System.IO.Log.LogRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.  
  
 La valeur de cette propriété peut être modifiée en appelant la méthode <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> ou la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser le membre <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> dans une boucle.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération d'ajout asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>Commence une opération d'ajout asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="userRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>Commence une opération d'ajout asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>Commence une opération d'ajout asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="userRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>Commence une opération d'ajout asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Le numéro de séquence de l'enregistrement le plus récent doit être écrit. Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque le vidage est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête de vidage asynchrone particulière des autres requêtes.</param>
        <summary>Commence une opération de vidage asynchrone, en utilisant l'espace précédemment réservé dans la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui représente l'opération de vidage asynchrone qui pourrait être toujours en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer l'objet <xref:System.IAsyncResult> retourné par la méthode actuelle à la méthode <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> pour vous assurer de la fin du vidage et de la libération appropriée des ressources. Si une erreur se produit pendant un vidage asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 L'appel de cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.LogRecordSequence> sont écrits de façon durable.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête de vidage asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> n'est pas valide pour cette séquence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</exception>
        <exception cref="T:System.InvalidOperationException">Le journal spécifié n'a pas d'étendues. Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une réserve asynchrone et ajoute l'opération.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">Collection de réservations dans laquelle les réservations sont effectuées.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>Commence une réserve asynchrone et ajoute l'opération. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="userRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">Collection de réservations dans laquelle les réservations sont effectuées.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>Commence une réserve asynchrone et ajoute l'opération. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération asynchrone d'écriture de la zone de reprise.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSeqNum">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservation">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</param>
        <summary>Commence une opération asynchrone d'écriture de la zone de reprise en utilisant l'espace précédemment réservé dans la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l'espace qui a été réservé précédemment, à l'aide d'une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> n'est pas valide pour cette séquence.  
  
- ou - 
Le numéro de séquence de démarrage de l'énumération du journal spécifié n'est pas valide.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservation" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs paramètres ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.  
  
- ou - 
 <paramref name="newBaseSeqNum" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSeqNum">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservationCollection">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</param>
        <summary>Commence une opération asynchrone d'écriture de la zone de reprise en utilisant l'espace précédemment réservé dans la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l'espace qui a été réservé précédemment, à l'aide d'une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> n'est pas valide pour cette séquence.  
  
- ou - 
Le numéro de séquence de démarrage de l'énumération du journal spécifié n'est pas valide.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservationCollection" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs paramètres ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.  
  
- ou - 
 <paramref name="newBaseSeqNum" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un <see cref="T:System.IO.Log.ReservationCollection" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Objet <see cref="T:System.IO.Log.ReservationCollection" /> nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Les réservations peuvent être exécutées de deux manières, comme le montrent les exemples suivants. Vous pouvez adopter ces pratiques dans les exemples pour un traitement fiable. Notez que cette tâche ne peut être effectuée que lors de l'utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par le composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre comment utiliser <xref:System.IO.Log.LogRecordSequence.Dispose%2A> pour libérer les ressources :  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone en attente.</param>
        <summary>Termine une opération d'ajout asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> a déjà été appelé pour l'opération asynchrone.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone en attente.</param>
        <summary>Termine une opération de vidage asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence du dernier enregistrement écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête de vidage asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> a déjà été appelé pour l'opération asynchrone.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone en attente.</param>
        <summary>Termine une réserve asynchrone et ajoute l'opération. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> a déjà été appelé pour l'opération asynchrone.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone en attente.</param>
        <summary>Termine une opération d'écriture de la zone de reprise asynchrone. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> a déjà été appelé pour l'opération asynchrone.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les enregistrements ajoutés de façon durable</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que tous les enregistrements ajoutés ont été écrits. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence du dernier enregistrement écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel à cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.LogRecordSequence> sont écrits de façon durable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors du vidage des données.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.NotSupportedException">Cette opération n'est pas prise en charge.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.InvalidOperationException">Le journal spécifié n'a pas d'étendues. Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Le numéro de séquence de l'enregistrement le plus récent doit être écrit. Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</param>
        <summary>Veille à ce que tous les enregistrements ajoutés jusqu'à l'enregistrement du numéro de séquence spécifié inclus ont été écrits de façon durable. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence du dernier enregistrement écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel à cette méthode garantit que tous les enregistrements avec les numéros de séquence jusqu'à et y compris le numéro de séquence spécifié ont été écrits de façon durable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> n'est pas valide pour cette séquence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.</exception>
        <exception cref="T:System.InvalidOperationException">Le journal spécifié n'a pas d'étendues. Une ou plusieurs étendues doivent être créées avant qu'une séquence d'enregistrement puisse être utilisée.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le numéro de séquence supérieur au dernier enregistrement ajouté</summary>
        <value>Numéro de séquence supérieur au dernier enregistrement ajouté.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété contient un numéro de séquence dont la supériorité au numéro de séquence du dernier enregistrement ajouté est garantie. Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>. Tous les autres numéros de séquence ne sont pas valides.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la classe <see cref="T:System.IO.Log.LogStore" /> qui contient les données pour cette séquence d'enregistrement. Cette méthode ne peut pas être héritée.</summary>
        <value>Classe <see cref="T:System.IO.Log.LogStore" /> qui contient les données pour cette séquence d'enregistrement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple indique comment utiliser le membre <xref:System.IO.Log.LogRecordSequence.LogStore%2A> pour ajouter les étendues.  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille maximale d'un enregistrement pouvant être ajouté à cette séquence d'enregistrement.</summary>
        <value>Taille maximale d'un enregistrement pouvant être ajouté à cette séquence d'enregistrement.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numéro de séquence du premier enregistrement à partir duquel démarre la lecture.</param>
        <param name="logRecordEnum">Valeur <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valide qui spécifie le sens de lecture (c'est-à-dire, vers l'avant ou l'arrière) des enregistrements à partir d'une <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>Retourne une collection dénombrable des enregistrements de la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Collection dénombrable des enregistrements de la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne une collection dénombrable d’enregistrements dans la séquence. L'ordre des enregistrements énumérés dépend de la valeur du paramètre `logRecordEnum`.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> dans une boucle.  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="logRecordEnum" /> n'est pas valide.  
  
- ou - 
L’élément spécifié était introuvable dans la collection.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.  
  
- ou - 
La taille de la mémoire tampon utilisée pour écrire l'enregistrement du journal est plus grand que la taille de la mémoire tampon utilisée pour le lire.  
  
- ou - 
La séquence d'enregistrement est endommagée.  
  
- ou - 
Le format ou la version de fichier journal spécifié n'est pas valide.  
  
- ou - 
L'enregistrement a été écrit avec une version incompatible de la séquence d'enregistrement.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération n'est pas valide car l'énumération n'a pas été démarrée. Un appel à <see cref="M:System.Collections.IEnumerator.MoveNext" /> doit être fait.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection dénombrable des zones de reprise dans la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Collection dénombrable des zones de reprise dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les zones de reprise sont énumérées en ordre de numéro de séquence inverse, autrement dit, du numéro de séquence le plus élevé au numéro de séquence le plus bas. Seules les zones de reprise avec des numéros de séquence compris entre le dernier numéro de séquence et le numéro de séquence de base sont énumérées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.  
  
- ou - 
La taille de la mémoire tampon utilisée pour écrire l'enregistrement du journal est plus grand que la taille de la mémoire tampon utilisée pour le lire.  
  
- ou - 
La séquence d'enregistrement est endommagée.  
  
- ou - 
Le format ou la version de fichier journal spécifié n'est pas valide.  
  
- ou - 
L'enregistrement a été écrit avec une version incompatible de la séquence d'enregistrement.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération n'est pas valide car l'énumération n'a pas été démarrée. Un appel à <see cref="M:System.Collections.IEnumerator.MoveNext" /> doit être fait.  
  
- ou - 
L'énumération est terminée.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fait automatiquement une réservation unique et ajoute un enregistrement à la séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la collection dans laquelle sont effectuées les réservations.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <summary>Fait automatiquement une réservation unique et ajoute un enregistrement à la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
   
  
## Examples  
 L'exemple suivant montre comment utiliser cette méthode pour faire des réservations. Notez que cette tâche ne peut être effectuée que lors de l'utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas valide pour cette séquence.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservations" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="nextUndoRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="userRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">Collection de réservations dans laquelle les réservations sont effectuées.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <summary>Fait automatiquement une réservation unique et ajoute un enregistrement à la séquence. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.LogRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="userRecord" /> ou <paramref name="previousRecord" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.NotSupportedException">L'opération ne peut pas être effectuée car la séquence d'enregistrement a été ouverte en lecture seule.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">Aucune réservation assez grande pour <paramref name="data" /> ne se trouve dans <paramref name="reservations" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre total d'octets ayant été réservés.</summary>
        <value>Taille totale de toutes les réservations effectuées dans cette séquence d'enregistrement.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le numéro de séquence de la zone de reprise plus proche de la fin du journal.</summary>
        <value>Numéro de séquence de la zone de reprise plus proche de la fin du journal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 À l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>, vous pouvez supprimer la zone de reprise la plus récemment écrite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les opérations d'ajout sont réitérées automatiquement ou non, lorsque le journal est complet.</summary>
        <value>
          <see langword="true" /> si les opérations d'ajout sont réitérées automatiquement si le journal est complet ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de cette propriété est `true` et qu'un appel <xref:System.IO.Log.LogRecordSequence.Append%2A> échoue parce qu'il n'y a pas suffisamment d'espace dans la séquence, la séquence d'enregistrement essaie de libérer de l'espace et réitère l'opération d'ajout.  
  
   
  
## Examples  
 L'exemple suivant indique comment utiliser la propriété <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A>.  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Le nouveau dernier numéro de séquence dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.  
  
Il doit faire référence à un enregistrement valide actuellement présent dans le journal.</param>
        <summary>Définit le dernier enregistrement dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le numéro de séquence spécifié doit être supérieur au numéro de séquence de base.  
  
 À l'issue de cette méthode, tous les enregistrements précédemment ajoutés avec des numéros de séquence supérieurs à celui du numéro de séquence spécifié sont inaccessibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sequenceNumber" /> n'est pas valide pour cette séquence.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.  
  
- ou - 
 <paramref name="sequenceNumber" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La fin du journal a été atteinte.  
  
- ou - 
Le format ou la version de fichier journal spécifié n'est pas valide.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Signale la nécessité de déplacer la fin de la séquence.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déclencher cet événement lorsque la séquence d'enregistrement n'a plus d'espace disponible. Lorsque cet événement est déclenché, la fin de la séquence (c'est-à-dire, le numéro de séquence de base) est avancée pour libérer de l'espace.  
  
 L'événement peut être déclenché à n'importe quel moment lorsque la séquence d'enregistrement décide qu'elle doit libérer de l'espace, pour une raison quelconque. Par exemple, le moteur de stratégie CLFS peut décider de déclencher l'événement lorsqu'il détermine que les fins de deux clients de journal qui partagent le même fichier journal sont trop éloignées. La libération de l'espace peut se faire par écriture de zones de reprise ou par troncation du journal et utilisation de la méthode <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> pour supprimer de l'espace. L'exemple de code de la section Exemple illustre la deuxième approche.  
  
 Vous pouvez également appeler la méthode <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> en dehors de l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> pour libérer de l'espace. Une zone de reprise est semblable à un point de contrôle dans d'autres systèmes de traitement de journal. L'appel de cette méthode indique que l'application considère tous les enregistrements antérieurs avant la zone de reprise comme entièrement terminés et utilisables pour de futurs ajouts d'enregistrements. Tout comme pour les autres enregistrements, l'enregistrement écrit par cette méthode requiert de l'espace libre réel dans le journal pour fonctionner.  
  
   
  
## Examples  
 Cet exemple indique comme utiliser l'événement <xref:System.IO.Log.LogRecordSequence.TailPinned> :  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit une zone de reprise dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Segment de tableau qui sera concaténé et ajouté en tant qu'enregistrement.</param>
        <summary>Écrit une zone de reprise dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <summary>Écrit une zone de reprise dans la classe <see cref="T:System.IO.Log.LogRecordSequence" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs arguments ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSeqNum">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <summary>Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> et met à jour le numéro de séquence de base. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSeqNum">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <summary>Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> et met à jour le numéro de séquence de base. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSeqNum">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservations">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <summary>Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> à l'aide d'une réservation, et met à jour le numéro de séquence de base. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSeqNum">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservationCollection">
          <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <summary>Écrit une zone de reprise dans <see cref="T:System.IO.Log.LogRecordSequence" /> à l'aide d'une réservation, et met à jour le numéro de séquence de base. Cette méthode ne peut pas être héritée.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSeqNum" /> n'est pas valide pour cette séquence.  
  
- ou - 
Le numéro de séquence de démarrage de l'énumération du journal spécifié n'est pas valide.  
  
- ou - 
 <paramref name="data" /> ne peut pas être ajouté car il est supérieur à la taille d'enregistrement maximale.  
  
- ou - 
 <paramref name="reservationCollection" /> n'a pas été créé par cette séquence d'enregistrement.</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs paramètres ont la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une fin ou base d'archive nouvelle ou existante du journal actif n'est pas valide.  
  
- ou - 
 <paramref name="newBaseSeqNum" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.IO.IOException">La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue.  
  
- ou - 
La requête n'a pas pu être exécutée en raison d'une erreur de périphérique d'E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès à la séquence de journal spécifiée est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
  </Members>
</Type>