<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adacaf7496c7db7a02e095d22f09f62c37fe27be" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30419553" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente un stockage structuré par journal.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.IO.Log.LogRecordSequence> fournit une implémentation de l'interface de séquence d'enregistrement sur un journal CLFS (Common Log File System). Cela fonctionne avec la classe <xref:System.IO.Log.LogStore> qui fournit une interface pour manipuler et gérer directement un fichier journal CLFS. Un magasin de journaux fournit le stockage en ajout seul pour un ensemble d'étendues de disque. La classe <xref:System.IO.Log.LogStore> représente ce stockage et fournit des méthodes pour ajouter et supprimer des conteneurs, définir la stratégie et créer des archives. Elle ne fournit pas de méthodes pour lire et écrire à partir du stockage. Ces méthodes sont fournies par la classe <xref:System.IO.Log.LogRecordSequence>.  
  
 La relation entre la classe <xref:System.IO.Log.LogStore> et la classe <xref:System.IO.Log.LogRecordSequence> est similaire à la relation entre un fichier sur un disque et un objet <xref:System.IO.FileStream>. Le fichier sur disque fournit la mémoire physique et a des attributs tels que la longueur et le dernier temps d'accès, alors que l'objet <xref:System.IO.FileStream> fournit une vue sur le fichier qui peut être utilisée pour la lecture et l'écriture. De la même façon, la classe <xref:System.IO.Log.LogStore> a des attributs tels qu'une stratégie et une collection d'étendues de disque, et la classe <xref:System.IO.Log.LogRecordSequence> fournit un mécanisme orienté par enregistrement pour lire et écrire des données.  
  
 Contrairement à la séquence d'enregistrement de fichier représentée par la classe <xref:System.IO.Log.FileRecordSequence>, une instance <xref:System.IO.Log.LogStore> stocke ses données dans une collection d'étendues de disque, représentée par les instances <xref:System.IO.Log.LogExtent>. Les étendues dans une instance <xref:System.IO.Log.LogStore> donnée sont toutes de taille uniforme et l'espace est ajouté et supprimé d'une instance <xref:System.IO.Log.LogStore> par incréments d'étendue. Pour ajouter et supprimer des étendues de journal, utilisez les méthodes <xref:System.IO.Log.LogExtentCollection.Add%2A> et <xref:System.IO.Log.LogExtentCollection.Remove%2A> de l'objet <xref:System.IO.Log.LogExtentCollection>, qui peut être retourné par la propriété <xref:System.IO.Log.LogStore.Extents%2A>.  
  
 Des stratégies peuvent être associées à une instance <xref:System.IO.Log.LogStore>. Elles sont représentées par les instances <xref:System.IO.Log.LogPolicy> qui peuvent être retournées par la propriété <xref:System.IO.Log.LogStore.Policy%2A>. Une stratégie énonce les règles que le journal tente de suivre, tel que le nombre maximal d'étendues et la taille minimale, et fournit des instructions à propos de l'agrandissement ou de la réduction de la taille du <xref:System.IO.Log.LogStore> sous certaines conditions. De plus, vous pouvez spécifier si une instance <xref:System.IO.Log.LogStore> peut être archivée. Les stratégies sont définies par journal et ne sont pas rémanentes, ce qui signifie qu'une fois que chaque handle du journal est fermé, la stratégie n'existe plus.  
  
   
  
## Examples  
 L'exemple suivant montre comment archiver un <xref:System.IO.Log.LogStore> dans un document XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogStore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Un handle de fichier pour le fichier journal encapsulé par l'objet <see cref="T:System.IO.Log.LogStore" /> actif.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogStore" /> pour le handle spécifié.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le handle de journal n'a pas pu être lié au pool de threads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogStore" /> avec le chemin d'accès et le mode spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour ouvrir un magasin de journaux avec le chemin d’accès et le mode spécifiés. Le magasin est ouvert avec l'accès en lecture/écriture et il partage l'accès en lecture.  
  
 Le paramètre `path` doit utiliser la syntaxe suivante :  
  
 `log:<physical log name>[::<log client name>]`  
  
 où `<physical log name>` est un chemin d'accès valide à un fichier journal et `<log client name>` est un identificateur client unique. Un magasin de journaux doit être un magasin de journaux physique ou virtuel, mais pas les deux à la fois. Une fois qu'un magasin de journaux a été créé physiquement ou virtuellement, il reste ainsi pour sa durée de vie. Un magasin de journaux physique est créé en spécifiant uniquement le nom de journal physique. Un magasin de journaux virtuel est créé en spécifiant à la fois le nom de journal physique et le nom de journal client.  
  
 Les clients qui partagent le même nom de journal physique partagent la même collection et stratégie d’étendues.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Le <paramref name="path" /> est une chaîne vide ("").  
  
 - ou -  
  
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
 - ou -  
  
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS s'il est disponible pour votre plateforme ou utilisez à la place la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogStore" /> avec le chemin d'accès, le mode et l'accès spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour ouvrir un nouveau magasin de journaux avec le chemin d’accès, le mode et l’accès spécifiés. Le magasin est ouvert avec le partage d'accès en lecture.  
  
 Le paramètre `path` doit utiliser la syntaxe suivante :  
  
 `log:<physical log name>[::<log client name>]`  
  
 où `<physical log name>` est un chemin d'accès valide à un fichier journal et `<log client name>` est un identificateur client unique. Un magasin de journaux doit être un magasin de journaux physique ou virtuel, mais pas les deux à la fois. Une fois qu'un magasin de journaux a été créé physiquement ou virtuellement, il reste ainsi pour sa durée de vie. Un magasin de journaux physique est créé en spécifiant uniquement le nom de journal physique. Un magasin de journaux virtuel est créé en spécifiant à la fois le nom de journal physique et le nom de journal client.  
  
 Les clients qui partagent le même nom de journal physique partagent la même collection et stratégie d’étendues.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Le <paramref name="path" /> est une chaîne vide ("").  
  
 - ou -  
  
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
 - ou -  
  
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.  
  
 - ou -  
  
 <paramref name="access" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS s'il est disponible pour votre plateforme ou utilisez à la place la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">L'une des valeurs <see cref="T:System.IO.FileShare" /> qui détermine comment le magasin de journaux sera partagé parmi les processus.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés. Le magasin est ouvert avec le partage d'accès spécifié.  
  
 Le paramètre `path` doit utiliser la syntaxe suivante :  
  
 `log:<physical log name>[::<log client name>]`  
  
 où `<physical log name>` est un chemin d'accès valide à un fichier journal et `<log client name>` est un identificateur client unique. Un magasin de journaux doit être un magasin de journaux physique ou virtuel, mais pas les deux à la fois. Une fois qu'un magasin de journaux a été créé physiquement ou virtuellement, il reste ainsi pour sa durée de vie. Un magasin de journaux physique est créé en spécifiant uniquement le nom de journal physique. Un magasin de journaux virtuel est créé en spécifiant à la fois le nom de journal physique et le nom de journal client.  
  
 Les clients qui partagent le même nom de journal physique partagent la même collection et stratégie d’étendues.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Le <paramref name="path" /> est une chaîne vide ("").  
  
 - ou -  
  
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
 - ou -  
  
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.  
  
 - ou -  
  
 <paramref name="access" /> contient une valeur non valide.  
  
 - ou -  
  
 <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS s'il est disponible pour votre plateforme ou utilisez à la place la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu au fichier de base du magasin de journaux à ouvrir.</param>
        <param name="mode">L'une des valeurs <see cref="T:System.IO.FileMode" /> déterminant le mode d'ouverture ou de création du magasin.</param>
        <param name="access">Une des valeurs de <see cref="T:System.IO.FileAccess" /> déterminant le mode d'accès au fichier par le <see cref="T:System.IO.Log.LogStore" />.</param>
        <param name="share">L'une des valeurs <see cref="T:System.IO.FileShare" /> qui détermine comment le magasin de journaux sera partagé parmi les processus.</param>
        <param name="fileSecurity">Une des valeurs de <see cref="T:System.Security.AccessControl.FileSecurity" /> qui spécifie la sécurité à définir sur le magasin créé récemment si le magasin doit être créé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un nouvel objet <xref:System.IO.Log.LogStore> qu'il ouvre avec le chemin d'accès, le mode et l'accès spécifiés. Le magasin est ouvert avec le partage d'accès spécifié. Le paramètre `path` doit respecter la syntaxe suivante :  
  
 `log:<physical log name>[::<log client name>]`  
  
 où `<physical log name>` est un chemin d'accès valide à un fichier journal et `<log client name>` est un identificateur client unique. Un magasin de journaux doit être un magasin de journaux physique ou virtuel, mais pas les deux à la fois. Une fois qu'un magasin de journaux a été créé physiquement ou virtuellement, il reste ainsi pour sa durée de vie. Un magasin de journaux physique est créé en spécifiant uniquement le nom de journal physique. Un magasin de journaux virtuel est créé en spécifiant à la fois le nom de journal physique et le nom de journal client.  
  
 Les clients qui partagent le même nom de journal physique partagent la même collection et stratégie d’étendues.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom de fichier du magasin de journaux spécifié par le <paramref name="path" /> n'est pas valide.  
  
 - ou -  
  
 Le <paramref name="Mode" /> a la valeur <see langword="CreateNew" />, celui-ci ne peut pas être utilisé sans accès en écriture.  
  
 - ou -  
  
 Le <paramref name="Mode" /> a la valeur <see langword="OpenOrCreate" />, celui-ci ne peut pas être utilisé sans accès en écriture.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.  
  
 - ou -  
  
 <paramref name="access" /> contient une valeur non valide.  
  
 - ou -  
  
 <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.  
  
 Impossible d'accéder au fichier spécifié par le <paramref name="path" /> parce qu'il est utilisé par un autre processus.  
  
 - ou -  
  
 Le fichier spécifié par le <paramref name="path" /> ne peut pas être créé parce que le fichier ou le répertoire existe déjà.  
  
 - ou -  
  
 Le handle de journal n'a pas pu être lié au pool de threads.  
  
 - ou -  
  
 Le format ou la version de fichier journal spécifié n'est pas valide.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.IO.Log.LogStore" /> ne peut pas être utilisé parce que le composant CLFS (Common Log File System) requis n'est pas installé. Installez le composant CLFS s'il est disponible pour votre plateforme ou utilisez à la place la classe <see cref="T:System.IO.Log.FileRecordSequence" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cette instance <see cref="T:System.IO.Log.LogStore" /> peut être archivée.</summary>
        <value>
          <see langword="true" /> si cette instance <see cref="T:System.IO.Log.LogStore" /> peut être archivée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.IO.Log.LogStore> n'est pas archivable, les appels aux méthodes <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> et <xref:System.IO.Log.LogStore.SetArchiveTail%2A> provoquent une <xref:System.NotSupportedException> qui est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le numéro de séquence le plus bas qui correspond à un enregistrement valide dans cette instance <see cref="T:System.IO.Log.LogStore" />.</summary>
        <value>Numéro de séquence le plus bas qui correspond à un enregistrement valide dans cette instance <see cref="T:System.IO.Log.LogStore" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prend un instantané de l'état du magasin de journaux nécessaire pour effectuer une sauvegarde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prend un instantané de l'état du magasin de journaux pour effectuer une sauvegarde.</summary>
        <returns>Objet <see cref="T:System.IO.Log.LogArchiveSnapshot" /> qui contient l'état nécessaire pour effectuer un archivage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant montre comment archiver un <xref:System.IO.Log.LogStore> dans un document XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le magasin de journaux n'est pas archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de la création de l'instantané de l'archive.</exception>
        <exception cref="T:System.ArgumentException">Un argument n’est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération non valide a été exécutée.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">Numéro de séquence de lancement dans la plage à archiver.</param>
        <param name="last">Numéro de séquence de fin dans la plage à archiver.</param>
        <summary>Prend un instantané de l'état du magasin de journaux entre les numéros de séquence spécifiés pour effectuer une sauvegarde.</summary>
        <returns>Objet <see cref="T:System.IO.Log.LogArchiveSnapshot" /> qui contient l'état nécessaire pour effectuer un archivage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'instantané d'archive retourné à partir de cette méthode comprend des informations à partir du numéro de séquence de base ou du numéro de séquence d'archive (en fonction du numéro le plus petit) jusqu'au dernier numéro de séquence. Il n'est pas inclusif pour le dernier numéro de séquence, ce qui signifie que l'archive inclut seulement les enregistrements jusqu'au dernier numéro de séquence sans inclure ce dernier. De plus, lorsque cette méthode est utilisée, le SequenceNumber de départ doit être égal au BaseSequenceNumber pour que l'archive soit cohérente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="first" /> ou <paramref name="last" /> n'est pas compris entre le numéro de base et les derniers numéros de cette séquence.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="first" /> est supérieur à <paramref name="last" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération non valide a été exécutée.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de la création de l'instantané de l'archive.</exception>
        <exception cref="T:System.NotSupportedException">Le magasin de journaux n'est pas archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès relatif ou absolu pour le fichier de base du magasin de journaux à supprimer.</param>
        <summary>Supprime le magasin de journaux.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Le <paramref name="path" /> est une chaîne vide ("").  
  
 - ou -  
  
 <paramref name="path" /> contient l'espace blanc uniquement.  
  
 - ou -  
  
 Le <paramref name="path" /> contient un ou plusieurs caractères non valides.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de l'ouverture du magasin de journaux.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.IO.Log.LogStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.IO.Log.LogStore.Dispose%2A> après avoir utilisé <xref:System.IO.Log.LogStore>. La méthode <xref:System.IO.Log.LogStore.Dispose%2A> rend le <xref:System.IO.Log.LogStore> inutilisable. Après avoir appelé <xref:System.IO.Log.LogStore.Dispose%2A>, vous devez libérer toutes les références à <xref:System.IO.Log.LogStore> pour que le garbage collector puisse récupérer la mémoire occupée par <xref:System.IO.Log.LogStore>.  
  
> [!NOTE]
>  Appelez toujours <xref:System.IO.Log.LogStore.Dispose%2A> avant de libérer votre dernière référence à <xref:System.IO.Log.LogStore>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.IO.Log.LogStore> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des étendues de journal qui contient les données pour ce magasin de journaux.</summary>
        <value>Instance <see cref="T:System.IO.Log.LogExtentCollection" /> qui contient la collection d'étendues de journal qui encapsule des données pour ce magasin de journaux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance <xref:System.IO.Log.LogStore> stocke ses données dans une collection d'étendues de disque, représentée par les instances <xref:System.IO.Log.LogExtent>. Les étendues dans une instance <xref:System.IO.Log.LogStore> donnée sont toutes de taille uniforme et l'espace est ajouté et supprimé d'une instance <xref:System.IO.Log.LogStore> par incréments d'étendue. Pour ajouter et supprimer des étendues de journal, utilisez les méthodes <xref:System.IO.Log.LogExtentCollection.Add%2A> et <xref:System.IO.Log.LogExtentCollection.Remove%2A> de l'objet <xref:System.IO.Log.LogExtentCollection>, qui est retourné par cette propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'octets disponible dans le magasin de journaux.</summary>
        <value>Nombre d'octets disponible dans le magasin de journaux.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle de fichier du système d'exploitation pour le fichier journal encapsulé par l'instance <see cref="T:System.IO.Log.LogStore" /> active.</summary>
        <value>Handle de fichier du système d'exploitation pour le fichier journal encapsulé par l'instance <see cref="T:System.IO.Log.LogStore" /> active.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le numéro de séquence de l'enregistrement suivant à ajouter au magasin de journaux.</summary>
        <value>Numéro de séquence de l'enregistrement suivant à ajouter au magasin de journaux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille du magasin de journaux en octets.</summary>
        <value>Taille du magasin de journaux en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille du magasin de journaux équivaut à la somme des tailles des étendues de journal.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la stratégie associée à ce magasin de journaux.</summary>
        <value>Instance <see cref="T:System.IO.Log.LogPolicy" /> qui représente la stratégie associée à ce magasin de journaux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser l'instance <xref:System.IO.Log.LogPolicy> retournée par cette propriété pour examiner et manipuler la stratégie de journalisation associée avec ce <xref:System.IO.Log.LogStore>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">Numéro de séquence de la fin de l'archive.</param>
        <summary>Définit le numéro de séquence de la fin de l'archive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le plus petit numéro de séquence de base et la fin de l'archive déterminent la fin du journal.  
  
   
  
## Examples  
 L'exemple suivant montre comment archiver un <xref:System.IO.Log.LogStore> dans un document XML.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="archiveTail" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="archiveTail" /> n'est pas valide pour cette séquence.</exception>
        <exception cref="T:System.InvalidOperationException">Une opération non valide a été exécutée.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de la création de l'instantané de l'archive.</exception>
        <exception cref="T:System.NotSupportedException">Le magasin de journaux n'est pas archivable.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution d'un programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de flux de journal dans ce magasin de journaux.</summary>
        <value>Nombre de flux de journal dans ce magasin de journaux.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>