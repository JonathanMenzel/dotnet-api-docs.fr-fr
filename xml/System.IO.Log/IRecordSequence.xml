<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d561530c39638e8e109f6a6b52022d3f3e77384d" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53290805" /></Metadata><TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit une interface générique à une séquence d'enregistrements.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'interface <xref:System.IO.Log.IRecordSequence> fournit une interface abstraite à un flux orienté par enregistrement. Une instance <xref:System.IO.Log.IRecordSequence> peut être utilisée pour la lecture et l'écriture des enregistrements du journal.  
  
 L'interface <xref:System.IO.Log.IRecordSequence> fournit les fonctionnalités suivantes :  
  
-   Ajout des enregistrements du journal à l'aide des méthodes <xref:System.IO.Log.IRecordSequence.Append%2A>.  
  
-   Lecture des enregistrements ajoutés à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
-   Écriture d'un enregistrement de reprise spécial à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
-   Lecture des enregistrements de reprise à partir de l'enregistrement de reprise le plus récemment écrit à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
-   Vidage des enregistrements vers le magasin durable à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
-   Réservation d'espace pour ajouter des enregistrements.  
  
-   Libération d'espace dans le journal en avançant la base du journal.  
  
-   Réception de notifications d'événement <xref:System.IO.Log.IRecordSequence.TailPinned> pour déplacer la base du journal afin de libérer de l'espace.  
  
 Les enregistrements du journal sont ajoutés à une instance <xref:System.IO.Log.IRecordSequence> et un numéro de séquence unique est assigné à chaque enregistrement du journal. Les numéros de séquence augmentent de façon stricte et monotone dans une séquence d'enregistrement donnée. Un enregistrement du journal se compose de données opaques, fournies à l'instance <xref:System.IO.Log.IRecordSequence> dans une <xref:System.Collections.IList> d'ArraySegments en octets.  
  
 L'interface <xref:System.IO.Log.IRecordSequence> expose également quelques propriétés de base qui fournissent des informations à propos des limites de journal.  
  
-   La propriété <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> contient le numéro de séquence du premier enregistrement valide dans la séquence d'enregistrement.  
  
-   La propriété <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> contient un numéro de séquence dont la supériorité au numéro de séquence du dernier enregistrement ajouté est garantie.  
  
-   La propriété <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> contient le numéro de séquence de la dernière zone de reprise écrite.  
  
-   La propriété <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> contient la taille du plus grand enregistrement qu'il est possible d'ajouter ou de lire à partir de la séquence.  
  
-   La propriété <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> contient la taille totale de toutes les réservations faites dans cette séquence d'enregistrement.  
  
-   Si la propriété <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> a la valeur `true` et qu'une opération <xref:System.IO.Log.IRecordSequence.Append%2A> échoue parce qu'aucun espace n'est disponible dans la séquence, la séquence d'enregistrement essaie de libérer de l'espace et réitère l'opération d'ajout.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base de la séquence d'enregistrement.</param>
        <summary>Avance le numéro de séquence de base du journal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez une instance <xref:System.IO.Log.LogRecordSequence> et essayez d'avancer le numéro de séquence pour libérer de l'espace dans le journal, le nouveau numéro de séquence de base doit résider dans une étendue de journal différente pour que la portée précédente soit marquée comme vide. La libération partielle d'étendues n'est pas prise en charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newBaseSequenceNumber" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newBaseSequenceNumber" /> n'est pas actif dans le journal.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de la modification de la séquence.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, écrit un enregistrement du journal dans la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit un enregistrement du journal dans la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <summary>En cas de substitution dans une classe dérivée, ajoute un enregistrement du journal dans la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <summary>En cas de substitution dans une classe dérivée, ajoute un enregistrement du journal à la <see cref="T:System.IO.Log.IRecordSequence" />, à l'aide de l'espace précédemment réservé dans la séquence.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <summary>En cas de substitution dans une classe dérivée, ajoute un enregistrement du journal à la <see cref="T:System.IO.Log.IRecordSequence" />, à l'aide de l'espace précédemment réservé dans la séquence.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le numéro de séquence du premier enregistrement valide dans la <see cref="T:System.IO.Log.IRecordSequence" /> actuelle.</summary>
        <value>Numéro de séquence le plus bas qui correspond à un enregistrement valide dans la <see cref="T:System.IO.Log.IRecordSequence" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
 La valeur de cette propriété peut être modifiée en appelant la méthode <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> ou <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservations"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`. Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.  
  
 Normalement, cette méthode se termine avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Le numéro de séquence de l'enregistrement le plus récent doit être écrit. Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque le vidage est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête de vidage asynchrone particulière des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une opération de vidage asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui représente l'opération de vidage asynchrone qui pourrait être toujours en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer l'objet <xref:System.IAsyncResult> retourné par la méthode actuelle à la méthode <xref:System.IO.Log.IRecordSequence.EndFlush%2A> pour vous assurer de la fin du vidage et de la libération appropriée des ressources. Si une erreur se produit pendant un vidage asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndFlush%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 L'appel de cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.IRecordSequence> sont écrits de façon durable.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête de vidage asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndFlush%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors du vidage des données.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, commence une réserve asynchrone et une opération d'ajout.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">Collection de réservations dans laquelle les réservations sont effectuées.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une réserve asynchrone et une opération d'ajout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">Collection de réservations dans laquelle les réservations sont effectuées.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, commence une réserve asynchrone et une opération d'ajout.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, commence une opération asynchrone d'écriture de la zone de reprise.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, une opération asynchrone d'écriture de la zone de reprise commence en utilisant l'espace précédemment réservé dans la séquence.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> est appelée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <param name="callback">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</param>
        <summary>En cas de substitution dans une classe dérivée, une opération asynchrone d'écriture de la zone de reprise commence en utilisant l'espace précédemment réservé dans la séquence.</summary>
        <returns><see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée. Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.  
  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <returns>Objet <see cref="T:System.IO.Log.ReservationCollection" /> nouvellement créé.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone non traitée.</param>
        <summary>En cas de substitution dans une classe dérivée, met un terme à une opération d'ajout asynchrone.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndAppend%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone non traitée.</param>
        <summary>En cas de substitution dans une classe dérivée, met un terme à une opération de vidage asynchrone.</summary>
        <returns>Numéro de séquence du dernier enregistrement écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête de vidage asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndFlush%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone non traitée.</param>
        <summary>En cas de substitution dans une classe dérivée, met un terme à une réserve asynchrone et une opération d'ajout.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Référence à la requête d'E/S asynchrone non traitée.</param>
        <summary>En cas de substitution dans une classe dérivée, met un terme à une opération asynchrone d'écriture de la zone de reprise.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> est appelé.  
  
 Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, les enregistrements ajoutés sont écrits.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, garantit que tous les enregistrements ajoutés ont été écrits.</summary>
        <returns>Numéro de séquence du dernier enregistrement écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel à cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.IRecordSequence> sont écrits de façon durable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors du vidage des données.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">Le numéro de séquence de l'enregistrement le plus récent doit être écrit. Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</param>
        <summary>En cas de substitution dans une classe dérivée, garantit que tous les enregistrements ajoutés jusqu'à et y compris l'enregistrement avec le numéro de séquence spécifié, ont été écrits de façon durable.</summary>
        <returns>Numéro de séquence du dernier enregistrement écrit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel à cette méthode garantit que tous les enregistrements avec les numéros de séquence jusqu'à et y compris le numéro de séquence spécifié ont été écrits de façon durable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors du vidage des données.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le numéro de séquence qui est supérieur au dernier enregistrement ajouté.</summary>
        <value>Numéro de séquence supérieur au dernier enregistrement ajouté.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété contient un numéro de séquence dont la supériorité au numéro de séquence du dernier enregistrement ajouté est garantie. Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.  
  
> [!NOTE]
>  Lors de l'utilisation d'une instance <xref:System.IO.Log.LogRecordSequence>, la valeur <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> peut devenir obsolète jusqu'à ce que les enregistrements soient vidés dans le journal. Consultez <xref:System.IO.Log.IRecordSequence.Flush%2A> et <xref:System.IO.Log.RecordAppendOptions> pour plus d’informations sur le vidage des enregistrements. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la taille en octets du plus grand enregistrement qui peut être ajouté à ou peut être lu dans cette séquence.</summary>
        <value>Taille en octets du plus grand enregistrement qui peut être ajouté à ou peut être lu de cette séquence.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">Numéro de séquence du premier enregistrement à partir duquel démarre la lecture.</param>
        <param name="logRecordEnum">Valeur <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valide qui spécifie le sens de lecture (c'est-à-dire, vers l'avant ou l'arrière) des enregistrements à partir d'une <see cref="T:System.IO.Log.LogRecordSequence" />.</param>
        <summary>En cas de substitution dans une classe dérivée, retourne une collection dénombrable des enregistrements de la séquence.</summary>
        <returns>Collection dénombrable des enregistrements de la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cas de substitution dans une classe dérivée, retourne une collection dénombrable des enregistrements de la séquence. L'ordre des enregistrements énumérés dépend de la valeur du paramètre `logRecordEnum`.  
  
   
  
## Examples  
 Cet exemple illustre l'utilisation de la méthode <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de la lecture de l'enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, retourne une collection dénombrable des zones de reprise dans la séquence.</summary>
        <returns>Collection dénombrable des zones de reprise dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les zones de reprise sont énumérées en ordre de numéro de séquence inverse, autrement dit, du numéro de séquence le plus élevé au numéro de séquence le plus bas. Seules les zones de reprise avec des numéros de séquence compris entre le dernier numéro de séquence et le numéro de séquence de base sont énumérées.  
  
> [!NOTE]
>  Si la portée de journal qui contient <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> est endommagée, cette méthode peut lever une <xref:System.IO.IOException> avec le message d'erreur suivant : « La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue ». Le code d'erreur suivant a été retourné : '80070026'.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de la lecture de l'enregistrement.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, effectue automatiquement une réservation unique et ajoute un enregistrement à la séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la collection dans laquelle sont effectuées les réservations.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <summary>En cas de substitution dans une classe dérivée, effectue automatiquement une réservation unique et ajoute un enregistrement à la séquence.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="nextUndoRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</param>
        <param name="previousRecord">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</param>
        <param name="recordAppendOptions">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</param>
        <param name="reservationCollection">Collection de réservations dans laquelle les réservations sont effectuées.</param>
        <param name="reservations">Réservations à effectuer, en octets.</param>
        <summary>En cas de substitution dans une classe dérivée, effectue automatiquement une réservation unique et ajoute un enregistrement à la séquence.</summary>
        <returns>Numéro de séquence de l'enregistrement du journal ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.  
  
 Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement. Si l'ajout échoue, aucun espace n'est réservé.  
  
 Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit. Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le nombre total des octets réservés.</summary>
        <value>Taille totale de toutes les réservations effectuées dans cette séquence d'enregistrement.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le numéro de séquence de la zone de reprise la plus récemment écrite.</summary>
        <value>Numéro de séquence de la zone de reprise la plus récemment écrite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les opérations d'ajout sont réitérées automatiquement si le journal est complet.</summary>
        <value><see langword="true" /> si les opérations d'ajout sont réitérées automatiquement si le journal est complet ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de cette propriété est `true` et qu'un appel <xref:System.IO.Log.IRecordSequence.Append%2A> échoue parce qu'il n'y a pas suffisamment d'espace dans la séquence, la séquence d'enregistrement essaie de libérer de l'espace et réitère l'opération d'ajout.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'accès à la propriété a été effectué après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la séquence d'enregistrement spécifie que la fin doit être avancée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez déclencher cet événement lorsque la séquence d'enregistrement n'a plus d'espace disponible. Lorsque cet événement est déclenché, la fin de la séquence (c'est-à-dire, le numéro de séquence de base) est avancée pour libérer de l'espace.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération. Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide. Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.  
  
 Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" />.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération. Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> et met à jour le numéro de séquence de base.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération. Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> et met à jour le numéro de séquence de base.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération. Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> à l'aide d'une réservation et met à jour le numéro de séquence de base.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération. Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</param>
        <param name="newBaseSequenceNumber">Nouveau numéro de séquence de base. Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</param>
        <param name="reservation"><see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</param>
        <summary>En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> à l'aide d'une réservation et met à jour le numéro de séquence de base.</summary>
        <returns>Numéro de séquence de la zone de reprise écrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client. Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle. Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération. Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.  
  
 Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement. Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.  
  
 Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection. Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.  
  
 Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour. Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.  
  
 Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération. Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
      </Docs>
    </Member>
  </Members>
</Type>