<Type Name="IRecordSequence" FullName="System.IO.Log.IRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="301e893723a61251df23dd4b0b37c1d04c13674c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36562208" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IRecordSequence : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRecordSequence implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.IRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRecordSequence&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRecordSequence : IDisposable" />
  <TypeSignature Language="F#" Value="type IRecordSequence = interface&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="24495-101">Fournit une interface générique à une séquence d'enregistrements.</span>
      <span class="sxs-lookup">
        <span data-stu-id="24495-101">Provides a generic interface to a sequence of records.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-102">L'interface <xref:System.IO.Log.IRecordSequence> fournit une interface abstraite à un flux orienté par enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-102">The <xref:System.IO.Log.IRecordSequence> interface provides an abstract interface to a record-oriented stream.</span></span> <span data-ttu-id="24495-103">Une instance <xref:System.IO.Log.IRecordSequence> peut être utilisée pour la lecture et l'écriture des enregistrements du journal.</span><span class="sxs-lookup"><span data-stu-id="24495-103">A <xref:System.IO.Log.IRecordSequence> instance can be used to read and write log records.</span></span>  
  
 <span data-ttu-id="24495-104">L'interface <xref:System.IO.Log.IRecordSequence> fournit les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="24495-104">The <xref:System.IO.Log.IRecordSequence> interface provides the following capabilities,</span></span>  
  
-   <span data-ttu-id="24495-105">Ajout des enregistrements du journal à l'aide des méthodes <xref:System.IO.Log.IRecordSequence.Append%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-105">Append log records using the <xref:System.IO.Log.IRecordSequence.Append%2A> methods.</span></span>  
  
-   <span data-ttu-id="24495-106">Lecture des enregistrements ajoutés à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-106">Read the appended records using the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
-   <span data-ttu-id="24495-107">Écriture d'un enregistrement de reprise spécial à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-107">Write a special restart record using the <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
-   <span data-ttu-id="24495-108">Lecture des enregistrements de reprise à partir de l'enregistrement de reprise le plus récemment écrit à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-108">Read restart records from the most recently written restart record using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
-   <span data-ttu-id="24495-109">Vidage des enregistrements vers le magasin durable à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-109">Flush the records to durable store using the  <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
-   <span data-ttu-id="24495-110">Réservation d'espace pour ajouter des enregistrements.</span><span class="sxs-lookup"><span data-stu-id="24495-110">Reserve space for appending records.</span></span>  
  
-   <span data-ttu-id="24495-111">Libération d'espace dans le journal en avançant la base du journal.</span><span class="sxs-lookup"><span data-stu-id="24495-111">Free log space by advancing the base of the log.</span></span>  
  
-   <span data-ttu-id="24495-112">Réception de notifications d'événement <xref:System.IO.Log.IRecordSequence.TailPinned> pour déplacer la base du journal afin de libérer de l'espace.</span><span class="sxs-lookup"><span data-stu-id="24495-112">Receive <xref:System.IO.Log.IRecordSequence.TailPinned> event notifications to move the base of the log to free space.</span></span>  
  
 <span data-ttu-id="24495-113">Les enregistrements du journal sont ajoutés à une instance <xref:System.IO.Log.IRecordSequence> et un numéro de séquence unique est assigné à chaque enregistrement du journal.</span><span class="sxs-lookup"><span data-stu-id="24495-113">Log records are appended to a <xref:System.IO.Log.IRecordSequence> instance, and each log record is given a unique sequence number.</span></span> <span data-ttu-id="24495-114">Les numéros de séquence augmentent de façon stricte et monotone dans une séquence d'enregistrement donnée.</span><span class="sxs-lookup"><span data-stu-id="24495-114">Sequence numbers are strictly monotonically increasing within a given record sequence.</span></span> <span data-ttu-id="24495-115">Un enregistrement du journal se compose de données opaques, fournies à l'instance <xref:System.IO.Log.IRecordSequence> dans une <xref:System.Collections.IList> d'ArraySegments en octets.</span><span class="sxs-lookup"><span data-stu-id="24495-115">A log record consists of opaque data, supplied to the <xref:System.IO.Log.IRecordSequence> instance in an <xref:System.Collections.IList> of ArraySegments of bytes.</span></span>  
  
 <span data-ttu-id="24495-116">L'interface <xref:System.IO.Log.IRecordSequence> expose également quelques propriétés de base qui fournissent des informations à propos des limites de journal.</span><span class="sxs-lookup"><span data-stu-id="24495-116">The <xref:System.IO.Log.IRecordSequence> interface also exposes a few basic properties which provides information about log boundaries.</span></span>  
  
-   <span data-ttu-id="24495-117">La propriété <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> contient le numéro de séquence du premier enregistrement valide dans la séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-117">The <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> property contains the sequence number of the first valid record in the record sequence.</span></span>  
  
-   <span data-ttu-id="24495-118">La propriété <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> contient un numéro de séquence dont la supériorité au numéro de séquence du dernier enregistrement ajouté est garantie.</span><span class="sxs-lookup"><span data-stu-id="24495-118">The <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A> property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span>  
  
-   <span data-ttu-id="24495-119">La propriété <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> contient le numéro de séquence de la dernière zone de reprise écrite.</span><span class="sxs-lookup"><span data-stu-id="24495-119">The <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A> property contains the sequence number of the last written restart area.</span></span>  
  
-   <span data-ttu-id="24495-120">La propriété <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> contient la taille du plus grand enregistrement qu'il est possible d'ajouter ou de lire à partir de la séquence.</span><span class="sxs-lookup"><span data-stu-id="24495-120">The <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A> property contains the size of the largest record that can be appended to, or read from the sequence.</span></span>  
  
-   <span data-ttu-id="24495-121">La propriété <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> contient la taille totale de toutes les réservations faites dans cette séquence d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-121">The <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A> property contains the total size of all reservations made in this record sequence.</span></span>  
  
-   <span data-ttu-id="24495-122">Si la propriété <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> a la valeur `true` et qu'une opération <xref:System.IO.Log.IRecordSequence.Append%2A> échoue parce qu'aucun espace n'est disponible dans la séquence, la séquence d'enregistrement essaie de libérer de l'espace et réitère l'opération d'ajout.</span><span class="sxs-lookup"><span data-stu-id="24495-122">If the <xref:System.IO.Log.IRecordSequence.RetryAppend%2A> property is set to `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> operation fails because there is no space in the sequence, the record sequence will attempt to free space, and retry the Append operation.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="iRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-123">Nouveau numéro de séquence de base de la séquence d'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-123">The new base sequence number of the record sequence.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-124">Avance le numéro de séquence de base du journal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-124">Moves the base sequence number of the log forward.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-125">Lorsque vous utilisez une instance <xref:System.IO.Log.LogRecordSequence> et essayez d'avancer le numéro de séquence pour libérer de l'espace dans le journal, le nouveau numéro de séquence de base doit résider dans une étendue de journal différente pour que la portée précédente soit marquée comme vide.</span><span class="sxs-lookup"><span data-stu-id="24495-125">When you use a <xref:System.IO.Log.LogRecordSequence> instance and try to advance the sequence number to free up space in the log, the new base sequence number must reside in a different log extent for the previous extent to be marked as empty.</span></span> <span data-ttu-id="24495-126">La libération partielle d'étendues n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="24495-126">Freeing extents partially is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-127">
            <paramref name="newBaseSequenceNumber" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-127">
              <paramref name="newBaseSequenceNumber" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="24495-128">
            <paramref name="newBaseSequenceNumber" /> n'est pas actif dans le journal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-128">
              <paramref name="newBaseSequenceNumber" /> is not active in the log.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-129">Une erreur d'E/S s'est produite lors de la modification de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-129">An I/O error occurred while modifying the sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-130">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-130">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-131">La séquence d'enregistrement est complète.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-131">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-132">En cas de substitution dans une classe dérivée, écrit un enregistrement du journal dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-132">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-133">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-133">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-134">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-134">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-135">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-135">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-136">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-136">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-137">En cas de substitution dans une classe dérivée, écrit un enregistrement du journal dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-137">When overridden in a derived class, writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-138">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-138">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-139">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-139">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-140">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-140">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-141">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-141">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-142">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-142">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-143">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-143">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-144">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-144">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-145">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-145">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-146">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-146">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-147">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-147">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-148">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-148">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-149">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-149">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-150">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-150">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-151">En cas de substitution dans une classe dérivée, ajoute un enregistrement du journal dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-151">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-152">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-152">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-153">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-153">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-154">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-154">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-155">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-155">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-156">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-156">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-157">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-157">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-158">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-158">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-159">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-159">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-160">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-160">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-161">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-161">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-162">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-162">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-163">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-163">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-164">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-164">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-165">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-165">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-166">En cas de substitution dans une classe dérivée, ajoute un enregistrement du journal à la <see cref="T:System.IO.Log.IRecordSequence" />, à l'aide de l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-166">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-167">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-167">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-168">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-168">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-169">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-169">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-170">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="24495-170">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="24495-171">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-171">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-172">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-172">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-173">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-173">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-174">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-174">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-175">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-175">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-176">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-176">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-177">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-177">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-178">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-178">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-179">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-179">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-180">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-180">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-181">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-181">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-182">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-182">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-183">En cas de substitution dans une classe dérivée, ajoute un enregistrement du journal à la <see cref="T:System.IO.Log.IRecordSequence" />, à l'aide de l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-183">When overridden in a derived class, appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-184">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-184">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-185">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-185">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-186">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-186">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-187">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="24495-187">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="24495-188">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-188">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-189">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-189">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-190">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-190">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-191">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-191">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-192">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-192">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-193">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-193">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-194">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-194">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-195">En cas de substitution dans une classe dérivée, obtient le numéro de séquence du premier enregistrement valide dans la <see cref="T:System.IO.Log.IRecordSequence" /> actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-195">When overridden in a derived class, gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24495-196">Numéro de séquence le plus bas qui correspond à un enregistrement valide dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-196">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-197">Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-197">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="24495-198">La valeur de cette propriété peut être modifiée en appelant la méthode <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> ou <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-198">The value of this property can be changed by calling the <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A> or <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-199">L'accès à la propriété a été effectué après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-199">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-200">En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-200">When overridden in a derived class, begins an asynchronous append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-201">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-201">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-202">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-202">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-203">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-203">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-204">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-204">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-205">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-205">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-206">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-206">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-207">En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-207">When overridden in a derived class, begins an asynchronous append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-208">
            <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-208">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-209">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-209">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-210">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-210">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-211">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-211">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-212">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-212">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-213">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-213">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-214">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-214">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-215">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-215">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-216">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-216">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-217">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-217">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-218">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-218">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-219">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-219">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-220">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-220">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-221">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-221">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-222">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-222">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-223">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-223">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-224">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-224">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-225">En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-225">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-226">
            <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-226">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-227">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-227">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-228">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-228">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-229">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-229">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-230">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-230">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-231">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-231">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-232">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-232">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-233">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-233">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-234">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-234">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-235">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-235">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-236">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-236">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-237">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-237">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-238">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-238">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-239">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-239">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-240">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-240">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-241">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-241">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-242">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-242">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-243">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-243">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-244">En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-244">When overridden in a derived class, begins an asynchronous append operation using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-245">
            <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-245">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-246">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-246">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-247">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-247">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-248">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-248">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-249">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-249">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-250">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="24495-250">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="24495-251">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-251">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-252">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-252">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-253">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-253">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-254">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-254">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-255">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-255">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-256">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-256">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-257">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-257">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousUndoRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousUndoRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginAppend (data, nextUndoRecord, previousUndoRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-258">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-258">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-259">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-259">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousUndoRecord">
          <span data-ttu-id="24495-260">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-260">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-261">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-261">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-262">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cet enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-262">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-263">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-263">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-264">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-264">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-265">En cas de substitution dans une classe dérivée, commence une opération d'ajout asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-265">When overridden in a derived class, begins an asynchronous append operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-266">
            <see cref="T:System.IAsyncResult" /> qui représente l'ajout asynchrone qui pourrait toujours être en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-266">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-267">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-267">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-268">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-268">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-269">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-269">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-270">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-270">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-271">L'enregistrement ajouté utilisera l'espace qui a été réservé précédemment, à l'aide d'une réservation spécifiée par le paramètre `reservations`.</span><span class="sxs-lookup"><span data-stu-id="24495-271">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="24495-272">Si l’ajout réussit, il utilisera la plus petite zone de réservation qui peut stocker les données et cette zone de réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-272">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-273">Normalement, cette méthode se termine avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-273">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="24495-274">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-274">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-275">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-275">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-276">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-276">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-277">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-277">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-278">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-278">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="24495-279">Le numéro de séquence de l'enregistrement le plus récent doit être écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-279">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="24495-280">Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-280">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-281">Rappel asynchrone facultatif à appeler lorsque le vidage est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-281">An optional asynchronous callback, to be called when the flush is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-282">Objet fourni par l'utilisateur qui distingue cette requête de vidage asynchrone particulière des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-282">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-283">En cas de substitution dans une classe dérivée, commence une opération de vidage asynchrone à l'aide de l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-283">When overridden in a derived class, begins an asynchronous flush operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-284">Objet <see cref="T:System.IAsyncResult" /> qui représente l'opération de vidage asynchrone qui pourrait être toujours en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-284">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-285">Vous devez passer l'objet <xref:System.IAsyncResult> retourné par la méthode actuelle à la méthode <xref:System.IO.Log.IRecordSequence.EndFlush%2A> pour vous assurer de la fin du vidage et de la libération appropriée des ressources.</span><span class="sxs-lookup"><span data-stu-id="24495-285">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="24495-286">Si une erreur se produit pendant un vidage asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndFlush%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-286">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-287">L'appel de cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.IRecordSequence> sont écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="24495-287">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="24495-288">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-288">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-289">Lorsque des erreurs se sont produites pendant une requête de vidage asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndFlush%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-289">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-290">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-290">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-291">Une erreur d'E/S s'est produite lors du vidage des données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-291">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-292">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-292">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-293">En cas de substitution dans une classe dérivée, commence une réserve asynchrone et une opération d'ajout.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-293">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-294">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-294">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-295">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-295">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-296">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-296">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-297">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-297">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="24495-298">Collection de réservations dans laquelle les réservations sont effectuées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-298">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-299">Réservations à effectuer, en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-299">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-300">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-300">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-301">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-301">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-302">En cas de substitution dans une classe dérivée, commence une réserve asynchrone et une opération d'ajout.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-302">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-303">
            <see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-303">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-304">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-304">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-305">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-305">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-306">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-306">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-307">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-307">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-308">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-308">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="24495-309">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="24495-309">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="24495-310">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-310">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="24495-311">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-311">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="24495-312">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-312">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-313">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-313">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-314">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-314">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-315">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-315">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-316">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-316">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-317">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-317">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-318">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-318">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-319">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-319">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-320">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-320">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-321">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-321">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="24495-322">Collection de réservations dans laquelle les réservations sont effectuées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-322">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-323">Réservations à effectuer, en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-323">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-324">Rappel asynchrone facultatif à appeler lorsque l'ajout est terminé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-324">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-325">Objet fourni par l'utilisateur qui distingue cette requête d'ajout asynchrone spécifique des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-325">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-326">En cas de substitution dans une classe dérivée, commence une réserve asynchrone et une opération d'ajout.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-326">When overridden in a derived class, begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-327">
            <see cref="T:System.IAsyncResult" /> qui représente l'opération asynchrone qui pourrait être toujours en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-327">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-328">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> pour vous assurer que l'opération d'ajout est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-328">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-329">Si une erreur s'est produite pendant un ajout asynchrone, une exception n'est pas levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-329">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-330">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-330">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-331">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-331">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-332">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-332">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="24495-333">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="24495-333">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="24495-334">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-334">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="24495-335">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-335">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="24495-336">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-336">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-337">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-337">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-338">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-338">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-339">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-339">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-340">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-340">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-341">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-341">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-342">En cas de substitution dans une classe dérivée, commence une opération asynchrone d'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-342">When overridden in a derived class, begins an asynchronous restart area write operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-343">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-343">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-344">Nouveau numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-344">The new base sequence number.</span>
          </span>
          <span data-ttu-id="24495-345">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-345">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="24495-346">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-346">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-347">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-347">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-348">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-348">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-349">En cas de substitution dans une classe dérivée, une opération asynchrone d'écriture de la zone de reprise commence en utilisant l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-349">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-350">
            <see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-350">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-351">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-351">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method, to assure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-352">Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-352">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-353">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-353">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-354">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-354">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-355">Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="24495-355">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="24495-356">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="24495-356">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="24495-357">Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l'espace qui a été réservé précédemment, à l'aide d'une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-357">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="24495-358">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-358">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-359">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-359">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-360">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-360">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="iRecordSequence.BeginWriteRestartArea (data, newBaseSequenceNumber, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-361">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-361">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-362">Nouveau numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-362">The new base sequence number.</span>
          </span>
          <span data-ttu-id="24495-363">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-363">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="24495-364">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-364">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="24495-365">Rappel asynchrone facultatif à appeler lorsque l'écriture de la zone de reprise est terminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-365">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="24495-366">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone de la zone de reprise des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-366">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-367">En cas de substitution dans une classe dérivée, une opération asynchrone d'écriture de la zone de reprise commence en utilisant l'espace précédemment réservé dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-367">When overridden in a derived class, begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-368">
            <see cref="T:System.IAsyncResult" /> qui représente l'opération d'écriture asynchrone de la zone de reprise qui pourrait être encore en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-368">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-369">Vous devez passer le <xref:System.IAsyncResult> retourné par cette méthode à la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> pour vous assurer que l'opération d'écriture de la zone de reprise est terminée et que des ressources peuvent être libérées de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="24495-369">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="24495-370">Si une erreur se produit pendant une opération d'écriture asynchrone de la zone de reprise, aucune exception n'est levée tant que la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> n'est pas appelée avec le <xref:System.IAsyncResult> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="24495-370">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="24495-371">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-371">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-372">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-372">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-373">Lorsque l'opération se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="24495-373">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="24495-374">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="24495-374">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="24495-375">Si une <xref:System.IO.Log.ReservationCollection> est spécifiée, la zone de reprise écrite utilise l'espace qui a été réservé précédemment, à l'aide d'une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-375">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="24495-376">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-376">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-377">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-377">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-378">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-378">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-379">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-379">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-380">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-380">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-381">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-381">The record sequence could not make enough free space to contain the new record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-382">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-382">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="iRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="24495-383">En cas de substitution dans une classe dérivée, crée <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-383">When overridden in a derived class, creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-384">Objet <see cref="T:System.IO.Log.ReservationCollection" /> nouvellement créé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-384">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-385">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-385">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="24495-386">Référence à la requête d'E/S asynchrone en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-386">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-387">En cas de substitution dans une classe dérivée, met un terme à une opération d'ajout asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-387">When overridden in a derived class, ends an asynchronous append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-388">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-388">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-389">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="24495-389">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="24495-390">Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndAppend%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="24495-390">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="24495-391">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-391">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-392">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-392">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-393">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-393">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="24495-394">Référence à la requête d'E/S asynchrone en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-394">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-395">En cas de substitution dans une classe dérivée, met un terme à une opération de vidage asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-395">When overridden in a derived class, ends an asynchronous flush operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-396">Numéro de séquence du dernier enregistrement écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-396">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-397">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="24495-397">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="24495-398">Les erreurs qui se produisent pendant une requête de vidage asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndFlush%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="24495-398">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="24495-399">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-399">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-400">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-400">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-401">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-401">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="24495-402">Référence à la requête d'E/S asynchrone en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-402">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-403">En cas de substitution dans une classe dérivée, met un terme à une réserve asynchrone et une opération d'ajout.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-403">When overridden in a derived class, ends an asynchronous reserve and append operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-404">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-404">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-405">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="24495-405">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="24495-406">Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="24495-406">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="24495-407">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-407">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-408">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-408">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-409">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-409">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="24495-410">Référence à la requête d'E/S asynchrone en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-410">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-411">En cas de substitution dans une classe dérivée, met un terme à une opération asynchrone d'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-411">When overridden in a derived class, ends an asynchronous restart area write operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-412">Numéro de séquence de l'enregistrement du journal écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-412">The sequence number of the written log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-413">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="24495-413">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="24495-414">Les erreurs qui se produisent pendant une requête d'écriture asynchrone, telle qu'une défaillance du disque pendant la requête d'E/S, deviennent visibles lorsque <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> est appelé.</span><span class="sxs-lookup"><span data-stu-id="24495-414">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="24495-415">Cette méthode doit être appelée une seule et unique fois pour chaque <xref:System.IAsyncResult> retourné par la méthode <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-415">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-416">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-416">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-417">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-417">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-418">En cas de substitution dans une classe dérivée, les enregistrements ajoutés sont écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-418">When overridden in a derived class, causes appended records to be written.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="24495-419">En cas de substitution dans une classe dérivée, garantit que tous les enregistrements ajoutés ont été écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-419">When overridden in a derived class, ensures that all appended records have been written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-420">Numéro de séquence du dernier enregistrement écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-420">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-421">L'appel à cette méthode permet de vous assurer que tous les enregistrements ajoutés à la <xref:System.IO.Log.IRecordSequence> sont écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="24495-421">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.IRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-422">Une erreur d'E/S s'est produite lors du vidage des données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-422">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-423">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-423">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="24495-424">Le numéro de séquence de l'enregistrement le plus récent doit être écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-424">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="24495-425">Si <see cref="T:System.IO.Log.SequenceNumber" /> n'est pas valide, alors tous les enregistrements doivent être écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-425">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-426">En cas de substitution dans une classe dérivée, garantit que tous les enregistrements ajoutés jusqu'à et y compris l'enregistrement avec le numéro de séquence spécifié, ont été écrits de façon durable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-426">When overridden in a derived class, ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-427">Numéro de séquence du dernier enregistrement écrit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-427">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-428">L'appel à cette méthode garantit que tous les enregistrements avec les numéros de séquence jusqu'à et y compris le numéro de séquence spécifié ont été écrits de façon durable.</span><span class="sxs-lookup"><span data-stu-id="24495-428">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-429">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-429">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-430">Une erreur d'E/S s'est produite lors du vidage des données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-430">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-431">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-431">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-432">En cas de substitution dans une classe dérivée, obtient le numéro de séquence qui est supérieur au dernier enregistrement ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-432">When overridden in a derived class, gets the sequence number which is greater than the last record appended.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24495-433">Numéro de séquence supérieur au dernier enregistrement ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-433">A sequence number which is greater than the last record appended.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-434">Cette propriété contient un numéro de séquence dont la supériorité au numéro de séquence du dernier enregistrement ajouté est garantie.</span><span class="sxs-lookup"><span data-stu-id="24495-434">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="24495-435">Les numéros de séquence valides sont supérieurs ou égaux à <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> et inférieurs à <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-435">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="24495-436">Lors de l'utilisation d'une instance <xref:System.IO.Log.LogRecordSequence>, la valeur <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> peut devenir obsolète jusqu'à ce que les enregistrements soient vidés dans le journal.</span><span class="sxs-lookup"><span data-stu-id="24495-436">When using a <xref:System.IO.Log.LogRecordSequence> instance, the <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> value can become out of date until records are flushed to the log.</span></span> <span data-ttu-id="24495-437">Voir <xref:System.IO.Log.IRecordSequence.Flush%2A> et <xref:System.IO.Log.RecordAppendOptions> pour plus d'informations sur le vidage des enregistrements.</span><span class="sxs-lookup"><span data-stu-id="24495-437">See <xref:System.IO.Log.IRecordSequence.Flush%2A> and <xref:System.IO.Log.RecordAppendOptions> for more information on flushing records..</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-438">L'accès à la propriété a été effectué après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-438">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.IRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-439">En cas de substitution dans une classe dérivée, obtient la taille en octets du plus grand enregistrement qui peut être ajouté à ou peut être lu dans cette séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-439">When overridden in a derived class, gets the size of the largest record that can be appended to or read from this sequence, in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24495-440">Taille en octets du plus grand enregistrement qui peut être ajouté à ou peut être lu de cette séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-440">The size of the largest record that can be appended to or read from this sequence, in bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-441">L'accès à la propriété a été effectué après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-441">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="24495-442">Numéro de séquence du premier enregistrement à partir duquel démarre la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-442">The sequence number of the first record where the reading starts.</span>
          </span>
        </param>
        <param name="logRecordEnum">
          <span data-ttu-id="24495-443">Valeur <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> valide qui spécifie le sens de lecture (c'est-à-dire, vers l'avant ou l'arrière) des enregistrements à partir d'une <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-443">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-444">En cas de substitution dans une classe dérivée, retourne une collection dénombrable des enregistrements de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-444">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-445">Collection dénombrable des enregistrements de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-445">An enumerable collection of records in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-446">En cas de substitution dans une classe dérivée, retourne une collection dénombrable des enregistrements de la séquence.</span><span class="sxs-lookup"><span data-stu-id="24495-446">When overridden in a derived class, returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="24495-447">L'ordre des enregistrements énumérés dépend de la valeur du paramètre `logRecordEnum`.</span><span class="sxs-lookup"><span data-stu-id="24495-447">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="24495-448">Cet exemple illustre l'utilisation de la méthode <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-448">This sample demonstrates the use of the <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A> method.</span></span>  
  
```csharp  
using System;  
 using System.IO;  
 using System.IO.Log;  
  
 class ReadRecordsSample  
 {  
     static SequenceNumber AppendRecord(IRecordSequence sequence,  
                                        string message,  
                                        SequenceNumber user,  
                                        SequenceNumber previous)  
     {  
         MemoryStream data = new MemoryStream();  
         BinaryWriter writer = new BinaryWriter(data);  
         writer.Write(message);  
  
         ArraySegment<byte>[] segments;  
         segments = new ArraySegment<byte>[1];  
         segments[0] = new ArraySegment(data.GetBuffer(),  
                                        0,  
                                        Data.Length);  
  
         return sequence.Append(segments,  
                                user,  
                                previous,  
                                WriteFlags.None);  
     }  
  
     public static void Main(string[] args)  
     {  
         IRecordSequence sequence;  
         sequence = new FileIRecordSequence(args[0]);  
  
         SequenceNumber a, b, c, d;  
  
         a = AppendRecord(sequence,  
                          "This is record A",  
                          SequenceNumber.Invalid,  
                          SequenceNumber.Invalid);  
         Console.WriteLine("Record A has sequence number System.IO.Log", a);  
  
         b = AppendRecord(sequence,  
                          "This is record B",  
                          a,  
                          a);  
         Console.WriteLine("Record B has sequence number System.IO.Log", b);  
  
         c = AppendRecord(sequence,  
                          "This is record C",  
                          a,  
                          a);  
         Console.WriteLine("Record C has sequence number System.IO.Log", c);  
  
         d = AppendRecord(sequence,  
                          "This is record D",  
                          b,  
                          c);  
         Console.WriteLine("Record D has sequence number System.IO.Log", d);  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(a, ReadDirection.Forward))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.User))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
  
         foreach(LogRecord record in  
                 sequence.ReadLogRecords(d, ReadDirection.Previous))  
         {  
             BinaryReader reader = new BinaryReader(record.Data);  
             Console.WriteLine("System.IO.Log: T:System.IO.Log.IRecordSequence",  
                               record.SequenceNumber,  
                               reader.ReadString());  
         }  
     }  
       }  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-449">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-449">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-450">Une erreur d'E/S s'est produite lors de la lecture de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-450">An I/O error occurred while reading the record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-451">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-451">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="iRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="24495-452">En cas de substitution dans une classe dérivée, retourne une collection dénombrable des zones de reprise dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-452">When overridden in a derived class, returns an enumerable collection of the restart areas in the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-453">Collection dénombrable des zones de reprise dans la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-453">An enumerable collection of the restart areas in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-454">Les zones de reprise sont énumérées en ordre de numéro de séquence inverse, autrement dit, du numéro de séquence le plus élevé au numéro de séquence le plus bas.</span><span class="sxs-lookup"><span data-stu-id="24495-454">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="24495-455">Seules les zones de reprise avec des numéros de séquence compris entre le dernier numéro de séquence et le numéro de séquence de base sont énumérées.</span><span class="sxs-lookup"><span data-stu-id="24495-455">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="24495-456">Si la portée de journal qui contient <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> est endommagée, cette méthode peut lever une <xref:System.IO.IOException> avec le message d'erreur suivant : « La requête n'a pas pu être exécutée en raison d'une exception d'E/S inattendue ».</span><span class="sxs-lookup"><span data-stu-id="24495-456">If the log extent containing the <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> becomes corrupted, this method can throw an <xref:System.IO.IOException> with the error message "The request could not be performed because of an unexpected I/O exception.</span></span> <span data-ttu-id="24495-457">Le code d'erreur suivant a été retourné : '80070026'.</span><span class="sxs-lookup"><span data-stu-id="24495-457">The following error code was returned: '80070026'".</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-458">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-458">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-459">Une erreur d'E/S s'est produite lors de la lecture de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-459">An I/O error occurred while reading the record.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-460">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-460">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-461">En cas de substitution dans une classe dérivée, effectue automatiquement une réservation unique et ajoute un enregistrement à la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-461">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-462">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-462">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-463">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-463">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-464">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-464">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-465">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-465">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="24495-466">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la collection dans laquelle sont effectuées les réservations.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-466">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-467">Réservations à effectuer, en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-467">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-468">En cas de substitution dans une classe dérivée, effectue automatiquement une réservation unique et ajoute un enregistrement à la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-468">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-469">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-469">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-470">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-470">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-471">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-471">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-472">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-472">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="24495-473">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="24495-473">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="24495-474">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-474">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="24495-475">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-475">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-476">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-476">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-477">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-477">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-478">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-478">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-479">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-479">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-480">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-480">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="24495-481">Numéro de séquence de l'enregistrement suivant dans l'ordre spécifié par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-481">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="24495-482">Numéro de séquence de l'enregistrement suivant dans l'ordre précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-482">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="24495-483">Une valeur valide de <see cref="T:System.IO.Log.RecordAppendOptions" /> qui spécifie comment les données doivent être écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-483">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="24495-484">Collection de réservations dans laquelle les réservations sont effectuées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-484">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="24495-485">Réservations à effectuer, en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-485">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-486">En cas de substitution dans une classe dérivée, effectue automatiquement une réservation unique et ajoute un enregistrement à la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-486">When overridden in a derived class, automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-487">Numéro de séquence de l'enregistrement du journal ajouté.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-487">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-488">Les données contenues dans le paramètre `data` seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-488">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-489">Toutefois, il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-489">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="24495-490">Les réservations spécifiées sont ajoutées à la collection de réservations fournie dans une opération atomique avec une opération d'ajout d'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-490">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="24495-491">Si l'ajout échoue, aucun espace n'est réservé.</span><span class="sxs-lookup"><span data-stu-id="24495-491">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="24495-492">Normalement, cette méthode doit se terminer avant que l'enregistrement ait été écrit.</span><span class="sxs-lookup"><span data-stu-id="24495-492">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="24495-493">Pour vous assurer de l'écriture d'un enregistrement, spécifiez l'indicateur <xref:System.IO.Log.RecordAppendOptions.ForceFlush> à l'aide du paramètre `recordAppendOptions` ou appelez la méthode <xref:System.IO.Log.IRecordSequence.Flush%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-493">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-494">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-494">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-495">Une erreur d'E/S s'est produite lors de l'ajout de l'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-495">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-496">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker le nouvel enregistrement ou effectuer la réservation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-496">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-497">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-497">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.IRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-498">En cas de substitution dans une classe dérivée, obtient le nombre total des octets réservés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-498">When overridden in a derived class, gets the total number of bytes that have been reserved.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24495-499">Taille totale de toutes les réservations effectuées dans cette séquence d'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-499">The total size of all reservations made in this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-500">L'accès à la propriété a été effectué après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-500">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.IRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-501">En cas de substitution dans une classe dérivée, obtient le numéro de séquence de la zone de reprise la plus récemment écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-501">When overridden in a derived class, gets the sequence number of the most recently written restart area.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24495-502">Numéro de séquence de la zone de reprise la plus récemment écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-502">The sequence number of the most recently written restart area.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-503">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-503">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-504">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-504">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-505">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-505">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-506">L'accès à la propriété a été effectué après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-506">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.IRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-507">Obtient ou définit une valeur qui indique si les opérations d'ajout sont réitérées automatiquement si le journal est complet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-507">Gets or sets a value indicating whether appends are automatically retried if the log is full.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="24495-508">
            <see langword="true" /> si les opérations d'ajout sont réitérées automatiquement si le journal est complet ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-508">
              <see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="24495-509">La valeur par défaut est <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-509">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-510">Si la valeur de cette propriété est `true` et qu'un appel <xref:System.IO.Log.IRecordSequence.Append%2A> échoue parce qu'il n'y a pas suffisamment d'espace dans la séquence, la séquence d'enregistrement essaie de libérer de l'espace et réitère l'opération d'ajout.</span><span class="sxs-lookup"><span data-stu-id="24495-510">If the value of this property is `true`, and an <xref:System.IO.Log.IRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-511">L'accès à la propriété a été effectué après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-511">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.IRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="24495-512">Se produit lorsque la séquence d'enregistrement spécifie que la fin doit être avancée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-512">Occurs when the record sequence determines that the tail must be moved forward.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-513">Vous pouvez déclencher cet événement lorsque la séquence d'enregistrement n'a plus d'espace disponible.</span><span class="sxs-lookup"><span data-stu-id="24495-513">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="24495-514">Lorsque cet événement est déclenché, la fin de la séquence (c'est-à-dire, le numéro de séquence de base) est avancée pour libérer de l'espace.</span><span class="sxs-lookup"><span data-stu-id="24495-514">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="24495-515">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-515">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-516">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-516">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-517">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-517">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-518">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-518">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="24495-519">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-519">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-520">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-520">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-521">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-521">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-522">Numéro de séquence de la zone de reprise écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-522">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-523">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-523">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-524">Le Système commun de journalisation (CLFS) maintient deux zones de reprise afin de garantir la disponibilité constante d'au moins une zone valide.</span><span class="sxs-lookup"><span data-stu-id="24495-524">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="24495-525">Lorsqu'une récupération est nécessaire, le CLFS lit sa zone de reprise et toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-525">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-526">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-526">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="24495-527">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-527">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="24495-528">Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-528">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-529">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="24495-529">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-530">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-530">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-531">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-531">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-532">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-532">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-533">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-533">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-534">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-534">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-535">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-535">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-536">Numéro de séquence de la zone de reprise écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-536">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-537">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-537">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-538">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-538">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-539">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-539">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="24495-540">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-540">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="24495-541">Les données contenues dans les segments de tableau d'octets seront concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-541">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-542">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="24495-542">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-543">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-543">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-544">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-544">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-545">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-545">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-546">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-546">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-547">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-547">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-548">Nouveau numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-548">The new base sequence number.</span>
          </span>
          <span data-ttu-id="24495-549">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-549">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-550">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> et met à jour le numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-550">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-551">Numéro de séquence de la zone de reprise écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-551">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-552">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-552">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-553">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-553">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-554">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-554">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="24495-555">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-555">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="24495-556">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-556">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-557">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="24495-557">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="24495-558">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="24495-558">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="24495-559">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="24495-559">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-560">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-560">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-561">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-561">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-562">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-562">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-563">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-563">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-564">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-564">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-565">Nouveau numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-565">The new base sequence number.</span>
          </span>
          <span data-ttu-id="24495-566">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-566">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-567">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> et met à jour le numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-567">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> and updates the base sequence number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-568">Numéro de séquence de la zone de reprise écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-568">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-569">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-569">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-570">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-570">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-571">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-571">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="24495-572">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-572">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="24495-573">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-573">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-574">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="24495-574">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="24495-575">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="24495-575">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="24495-576">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="24495-576">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-577">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-577">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-578">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-578">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-579">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-579">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-580">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-580">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-581">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-581">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-582">Nouveau numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-582">The new base sequence number.</span>
          </span>
          <span data-ttu-id="24495-583">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-583">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="24495-584">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-584">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-585">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> à l'aide d'une réservation et met à jour le numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-585">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-586">Numéro de séquence de la zone de reprise écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-586">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-587">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-587">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-588">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-588">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-589">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-589">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="24495-590">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-590">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="24495-591">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-591">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-592">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="24495-592">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="24495-593">Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-593">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="24495-594">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-594">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-595">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="24495-595">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="24495-596">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="24495-596">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="24495-597">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-597">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-598">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-598">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-599">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-599">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-600">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-600">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-601">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-601">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-602">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-602">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber, class System.IO.Log.ReservationCollection reservation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSequenceNumber As SequenceNumber, reservation As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSequenceNumber, System::IO::Log::ReservationCollection ^ reservation);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="iRecordSequence.WriteRestartArea (data, newBaseSequenceNumber, reservation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="24495-603">Liste des segments de tableau d'octets qui seront concaténés et ajoutés en tant qu'enregistrement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-603">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="24495-604">Nouveau numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-604">The new base sequence number.</span>
          </span>
          <span data-ttu-id="24495-605">Le numéro de séquence spécifié doit être supérieur ou égal au numéro de séquence de base actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-605">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="24495-606">
            <see cref="T:System.IO.Log.ReservationCollection" /> qui contient la réservation qui doit être utilisée pour cette zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-606">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="24495-607">En cas de substitution dans une classe dérivée, écrit une zone de reprise dans la <see cref="T:System.IO.Log.IRecordSequence" /> à l'aide d'une réservation et met à jour le numéro de séquence de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-607">When overridden in a derived class, writes a restart area to the <see cref="T:System.IO.Log.IRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="24495-608">Numéro de séquence de la zone de reprise écrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-608">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="24495-609">Une zone de reprise est utilisée pour stocker temporairement des informations qui contiennent une dernière opération de point de contrôle du client.</span><span class="sxs-lookup"><span data-stu-id="24495-609">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="24495-610">Lorsqu'il est nécessaire d'effectuer une récupération, vous pouvez analyser la zone de reprise pour récupérer toutes les données de la dernière opération de point de contrôle.</span><span class="sxs-lookup"><span data-stu-id="24495-610">When a recovery is necessary, you can parse the restart area to retrieve all the data from the last checkpoint operation.</span></span> <span data-ttu-id="24495-611">Ces données initialisent la table de transactions, la table de pages de modifications et la table de fichiers ouverts pour qu’elles puissent être utilisées dans le processus de récupération.</span><span class="sxs-lookup"><span data-stu-id="24495-611">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span> <span data-ttu-id="24495-612">Une zone de reprise peut être lue à l'aide de la méthode <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>.</span><span class="sxs-lookup"><span data-stu-id="24495-612">A restart area can be read using the <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="24495-613">Lorsqu'une zone de reprise est écrite, les données dans les segments de tableau d'octets sont concaténées dans un tableau d'octets unique pour l'ajouter en tant qu'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="24495-613">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="24495-614">Il n'est pas possible de rétablir les segments du tableau en fractionnant les données lors de la lecture de la zone de reprise.</span><span class="sxs-lookup"><span data-stu-id="24495-614">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="24495-615">Si une réservation est spécifiée, la zone de reprise écrite utilise l’espace qui a été réservé précédemment, à l’aide d’une réservation contenue dans la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-615">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="24495-616">Si la méthode réussit, elle utilisera la plus petite réservation qui peut stocker les données et cette réservation sera supprimée de la collection.</span><span class="sxs-lookup"><span data-stu-id="24495-616">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="24495-617">Lorsque la méthode se termine correctement, cela signifie que le numéro de séquence de base a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="24495-617">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="24495-618">Tous les enregistrements du journal avec des numéros de séquence inférieurs au nouveau numéro de séquence de base sont inaccessibles.</span><span class="sxs-lookup"><span data-stu-id="24495-618">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="24495-619">Si une séquence d’enregistrement a été supprimée ou si vous passez un argument non valide, les exceptions sont immédiatement levées dans cette opération.</span><span class="sxs-lookup"><span data-stu-id="24495-619">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="24495-620">Lorsque des erreurs se sont produites pendant une requête d'ajout asynchrone, par exemple, une défaillance du disque pendant la requête d'E/S, les exceptions sont levées lorsque la méthode <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="24495-620">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="24495-621">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-621">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="24495-622">Une erreur d'E/S s'est produite lors de l'écriture de la zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-622">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="24495-623">La séquence d'enregistrement n'a pas réussi à libérer suffisamment d'espace pour stocker la nouvelle zone de reprise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-623">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="24495-624">La méthode a été appelée après la suppression de la séquence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="24495-624">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>