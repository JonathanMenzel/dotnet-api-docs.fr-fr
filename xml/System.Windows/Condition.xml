<Type Name="Condition" FullName="System.Windows.Condition">
  <Metadata><Meta Name="ms.openlocfilehash" Value="256beaf14ac149cabccdf1f49513d981bd92a970" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55333783" /></Metadata><TypeSignature Language="C#" Value="public sealed class Condition : System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Condition extends System.Object implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Condition" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Condition&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Condition sealed : System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Condition = class&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XamlSetMarkupExtension("ReceiveMarkupExtension")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XamlSetTypeConverter("ReceiveTypeConverter")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une condition pour <see cref="T:System.Windows.MultiTrigger" /> et <see cref="T:System.Windows.MultiDataTrigger" />, qui applique des modifications aux valeurs des propriétés selon un ensemble de conditions.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s et <xref:System.Windows.MultiDataTrigger>vous permettent de définir des valeurs de propriété selon un ensemble de conditions. Une condition est satisfaite lorsque la valeur de propriété de l’élément de données ou d’élément correspond à spécifié <xref:System.Windows.Condition.Value%2A> (vérification de l’égalité de référence). Si toutes les conditions spécifiées sont satisfaites, le déclencheur est appliqué.  
  
 Voici une liste de cas qui provoquera une exception :  
  
-   Pour chaque <xref:System.Windows.Condition>, vous pouvez uniquement définir soit la <xref:System.Windows.Condition.Property%2A> propriété ou le <xref:System.Windows.Condition.Binding%2A> propriété. Si les deux propriétés sont définies, une exception est levée.  
  
-   Si le <xref:System.Windows.Condition> concerne un <xref:System.Windows.MultiTrigger>, le <xref:System.Windows.Condition.Property%2A> propriété ne peut pas être null.  
  
-   Si le <xref:System.Windows.Condition> concerne un <xref:System.Windows.MultiDataTrigger>, le <xref:System.Windows.Condition.Binding%2A> propriété ne peut pas être null.  
  
-   Une exception est levée si le texte spécifié <xref:System.Windows.Condition.Value%2A> n’est pas valide pour le type de l’objet <xref:System.Windows.Condition.Property%2A>.  
  
 Notez que si le <xref:System.Windows.Condition> concerne un <xref:System.Windows.MultiTrigger>, le <xref:System.Windows.Condition.Property%2A> et <xref:System.Windows.Condition.Value%2A> propriétés doivent être définies. Si c’est pour un <xref:System.Windows.MultiDataTrigger>, le <xref:System.Windows.Condition.Binding%2A> et <xref:System.Windows.Condition.Value%2A> propriétés doivent être définies.  
  
   
  
## Examples  
 L’exemple suivant contient deux <xref:System.Windows.MultiTrigger>s. Les premiers jeux le **MinWidth** valeur de propriété lorsque la **HasItems** propriété a la valeur false et le **largeur** propriété est **automatique**. L’autre est similaire, mais concerne la **MinHeight** propriété.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 Consultez le <xref:System.Windows.Condition.Binding%2A> propriété pour obtenir des exemples de conditions utilisées dans un <xref:System.Windows.MultiDataTrigger>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Condition" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.Data.BindingBase binding, object conditionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Data.BindingBase binding, object conditionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.Data.BindingBase,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (binding As BindingBase, conditionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::Data::BindingBase ^ binding, System::Object ^ conditionValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.Data.BindingBase * obj -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (binding, conditionValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
        <Parameter Name="conditionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binding">Liaison qui spécifie la propriété de la condition.</param>
        <param name="conditionValue">Valeur de la condition.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.DependencyProperty conditionProperty, object conditionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty conditionProperty, object conditionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (conditionProperty As DependencyProperty, conditionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::DependencyProperty ^ conditionProperty, System::Object ^ conditionValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.DependencyProperty * obj -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (conditionProperty, conditionValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="conditionProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="conditionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="conditionProperty">Propriété de la condition.</param>
        <param name="conditionValue">Valeur de la condition.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Condition" /> avec la propriété ou valeur spécifiée. Ce constructeur effectue la validation des paramètres.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.DependencyProperty conditionProperty, object conditionValue, string sourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty conditionProperty, object conditionValue, string sourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.DependencyProperty,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (conditionProperty As DependencyProperty, conditionValue As Object, sourceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::DependencyProperty ^ conditionProperty, System::Object ^ conditionValue, System::String ^ sourceName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.DependencyProperty * obj * string -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (conditionProperty, conditionValue, sourceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="conditionProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="conditionValue" Type="System.Object" />
        <Parameter Name="sourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="conditionProperty">Propriété de la condition.</param>
        <param name="conditionValue">Valeur de la condition.</param>
        <param name="sourceName"><c>x:Name</c> de l’objet avec <paramref name="conditionProperty" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Condition" /> avec les propriété, valeur et nom spécifiés de l'objet source.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Binding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingBase Binding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingBase Binding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Binding" />
      <MemberSignature Language="VB.NET" Value="Public Property Binding As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingBase ^ Binding { System::Windows::Data::BindingBase ^ get(); void set(System::Windows::Data::BindingBase ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Binding : System.Windows.Data.BindingBase with get, set" Usage="System.Windows.Condition.Binding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la liaison qui spécifie la propriété de la condition. Cela s’applique uniquement aux objets <see cref="T:System.Windows.MultiDataTrigger" />.</summary>
        <value>La valeur par défaut est null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiDataTrigger>s vous permettent de définir des valeurs de propriété en fonction des valeurs des données qui sont retournées. Par exemple, si vous affichez une liste d’éléments de tâche, vous souhaiterez afficher une tâche avec un arrière-plan rouge si elle est de priorité élevée et n’a pas été examiné pendant plus de deux semaines.  
  
 Vous créez une liaison et que vous utilisez le <xref:System.Windows.Data.Binding.Path%2A> propriété à lier à une propriété d’un objet (l’objet de source de liaison). Par exemple, vous pouvez lier à la *priorité* propriété d’un *tâche*. Pour plus d’informations, consultez [Vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Notez que s’il s’agit d’une condition pour une <xref:System.Windows.MultiDataTrigger>, le <xref:System.Windows.Condition.Binding%2A> et <xref:System.Windows.Condition.Value%2A> propriétés doivent être définies. Définition de la <xref:System.Windows.Condition.Property%2A> valeur provoque une exception dans ce cas.  
  
<a name="xamlAttributeUsage_PriorityBinding"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="{Binding  declaration}"/>  
```  
  
<a name="xamlPropertyElementUsage_Binding"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Binding>  
    <Binding …/>  
  </object.Binding>  
</object>  
```  
  
<a name="xamlValues_PriorityBinding"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *déclaration*  
 Une déclaration de liaison. Consultez [vue d’ensemble des déclarations de liaison](~/docs/framework/wpf/data/binding-declarations-overview.md) pour plus d’informations.  
  
   
  
## Examples  
 Dans l’exemple suivant, le <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> de la <xref:System.Windows.Controls.ListBox> est lié à *emplacements*, un <xref:System.Collections.ObjectModel.ObservableCollection%601> de *Place* objets. *Place* objets ont des propriétés *nom* et *état*.  
  
 Chaque <xref:System.Windows.Controls.ListBoxItem> de la <xref:System.Windows.Controls.ListBox> affiche un *Place* objet. Le <xref:System.Windows.Style> dans l’exemple est appliqué à chacune <xref:System.Windows.Controls.ListBoxItem>. Le <xref:System.Windows.Condition>s de la <xref:System.Windows.MultiDataTrigger> sont spécifiés telles que si le *nom* et *état* de la *Place* élément de données est « Portland » et « Ou » respectivement, le arrière-plan de correspondant <xref:System.Windows.Controls.ListBoxItem> est défini sur Cyan.  
  
 [!code-xaml[DataTrigger#1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTrigger/CSharp/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Condition.Property" />
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty Property { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty Property" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Property" />
      <MemberSignature Language="VB.NET" Value="Public Property Property As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ Property { System::Windows::DependencyProperty ^ get(); void set(System::Windows::DependencyProperty ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Property : System.Windows.DependencyProperty with get, set" Usage="System.Windows.Condition.Property" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la propriété de la condition. Cela s’applique uniquement aux objets <see cref="T:System.Windows.MultiTrigger" />.</summary>
        <value><see cref="T:System.Windows.DependencyProperty" /> qui spécifie la propriété de la condition. La valeur par défaut est null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s vous permettent de définir des valeurs de propriété selon un ensemble de conditions. Une condition est satisfaite lorsque la valeur de la propriété (spécifié par le <xref:System.Windows.Condition.Property%2A> propriété) de l’élément correspond à spécifié <xref:System.Windows.Condition.Value%2A> (vérification de l’égalité de référence). Si toutes les conditions spécifiées sont satisfaites, le déclencheur est appliqué.  
  
 Si `TargetType` n’est pas définie sur le style du modèle qui contient les déclencheurs. Vous devez qualifier le nom de propriété à l’aide de la `ClassName.PropertyName` syntaxe.  
  
 Notez que s’il s’agit d’une condition pour une <xref:System.Windows.MultiTrigger>, le <xref:System.Windows.Condition.Property%2A> et <xref:System.Windows.Condition.Value%2A> propriétés doivent être définies. Définition de la <xref:System.Windows.Condition.Binding%2A> valeur provoque une exception dans ce cas.  
  
 Pour <xref:System.Windows.Condition>s dans <xref:System.Windows.MultiDataTrigger>s, le <xref:System.Windows.Condition.Binding%2A> propriété doit être utilisée au lieu de cette propriété.  
  
   
  
## Examples  
 L’exemple suivant contient deux <xref:System.Windows.MultiTrigger>s. Les premiers jeux le **MinWidth** valeur de propriété lorsque la **HasItems** propriété a la valeur false et le **largeur** propriété est **automatique**. L’autre est similaire, mais concerne la **MinHeight** propriété.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Condition.Binding" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMarkupExtension">
      <MemberSignature Language="C#" Value="public static void ReceiveMarkupExtension (object targetObject, System.Windows.Markup.XamlSetMarkupExtensionEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReceiveMarkupExtension(object targetObject, class System.Windows.Markup.XamlSetMarkupExtensionEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.ReceiveMarkupExtension(System.Object,System.Windows.Markup.XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReceiveMarkupExtension (targetObject As Object, eventArgs As XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReceiveMarkupExtension(System::Object ^ targetObject, System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="static member ReceiveMarkupExtension : obj * System.Windows.Markup.XamlSetMarkupExtensionEventArgs -&gt; unit" Usage="System.Windows.Condition.ReceiveMarkupExtension (targetObject, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetObject" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
      </Parameters>
      <Docs>
        <param name="targetObject">Objet où l'extension de balisage définit la valeur.</param>
        <param name="eventArgs">Données pertinentes pour le traitement de l'extension de balisage.</param>
        <summary>Gère des cas où une extension de balisage fournit une valeur pour une propriété d'un objet <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la méthode référencée par un appliqué <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> attribut au niveau de la classe, ce qui signifie que cette méthode traite toutes les tentatives de définir des valeurs de <xref:System.Windows.Condition> avec une extension de balisage. Vous n’en général, appelez pas cette méthode directement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionAttribute" />
        <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTypeConverter">
      <MemberSignature Language="C#" Value="public static void ReceiveTypeConverter (object targetObject, System.Windows.Markup.XamlSetTypeConverterEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReceiveTypeConverter(object targetObject, class System.Windows.Markup.XamlSetTypeConverterEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.ReceiveTypeConverter(System.Object,System.Windows.Markup.XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReceiveTypeConverter (targetObject As Object, eventArgs As XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReceiveTypeConverter(System::Object ^ targetObject, System::Windows::Markup::XamlSetTypeConverterEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="static member ReceiveTypeConverter : obj * System.Windows.Markup.XamlSetTypeConverterEventArgs -&gt; unit" Usage="System.Windows.Condition.ReceiveTypeConverter (targetObject, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetObject" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.Windows.Markup.XamlSetTypeConverterEventArgs" />
      </Parameters>
      <Docs>
        <param name="targetObject">Objet où le convertisseur de type définit la valeur.</param>
        <param name="eventArgs">Données pertinentes pour le traitement du convertisseur de type.</param>
        <summary>Gère des cas où un convertisseur de type fournit une valeur pour une propriété d’un objet <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la méthode référencée par un appliqué <xref:System.Windows.Markup.XamlSetTypeConverterAttribute> attribut au niveau de la classe, ce qui signifie que cette méthode traite toutes les tentatives de définir des valeurs de <xref:System.Windows.Condition> avec un convertisseur de type. Vous n’en général, appelez pas cette méthode directement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.XamlSetTypeConverterAttribute" />
        <altmember cref="T:System.Windows.Markup.XamlSetTypeConverterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SourceName">
      <MemberSignature Language="C#" Value="public string SourceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.SourceName" />
      <MemberSignature Language="VB.NET" Value="Public Property SourceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SourceName : string with get, set" Usage="System.Windows.Condition.SourceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'objet avec la propriété qui entraîne l'application des méthodes setter associées. Cela s’applique uniquement aux objets <see cref="T:System.Windows.MultiTrigger" />.</summary>
        <value>La valeur par défaut de la propriété est <see langword="null" />. Si cette propriété a la valeur <see langword="null" />, celle de l'objet qui est appelé provoque l'application des accesseurs Set associés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez définir cette propriété sur le nom de n’importe quel élément dans la portée d'où la collection de déclencheurs (la collection dont le déclencheur qui contient cette condition fait partie de) est appliquée. Il s’agit généralement d’un élément nommé qui est dans le modèle qui contient le déclencheur.  
  
 Vous pouvez nommer un objet en utilisant le [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md) syntaxe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Après que l'utilisation d'une <see cref="T:System.Windows.Condition" /> ait été lancée, cette condition ne peut pas être modifiée.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signale à l'objet que l'initialisation démarre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Condition> est castée en interface <xref:System.ComponentModel.ISupportInitialize>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signale à l'objet que l'initialisation est terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Condition> est castée en interface <xref:System.ComponentModel.ISupportInitialize>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj with get, set" Usage="System.Windows.Condition.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Markup.SetterTriggerConditionValueConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de la condition.</summary>
        <value>La propriété <see cref="P:System.Windows.Condition.Value" /> ne peut pas être nulle pour une <see cref="T:System.Windows.Condition" /> donnée.  
  
Consultez également la section Exceptions. La valeur par défaut est null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s et <xref:System.Windows.MultiDataTrigger>vous permettent de définir des valeurs de propriété selon un ensemble de conditions. Une condition est satisfaite lorsque la valeur de propriété de l’élément de données ou d’élément correspond à spécifié <xref:System.Windows.Condition.Value%2A>. Si toutes les conditions spécifiées sont satisfaites, le déclencheur est appliqué. Si toutes les conditions spécifiées sont satisfaites, le déclencheur est appliqué.  
  
   
  
## Examples  
 L’exemple suivant contient deux <xref:System.Windows.MultiTrigger>s. Les premiers jeux le **MinWidth** valeur de propriété lorsque la **HasItems** propriété a la valeur false et le **largeur** propriété est **automatique**. L’autre est similaire, mais concerne la **MinHeight** propriété.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 Consultez le <xref:System.Windows.Condition.Binding%2A> propriété pour obtenir des exemples de conditions utilisées dans un <xref:System.Windows.MultiDataTrigger>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Les expressions ne sont pas prises en charge.</exception>
      </Docs>
    </Member>
  </Members>
</Type>