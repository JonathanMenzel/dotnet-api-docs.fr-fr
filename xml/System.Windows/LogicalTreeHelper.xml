<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LogicalTreeHelper.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5f2fd27ad4c537a177069b372af2f1a949e102361.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f2fd27ad4c537a177069b372af2f1a949e102361</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.LogicalTreeHelper">
          <source>Provides static helper methods for querying objects in the logical tree.</source>
          <target state="translated">Fournit des méthodes d’assistance statiques permettant d’interroger des objets dans l’arborescence logique.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>The <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> class provides methods that you can use to return child collections of objects, or specific objects from within subnodes of the logical tree.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> classe fournit des méthodes qui vous permet de retourner des collections enfants d’objets ou des objets spécifiques à partir de sous-nœuds de l’arborescence logique.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>However, most of the object tree operations that you typically perform are also exposed by similar methods or properties on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Toutefois, la plupart des opérations d’arborescence objet que vous effectuez en général est également exposée par les propriétés ou méthodes semblables sur <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>For example, try the following:</source>
          <target state="translated">Par exemple, essayez ce qui suit :</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>Instead of calling the static <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.GetChildren%2A&gt;</ph> method, which returns an enumerator for the logical child objects, use the dedicated collection exposed in the content model for that object.</source>
          <target state="translated">Au lieu d’appeler la méthode statique <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.GetChildren%2A&gt;</ph> (méthode), qui retourne un énumérateur pour les enfants logiques des objets, utilisez la collection dédiée exposée dans le modèle de contenu pour cet objet.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>Nearly all objects that support a content model expose some property that contains the collection of child objects, and provides collection interface support directly on that collection.</source>
          <target state="translated">Presque tous les objets qui prennent en charge un modèle de contenu exposent une propriété qui contient la collection d’objets enfants et fournit l’interface prise en charge directement dans cette collection.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>Instead of calling the static <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> method to obtain a child object by specifying its name, call the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType&gt;</ph> method on specific objects.</source>
          <target state="translated">Au lieu d’appeler la méthode statique <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> méthode pour obtenir un objet enfant en spécifiant son nom, appelez le <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType&gt;</ph> méthode sur des objets spécifiques.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source><ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> is most useful for analysis scenarios where you are traveling up or down the logical tree recursively through multiple levels, and want to use a consistent approach for examining the various parent or child objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> est particulièrement utile pour les scénarios d’analyse où vous êtes en déplacement vers le haut ou vers le bas l’arborescence logique de manière récursive à travers plusieurs niveaux et à utiliser une approche cohérente pour examiner les différents objets parents ou enfants.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.LogicalTreeHelper">
          <source>In this case, you might be accessing a mixture of content models, and using the more content-model specific APIs would be too complex.</source>
          <target state="translated">Dans ce cas, vous pouvez accéder à une combinaison des modèles de contenu, et en utilisant le modèle de contenu plus API spécifiques serait trop complexes.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)">
          <source>The UI element to bring into view.</source>
          <target state="translated">Élément d'interface utilisateur à afficher.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)">
          <source>Attempts to bring the requested UI element into view and raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> event on the target in order to report the results.</source>
          <target state="translated">Tente d'afficher l'élément d'interface utilisateur demandé et déclenche l'événement <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> sur la cible pour signaler les résultats.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)">
          <source>It is typically more convenient to call the instance methods <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType&gt;</ph> rather than this static utility method.</source>
          <target state="translated">Il est généralement plus pratique appeler les méthodes d’instance <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A?displayProperty=nameWithType&gt;</ph> au lieu de cette méthode utilitaire statique.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)">
          <source>The behavior of the instance methods is equivalent to the behavior of the static method.</source>
          <target state="translated">Le comportement des méthodes d’instance est équivalent au comportement de la méthode statique.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.BringIntoView(System.Windows.DependencyObject)">
          <source>Even if the <ph id="ph1">`current`</ph> UI element provided was a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, the resulting event is still the same <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> event, with the originating <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> identifiable by checking the event data of the event.</source>
          <target state="translated">Même si le <ph id="ph1">`current`</ph> élément d’interface utilisateur fournie était un <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, l’événement résultant est le même <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> événement, avec l’origine <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> identifiable par la vérification des données de l’événement.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The object to start searching from.</source>
          <target state="translated">Objet à partir duquel commencer la recherche.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>This object must be either a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> or a <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Cet objet doit être un type <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The name of the object to find.</source>
          <target state="translated">Nom de l'objet à rechercher.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>Attempts to find and return an object that has the specified name.</source>
          <target state="translated">Tente de rechercher et de retourner un objet qui a le nom spécifié.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The search starts from the specified object and continues into subnodes of the logical tree.</source>
          <target state="translated">La recherche démarre à partir de l'objet spécifié et continue dans les sous-nœuds de l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The object with the matching name, if one is found; returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching name was found in the logical tree.</source>
          <target state="translated">Objet avec le nom correspondant, si la recherche aboutit ; retourne <ph id="ph1">&lt;see langword="null" /&gt;</ph> si aucun nom correspondant n'a été trouvé dans l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The methods <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> are superficially similar to <ph id="ph3">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph>, but operate by different logic:</source>
          <target state="translated">Les méthodes <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> sont superficiellement semblables à <ph id="ph3">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph>, mais fonctionnent par logique différente :</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The search direction for <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> is toward child objects (down the tree); the search direction for the <ph id="ph2">`FindName`</ph> methods is towards parent objects (up the tree).</source>
          <target state="translated">Le sens de la recherche pour <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> vers les objets enfants (vers le bas l’arborescence) ; le sens de la recherche pour le <ph id="ph2">`FindName`</ph> méthodes est vers les objets parents (dans l’arborescence).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>The <ph id="ph1">`FindName`</ph> methods are governed by the concept of a XAML namescope.</source>
          <target state="translated">Le <ph id="ph1">`FindName`</ph> méthodes sont régies par le concept d’une portée de nom XAML.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>Using <ph id="ph1">`FindName`</ph> you are guaranteed that only one object of that name exists, because XAML namescopes enforce uniqueness.</source>
          <target state="translated">À l’aide de <ph id="ph1">`FindName`</ph> vous avez la garantie qu’un seul objet de ce nom existe, car l’unicité de portées de nom XAML.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>In contrast, <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> ignores XAML namescope and might cross XAML namescope boundaries during the search.</source>
          <target state="translated">En revanche, <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> ignore la portée de nom XAML et peut traverser les limites de portée de nom XAML pendant la recherche.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>As such, there is no guarantee of uniqueness of the <ph id="ph1">`elementName`</ph> name once boundaries are crossed.</source>
          <target state="translated">Par conséquent, il n’existe aucune garantie d’unicité de la <ph id="ph1">`elementName`</ph> nom une fois que les limites sont traversées.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.FindLogicalNode(System.Windows.DependencyObject,System.String)">
          <source>For more information about XAML namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les portées de nom XAML, consultez <bpt id="p1">[</bpt>portées de nom XAML WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Windows.LogicalTreeHelper">
          <source>Returns the collection of immediate child objects of the specified object by processing the logical tree.</source>
          <target state="translated">Retourne la collection d'objets enfants immédiats de l'objet spécifié, en traitant l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>The object from which to start processing the logical tree.</source>
          <target state="translated">Objet à partir duquel commencer le traitement de l’arborescence logique.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>This is expected to be either a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Il peut s'agir de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>Returns the collection of immediate child objects of the specified object, by processing the logical tree.</source>
          <target state="translated">Retourne la collection d’objets enfants immédiats de l’objet spécifié en traitant l’arborescence logique.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>The enumerable collection of immediate child objects from the logical tree of the specified object.</source>
          <target state="translated">Collection énumérable d’objets enfants immédiats de l’arborescence logique de l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>Use this signature and helper method primarily when you are unsure whether <ph id="ph1">`current`</ph> is a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> and are also unsure whether that object's class supports its own content model collection.</source>
          <target state="translated">Utilisez cette méthode de signature et d’assistance essentiellement lorsque vous n’êtes pas certain si <ph id="ph1">`current`</ph> est un <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> et également si les classes de cet objet prend en charge sa propre collection de modèle de contenu.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>If you can determine the type of the object you are querying, check the specific content property that you know exists on that type.</source>
          <target state="translated">Si vous pouvez déterminer le type de l’objet que vous interrogez, vérifiez la propriété de contenu spécifique dont vous savez qu’il existe sur ce type.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.DependencyObject)">
          <source>For example, if you know that the object you are querying is an <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, check the <ph id="ph2">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> property to get a strongly typed collection, which has collection interface support and is probably more useful than an enumerator.</source>
          <target state="translated">Par exemple, si vous savez que l’objet que vous interrogez est un <ph id="ph1">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, vérifiez le <ph id="ph2">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> propriété à obtenir une collection fortement typée, qui prend en charge les interface de collection et est probablement plus utile qu’un énumérateur.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkContentElement)">
          <source>The object from which to start processing the logical tree.</source>
          <target state="translated">Objet à partir duquel commencer le traitement de l’arborescence logique.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkContentElement)">
          <source>Returns the collection of immediate child objects of the specified <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> by processing the logical tree.</source>
          <target state="translated">Retourne la collection d'objets enfants immédiats de l'objet <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> spécifié, en traitant l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkContentElement)">
          <source>The enumerable collection of immediate child objects starting from <ph id="ph1">&lt;paramref name="current" /&gt;</ph> in the logical tree.</source>
          <target state="translated">Collection énumérable d'objets enfants immédiats en commençant par <ph id="ph1">&lt;paramref name="current" /&gt;</ph> dans l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkElement)">
          <source>The object from which to start processing the logical tree.</source>
          <target state="translated">Objet à partir duquel commencer le traitement de l’arborescence logique.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkElement)">
          <source>Returns the collection of immediate child objects of the specified <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> by processing the logical tree.</source>
          <target state="translated">Retourne la collection d'objets enfants immédiats de l'objet <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> spécifié, en traitant l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetChildren(System.Windows.FrameworkElement)">
          <source>The enumerable collection of immediate child objects starting from <ph id="ph1">&lt;paramref name="current" /&gt;</ph> in the logical tree.</source>
          <target state="translated">Collection énumérable d'objets enfants immédiats en commençant par <ph id="ph1">&lt;paramref name="current" /&gt;</ph> dans l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)">
          <source>The object to find the parent object for.</source>
          <target state="translated">Objet pour lequel rechercher l'objet parent.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)">
          <source>This is expected to be either a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> or a <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Il peut s'agir de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)">
          <source>Returns the parent object of the specified object by processing the logical tree.</source>
          <target state="translated">Retourne l'objet parent de l'objet spécifié en traitant l'arborescence logique.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)">
          <source>The requested parent object.</source>
          <target state="translated">Objet parent demandé.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.LogicalTreeHelper.GetParent(System.Windows.DependencyObject)">
          <source>This method is merely a wrapper that gets the appropriate type version (<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>) of the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType&gt;</ph> property; so unless you are unable to determine the <ph id="ph5">`current`</ph> type, you might want to check the respective instance properties instead.</source>
          <target state="translated">Cette méthode est simplement un wrapper qui obtient la version du type approprié (<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>) de la <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Parent%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A?displayProperty=nameWithType&gt;</ph> propriété ; ainsi, sauf si vous ne parvenez pas à déterminer le <ph id="ph5">`current`</ph> type, vous souhaiterez vérifier respectifs propriétés de l’instance à la place.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>