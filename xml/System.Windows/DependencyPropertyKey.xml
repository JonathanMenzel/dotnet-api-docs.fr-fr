<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyPropertyKey.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a12e407bc5345e416145c390f8fcd6f8262c445.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a12e407bc5345e416145c390f8fcd6f8262c445</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyPropertyKey">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">Fournit un identificateur de propriété de dépendance pour un accès en écriture limité à une propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instances are obtained as the return value of a dependency property registration call using the methods <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> les instances sont obtenues comme valeur de retour d’un appel de l’inscription de propriété de dépendance à l’aide de méthodes <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The types that register a dependency property can use the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> that adjust the property's value as part of class logic.</source>
          <target state="translated">Les types qui inscrivent une propriété de dépendance peuvent utiliser le <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> dans les appels à <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> qui ajustent la valeur de propriété dans le cadre de la logique de la classe.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">Si autorisé par le niveau d’accès de la clé, classes connexes peuvent également utiliser la clé et la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">Par exemple, vous pouvez déclarer une clé interne, et les autres types dans le même assembly peuvent également définir cette propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> retourné par la dépendance en lecture seule inscription de la propriété ne doit pas être rendue publique, car la propriété devient définissable, alors que vous avez le point d’inscription de propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">En outre, l’exposition de la clé provoque une discordance entre la dépendance disponible comportements de la propriété et ses <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> des implémentations de wrapper de propriété, qui est la conception d’une classe incorrect.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Instead of exposing the key itself, you should instead expose the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value of the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> as a <ph id="ph3">`public static readonly`</ph><ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> on your class.</source>
          <target state="translated">Au lieu d’exposer la clé elle-même, vous exposez le <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> valeur de la <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> comme un <ph id="ph3">`public static readonly`</ph> <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> sur votre classe.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">Ainsi, la propriété à retourner un identificateur de propriété de dépendance valide pour certaines opérations de système de propriétés telles que l’énumération localement les valeurs de l’ensemble.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>However, the identifier thus obtained does not have the full capabilities of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> for many property system operations.</source>
          <target state="translated">Toutefois, l’identificateur ainsi obtenu n’a pas de toutes les fonctionnalités d’un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> pour de nombreuses opérations de système de propriété.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</source>
          <target state="translated">L’exemple suivant inscrit une propriété de dépendance en lecture seule et qu’il utilise également la clé pour deux raisons dans d’autres membres de classe : implémentation get « wrapper » et comme identificateur pour une opération de détermination protégée qui définit la valeur basée sur des calculs d’autres valeurs de propriété.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">Obtient l'identificateur de propriété de dépendance associé à cet identificateur de propriété de dépendance en lecture seule spécialisé.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">Identificateur de propriété de dépendance pertinent.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> la valeur Active l’identificateur d’une propriété en lecture seule à participer à des opérations de système de propriétés à l’aide de certaines des interfaces de mêmes que celle utilisée pour les propriétés de dépendance en lecture-écriture.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class.</source>
          <target state="translated">Pour implémenter l’accesseur get de propriété pour une propriété de dépendance en lecture seule, vous devez créer et exposer un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur sur votre classe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>This serves two purposes:</source>
          <target state="translated">Cela a deux objectifs :</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Your own class needs the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">Les besoins de votre propre classe le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur afin d’implémenter l’accesseur get pour le wrapper de propriété.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>You use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as a parameter for the <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> call that implements the get accessor.</source>
          <target state="translated">Vous utilisez la <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> en tant que paramètre pour le <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> appel qui implémente l’accesseur get.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateurs d’exposent votre propriété de dépendance pour le système de propriétés telles que les autres méthodes qui dépendent des métadonnées puissent y accéder dans un formulaire standard.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>For instance, if you called <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> on some <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value rather than the key.</source>
          <target state="translated">Par exemple, si vous avez appelé <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> sur certains <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> et obtenu une énumération des propriétés localement définies (valeurs et identificateurs), l’identificateur retourné pour une propriété de dépendance en lecture seule serait votre <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> valeur au lieu de la clé.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Not exposing a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">Ne pas exposer un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur n’augmente pas la sécurité de votre propriété de dépendance en lecture seule en aucune façon, elle permet simplement d’opérations qui concernent votre propriété plus difficile pour les classes dérivées suivantes et les instances de classe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>To expose the  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class, you call <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> directly on your key.</source>
          <target state="translated">Pour exposer la <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur sur votre classe, vous appelez <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> directement sur votre clé.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on the class, which parallels the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</source>
          <target state="translated">Cette valeur permet de créer un <ph id="ph1">`public static readonly`</ph> <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur de la classe qui correspond le <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> to expose the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier (<ph id="ph3">`AquariumGraphicProperty`</ph>) for the <ph id="ph4">`AquariumGraphic`</ph> read-only dependency property on a class.</source>
          <target state="translated">L’exemple suivant appelle <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> pour exposer le <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur (<ph id="ph3">`AquariumGraphicProperty`</ph>) pour le <ph id="ph4">`AquariumGraphic`</ph> propriété de dépendance en lecture seule dans une classe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The example also shows the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> creation (as an internal member) and the get accessor for <ph id="ph2">`AquariumGraphic`</ph>.</source>
          <target state="translated">Cet exemple montre également le <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> création (comme un membre interne) et l’accesseur get pour <ph id="ph2">`AquariumGraphic`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">Type sur lequel cette propriété de dépendance est basée et dont les métadonnées doivent être substituées.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata supplied for this type.</source>
          <target state="translated">Métadonnées fournies pour ce type.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">Substitue les métadonnées d'une propriété de dépendance en lecture seule représentée par cet identificateur de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">Substitution des métadonnées sur une propriété de dépendance en lecture seule est effectuée pour des raisons similaires en tant que la substitution des métadonnées sur une propriété de dépendance en lecture-écriture et est limitée à l’accès au niveau de la clé, car les comportements spécifiés dans les métadonnées peuvent modifier le comportement de jeu (le valeur par défaut, par exemple).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">Comme avec les propriétés de dépendance en lecture-écriture, la substitution de métadonnées sur une propriété de dépendance en lecture seule ne doit être effectuée avant que la propriété soit placée en cours d’utilisation par le système de propriétés (cela équivaut à l’heure que les instances spécifiques d’objets qui inscrivent la propriété sont instanciées).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">Les appels à <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> doivent être exécutés uniquement dans les constructeurs statiques du type qui fournit en tant que le <ph id="ph2">`forType`</ph> paramètre de cette méthode ou initialisation équivalente pour cette classe.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This method effectively forwards to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method, passing the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instance as the key parameter.</source>
          <target state="translated">Cette méthode transfère efficacement à le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> méthode, en passant le <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instance que le paramètre de clé.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The following example overrides metadata for an existing read-only dependency property that a class inherits.</source>
          <target state="translated">L’exemple suivant substitue les métadonnées pour une propriété de dépendance en lecture seule existante qui hérite d’une classe.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</source>
          <target state="translated">Dans ce cas, l’objectif de scénario a pour ajouter un rappel de valeur forcée que les métadonnées de propriété de base n’ont pas.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values, etc.)</source>
          <target state="translated">Vous pouvez également substituer les métadonnées pour toute autre raison justifiant la substitution des métadonnées (valeur par défaut, ajout <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> valeurs, etc..)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">A tenté de substituer des métadonnées sur une propriété de dépendance en lecture-écriture (cette opération ne peut pas être exécutée à l'aide de cette signature).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">Les métadonnées ont déjà été établies pour la propriété telle que définie par le type fourni.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>