<Type Name="NameScope" FullName="System.Windows.NameScope">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e592cda49827dc25a97d85376a3be8483889b1d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NameScope : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,object&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;, System.Windows.Markup.INameScopeDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NameScope extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, object&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable, class System.Windows.Markup.INameScope, class System.Windows.Markup.INameScopeDictionary" />
  <TypeSignature Language="DocId" Value="T:System.Windows.NameScope" />
  <TypeSignature Language="VB.NET" Value="Public Class NameScope&#xA;Implements ICollection(Of KeyValuePair(Of String, Object)), IDictionary(Of String, Object), IEnumerable(Of KeyValuePair(Of String, Object)), INameScopeDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class NameScope : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;, System::Windows::Markup::INameScopeDictionary" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScopeDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ff51f-101">Implémente la prise en charge WPF de base pour les méthodes <see cref="T:System.Windows.Markup.INameScope" /> qui stockent ou extraient des mappages d'objet de nom dans une portée de nom XAML particulière.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ff51f-101">Implements base WPF support for the <see cref="T:System.Windows.Markup.INameScope" /> methods that store or retrieve name-object mappings into a particular XAML namescope.</span>
      </span>
      <span data-ttu-id="ff51f-102">Ajoute la prise en charge des propriétés jointes pour simplifier l’obtention ou la définition de noms de portée de nom XAML de manière dynamique au niveau de l’élément.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ff51f-102">Adds attached property support to make it simpler to get or set XAML namescope names dynamically at the element level..</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-103">Cette classe implémente la prise en charge de la portée de nom XAML intégrée pour le traitement WPF de XAML.</span><span class="sxs-lookup"><span data-stu-id="ff51f-103">This class implements built-in XAML namescope support for WPF treatment of XAML.</span></span> <span data-ttu-id="ff51f-104"><xref:System.Windows.NameScope> aide à la création de portées de nom XAML initiales en fonction de l’analyse XAML, telles que lorsque l’instanciation des styles et modèles.</span><span class="sxs-lookup"><span data-stu-id="ff51f-104"><xref:System.Windows.NameScope> assists in creation of initial XAML namescopes based on parsing XAML, such as when instantiating styles and templates.</span></span> <span data-ttu-id="ff51f-105">Il prend également en charge la création de portées de nom XAML par le processus qui se produisent en dehors du chargement de XAML normal des éléments par l’implémentation du processeur XAML WPF.</span><span class="sxs-lookup"><span data-stu-id="ff51f-105">It also supports creation of XAML namescopes by processes that occur outside of normal XAML loading of elements by the WPF XAML processor implementation.</span></span>  
  
 <span data-ttu-id="ff51f-106"><xref:System.Windows.NameScope> est généralement davantage destiné à fournir l’infrastructure que pour les scénarios de code utilisateur courants qui impliquent l’utilisation de la portée de nom XAML.</span><span class="sxs-lookup"><span data-stu-id="ff51f-106"><xref:System.Windows.NameScope> is generally more devoted to supplying infrastructure than for common user code scenarios that involve working with a XAML namescope.</span></span> <span data-ttu-id="ff51f-107">La plupart des scénarios, le <xref:System.Windows.FrameworkElement.FindName%2A> méthodes exposées sur <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> sont des méthodes les plus appropriées à appeler pour rechercher des éléments par nom défini par XAML.</span><span class="sxs-lookup"><span data-stu-id="ff51f-107">For most scenarios, the <xref:System.Windows.FrameworkElement.FindName%2A> methods exposed on <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> are more appropriate methods to call to search for elements by XAML-defined name.</span></span> <span data-ttu-id="ff51f-108">Le <xref:System.Windows.FrameworkElement.Name%2A> propriétés exposées par <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> sont des propriétés plus appropriées à utiliser pour définir le nom initial en tant qu’attributs de balisage.</span><span class="sxs-lookup"><span data-stu-id="ff51f-108">The <xref:System.Windows.FrameworkElement.Name%2A> properties exposed by <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> are more appropriate properties to use to set the initial name as markup attributes.</span></span>  
  
 <span data-ttu-id="ff51f-109">Les différentes méthodes de <xref:System.Windows.NameScope> sont utilisés par les éléments de base et d’autres classes qui gèrent les portées de nom XAML pour prendre en charge <xref:System.Windows.Markup.INameScope.RegisterName%2A> et <xref:System.Windows.Markup.INameScope.FindName%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff51f-109">The various methods of <xref:System.Windows.NameScope> are used by base elements and other classes that maintain XAML namescopes in order to support <xref:System.Windows.Markup.INameScope.RegisterName%2A> and <xref:System.Windows.Markup.INameScope.FindName%2A>.</span></span> <span data-ttu-id="ff51f-110">Vous utilisez généralement l’API dans le <xref:System.Windows.NameScope> uniquement si vous remplacez ou augmentez le comportement d’élément de base pour la manière dont ils traitent les portées de nom XAML pour les éléments racine d’une page XAML et dans le cadre des modèles de classe (qui utilisent une portée de nom XAML séparée du reste de la page).</span><span class="sxs-lookup"><span data-stu-id="ff51f-110">You generally use the API in the <xref:System.Windows.NameScope> class only if you are replacing or augmenting the base element behavior for how they process XAML namescopes for root elements of a XAML page, and as part of templates (which use a separate XAML namescope from the rest of the page).</span></span>  
  
 <span data-ttu-id="ff51f-111">Dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.Windows.NameScope> fournit des implémentations d’interface de collection telles que vous pouvez accéder aux collections des noms qui sont détenues par la portée de nom XAML, y compris l’ajout à ce dernier via des appels à un <xref:System.Windows.NameScope.Add%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ff51f-111">In [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.Windows.NameScope> provides collection interface implementations such that you can access the collections of names that are held by a XAML namescope, including adding to it through calls to an <xref:System.Windows.NameScope.Add%2A> method.</span></span>  
  
 <span data-ttu-id="ff51f-112">Pour plus d’informations sur les concepts de portée de nom XAML, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="ff51f-112">For more information on XAML namescope concepts, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="ff51f-113">Les noms dans une portée de nom XAML doivent utiliser une grammaire particulière qui restreint les chaînes que vous pouvez utiliser pour les entrées de <xref:System.Windows.NameScope> API.</span><span class="sxs-lookup"><span data-stu-id="ff51f-113">Names in a XAML namescope must use a particular grammar that restricts the strings you might use for inputs of <xref:System.Windows.NameScope> API.</span></span> <span data-ttu-id="ff51f-114">Consultez [XamlName, grammaire](~/docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="ff51f-114">See [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.INameScope" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NameScope();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-115">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-115">Initializes a new instance of the <see cref="T:System.Windows.NameScope" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-116">Ajoute un élément à la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-116">Adds an item to the collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Collections.Generic.KeyValuePair&lt;string,object&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="ff51f-117">
            <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (la clé est <see cref="T:System.String" />, la valeur est <see cref="T:System.Object" />) qui représente le mappage de nom à ajouter à la portée de nom XAML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-117">A <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (key is <see cref="T:System.String" />, value is <see cref="T:System.Object" />) that represents the name mapping to add to the XAML namescope.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-118">Ajoute un élément à la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-118">Adds an item to the collection.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ff51f-119">L'un des deux composants de <paramref name="item" /> ou les deux sont <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-119">Either or both components of <paramref name="item" /> are <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Add(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="ff51f-120">Clé de chaîne, qui est le nom du mappage de la portée de nom XAML à ajouter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-120">The string key, which is the name of the XAML namescope mapping to add.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ff51f-121">Valeur d'objet, qui est la référence d'objet du mappage de la portée de nom XAML à ajouter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-121">The object value, which is the object reference of the XAML namescope mapping to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-122">Ajoute un élément à la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-122">Adds an item to the collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-123">Cette méthode inclut <xref:System.Windows.NameScope.Add%2A> afin qu’il ne soit pas nécessaire d’impliquer le <xref:System.Collections.Generic.KeyValuePair%602> type dans votre utilisation.</span><span class="sxs-lookup"><span data-stu-id="ff51f-123">This method basically wraps <xref:System.Windows.NameScope.Add%2A> so that it is not necessary to involve the <xref:System.Collections.Generic.KeyValuePair%602> type in your usage.</span></span>  
  
 <span data-ttu-id="ff51f-124">Les noms dans une portée de nom XAML doivent utiliser une grammaire particulière qui restreint les chaînes que vous pouvez utiliser pour les entrées de <xref:System.Windows.NameScope> API.</span><span class="sxs-lookup"><span data-stu-id="ff51f-124">Names in a XAML namescope must use a particular grammar that restricts the strings you might use for inputs of <xref:System.Windows.NameScope> API.</span></span> <span data-ttu-id="ff51f-125">Consultez [XamlName, grammaire](~/docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="ff51f-125">See [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-126">
            <paramref name="key" /> ou <paramref name="value" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-126">
              <paramref name="key" /> or <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-127">Supprime tous les éléments de la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-127">Removes all items from the collection.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,object&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of String, Object)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="ff51f-128">Élément à rechercher dans la collection, spécifié comme un <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (la clé est <see cref="T:System.String" />, la valeur est <see cref="T:System.Object" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-128">The item to find in the collection, specified as a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (key is <see cref="T:System.String" />, value is <see cref="T:System.Object" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-129">Détermine si la collection contient l'élément spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-129">Determines whether the collection contains a specified item.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-130">
            <see langword="true" /> si le <see cref="T:System.Collections.Generic.KeyValuePair`2" /> spécifié identifie un mappage existant dans ce <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-130">
              <see langword="true" /> if the specified <see cref="T:System.Collections.Generic.KeyValuePair`2" /> identifies an existing mapping in this <see cref="T:System.Windows.NameScope" /> .</span>
          </span>
          <span data-ttu-id="ff51f-131">
            <see langword="false" /> si <see cref="T:System.Collections.Generic.KeyValuePair`2" /> spécifié n'existe pas dans le <see cref="T:System.Windows.NameScope" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-131">
              <see langword="false" /> if the specified <see cref="T:System.Collections.Generic.KeyValuePair`2" /> does not exist in the current <see cref="T:System.Windows.NameScope" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-132">En général vous intéresse uniquement si un nom est déjà défini dans la portée de nom XAML, et quelle valeur de référence d’objet qu’il est mappé à est immatériel.</span><span class="sxs-lookup"><span data-stu-id="ff51f-132">Generally you are only interested in whether a name is already defined in the XAML namescope, and what object reference value it is mapped to is immaterial.</span></span> <span data-ttu-id="ff51f-133">Pour ce scénario, vous pouvez appeler <xref:System.Windows.NameScope.ContainsKey%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="ff51f-133">For this scenario, you can call <xref:System.Windows.NameScope.ContainsKey%2A> instead.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ff51f-134">
            <paramref name="key" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-134">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.ContainsKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="ff51f-135">Clé de chaîne à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-135">The string key to find.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-136">Retourne une valeur qui indique si un nom fourni existe déjà dans ce <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-136">Returns whether a provided name already exists in this <see cref="T:System.Windows.NameScope" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-137">
            <see langword="true" /> si le <paramref name="key" /> spécifié identifie un nom pour un mappage existant dans ce <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-137">
              <see langword="true" /> if the specified <paramref name="key" /> identifies a name for an existing mapping in this <see cref="T:System.Windows.NameScope" />.</span>
          </span>
          <span data-ttu-id="ff51f-138">
            <see langword="false" /> si <paramref name="key" /> spécifié n'existe pas dans le <see cref="T:System.Windows.NameScope" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-138">
              <see langword="false" /> if the specified <paramref name="key" /> does not exist in the current <see cref="T:System.Windows.NameScope" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-139">Les noms dans une portée de nom XAML doivent utiliser une grammaire particulière qui restreint les chaînes que vous pouvez utiliser pour les entrées de <xref:System.Windows.NameScope> API.</span><span class="sxs-lookup"><span data-stu-id="ff51f-139">Names in a XAML namescope must use a particular grammar that restricts the strings you might use for inputs of <xref:System.Windows.NameScope> API.</span></span> <span data-ttu-id="ff51f-140">Consultez [XamlName, grammaire](~/docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="ff51f-140">See [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-141">
            <paramref name="key" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-141">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;string,object&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of String, Object)(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ff51f-142">Tableau unidimensionnel qui représente la destination des éléments copiés à partir de la collection. Le tableau doit avoir une indexation de base zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-142">The one-dimensional array that is the destination of the elements copied from the collection The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="ff51f-143">Index de base zéro dans un <c>tableau</c> auquel commencer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-143">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-144">Copie les éléments de la collection dans un tableau, en commençant au niveau d’un index de tableau particulier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-144">Copies the elements of the collection to an array, starting at a particular array index.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-145">Retourne le nombre d'éléments dans la collection de noms mappés dans ce <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-145">Returns the number of items in the collection of mapped names in this <see cref="T:System.Windows.NameScope" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff51f-146">Nombre d’éléments dans la collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-146">The number of items in the collection.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="ff51f-147">Partie nom d’un mappage existant pour lequel récupérer la partie objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-147">Name portion of an existing mapping to retrieve the object portion for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-148">Retourne l'objet correspondant dans la portée de nom XAML conservée par ce <see cref="T:System.Windows.NameScope" />, selon une chaîne de nom fournie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-148">Returns the corresponding object in the XAML namescope maintained by this <see cref="T:System.Windows.NameScope" />, based on a provided name string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-149">Objet demandé qui est mappé avec <paramref name="name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-149">The requested object that is mapped with <paramref name="name" />.</span>
          </span>
          <span data-ttu-id="ff51f-150">Retourner <see langword="null" /> si <paramref name="name" /> a été fourni comme <see langword="null" /> ou chaîne vide, ou si aucun objet correspondant n'a été trouvé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-150">Can return <see langword="null" /> if <paramref name="name" /> was provided as <see langword="null" /> or empty string, or if no matching object was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-151">Plusieurs éléments de base (<xref:System.Windows.FrameworkElement>, <xref:System.Windows.FrameworkElement>) également exposer une `FindName` méthode avec des fonctionnalités identiques.</span><span class="sxs-lookup"><span data-stu-id="ff51f-151">Several base elements (<xref:System.Windows.FrameworkElement>, <xref:System.Windows.FrameworkElement>) also expose a `FindName` method with identical functionality.</span></span> <span data-ttu-id="ff51f-152">Les versions de l’élément de base effectuent une recherche de portée de nom XAML dans l’arborescence logique classique, l’utilisation vers l’élément racine.</span><span class="sxs-lookup"><span data-stu-id="ff51f-152">The base element versions perform a XAML namescope search within the conventional logical tree, working towards the root element.</span></span> <span data-ttu-id="ff51f-153">Une fois la portée de nom XAML est déterminée, cette portée de nom XAML est interrogée pour le nom demandé.</span><span class="sxs-lookup"><span data-stu-id="ff51f-153">Once the XAML namescope is determined, that XAML namescope is queried for the requested name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindName(System.String)" />
        <altmember cref="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNameScope">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.INameScope GetNameScope (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.INameScope GetNameScope(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.GetNameScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::INameScope ^ GetNameScope(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.INameScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">
          <span data-ttu-id="ff51f-154">Objet duquel obtenir la portée de nom XAML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-154">The object to get the XAML namescope from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-155">Fournit l'accesseur get de propriété jointe pour la propriété jointe <see cref="P:System.Windows.NameScope.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-155">Provides the attached property get accessor for the <see cref="P:System.Windows.NameScope.NameScope" /> attached property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-156">Portée de nom XAML, comme une instance <see cref="T:System.Windows.Markup.INameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-156">A XAML namescope, as an <see cref="T:System.Windows.Markup.INameScope" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-157">L’objectif de cette méthode est à la fois pour implémenter le `get` accesseur pour l’utilisation de <xref:System.Windows.NameScope.NameScope%2A> comme une propriété attachée dans l’utilisation XAML et de fournir l’accesseur pour effectuer l’opération équivalente dans le code.</span><span class="sxs-lookup"><span data-stu-id="ff51f-157">The purpose of this method is both to implement the `get` accessor for using <xref:System.Windows.NameScope.NameScope%2A> as an attached property in XAML usage, and to provide the accessor for performing the equivalent operation in code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-158">
            <paramref name="dependencyObject" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-158">
              <paramref name="dependencyObject" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-159">Obtient une valeur indiquant si la collection est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-159">Gets a value indicating whether the collection is read-only.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff51f-160">Retourne toujours <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-160">Always returns <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="ff51f-161">Nom de chaîne pour le mappage de nom XAML à obtenir ou définir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-161">The string name for the XAML name mapping to get or set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-162">Obtient ou définit l'élément avec la clé spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-162">Gets or sets the item with the specified key.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff51f-163">Valeur de l'objet mappé par le nom XAML fourni comme <paramref name="key" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-163">The value of the object mapped by the XAML name provided as <paramref name="key" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-164">
            <paramref name="key" /> est fourni comme <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-164">
              <paramref name="key" /> is provided as <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ff51f-165">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-165">-or-</span>
          </span>
          <span data-ttu-id="ff51f-166">
            <paramref name="value" /> est fourni comme <see langword="null" /> pour une opération Set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-166">
              <paramref name="value" /> is provided as <see langword="null" /> for a set operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ Keys { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-167">Obtient une collection des clés dans le dictionnaire <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-167">Gets a collection of the keys in the <see cref="T:System.Windows.NameScope" /> dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff51f-168">Collection des clés dans le dictionnaire <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-168">A collection of the keys in the <see cref="T:System.Windows.NameScope" /> dictionary.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NameScope">
      <MemberSignature Language="C#" Value="see GetNameScope, and SetNameScope" />
      <MemberSignature Language="ILAsm" Value="see GetNameScope, and SetNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.NameScope" />
      <MemberSignature Language="VB.NET" Value="see GetNameScope, and SetNameScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NameScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.NameScope.NameScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-169">Identifie la propriété jointe <see cref="P:System.Windows.NameScope.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-169">Identifies the <see cref="P:System.Windows.NameScope.NameScope" /> attached property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="ff51f-170">Nom à utiliser pour le mappage de l’objet donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-170">The name to use for mapping the given object.</span>
          </span>
        </param>
        <param name="scopedElement">
          <span data-ttu-id="ff51f-171">Objet à mapper au nom fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-171">The object to be mapped to the provided name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-172">Inscrit une nouvelle paire nom-objet dans la portée de nom XAML actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-172">Registers a new name-object pair into the current XAML namescope.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-173">
            <paramref name="name" /> ou <paramref name="scopedElement" /> a été fourni avec la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-173">
              <paramref name="name" /> or <paramref name="scopedElement" /> was provided as <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ff51f-174">
            <paramref name="name" /> a été fourni comme chaîne vide</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-174">
              <paramref name="name" /> was provided as empty string</span>
          </span>
          <span data-ttu-id="ff51f-175">\- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-175">\- or -</span>
          </span>
          <span data-ttu-id="ff51f-176">Le <paramref name="name" /> fourni a été rejeté par l'analyseur, car il contenait des caractères non valides pour un nom XAML</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-176">
              <paramref name="name" /> provided was rejected by the parser, because it contained characters that are invalid for a XAML name</span>
          </span>
          <span data-ttu-id="ff51f-177">\- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-177">\- or -</span>
          </span>
          <span data-ttu-id="ff51f-178">
            <paramref name="name" /> fourni provoquerait une inscription de nom en double.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-178">
              <paramref name="name" /> provided would result in a duplicate name registration.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-179">Supprime l'objet spécifique de la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-179">Removes the specific object from the collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Collections.Generic.KeyValuePair&lt;string,object&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As KeyValuePair(Of String, Object)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="ff51f-180">Objet à supprimer de la collection, spécifié comme un <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (la clé est <see cref="T:System.String" />, la valeur est <see cref="T:System.Object" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-180">The object to remove from the collection, specified as a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (key is <see cref="T:System.String" />, value is <see cref="T:System.Object" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-181">Supprime l'objet spécifique de la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-181">Removes the specific object from the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-182">
            <see langword="true" /> si l'élément a été supprimé avec succès de la collection ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-182">
              <see langword="true" /> if item was successfully removed from the collection, otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="ff51f-183">Retourne également <see langword="false" /> si l'élément est introuvable dans la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-183">Also returns <see langword="false" /> if the item was not found in the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-184">Étant donné que <xref:System.Windows.NameScope> est un dictionnaire est aucun concept de première occurrence ; donné <xref:System.Collections.Generic.KeyValuePair%602> est garanti unique.</span><span class="sxs-lookup"><span data-stu-id="ff51f-184">Because <xref:System.Windows.NameScope> is a dictionary there is no concept of first occurrence; any given <xref:System.Collections.Generic.KeyValuePair%602> is guaranteed unique.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="ff51f-185">Clé de chaîne, qui est le nom du mappage de la portée de nom XAML à supprimer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-185">The string key, which is the name of the XAML namescope mapping to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-186">Supprime de la collection un mappage pour un nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-186">Removes a mapping for a specified name from the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-187">
            <see langword="true" /> si l'élément a été supprimé avec succès de la collection ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-187">
              <see langword="true" /> if item was successfully removed from the collection, otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="ff51f-188">Retourne également <see langword="false" /> si l'élément est introuvable dans la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-188">Also returns <see langword="false" /> if the item was not found in the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-189">Cette méthode inclut <xref:System.Windows.NameScope.UnregisterName%2A>, qui retourne `false` dans les cas qui sinon auraient déclenché des exceptions dans <xref:System.Windows.NameScope.UnregisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff51f-189">This method basically wraps <xref:System.Windows.NameScope.UnregisterName%2A>, returning `false` in cases that otherwise would have raised exceptions in <xref:System.Windows.NameScope.UnregisterName%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNameScope">
      <MemberSignature Language="C#" Value="public static void SetNameScope (System.Windows.DependencyObject dependencyObject, System.Windows.Markup.INameScope value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetNameScope(class System.Windows.DependencyObject dependencyObject, class System.Windows.Markup.INameScope value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.SetNameScope(System.Windows.DependencyObject,System.Windows.Markup.INameScope)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetNameScope(System::Windows::DependencyObject ^ dependencyObject, System::Windows::Markup::INameScope ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Markup.INameScope" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">
          <span data-ttu-id="ff51f-190">Objet pour lequel modifier la portée de nom XAML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-190">Object to change XAML namescope for.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ff51f-191">Nouvelle portée de nom XAML, utilisant un transtypage d’interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-191">The new XAML namescope, using an interface cast.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-192">Fournit l'accesseur set de propriété jointe pour la propriété jointe <see cref="P:System.Windows.NameScope.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-192">Provides the attached property set accessor for the <see cref="P:System.Windows.NameScope.NameScope" /> attached property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-193">L’objectif de cette méthode est à la fois en tant que le `set` accesseur pour l’utilisation de <xref:System.Windows.NameScope.NameScope%2A> comme une propriété attachée dans l’utilisation XAML et de fournir l’accesseur pour effectuer l’opération équivalente dans le code.</span><span class="sxs-lookup"><span data-stu-id="ff51f-193">The purpose of this method is both to act as the `set` accessor for using <xref:System.Windows.NameScope.NameScope%2A> as an attached property in XAML usage, and to provide the accessor for performing the equivalent operation in code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-194">
            <paramref name="dependencyObject" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-194">
              <paramref name="dependencyObject" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-195">Retourne un énumérateur qui itère au sein d’une collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-195">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-196">Énumérateur qui itère au sein d’une collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-196">An enumerator that iterates through a collection.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (string key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(string key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.TryGetValue(System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(System::String ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="ff51f-197">Clé de la valeur à obtenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-197">The key of the value to get.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ff51f-198">Cette méthode retourne la valeur associée à la clé spécifiée, si la clé est trouvée ; sinon, un objet null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-198">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, a null object.</span>
          </span>
          <span data-ttu-id="ff51f-199">Ce paramètre est passé sans être initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-199">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-200">Obtient la valeur associée à la clé spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-200">Gets the value associated with the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ff51f-201">true si le <see cref="T:System.Windows.NameScope" /> contient un mappage pour le nom fourni comme <paramref name="key" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-201">true if the <see cref="T:System.Windows.NameScope" /> contains a mapping for the name provided as <paramref name="key" />.</span>
          </span>
          <span data-ttu-id="ff51f-202">Sinon, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-202">Otherwise, false.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="ff51f-203">Nom du mappage à supprimer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-203">The name of the mapping to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ff51f-204">Supprime un mappage nom-objet de la portée de nom XAML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-204">Removes a name-object mapping from the XAML namescope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff51f-205">Avant d’appeler cette méthode, vous pouvez utiliser <xref:System.Windows.NameScope.FindName%2A> pour déterminer si un mappage nom-objet spécifique existe.</span><span class="sxs-lookup"><span data-stu-id="ff51f-205">Before calling this method, you can use <xref:System.Windows.NameScope.FindName%2A> to determine whether a specific name-object mapping exists.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ff51f-206">
            <paramref name="name" /> a été fourni comme chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-206">
              <paramref name="name" /> was provided as empty string.</span>
          </span>
          <span data-ttu-id="ff51f-207">\- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-207">\- or -</span>
          </span>
          <span data-ttu-id="ff51f-208">Le <paramref name="name" /> fourni n'avait pas été enregistré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-208">
              <paramref name="name" /> provided had not been registered.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ff51f-209">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-209">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
        <altmember cref="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;object&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;object&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::Object ^&gt; ^ Values { System::Collections::Generic::ICollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ff51f-210">Obtient une collection des valeurs dans le dictionnaire <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-210">Gets a collection of the values in the <see cref="T:System.Windows.NameScope" /> dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ff51f-211">Collection des valeurs dans le dictionnaire <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ff51f-211">A collection of the values in the <see cref="T:System.Windows.NameScope" /> dictionary.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>