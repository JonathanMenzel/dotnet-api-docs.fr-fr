<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8f6112c09b1f961b689a530d29b65eeca46e3156" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30679763" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contient des données d’événements et des informations état associées à un événement routé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autre <xref:System.Windows.RoutedEventArgs> peut être utilisé avec un seul <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Cette classe est chargée d’empaqueter les données d’événement pour un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, qui fournit des informations d’état des événements supplémentaires et est utilisé par le système d’événements pour appeler le gestionnaire associé à l’événement routé.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez ce constructeur sans paramètre, le toutes les propriétés publiques de la nouvelle <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> valeur par défaut est `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> valeur par défaut est `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.  
  
 Valeurs null <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> cela signifie simplement que le <xref:System.Windows.RoutedEventArgs> données n’effectue aucune tentative pour spécifier la source. Lorsque cette instance est utilisée dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>, le <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeurs sont remplis en fonction de l’élément qui a déclenché l’événement et est passé aux écouteurs par le routage.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificateur d'événement routé pour cette instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" /> à l'aide de l'identificateur d'événement routé fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés du nouveau n’est pas spécifié lorsque vous utilisez ce constructeur surchargé, <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> valeur par défaut est `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.  
  
 Valeurs null <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> cela signifie simplement que cela <xref:System.Windows.RoutedEventArgs> n’effectue aucune tentative pour spécifier la source. Lorsque cette instance est utilisée dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>, le <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeurs sont remplis en fonction de l’élément qui a déclenché l’événement et est passé aux écouteurs par le routage.  
  
   
  
## Examples  
 L’exemple suivant construit une nouvelle <xref:System.Windows.RoutedEventArgs> pour une utilisation dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificateur d'événement routé pour cette instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Autre source qui sera signalée lorsque l'événement sera géré. La propriété <see cref="P:System.Windows.RoutedEventArgs.Source" /> est alors préremplie.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" /> à l'aide de l'identificateur d'événement routé fourni afin de pouvoir déclarer une source différente pour l'événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés du nouveau n’est pas spécifié lorsque vous utilisez ce constructeur surchargé, <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.  
  
 Valeurs null <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sont remplis en fonction de l’élément qui a déclenché l’événement et transmises par le routage, mais elles seront `null` avant l’appel.  
  
 Utilisez cette signature lors du passage de <xref:System.Windows.RoutedEventArgs> à des éléments virtuels tels que <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, où les arguments sont utilisés pour appeler <xref:System.Windows.UIElement.RaiseEvent%2A> en interne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique l’état actuel de la gestion des événements pour un événement routé le long de son itinéraire.</summary>
        <value>Définition, affectez <see langword="true" /> si l’événement doit être marqué comme géré ; sinon <see langword="false" />. Si la lecture de cette valeur, <see langword="true" /> indique que, soit en utilisant un gestionnaire de classe le long de l’itinéraire, un gestionnaire d’instance a déjà marqué cet événement géré. <see langword="false" /> indique qu’aucun gestionnaire n’a marqué l’événement comme géré.  
  
 La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le marquage de l’événement géré limite la visibilité de l’événement routé pour les écouteurs sur l’itinéraire d’événement. L’événement circulent toujours le reste de l’itinéraire, mais seuls les gestionnaires ajoutés avec `HandledEventsToo` `true` dans le <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> appel de méthode sera appelé en réponse. Gestionnaires par défaut sur les écouteurs d’instance (tels que ceux exprimés dans [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) ne sera pas appelé. La gestion des événements qui sont marqués gérés ne sont pas un scénario courant.  
  
 Si vous êtes l’auteur du contrôle définissez vos propres événements, les décisions que vous prenez concernant les événements gestion au niveau de la classe a un impact sur les utilisateurs de votre contrôle, ainsi que tous les utilisateurs de contrôles dérivés, et potentiellement les autres éléments qui sont contenus dans votre contrôle ou qui contient votre contrôle. Pour plus d’informations, consultez [Marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 En de rares circonstances, il convient de gérer les événements où <xref:System.Windows.RoutedEventArgs.Handled%2A> est marquée `true`et modifiez les arguments d’événement en définissant <xref:System.Windows.RoutedEventArgs.Handled%2A> à `false`. Cela peut être nécessaire dans certaines zones d’événements d’entrée de contrôles, telles que la gestion de clés de <xref:System.Windows.UIElement.KeyDown> et <xref:System.Windows.UIElement.TextInput> où bas niveau et haut niveau des événements d’entrée sont en concurrence pour la gestion chacun tente de travailler avec une autre stratégie de routage.  
  
   
  
## Examples  
 L’exemple suivant implémente un gestionnaire d’événements qui marque l’événement géré.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Implémentation de gestionnaire générique/délégué à appeler.</param>
        <param name="genericTarget">Cible sur laquelle le gestionnaire fourni doit être appelé.</param>
        <summary>En cas de substitution dans une classe dérivée, fournit un moyen d’appeler des gestionnaires d’événements d’une manière propre au type, ce qui peut améliorer l’efficacité par rapport à l’implémentation de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de base incorpore la réflexion pour déterminer le gestionnaire approprié pour tous les cas où le gestionnaire n’est pas <xref:System.Windows.RoutedEventHandler>, et cette étape de réflexion a des conséquences sur les performances. Appels peuvent être effectuées plus efficaces en vous appuyant ne pas sur la réflexion. C’est le scénario qui motive cette méthode pour toute classe d’arguments d’événement routé choisissez Remplacer. Les implémentations doivent appeler pas la base pour cette méthode, car votre implémentation doit être déjà chargée d’appeler les gestionnaires de types sécurisés.  
  
   
  
## Examples  
 Voici pseudocode suivant illustre un modèle de base qui peut être utilisé pour l’implémentation. Ici, `MyRoutedEventHandler` est une sous-classe de <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cette méthode est conçue pour être substituée par les classes de données d’événement dérivé pour appeler plus efficacement leurs délégués. L’implémentation doit effectuer un cast fourni <paramref name="genericHandler" /> spécifique au type délégué et puis appeler ce gestionnaire.  
  
 L’implémentation par défaut va tenter d’appeler le gestionnaire fourni, essayez d’effectuer un cast en tant que <see cref="T:System.Windows.RoutedEventHandler" />. Si le paramètre <paramref name="genericHandler" /> ou <paramref name="genericTarget" /> est fournie en tant que <see langword="null" />, des exceptions sont levées.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nouvelle valeur de <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>En cas de substitution dans une classe dérivée, fournit un point d'entrée de notification de rappel dès que la valeur de propriété <see cref="P:System.Windows.RoutedEventArgs.Source" /> d'une instance change.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>La modification de la source indiquée d’un événement par programmation peut requérir la mise à jour les données spécifiques au type de l’événement. Pour cette raison, le <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> méthode virtuelle est protégée et est destinée à être substituée par des sous-classes de <see cref="T:System.Windows.RoutedEventArgs" />.  
  
 Cette méthode n’a aucune implémentation par défaut.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la source de signalement d’origine telle que déterminée par un test de positionnement pur, avant tout ajustement <see cref="P:System.Windows.RoutedEventArgs.Source" /> pouvant être effectué par une classe parente.</summary>
        <value>Source de création de rapports d'origine avant que la gestion de classe n'ait effectué un ajustement <see cref="P:System.Windows.RoutedEventArgs.Source" /> pour aplatir des arborescences d'éléments composées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété acquiert sa valeur, avant de la classe de gestionnaires d’événements ou d’instances sont appelées et n’est jamais ajustée au-delà de ce point. Les informations de la source d’origine sont en lecture seule pour les gestionnaires de classe ou des implémentations de la classe, comme il est signalé dans les données d’événement.  
  
 Cas où la source peut être ajustée, notamment les éléments de contenu à l’intérieur d’un modèle de contenu pour un contrôle (le contenu d’un élément de liste, par exemple, signalera l’élément de liste en tant que le <xref:System.Windows.RoutedEventArgs.Source%2A> et l’élément réel dans l’élément de liste sera le <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Ajustements de source par différents éléments et les modèles de contenu varient pour chaque classe. Chaque classe qui ajuste des sources d’événements essaie de prévoir quelle source les plus utiles à un rapport de plus de scénarios d’entrée et les scénarios pour lesquels la classe est prévue et puis jeux source comme la <xref:System.Windows.RoutedEventArgs.Source%2A>. Si cette source n’est pas celui qui est en rapport avec votre gestion de l’événement, essayez de vérifier <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> à la place pour voir si elle signale une autre source qui est plus adaptée. Pour plus d’informations sur les événements d’entrée, consultez [vue d’ensemble d’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associé à cette instance <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Identificateur de l’événement qui a été appelée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas définir cette valeur sur un <xref:System.Windows.RoutedEventArgs> qui a déjà été routé (par exemple, si vous avez obtenu les arguments via un gestionnaire). Toute tentative génère une exception. Vous pouvez uniquement définir sur une instance qui n’a pas encore été utilisée pour générer un appel de l’événement.  
  
 La valeur de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ne peut pas être `null` à tout moment.  
  
   
  
## Examples  
 L’exemple suivant crée des données de l’événement routé avec un constructeur initial et définit ensuite la <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> propriété comme opération suivante. Vous devez avoir <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> défini avant de déclencher l’événement routé.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tenté de modifier la valeur <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> lors de l'acheminement de l'événement.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une référence à l’objet ayant déclenché l’événement.</summary>
        <value>Objet ayant déclenché l'événement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour toute propagation routé événement qui a poursuivi son itinéraire au-delà de l’élément qui l’a déclenché et pour n’importe quel tunneling acheminés d’événement qui n’a pas encore atteint l’élément qui l’a déclenché, la valeur de <xref:System.Windows.RoutedEventArgs.Source%2A> sera différente de la valeur de la `sender` paramètre de la classe d’arguments d’événement. Parmi les deux éléments impliqués dans l’événement sont le plus important dans un gestionnaire donné (<xref:System.Windows.RoutedEventArgs.Source%2A>, l’élément qui a déclenché ou `sender`, l’élément qui le gère actuellement) dépend de la logique d’application que votre gestionnaire est adressage.  
  
 Définition de cette propriété est généralement uniquement le cas lors de la substitution ou d’implémentation d’autres [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] qui ajustent des sources d’événements, par exemple quand un événement de gestion de classe. La redéfinition des sources d’événements apparentes à partir des gestionnaires d’instance n'est pas recommandée, en particulier lorsque le gestionnaire ne marque pas l’événement comme géré.  
  
 Si vous redéfinissez <xref:System.Windows.RoutedEventArgs.Source%2A> pour signaler une source d’événement différente, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> continuera à signaler la source en tant que premier déclenchée par l’origine <xref:System.Windows.UIElement.RaiseEvent%2A> appeler.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>