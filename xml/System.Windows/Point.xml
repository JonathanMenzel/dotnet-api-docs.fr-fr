<Type Name="Point" FullName="System.Windows.Point">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="656bf6a484a46164e7da6c818efeae44503e9c85" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52359314" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Point : IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Point extends System.ValueType implements class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Point" />
  <TypeSignature Language="VB.NET" Value="Public Structure Point&#xA;Implements IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Point : IFormattable" />
  <TypeSignature Language="F#" Value="type Point = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.PointConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.Converters.PointValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une paire de coordonnées x et y dans l'espace à deux dimensions.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans XAML, le séparateur entre les <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> valeurs d’un <xref:System.Windows.Point> peut être une virgule ou un espace.  
  
 Certaines cultures peuvent utiliser le caractère virgule comme séparateur décimal au lieu de la virgule. XAML de traitement pour la culture dite indifférente est en-US dans la plupart des implémentations de processeur XAML par défaut et attend le point comme séparateur décimal. Évitez d’utiliser le caractère virgule comme séparateur décimal si vous spécifiez un <xref:System.Windows.Point> dans XAML, car cela qui entrera en conflit avec la conversion de type chaîne d’un <xref:System.Windows.Point> attribut la valeur dans le <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> composants.  
  
<a name="xamlAttributeUsage_Duration"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="x,y"/>  
-or-  
<object property="x y"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *x*  
 Coordonnée x de ce <xref:System.Windows.Point>.  
  
 *y*  
 Coordonnée y de ce <xref:System.Windows.Point>.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures ne sont pas égales.  Il illustre également comment affecter des valeurs à un <xref:System.Windows.Point> structure lors de la structure est déclarée et une fois que la structure a été déclarée.  
  
 [!code-csharp[PointExamples_snip#PointInequalityExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#pointinequalityexample)]
 [!code-vb[PointExamples_snip#PointInequalityExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#pointinequalityexample)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Point (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (x As Double, y As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Point(double x, double y);" />
      <MemberSignature Language="F#" Value="new System.Windows.Point : double * double -&gt; System.Windows.Point" Usage="new System.Windows.Point (x, y)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Coordonnée x de la nouvelle structure <see cref="T:System.Windows.Point" />.</param>
        <param name="y">Coordonnée y de la nouvelle structure <see cref="T:System.Windows.Point" />.</param>
        <summary>Crée une structure <see cref="T:System.Windows.Point" /> qui contient les coordonnées spécifiées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Windows.Point Add (System.Windows.Point point, System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point Add(valuetype System.Windows.Point point, valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Add(System.Windows.Point,System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point Add(System::Windows::Point point, System::Windows::Vector vector);" />
      <MemberSignature Language="F#" Value="static member Add : System.Windows.Point * System.Windows.Vector -&gt; System.Windows.Point" Usage="System.Windows.Point.Add (point, vector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="point">Structure <see cref="T:System.Windows.Point" /> à ajouter.</param>
        <param name="vector">Structure <see cref="T:System.Windows.Vector" /> à ajouter.</param>
        <summary>Ajoute <see cref="T:System.Windows.Vector" /> à un <see cref="T:System.Windows.Point" /> et retourne le résultat sous forme de structure <see cref="T:System.Windows.Point" />.</summary>
        <returns>Retourne la somme de <paramref name="point" /> et <paramref name="vector" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ajout d’un <xref:System.Windows.Point> structure un <xref:System.Windows.Point> structure est interdite.  
  
   
  
## Examples  
 Cet exemple ajoute un <xref:System.Windows.Point> à un <xref:System.Windows.Vector> et retourne le résultat comme un <xref:System.Windows.Vector> structure.  
  
 [!code-csharp[PointExamples_snip#AddPointAndVectorExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#addpointandvectorexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.op_Addition(System.Windows.Point,System.Windows.Vector)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare l'égalité de deux structures <see cref="T:System.Windows.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="point.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <see cref="T:System.Object" /> à comparer.</param>
        <summary>Détermine si l'<see cref="T:System.Object" /> spécifié est un <see cref="T:System.Windows.Point" /> et s'il contient les mêmes coordonnées que ce <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="o" /> est un <see cref="T:System.Windows.Point" /> et qu'il reprend les mêmes valeurs <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> que <see cref="T:System.Windows.Point" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Point> les coordonnées sont décrites à l’aide de <xref:System.Double> valeurs. Étant donné que la valeur d’un <xref:System.Double> peut manquer de précision lors de l’opération, une comparaison entre deux <xref:System.Windows.Point> valeurs qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures sont égales à l’aide de la non statique <xref:System.Windows.Point.Equals%2A> (méthode).  
  
 [!code-csharp[PointExamples_snip#NonStaticEqualsExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#nonstaticequalsexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.op_Equality(System.Windows.Point,System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Windows.Point value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Windows.Point value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Equals(System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Point) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Windows::Point value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Windows.Point -&gt; bool" Usage="point.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="value">Point à comparer à cette instance.</param>
        <summary>Compare l'égalité de deux structures <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see langword="true" /> si les deux structures <see cref="T:System.Windows.Point" /> contiennent les mêmes valeurs de <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Point> les coordonnées sont exprimées à l’aide de <xref:System.Double> valeurs. Étant donné que la valeur d’un <xref:System.Double> peuvent perdre en précision lorsqu’elles sont exploitées, une comparaison entre deux <xref:System.Windows.Point> valeurs qui sont logiquement égales peuvent échouer.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.op_Equality(System.Windows.Point,System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (System.Windows.Point point1, System.Windows.Point point2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Equals(System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (point1 As Point, point2 As Point) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Windows::Point point1, System::Windows::Point point2);" />
      <MemberSignature Language="F#" Value="static member Equals : System.Windows.Point * System.Windows.Point -&gt; bool" Usage="System.Windows.Point.Equals (point1, point2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point1">Premier point à comparer.</param>
        <param name="point2">Deuxième point à comparer.</param>
        <summary>Compare l'égalité de deux structures <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="point1" /> et <paramref name="point2" /> contiennent les mêmes valeurs respectives <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coordonnées du point sont décrites à l’aide de <xref:System.Double> valeurs. Étant donné que la valeur d’un <xref:System.Double> peut manquer de précision lors de l’opération, une comparaison entre deux <xref:System.Windows.Point> valeurs qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures sont égales à l’aide de la méthode statique <xref:System.Windows.Point.Equals%2A> (méthode).  
  
 [!code-csharp[PointExamples_snip#StaticEqualsExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#staticequalsexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.op_Equality(System.Windows.Point,System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="point.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour ce <see cref="T:System.Windows.Point" />.</summary>
        <returns>Code de hachage pour cette structure <see cref="T:System.Windows.Point" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment obtenir le code de hachage d’un <xref:System.Windows.Point> structure.  
  
 [!code-csharp[PointExamples_snip#GetHashCodeExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#gethashcodeexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Windows.Point Multiply (System.Windows.Point point, System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point Multiply(valuetype System.Windows.Point point, valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Multiply(System.Windows.Point,System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point Multiply(System::Windows::Point point, System::Windows::Media::Matrix matrix);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Windows.Point * System.Windows.Media.Matrix -&gt; System.Windows.Point" Usage="System.Windows.Point.Multiply (point, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="point">Point à transformer.</param>
        <param name="matrix">Matrice de transformation.</param>
        <summary>Transforme la structure <see cref="T:System.Windows.Point" /> spécifiée par la structure <see cref="T:System.Windows.Media.Matrix" /> indiquée.</summary>
        <returns>Point transformé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment multiplier un <xref:System.Windows.Point> structure par une <xref:System.Windows.Media.Matrix> structure à l’aide de la <xref:System.Windows.Point.Multiply%2A> (méthode).  
  
 [!code-csharp[PointExamples_snip#MultiplyPointByMatrixExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#multiplypointbymatrixexample_csharp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.op_Multiply(System.Windows.Point,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public void Offset (double offsetX, double offsetY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Offset(float64 offsetX, float64 offsetY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Offset(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Offset (offsetX As Double, offsetY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Offset(double offsetX, double offsetY);" />
      <MemberSignature Language="F#" Value="member this.Offset : double * double -&gt; unit" Usage="point.Offset (offsetX, offsetY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offsetX" Type="System.Double" />
        <Parameter Name="offsetY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offsetX">Décalage de 
 coordonnée <see cref="P:System.Windows.Point.X" /> du point.</param>
        <param name="offsetY">Décalage de 
coordonnée <see cref="P:System.Windows.Point.Y" /> du point.</param>
        <summary>Décale les coordonnées <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> d'un point des valeurs spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération est équivalente à l’ajout d’un <xref:System.Windows.Point> à un <xref:System.Windows.Vector>.  
  
 Notez que l’appel le <xref:System.Windows.Point.Offset%2A> méthode a un effet uniquement si vous pouvez modifier le <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> propriétés directement. Étant donné que <xref:System.Windows.Point> est un type valeur, si vous référencez un <xref:System.Windows.Point> objet en utilisant une propriété ou un indexeur, vous obtenez une copie de l’objet, pas une référence à l’objet. Si vous tentez de modifier <xref:System.Windows.Point.X%2A> ou <xref:System.Windows.Point.Y%2A> sur une référence de propriété ou un indexeur, une erreur du compilateur se produit. De même, l’appel <xref:System.Windows.Point.Offset%2A> sur la propriété ou l’indexeur ne changera pas l’objet sous-jacent.  Si vous souhaitez modifier la valeur d’un <xref:System.Windows.Point> qui est référencée comme une propriété ou un indexeur, créez une nouvelle <xref:System.Windows.Point>, modifiez ses champs et affectez le <xref:System.Windows.Point> à la propriété ou l’indexeur.  
  
   
  
## Examples  
 L’exemple suivant montre comment décaler le <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> valeurs d’un <xref:System.Windows.Point> structure.  
  
 [!code-csharp[PointExamples_snip#OffsetExample_csharp](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#offsetexample_csharp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point operator + (System.Windows.Point point, System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Point op_Addition(valuetype System.Windows.Point point, valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Addition(System.Windows.Point,System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point operator +(System::Windows::Point point, System::Windows::Vector vector);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Windows.Point * System.Windows.Vector -&gt; System.Windows.Point" Usage="point + vector" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="point">Point à translater.</param>
        <param name="vector">Valeur de translation de <paramref name="point" />.</param>
        <summary>Translate le <see cref="T:System.Windows.Point" /> spécifié de <see cref="T:System.Windows.Vector" /> et renvoie le résultat.</summary>
        <returns>Résultat de la translation du point spécifié du vecteur indiqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment ajouter un <xref:System.Windows.Point> à un <xref:System.Windows.Vector> à l’aide de surchargé (+) opérateur.  
  
 [!code-csharp[PointExamples_snip#OverloadedAdditionOperatorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedadditionoperatorexample)]
 [!code-vb[PointExamples_snip#OverloadedAdditionOperatorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedadditionoperatorexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.Add(System.Windows.Point,System.Windows.Vector)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Point point1, System.Windows.Point point2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Equality(System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (point1 As Point, point2 As Point) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Point point1, System::Windows::Point point2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Point * System.Windows.Point -&gt; bool" Usage="point1 = point2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point1">Première structure <see cref="T:System.Windows.Point" /> à comparer.</param>
        <param name="point2">Deuxième structure <see cref="T:System.Windows.Point" /> à comparer.</param>
        <summary>Compare l'égalité de deux structures <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see langword="true" /> si les coordonnées <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> de <paramref name="point1" /> et de <paramref name="point2" /> sont respectivement égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Coordonnées d’un point sont décrites à l’aide de <xref:System.Double> valeurs. Étant donné que la valeur de <xref:System.Double> peuvent perdre en précision lorsque les opérations arithmétiques sont exécutées dessus, une comparaison entre deux <xref:System.Windows.Point> valeurs qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures sont égales à l’aide de l’opérateur surchargé (==).  
  
 [!code-csharp[PointExamples_snip#OverloadedEqualityOperatorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedequalityoperatorexample)]
 [!code-vb[PointExamples_snip#OverloadedEqualityOperatorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedequalityoperatorexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Point.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit un <see cref="T:System.Windows.Point" /> en <see cref="T:System.Windows.Size" /> ou en <see cref="T:System.Windows.Vector" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Windows.Size (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Size op_Explicit(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Explicit(System.Windows.Point)~System.Windows.Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Windows::Size(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Windows.Point -&gt; System.Windows.Size" Usage="System.Windows.Point.op_Explicit point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Point à convertir.</param>
        <summary>Crée une structure <see cref="T:System.Windows.Size" /> avec <see cref="P:System.Windows.Size.Width" /> égal à la valeur <see cref="P:System.Windows.Point.X" /> de ce point et <see cref="P:System.Windows.Size.Height" /> égal à sa valeur <see cref="P:System.Windows.Point.Y" />.</summary>
        <returns>Une structure <see cref="T:System.Windows.Size" /> avec <see cref="P:System.Windows.Size.Width" /> égal à la valeur <see cref="P:System.Windows.Point.X" /> de ce point et <see cref="P:System.Windows.Size.Height" /> égal à sa valeur <see cref="P:System.Windows.Point.Y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné qu’un <xref:System.Windows.Size> structure ne peut pas être négative, les valeurs absolues du point <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> propriétés sont utilisées.  
  
   
  
## Examples  
 L’exemple suivant montre comment convertir explicitement un <xref:System.Windows.Point> dans un <xref:System.Windows.Size>.  
  
 [!code-csharp[PointExamples_snip#OverloadedExplicitOperatorSizeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedexplicitoperatorsizeexample)]
 [!code-vb[PointExamples_snip#OverloadedExplicitOperatorSizeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedexplicitoperatorsizeexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Windows.Vector (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Vector op_Explicit(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Explicit(System.Windows.Point)~System.Windows.Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Windows::Vector(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Windows.Point -&gt; System.Windows.Vector" Usage="System.Windows.Point.op_Explicit point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Point à convertir.</param>
        <summary>Crée une structure <see cref="T:System.Windows.Vector" /> avec une valeur <see cref="P:System.Windows.Vector.X" /> égale à la valeur <see cref="P:System.Windows.Point.X" /> du point et <see cref="P:System.Windows.Vector.Y" /> égal à <see cref="P:System.Windows.Point.Y" /> du point.</summary>
        <returns>Vecteur avec une valeur <see cref="P:System.Windows.Vector.X" /> égale à la valeur <see cref="P:System.Windows.Point.X" /> du point et <see cref="P:System.Windows.Vector.Y" /> égal à <see cref="P:System.Windows.Point.Y" /> du point.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment convertir explicitement un <xref:System.Windows.Point> dans un <xref:System.Windows.Vector>.  
  
 [!code-csharp[PointExamples_snip#OverloadedExplicitOperatorVectorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedexplicitoperatorvectorexample)]
 [!code-vb[PointExamples_snip#OverloadedExplicitOperatorVectorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedexplicitoperatorvectorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Point point1, System.Windows.Point point2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Inequality(System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (point1 As Point, point2 As Point) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Point point1, System::Windows::Point point2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Point * System.Windows.Point -&gt; bool" Usage="System.Windows.Point.op_Inequality (point1, point2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point1">Premier point à comparer.</param>
        <param name="point2">Deuxième point à comparer.</param>
        <summary>Compare l'inégalité de deux structures <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="point1" /> et <paramref name="point2" /> présentent des coordonnées <see cref="P:System.Windows.Point.X" /> ou <see cref="P:System.Windows.Point.Y" /> différentes ; <see langword="false" /> si <paramref name="point1" /> et <paramref name="point2" /> ont les mêmes coordonnées <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 D’un point de <xref:System.Windows.Point.X%2A> et <xref:System.Windows.Point.Y%2A> les coordonnées sont décrites à l’aide de <xref:System.Double> valeurs. Étant donné que <xref:System.Double> valeurs peuvent perdre en précision lorsqu’elles sont exploitées, une comparaison entre deux <xref:System.Windows.Point> valeurs qui sont logiquement égales peuvent échouer.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures ne sont pas égales, en utilisant surchargées ( ! =) opérateur.  
  
 [!code-csharp[PointExamples_snip#OverloadedInequalityOperatorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedinequalityoperatorexample)]
 [!code-vb[PointExamples_snip#OverloadedInequalityOperatorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedinequalityoperatorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Windows.Point operator * (System.Windows.Point point, System.Windows.Media.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Point op_Multiply(valuetype System.Windows.Point point, valuetype System.Windows.Media.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Multiply(System.Windows.Point,System.Windows.Media.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point operator *(System::Windows::Point point, System::Windows::Media::Matrix matrix);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Windows.Point * System.Windows.Media.Matrix -&gt; System.Windows.Point" Usage="point * matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="matrix" Type="System.Windows.Media.Matrix" />
      </Parameters>
      <Docs>
        <param name="point">Point à transformer.</param>
        <param name="matrix">Matrice de transformation.</param>
        <summary>Transforme le <see cref="T:System.Windows.Point" /> spécifié par un objet <see cref="T:System.Windows.Media.Matrix" /> donné.</summary>
        <returns>Résultat de la transformation du point spécifié par la matrice indiquée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment multiplier un <xref:System.Windows.Point> par un <xref:System.Windows.Media.Matrix> à l’aide de l’opérateur surchargé (*).  
  
 [!code-csharp[PointExamples_snip#OverloadedMultiplyPointByMatrixOperatorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedmultiplypointbymatrixoperatorexample)]
 [!code-vb[PointExamples_snip#OverloadedMultiplyPointByMatrixOperatorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedmultiplypointbymatrixoperatorexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.Multiply(System.Windows.Point,System.Windows.Media.Matrix)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Soustrait l'attribut <see cref="T:System.Windows.Vector" /> ou <see cref="T:System.Windows.Point" /> du <see cref="T:System.Windows.Point" /> spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Windows.Vector operator - (System.Windows.Point point1, System.Windows.Point point2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Vector op_Subtraction(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Subtraction(System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (point1 As Point, point2 As Point) As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Vector operator -(System::Windows::Point point1, System::Windows::Point point2);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Windows.Point * System.Windows.Point -&gt; System.Windows.Vector" Usage="point1 - point2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point1">Point duquel <paramref name="point2" /> est soustrait.</param>
        <param name="point2">Point à soustraire de <paramref name="point1" />.</param>
        <summary>Soustrait le <see cref="T:System.Windows.Point" /> spécifié d'un autre <see cref="T:System.Windows.Point" /> indiqué et retourne la différence sous forme de <see cref="T:System.Windows.Vector" />.</summary>
        <returns>Différence entre <paramref name="point1" /> et <paramref name="point2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant indique comment soustraire un <xref:System.Windows.Point> à partir d’un autre <xref:System.Windows.Point> et retourner un <xref:System.Windows.Vector> à l’aide de l’opérateur surchargé (-).  
  
 [!code-csharp[PointExamples_snip#OverloadedSubtractionOperatorExample2](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedsubtractionoperatorexample2)]
 [!code-vb[PointExamples_snip#OverloadedSubtractionOperatorExample2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedsubtractionoperatorexample2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.Subtract(System.Windows.Point,System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Windows.Point operator - (System.Windows.Point point, System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Windows.Point op_Subtraction(valuetype System.Windows.Point point, valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.op_Subtraction(System.Windows.Point,System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point operator -(System::Windows::Point point, System::Windows::Vector vector);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Windows.Point * System.Windows.Vector -&gt; System.Windows.Point" Usage="point - vector" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="point">Point duquel <paramref name="vector" /> est soustrait.</param>
        <param name="vector">Vecteur à soustraire de <paramref name="point1" />.</param>
        <summary>Soustrait l'objet <see cref="T:System.Windows.Vector" /> spécifié du <see cref="T:System.Windows.Point" /> indiqué et retourne le <see cref="T:System.Windows.Point" /> résultant.</summary>
        <returns>Différence entre <paramref name="point" /> et <paramref name="vector" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant indique comment soustraire un <xref:System.Windows.Vector> à partir d’un <xref:System.Windows.Point> à l’aide de l’opérateur surchargé (-).  
  
 [!code-csharp[PointExamples_snip#OverloadedSubtractionOperatorExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#overloadedsubtractionoperatorexample1)]
 [!code-vb[PointExamples_snip#OverloadedSubtractionOperatorExample1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#overloadedsubtractionoperatorexample1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.Subtract(System.Windows.Point,System.Windows.Vector)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Windows.Point Parse (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point Parse(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (source As String) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point Parse(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Windows.Point" Usage="System.Windows.Point.Parse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Représentation sous forme de chaîne d'un point.</param>
        <summary>Construit un <see cref="T:System.Windows.Point" /> à partir du <see cref="T:System.String" /> spécifié.</summary>
        <returns>Structure <see cref="T:System.Windows.Point" /> équivalente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Point.Parse%2A> méthode pour convertir un <xref:System.String> la représentation sous forme d’un point dans un <xref:System.Windows.Point> structure.  
  
 [!code-csharp[PointExamples_snip#ParseExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#parseexample)]
 [!code-vb[PointExamples_snip#ParseExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#parseexample)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="source" /> ne se compose pas de deux valeurs doubles délimitées par une virgule ou un espace.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> ne contient pas deux nombres.  
  
- ou - 
 <paramref name="source" /> contient trop de séparateurs.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Soustrait l'attribut <see cref="T:System.Windows.Point" /> ou <see cref="T:System.Windows.Vector" /> du <see cref="T:System.Windows.Point" /> spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Windows.Vector Subtract (System.Windows.Point point1, System.Windows.Point point2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Vector Subtract(valuetype System.Windows.Point point1, valuetype System.Windows.Point point2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Subtract(System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (point1 As Point, point2 As Point) As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Vector Subtract(System::Windows::Point point1, System::Windows::Point point2);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Windows.Point * System.Windows.Point -&gt; System.Windows.Vector" Usage="System.Windows.Point.Subtract (point1, point2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point2" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point1">Point duquel <paramref name="point2" /> est soustrait.</param>
        <param name="point2">Point à soustraire de <paramref name="point1" />.</param>
        <summary>Soustrait le <see cref="T:System.Windows.Point" /> spécifié d'un autre <see cref="T:System.Windows.Point" /> indiqué et retourne la différence sous forme de <see cref="T:System.Windows.Vector" />.</summary>
        <returns>Différence entre <paramref name="point1" /> et <paramref name="point2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant indique comment soustraire un <xref:System.Windows.Point> à partir d’un autre <xref:System.Windows.Point> à l’aide de la méthode statique <xref:System.Windows.Point.Subtract%2A> (méthode).  
  
 [!code-csharp[PointExamples_snip#SubtractExample2](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#subtractexample2)]
 [!code-vb[PointExamples_snip#SubtractExample2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#subtractexample2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Point.op_Subtraction(System.Windows.Point,System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Windows.Point Subtract (System.Windows.Point point, System.Windows.Vector vector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point Subtract(valuetype System.Windows.Point point, valuetype System.Windows.Vector vector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.Subtract(System.Windows.Point,System.Windows.Vector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point Subtract(System::Windows::Point point, System::Windows::Vector vector);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Windows.Point * System.Windows.Vector -&gt; System.Windows.Point" Usage="System.Windows.Point.Subtract (point, vector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="vector" Type="System.Windows.Vector" />
      </Parameters>
      <Docs>
        <param name="point">Point duquel <paramref name="vector" /> est soustrait.</param>
        <param name="vector">
          <paramref name="vector" /> à soustraire du <paramref name="point" />.</param>
        <summary>Soustrait l'objet <see cref="T:System.Windows.Vector" /> spécifié du <see cref="T:System.Windows.Point" /> indiqué et retourne le <see cref="T:System.Windows.Point" /> résultant.</summary>
        <returns>Différence entre <paramref name="point" /> et <paramref name="vector" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant indique comment soustraire un <xref:System.Windows.Vector> à partir d’un <xref:System.Windows.Point> à l’aide de la méthode statique <xref:System.Windows.Point.Subtract%2A> (méthode).  
  
 [!code-csharp[PointExamples_snip#SubtractExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#subtractexample1)]
 [!code-vb[PointExamples_snip#SubtractExample1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#subtractexample1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Point.Subtract" />
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne spécifiant le format à utiliser.  
  
- ou - 
 <see langword="null" /> pour utiliser le format par défaut défini pour le type de l'implémentation <see cref="T:System.IFormattable" />.</param>
        <param name="provider">
          <see langword="IFormatProvider" /> à utiliser pour mettre en forme la valeur.  
  
- ou - 
 <see langword="null" /> pour obtenir les informations de mise en forme des nombres à partir des paramètres régionaux définis dans le système d'exploitation.</param>
        <summary>Ce membre prend en charge l’infrastructure [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] et n’est pas destiné à être directement utilisé à partir de votre code. Pour obtenir une description de ce membre, consultez <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />.</summary>
        <returns>Chaîne contenant la valeur de l'instance actuelle au format spécifié.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une représentation <see cref="T:System.String" /> de cette structure <see cref="T:System.Windows.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="point.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une représentation <see cref="T:System.String" /> de <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see cref="T:System.String" /> contenant les valeurs <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> de cette structure de <see cref="T:System.Windows.Point" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Point.ToString%2A> méthode pour obtenir un <xref:System.String> représentation sous forme d’un <xref:System.Windows.Point> structure.  
  
 [!code-csharp[PointExamples_snip#ToStringExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#tostringexample)]
 [!code-vb[PointExamples_snip#ToStringExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#tostringexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Point.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="point.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Informations de mise en forme spécifiques à la culture.</param>
        <summary>Crée une représentation <see cref="T:System.String" /> de <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see cref="T:System.String" /> contenant les valeurs <see cref="P:System.Windows.Point.X" /> et <see cref="P:System.Windows.Point.Y" /> de cette structure de <see cref="T:System.Windows.Point" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="X">
      <MemberSignature Language="C#" Value="public double X { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 X" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Point.X" />
      <MemberSignature Language="VB.NET" Value="Public Property X As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double X { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.X : double with get, set" Usage="System.Windows.Point.X" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la coordonnée <see cref="P:System.Windows.Point.X" />-de cette structure <see cref="T:System.Windows.Point" />.</summary>
        <value>Valeur de la coordonnée <see cref="P:System.Windows.Point.X" />-de cette structure <see cref="T:System.Windows.Point" />.  La valeur par défaut est <c>0</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures ne sont pas égales.  Il illustre également comment affecter des valeurs à un <xref:System.Windows.Point> structure lors de la structure est déclarée et une fois que la structure a été déclarée.  
  
 [!code-csharp[PointExamples_snip#PointInequalityExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#pointinequalityexample)]
 [!code-vb[PointExamples_snip#PointInequalityExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#pointinequalityexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Point.Y" />
      </Docs>
    </Member>
    <Member MemberName="Y">
      <MemberSignature Language="C#" Value="public double Y { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Y" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Point.Y" />
      <MemberSignature Language="VB.NET" Value="Public Property Y As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Y { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Y : double with get, set" Usage="System.Windows.Point.Y" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de coordonnée <see cref="P:System.Windows.Point.Y" /> de ce <see cref="T:System.Windows.Point" />.</summary>
        <value>Valeur de la coordonnée <see cref="P:System.Windows.Point.Y" />-de cette structure <see cref="T:System.Windows.Point" />.  La valeur par défaut est <c>0</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment vérifier si deux <xref:System.Windows.Point> structures ne sont pas égales.  Il illustre également comment affecter des valeurs à un <xref:System.Windows.Point> structure lors de la structure est déclarée et une fois que la structure a été déclarée.  
  
 [!code-csharp[PointExamples_snip#PointInequalityExample](~/samples/snippets/csharp/VS_Snippets_Wpf/PointExamples_snip/CSharp/PointExample.cs#pointinequalityexample)]
 [!code-vb[PointExamples_snip#PointInequalityExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PointExamples_snip/visualbasic/pointexample.vb#pointinequalityexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Point.X" />
      </Docs>
    </Member>
  </Members>
</Type>