<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="423f853a60d99a5767f47d8a9e4d3ef0dce3cb15" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39845056" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Définit certains aspects du comportement d’une propriété de dépendance quand elle est appliquée à un type spécifique, notamment les conditions dans lesquelles elle a été inscrite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Métadonnées de propriété peuvent être définies et utilisées lors de l’inscription de propriété de dépendance lors de l’appel le <xref:System.Windows.DependencyProperty.Register%2A> (méthode) (ou variantes pour les propriétés jointes ou les propriétés de dépendance en lecture seule), ou après l’inscription de propriétaire d’origine lors de l’appel de la <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> (méthode). <xref:System.Windows.DependencyProperty.AddOwner%2A> accepte également les métadonnées de propriété.  
  
 Cette classe est une classe de base concrète qui peut être utilisée dans chacune de ces appels. Toutefois, il est très courant de spécifier des métadonnées à l’aide d’une des classes dérivées telles que <xref:System.Windows.FrameworkPropertyMetadata>. Ces classes dérivées prennent en charge davantage de métadonnées détaillées transportées sous forme de valeurs de propriété booléenne, qui sont utiles pour détecter ou activer certains comportements de système et de mise en page de propriété qui sont implémentés uniquement au niveau du [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] au niveau du framework.  
  
 Plusieurs propriétés de cette classe sont en lecture-écriture pour le modèle objet, mais ne peut être écrit avant de l’instance utilisée dans une opération de système de propriétés telles que <xref:System.Windows.DependencyProperty.Register%2A> ou <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>. Chacune de ces propriétés peut également avoir été défini par le constructeur, mais sont exposées afin que <xref:System.Windows.PropertyMetadata.Merge%2A> implémentations de méthode pour les définir.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Ce type et les membres de ce type, ne sont pas généralement utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.PropertyMetadata" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.PropertyMetadata" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut à spécifier pour une propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.PropertyMetadata" /> avec une valeur par défaut spécifiée pour la propriété de dépendance à laquelle ces métadonnées seront appliquées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation (l’incompatibilité lève une exception au moment de l’exécution).  
  
 Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> ne peut pas être spécifié. Une telle tentative lève une exception.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ne peut pas avoir la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés doit appeler à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.PropertyMetadata" /> avec la référence d'implémentation <see cref="T:System.Windows.PropertyChangedCallback" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés doit appeler à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.PropertyMetadata" /> avec la valeur par défaut et la référence d'implémentation <see cref="T:System.Windows.PropertyChangedCallback" /> spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation (l’incompatibilité lève une exception au moment de l’exécution).  
  
 Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> ne peut pas être spécifié. Une telle tentative lève une exception.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ne peut pas avoir la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés doit appeler à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui doit être appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> à l'aide de cette propriété.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.PropertyMetadata" /> avec la valeur par défaut et les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous souhaitez spécifier un <xref:System.Windows.CoerceValueCallback> mais pas un <xref:System.Windows.PropertyChangedCallback>, vous pouvez passer `null` pour le `propertyChangedCallback` paramètre.  
  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation (l’incompatibilité lève une exception au moment de l’exécution).  
  
 Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> ne peut pas être spécifié. Une telle tentative lève une exception.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> ne peut pas avoir la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une référence à une implémentation <see cref="T:System.Windows.CoerceValueCallback" /> spécifiée dans ces métadonnées.</summary>
        <value>Référence d'implémentation <see cref="T:System.Windows.CoerceValueCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les rappels dans les métadonnées de propriété ne sont pas des membres publics généralement sur le type conteneur, donc la valeur de cette propriété n’est pas importante pour la plupart des scénarios qui consomment uniquement les métadonnées d’une propriété de dépendance existante. Cette propriété est exposée est afin que les sous-classes de métadonnées puissent appliquer la logique de fusion souhaitée si les métadonnées de base et substitution / d’ajout spécifient un <xref:System.Windows.CoerceValueCallback>. Toutefois, la valeur par défaut de fusion logique pour un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> consiste à remplacer le précédent.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> est défini dans le modèle objet en lecture-écriture. C’est le cas <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> peuvent être ajustées après initialisation de la <xref:System.Windows.PropertyMetadata> objet lui-même. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont maintenant considérées comme immuables. Tentative de définition <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> une fois <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossible de définir une propriété de métadonnées une fois qu’elle est appliquée à une opération de propriété de dépendance.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur par défaut de la propriété de dépendance.</summary>
        <value>Valeur par défaut de la propriété. La valeur par défaut sur un <see cref="T:System.Windows.PropertyMetadata" /> instance créée avec le constructeur sans paramètre sera <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> est défini dans le modèle objet en lecture-écriture. C’est le cas <xref:System.Windows.PropertyMetadata.DefaultValue%2A> peuvent être ajustées après initialisation de la <xref:System.Windows.PropertyMetadata> objet lui-même. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont maintenant considérées comme immuables. Tentative de définition <xref:System.Windows.PropertyMetadata.DefaultValue%2A> une fois <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
 Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> ne peut pas être définie à l’aide <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ou le constructeur. Une telle tentative lève une exception.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de ce type ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Impossible de définir la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> une fois créée.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de définir une propriété de métadonnées une fois qu’elle est appliquée à une opération de propriété de dépendance.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui détermine si les métadonnées ont été appliquées à une propriété, entraînant l'état immuable de cette instance de métadonnées.</summary>
        <value><see langword="true" /> si l'instance de métadonnées est immuable ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diverses propriétés de <xref:System.Windows.PropertyMetadata>, tel que <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, sont définis dans le modèle objet en lecture-écriture. Ainsi, ces propriétés peuvent être ajustées après l’initialisation de la <xref:System.Windows.PropertyMetadata> objet lui-même. Toutefois, une fois que les métadonnées sont appliquées à une propriété de dépendance dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont maintenant considérées comme immuables. Au moment de l’un de ces appels, <xref:System.Windows.PropertyMetadata.OnApply%2A> est appelée, et la valeur de cette propriété est définie sur `true`.  
  
   
  
## Examples  
 L’exemple suivant vérifie <xref:System.Windows.PropertyMetadata.IsSealed%2A> avant une opération de définition d’une propriété de métadonnées personnalisées.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Métadonnées de base à fusionner avec les valeurs de cette instance.</param>
        <param name="dp">Propriété de dépendance à laquelle ces métadonnées sont appliquées.</param>
        <summary>Fusionne ces métadonnées avec les métadonnées de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée en interne lorsque les métadonnées sont substituées (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> méthode).  
  
   
  
## Examples  
 L’exemple suivant implémente une fusion pour un type de métadonnées personnalisé qui ajoute une propriété supplémentaire pour les métadonnées de propriété.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les implémentations qui dérivent de classe <see cref="T:System.Windows.PropertyMetadata" /> doivent remplacer cette méthode pour prendre en compte pour les propriétés de métadonnées qu’ils ont ajoutées dans leurs implémentations. Par exemple, votre implémentation peut ajouter une nouvelle valeur d’énumération d’indicateurs et le <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implémentation doit ensuite être en mesure de combiner ces indicateurs correctement.  Appelez toujours l’implémentation de base avant votre code d’implémentation, car l’implémentation de base prend en charge de la fusion de toutes les propriétés déjà définies sur le <see cref="T:System.Windows.PropertyMetadata" /> type.  Le comportement exact de la fusion est à vous. Vous pouvez choisir de combiner des valeurs, revenir à la valeur de base si les métadonnées dérivées ont été laissées à la valeur par défaut ou de nombreux autres comportements basés sur les types de propriétés que vous avez ajouté à votre classe de métadonnées et leurs significations.</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Propriété de dépendance à laquelle les métadonnées ont été appliquées.</param>
        <param name="targetType">Type associé à ces métadonnées s'il s'agit de métadonnées spécifiques au type. S'il s'agit de métadonnées par défaut, cette valeur est une référence nulle.</param>
        <summary>Appelé lorsque ces métadonnées ont été appliquées à une propriété qui indique que les métadonnées sont sealed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-classes doivent s’assurer que toute mutabilité de la structure de données d’un <xref:System.Windows.PropertyMetadata> sous-classe doit être marquée comme immuable une fois <xref:System.Windows.PropertyMetadata.OnApply%2A> est appelée. Cette méthode sera appelée une fois que les métadonnées sont appliquées à une opération de système de propriétés (inscrire, ajouter un propriétaire, substituer les métadonnées).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une référence à une implémentation <see cref="T:System.Windows.PropertyChangedCallback" /> spécifiée dans ces métadonnées.</summary>
        <value>Référence d'implémentation <see cref="T:System.Windows.PropertyChangedCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les rappels dans les métadonnées de propriété ne sont pas des membres publics généralement sur le type de définition, la valeur de cette propriété n’est pas importante pour la plupart des scénarios qui consomment uniquement les métadonnées d’une propriété de dépendance existante. Cette propriété est exposée est afin que les classes de métadonnées puissent appliquer la logique de fusion souhaitée si les métadonnées de base et substitution / d’ajout spécifient un <xref:System.Windows.PropertyChangedCallback>. La logique de fusion par défaut est de conserver toutes les <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implémentations dans une table et d’appeler chacune d’elles, les rappels établis par la classe la plus profonde dans la hiérarchie s’exécutant en premier.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> est défini dans le modèle objet en lecture-écriture. C’est le cas <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> peuvent être ajustées après initialisation de la <xref:System.Windows.PropertyMetadata> objet lui-même. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont maintenant considérées comme immuables. Tentative de définition <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> une fois <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossible de définir une propriété de métadonnées une fois qu’elle est appliquée à une opération de propriété de dépendance.</exception>
      </Docs>
    </Member>
  </Members>
</Type>