<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="PropertyMetadata.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac55c5dfef7a02e9b858a22854c1ef79b198ef1d9bc.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.PropertyMetadata">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">Définit certains aspects du comportement d’une propriété de dépendance quand elle est appliquée à un type spécifique, notamment les conditions dans lesquelles elle a été inscrite.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>Property metadata can be defined and used during dependency property registration when calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> method.</source>
          <target state="translated">Métadonnées de propriété peuvent être définies et utilisées lors de l’inscription de propriété de dépendance lors de l’appel du <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> (méthode) (ou variantes pour les propriétés jointes ou les propriétés de dépendance en lecture seule) ou après l’inscription du propriétaire d’origine lors de l’appel de la <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> also takes property metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> prend également les métadonnées de propriété.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">Cette classe est une classe concrète qui peut être utilisée dans chacun de ces appels.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>However, it is very common to specify metadata using one of the derived classes such as <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Toutefois, il est très courant pour spécifier les métadonnées à l’aide d’une des classes dérivées telles que <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">Ces classes dérivées prennent en charge davantage de métadonnées détaillées exécutées comme valeurs de propriété booléenne qui sont utiles pour détecter ou activer certains comportements de système et de mise en page de propriété qui sont implémentées uniquement à la <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> niveau de l’infrastructure.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>.</source>
          <target state="translated">Plusieurs propriétés de cette classe sont en lecture-écriture pour le modèle objet, mais peuvent uniquement être écrites avant l’instance utilisé dans une opération de système de propriétés telles que <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>Each of these properties could also have been set by the constructor but are exposed so that <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;</ph> method implementations can set them.</source>
          <target state="translated">Chacune de ces propriétés peut également avoir été défini par le constructeur, mais elles sont exposées afin que <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;</ph> implémentations de méthode pour les définir.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>XAML Text Usage</source>
          <target state="translated">Utilisation de texte XAML</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Ce type et les membres de ce type, sont généralement pas utilisées dans <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="T:System.Windows.PropertyMetadata">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Valeur par défaut à spécifier pour une propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> avec une valeur par défaut spécifiée pour la propriété de dépendance à laquelle ces métadonnées seront appliquées.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Le type de la valeur fournie pour <ph id="ph1">`defaultValue`</ph> doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation (l’incompatibilité lève une exception au moment de l’exécution).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
          <target state="translated">Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un <ph id="ph1">`defaultValue`</ph> de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ne peut pas être spécifié.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Toute tentative lève une exception.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> cannot be set to the value <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> ne peut pas avoir la valeur <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Référence à l'implémentation d'un gestionnaire que le système de propriétés doit appeler à chaque fois que la valeur effective de la propriété change.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> avec la référence d'implémentation <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> spécifiée.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Référence à l'implémentation d'un gestionnaire que le système de propriétés doit appeler à chaque fois que la valeur effective de la propriété change.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with the specified default value and <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> avec la valeur par défaut et la référence d'implémentation <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> spécifiées.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Le type de la valeur fournie <ph id="ph1">`defaultValue`</ph> doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation (l’incompatibilité lève une exception au moment de l’exécution).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
          <target state="translated">Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un <ph id="ph1">`defaultValue`</ph> de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ne peut pas être spécifié.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Toute tentative lève une exception.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> cannot be set to the value <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> ne peut pas avoir la valeur <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Référence à l'implémentation d'un gestionnaire que le système de propriétés doit appeler à chaque fois que la valeur effective de la propriété change.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Reference to a handler implementation that is to be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Référence à l'implémentation d'un gestionnaire qui doit être appelée à chaque fois que le système de propriétés appelle <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> à l'aide de cette propriété.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with the specified default value and callbacks.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> avec la valeur par défaut et les rappels spécifiés.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>If you want to specify a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> but not a <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, you can pass <ph id="ph3">`null`</ph> for the <ph id="ph4">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">Si vous souhaitez spécifier un <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> mais pas un <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, vous pouvez passer <ph id="ph3">`null`</ph> pour la <ph id="ph4">`propertyChangedCallback`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Le type de la valeur fournie pour <ph id="ph1">`defaultValue`</ph> doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation (l’incompatibilité lève une exception au moment de l’exécution).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
          <target state="translated">Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un <ph id="ph1">`defaultValue`</ph> de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ne peut pas être spécifié.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Toute tentative lève une exception.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> cannot be set to the value <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> ne peut pas avoir la valeur <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>Gets or sets a reference to a <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> implementation specified in this metadata.</source>
          <target state="translated">Obtient ou définit une référence à une implémentation <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> spécifiée dans ces métadonnées.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Référence d'implémentation <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">Les rappels dans les métadonnées de propriété ne sont pas des membres publics généralement sur le type conteneur, la valeur de cette propriété n’est pas importante pour la plupart des scénarios qui consomment uniquement les métadonnées d’une propriété de dépendance existant.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated">Est de cette propriété est exposée afin que les sous-classes de métadonnées puissent appliquer la logique de fusion souhaitée si les métadonnées de base et les métadonnées de substitution / d’ajout spécifient un <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>However, the default merge logic for a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is to replace the previous one.</source>
          <target state="translated">Toutefois, la valeur par défaut de fusion logique pour un <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> consiste à remplacer la précédente.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is defined in the object model as read-write.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> est défini dans le modèle objet en lecture-écriture.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">C’est le cas <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> peuvent être ajustées après initialisation de la <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> objet lui-même.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont désormais considérées comme immuables.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentative de définition <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> une fois <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> est <ph id="ph3">`true`</ph> sur les métadonnées de cette instance lève une exception.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Impossible de définir une propriété de métadonnées une fois qu’elle est appliquée à une opération de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">Obtient ou définit la valeur par défaut de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>The default value of the property.</source>
          <target state="translated">Valeur par défaut de la propriété.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>The default value on a <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> instance created with the parameterless constructor will be <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut sur un <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> instance créé avec le constructeur sans paramètre sera <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> is defined in the object model as read-write.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> est défini dans le modèle objet en lecture-écriture.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">C’est le cas <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> peuvent être ajustées après initialisation de la <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> objet lui-même.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont désormais considérées comme immuables.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentative de définition <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> une fois <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> est <ph id="ph3">`true`</ph> sur les métadonnées de cette instance lève une exception.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be set using either <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> or the constructor.</source>
          <target state="translated">Bien qu’il soit la valeur par défaut par le constructeur sans paramètre, un <ph id="ph1">`defaultValue`</ph> de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ne peut pas être définie à l’aide <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> ou le constructeur.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Toute tentative lève une exception.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>XAML Text Usage</source>
          <target state="translated">Utilisation de texte XAML</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membres de ce type ne sont généralement pas utilisées dans <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Cannot be set to the value <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph> once created.</source>
          <target state="translated">Impossible de définir la valeur <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph> une fois créée.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Impossible de définir une propriété de métadonnées une fois qu’elle est appliquée à une opération de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">Obtient une valeur qui détermine si les métadonnées ont été appliquées à une propriété, entraînant l'état immuable de cette instance de métadonnées.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the metadata instance is immutable; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance de métadonnées est immuable ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>Various properties of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, such as <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are defined in the object model as read-write.</source>
          <target state="translated">Diverses propriétés de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, tel que <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, sont définis dans le modèle objet en lecture-écriture.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>This is so those properties can be adjusted after initialization of the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">Ainsi, ces propriétés peuvent être ajustées après l’initialisation de la <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> objet lui-même.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>However, once the metadata is applied to a dependency property as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Toutefois, une fois que les métadonnées sont appliquées à une propriété de dépendance dans le cadre d’un appel à <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont désormais considérées comme immuables.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>At the time of one of these calls, <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> is called, and the value of this property is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Au moment de l’un de ces appels, <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> est appelée, et la valeur de cette propriété est définie <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>The following example  checks <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> prior to a set operation of a custom metadata property.</source>
          <target state="translated">L’exemple suivant vérifie <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> avant une opération de définition d’une propriété de métadonnées personnalisées.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">Métadonnées de base à fusionner avec les valeurs de cette instance.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">Propriété de dépendance à laquelle ces métadonnées sont appliquées.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">Fusionne ces métadonnées avec les métadonnées de base.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>This method is used internally when metadata is being overridden (<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method).</source>
          <target state="translated">Cette méthode est utilisée en interne lorsque les métadonnées sont substituées (<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> méthode).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</source>
          <target state="translated">L’exemple suivant implémente une fusion pour un type de métadonnées personnalisé qui ajoute une propriété supplémentaire pour les métadonnées de propriété.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Class implementations that derive from <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> should override this method to account for any metadata properties they have added in their implementations.</source>
          <target state="translated">Les implémentations qui dérivent de classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> doivent substituer cette méthode pour prendre en compte pour toutes les propriétés de métadonnées qu’ils ont ajoutées dans leurs implémentations.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>For instance, your implementation might have added a new flagwise enumeration value, and the <ph id="ph1">&lt;see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation should then be able to combine those flags correctly.</source>
          <target state="translated">Par exemple, votre implémentation peut ajouter une nouvelle valeur de l’énumération d’indicateurs et le <ph id="ph1">&lt;see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implémentation doit pouvoir ensuite combiner ces indicateurs correctement.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> type.</source>
          <target state="translated">Appelez toujours l’implémentation de base avant votre code d’implémentation, car l’implémentation de base prend en charge de la fusion de toutes les propriétés déjà définies sur le <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> type.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The exact behavior of the merge is up to you.</source>
          <target state="translated">Le comportement exact de la fusion est à vous.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</source>
          <target state="translated">Vous pouvez choisir de combiner des valeurs, de revenir à la valeur de base si les métadonnées dérivées sont toujours la valeur par défaut ou de nombreux autres comportements basés sur les types de propriétés que vous avez ajouté à votre classe de métadonnées et leurs significations.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">Propriété de dépendance à laquelle les métadonnées ont été appliquées.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">Type associé à ces métadonnées s'il s'agit de métadonnées spécifiques au type.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">S'il s'agit de métadonnées par défaut, cette valeur est une référence nulle.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Appelé lorsque ces métadonnées ont été appliquées à une propriété qui indique que les métadonnées sont sealed.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Subclasses should assure that any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> subclass should be marked as immutable once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> is called.</source>
          <target state="translated">Les sous-classes doivent s’assurer que toute mutabilité de la structure de données d’une <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> sous-classe doit être marquée comme étant immuable une fois <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">Cette méthode sera appelée une fois que les métadonnées sont appliquées à une opération de système de propriétés (inscrire, ajoutez propriétaire, remplacer les métadonnées).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>Gets or sets a reference to a <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation specified in this metadata.</source>
          <target state="translated">Obtient ou définit une référence à une implémentation <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> spécifiée dans ces métadonnées.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Référence d'implémentation <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">Les rappels dans les métadonnées de propriété ne sont pas des membres publics généralement sur le type de définition, la valeur de cette propriété n’est pas importante pour la plupart des scénarios qui consomment uniquement les métadonnées d’une propriété de dépendance existant.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.</source>
          <target state="translated">Est de cette propriété est exposée afin que les classes de métadonnées puissent appliquer la logique de fusion souhaitée si les métadonnées de base et les métadonnées de substitution / d’ajout spécifient un <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>The default merge logic for is to maintain all <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">La logique de fusion par défaut est de conserver toutes les <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> implémentations dans une table et d’appeler chacune d’elles, les rappels établis par la classe la plus profonde dans la hiérarchie s’exécutant en premier.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> is defined in the object model as read-write.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> est défini dans le modèle objet en lecture-écriture.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">C’est le cas <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> peuvent être ajustées après initialisation de la <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> objet lui-même.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, le système de propriétés scelle l’instance des métadonnées et les propriétés sont désormais considérées comme immuables.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentative de définition <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> une fois <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> est <ph id="ph3">`true`</ph> sur les métadonnées de cette instance lève une exception.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Impossible de définir une propriété de métadonnées une fois qu’elle est appliquée à une opération de propriété de dépendance.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>