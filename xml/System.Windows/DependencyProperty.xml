<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0129b0c47acecd870bafaaa4655db115fee937a4" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55372654" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une propriété qui peut être définie par le biais de méthodes, par exemple style, liaison de données, animation et héritage.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyProperty> prend en charge les fonctionnalités suivantes dans [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   La propriété peut être définie dans un style. Pour plus d’informations, consultez [Application d’un style et création de modèles](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   La propriété peut être définie via la liaison de données. Pour plus d’informations sur les propriétés de dépendance de liaison de données, consultez [Comment : Lier les propriétés de deux contrôles](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   La propriété peut être définie avec une référence de ressource dynamique. Pour plus d’informations, consultez [Ressources XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   La propriété peut hériter automatiquement sa valeur d’un élément parent dans l’arborescence d’éléments. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   La propriété peut être animée. Pour plus d’informations, consultez [Vue d’ensemble de l’animation](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   La propriété peut signaler lorsque la valeur précédente de la propriété a été modifiée et que la valeur de propriété peut être forcée. Pour plus d’informations, consultez [Validation et rappels de propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   La propriété signale des informations à [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], telles que si la modification d’une valeur de propriété doit requérir que le système de disposition recompose les visuels d’un élément.  
  
-   La propriété reçoit la prise en charge dans le [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Par exemple, la propriété peut être modifiée dans le **propriétés** fenêtre.  
  
 Pour en savoir plus sur les propriétés de dépendance, consultez [vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Si vous souhaitez que les propriétés de vos types personnalisés pour prendre en charge les fonctionnalités dans la liste précédente, vous devez créer une propriété de dépendance.  Pour savoir comment créer des propriétés de dépendance personnalisées, consultez [des propriétés de dépendance personnalisées](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Une propriété jointe est une propriété qui permet à n’importe quel objet pour signaler des informations pour le type qui définit la propriété jointe. Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], n’importe quel type qui hérite de <xref:System.Windows.DependencyObject> pouvez utiliser une propriété jointe, quel que soit l’indique si le type hérite du type qui définit la propriété. Une propriété jointe est une fonctionnalité de le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] langage.  Pour définir une propriété jointe dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], utilisez le *TypePropriétaire*. *propertyName* syntaxe. Un exemple d’une propriété jointe est le <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> propriété. Si vous souhaitez créer une propriété qui peut être utilisée sur tous les <xref:System.Windows.DependencyObject> types, vous devez créer une propriété jointe. Pour en savoir plus sur les propriétés jointes, notamment comment les créer, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `dependencyPropertyName`  
 Chaîne qui spécifie le <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> de la propriété de dépendance souhaitée. Cela peut être précédée d’un préfixe d’espace de noms XML si la propriété n’est pas dans l’espace de noms XML par défaut (pour plus d’informations, consultez [espaces de noms XAML et Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Chaîne qui spécifie un type de propriétaire d’une propriété de dépendance, un point (.), puis le <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` peut également être précédé par un préfixe d’espace de noms XML. Cette utilisation est particulière à liaison tardive styles et modèles, où le propriétaire de la propriété de dépendance doit être spécifié pour l’analyse de contexte, car le `TargetType` n’est pas encore connu. Pour plus d’informations, consultez [Application d’un style et création de modèles](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Chaîne qui spécifie le propriétaire d’une propriété jointe, un point (.), puis le nom de la propriété jointe. `attachedPropertyOwnerType` peut également être précédé par un préfixe d’espace de noms XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un autre type en tant que propriétaire d’une propriété de dépendance qui a déjà été inscrite à un type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Type à ajouter en tant que propriétaire de cette propriété de dépendance.</param>
        <summary>Ajoute un autre type en tant que propriétaire d’une propriété de dépendance qui a déjà été inscrite.</summary>
        <returns>Référence à l’identificateur <see cref="T:System.Windows.DependencyProperty" /> d’origine qui identifie la propriété de dépendance. Cet identificateur doit être exposé par la classe d’ajout en tant que champ <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet le système de propriétés identifier une propriété de dépendance sur un type qui n’a pas inscrit initialement cette propriété de dépendance particulière.  
  
 En règle générale, <xref:System.Windows.DependencyProperty.AddOwner%2A> est utilisé pour ajouter des propriétés de dépendance à des classes qui n’exposent pas déjà cette propriété de dépendance via l’héritage de classe managée (héritage de classe provoque les propriétés de wrapper être héritée par la classe dérivée et par conséquent fournit l’accès général de table des membres à la propriété de dépendance déjà). <xref:System.Windows.DependencyProperty.AddOwner%2A> permet le système de propriétés identifier une propriété de dépendance sur un type qui n’a pas inscrit initialement cette propriété de dépendance.  
  
 Cette signature ne permet pas pour la spécification des métadonnées.  Lorsque vous utilisez cette méthode, les métadonnées sont générées automatiquement pour le nouveau <xref:System.Windows.DependencyProperty> et son type de propriétaire. Les métadonnées générées automatiquement sont le résultat des métadonnées fusionnées à partir de tous les types de base qui ont cette propriété est définie. Si aucune métadonnée fusionnée n’est disponible, les métadonnées par défaut pour la propriété sont utilisée. Si la propriété est inscrite à l’aide de la <xref:System.Windows.DependencyProperty.RegisterAttached%2A> (méthode), les métadonnées par défaut est le même que les métadonnées qui sont créée lorsque <xref:System.Windows.DependencyProperty.RegisterAttached%2A> a été appelée. Sinon, le <xref:System.Windows.PropertyMetadata> objet est créé avec le <xref:System.Windows.PropertyMetadata.DefaultValue%2A> propriété la valeur par défaut du type de propriété et toutes les autres propriétés de la <xref:System.Windows.PropertyMetadata> est défini sur `null`. Utilisez le <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> signature si vous souhaitez fournir des métadonnées pour la version de la propriété de dépendance comme ajouté au type fourni.  
  
 La valeur de retour de cette méthode est généralement utilisée pour déclarer et exposer la propriété de dépendance en stockant un identificateur de propriété de dépendance. L’identificateur fournit l’accès à la propriété de dépendance si vous souhaitez appeler le système de propriétés [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] par rapport à la propriété de dépendance, en particulier, tel qu’il existe sur la classe propriétaire d’ajout. Le même nom de propriété pour le propriétaire d’origine et ajout d’un propriétaire doit être utilisé pour indiquer les fonctionnalités semblables. Vous devez utiliser le <xref:System.Windows.DependencyProperty> valeur de retour de la <xref:System.Windows.DependencyProperty.AddOwner%2A> méthode pour définir l’identificateur de propriété de dépendance et également déclarer [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Le <xref:System.Windows.DependencyProperty.AddOwner%2A> méthodologie recommandée ci-dessus est utilisée lors de la création de propriétés de dépendance sont déclarées dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Par exemple, les deux <xref:System.Windows.Controls.Border> et <xref:System.Windows.Controls.Control> définir un `BorderBrush` propriété de dépendance, qui ont des fonctionnalités similaires. <xref:System.Windows.Controls.Control> définit son `BorderBrush` propriété au système de propriétés en appelant <xref:System.Windows.DependencyProperty.AddOwner%2A> basée sur le propriétaire d’origine <xref:System.Windows.Controls.Border> et son inscrit <xref:System.Windows.Controls.Border.BorderBrushProperty> identificateur de propriété de dépendance. Le <xref:System.Windows.DependencyProperty.AddOwner%2A> retourner la valeur est ensuite utilisée pour établir un nouvelle statique <xref:System.Windows.DependencyProperty> champ (<xref:System.Windows.Controls.Control.BorderBrushProperty>) de cette propriété sur l’ajout d’un propriétaire et un `BorderBrush` wrapper de propriété est également déclaré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Type à ajouter en tant que propriétaire de cette propriété de dépendance.</param>
        <param name="typeMetadata">Métadonnées qui qualifient la propriété de dépendance telle qu’elle existe sur le type fourni.</param>
        <summary>Ajoute un autre type en tant que propriétaire d’une propriété de dépendance déjà inscrite, et fournit des métadonnées de propriété de dépendance à la propriété de dépendance telle qu’elle existe sur le type de propriétaire fourni.</summary>
        <returns>Référence à l’identificateur <see cref="T:System.Windows.DependencyProperty" /> d’origine qui identifie la propriété de dépendance. Cet identificateur doit être exposé par la classe d’ajout en tant que champ <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet le système de propriétés identifier une propriété de dépendance sur un type qui n’a pas inscrit initialement cette propriété de dépendance particulière.  
  
 La valeur de retour de cette méthode est utilisée pour déclarer et exposer la propriété de dépendance, en particulier car elle existe sur la classe propriétaire d’ajout. En règle générale, le même nom de propriété pour le propriétaire d’origine et ajout d’un propriétaire doit être utilisé pour indiquer les fonctionnalités semblables. Il est recommandé d’exposer les identificateurs, comme pour les nouveaux [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Le <xref:System.Windows.DependencyProperty.AddOwner%2A> méthodologie recommandée ci-dessus est utilisée lors de la création [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] déclarés dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Par exemple, les deux <xref:System.Windows.Controls.Border> et <xref:System.Windows.Controls.Control> définir un `BorderBrush` propriété de dépendance, qui ont des fonctionnalités similaires. <xref:System.Windows.Controls.Control> définit son `BorderBrush` propriété au système de propriétés en appelant <xref:System.Windows.DependencyProperty.AddOwner%2A> propriétaire d’origine <xref:System.Windows.Controls.Border> et son inscrit <xref:System.Windows.Controls.Border.BorderBrushProperty> identificateur de propriété de dépendance. Le <xref:System.Windows.DependencyProperty.AddOwner%2A> retourner la valeur est ensuite utilisée pour établir un mappage statique <xref:System.Windows.DependencyProperty> champ (<xref:System.Windows.Controls.Control.BorderBrushProperty>) de cette propriété sur l’ajout d’un propriétaire et un `BorderBrush` wrapper de propriété est également déclaré.  
  
 Identificateur de propriété de dépendance de l’ajout d’un propriétaire doit être utilisé pour les opérations telles que <xref:System.Windows.DependencyObject.GetValue%2A>. Toutefois, les opérations spécifiques au type impliquant des types ou des instances de la classe qui a été ajouté comme propriétaire avec des métadonnées différentes est toujours retournent le résultats attendus, même si la version d’origine (pas le propriétaire ajouté) identificateur de propriété de dépendance est spécifié dans appels aux méthodes telles que <xref:System.Windows.DependencyObject.GetValue%2A> ou <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Les métadonnées pour l’ajout d’un propriétaire sont conservés après par le <xref:System.Windows.DependencyProperty.AddOwner%2A> s’appeler lui-même, pas nécessairement référencés exclusivement par le champ d’identificateur de classe propriétaire Ajout. Néanmoins, il est conseillé pour exposer l’identificateur, comme pour les nouveaux [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <xref:System.Windows.DependencyProperty.AddOwner%2A>, car sinon, crée une disparité entre les [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] représentations sous forme de vos propriétés.  
  
 Métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base. Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine seront conservé. Seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées remplacent les caractéristiques des métadonnées de base. Certaines caractéristiques, telles que <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, sont remplacées si elles sont spécifiées dans les nouvelles métadonnées. D’autres, tels que <xref:System.Windows.PropertyChangedCallback>, sont combinées. Au final, le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour le remplacement, donc le comportement décrit ici concerne les classes de métadonnées de propriété existantes utilisées par [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés de dépendance. Pour plus d’informations, consultez [les métadonnées de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-metadata.md) et [les métadonnées de propriété de Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les métadonnées par défaut de la propriété de dépendance.</summary>
        <value>Métadonnées par défaut de la propriété de dépendance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les métadonnées par défaut correspond aux métadonnées de propriété qui sont disponible pour cet objet particulier ou un objet d’un type dérivé où aucune métadonnée de remplacement a été fournie par explicite <xref:System.Windows.DependencyProperty.Register%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appeler.  
  
 Si le propriétaire d’origine applique les métadonnées pour la première <xref:System.Windows.DependencyProperty.Register%2A> appel qui a établi la propriété de dépendance, alors que les métadonnées sont retournée en tant que <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Si aucune métadonnée n’a été appliquée dans la version d’origine <xref:System.Windows.DependencyProperty.Register%2A> appeler, les métadonnées par défaut sont alors généré depuis le <xref:System.Windows.DependencyProperty.Register%2A> appel et cette valeur est retournée en tant que le <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 L’objectif principal de l’association de métadonnées par défaut avec un <xref:System.Windows.DependencyProperty> consiste à fournir une valeur par défaut de cette propriété sur n’importe quel <xref:System.Windows.DependencyObject> ou un type dérivé.  
  
 Pour les propriétés non jointes, le type de métadonnées retourné par cette propriété ne peut pas être casté aux types dérivés de <xref:System.Windows.PropertyMetadata> tapez, même si la propriété a été inscrite avec un type de métadonnées dérivées. Si vous souhaitez que les métadonnées inscrite à l’origine, notamment son type de métadonnées dérivées éventuellement d’origine, appelez <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> au lieu de cela, en passant l’enregistrement d’origine de type en tant que paramètre.  
  
 Pour les propriétés jointes, le type de métadonnées retourné par cette propriété correspond au type donné dans la version d’origine <xref:System.Windows.DependencyProperty.RegisterAttached%2A> méthode d’inscription.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un code de hachage pour ce <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Code de hachage pour cette <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système de propriétés utilise son propre identificateur unique <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, et la valeur de cette propriété est retournée par <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les métadonnées associées à cette propriété de dépendance telles qu’elles existent pour un type particulier. Il peut s’agir du type où la propriété de dépendance a été inscrite initialement, un type auquel elle a été ajoutée par la suite, ou un type où la propriété de dépendance a été obtenue par le biais de l’héritage mais où les métadonnées ont été substituées de manière spécifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Type spécifique à partir duquel récupérer les métadonnées de propriété de dépendance.</param>
        <summary>Retourne les métadonnées pour cette propriété de dépendance telle qu’elles existent sur un type existant spécifié.</summary>
        <returns>Objet de métadonnées de propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifiez le type ou une référence d’objet à utiliser comme type est nécessaire, car les métadonnées peuvent varier de l’inscription d’origine due aux <xref:System.Windows.DependencyProperty.AddOwner%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appels qui modifient les métadonnées de la propriété de dépendance telle qu’elle existe sur un type.  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance selon son type. Le type est obtenu en utilisant un `typeof` opérateur.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objet de dépendance dont le type est vérifié pour déterminer de quelle version spécifique au type de la propriété de dépendance les métadonnées doivent provenir.</param>
        <summary>Retourne les métadonnées pour cette propriété de dépendance telle qu’elles existent sur l’instance d’objet spécifiée.</summary>
        <returns>Objet de métadonnées de propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En spécifiant le type ou une référence d’objet est nécessaire, car les métadonnées de toute propriété de dépendance peuvent varier de l’inscription d’origine due aux <xref:System.Windows.DependencyProperty.AddOwner%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appels qui peuvent restreindre les métadonnées de propriété car elle existe sur un type.  
  
 Lorsque vous demandez des métadonnées de propriété basées sur une instance, vous passez simplement l’instance afin que son type peut être évalué en interne. Métadonnées de propriété de dépendance ne varient pas par instance ; Il est toujours cohérent pour n’importe quelle combinaison de la propriété de type donnée.  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance basée sur un spécifique <xref:System.Windows.DependencyObject> instance.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Objet spécifique qui enregistre le type d’objet de dépendance à partir duquel les métadonnées de propriété de dépendance sont souhaitées.</param>
        <summary>Retourne les métadonnées pour cette propriété de dépendance telle qu’elles existent sur un type spécifié.</summary>
        <returns>Objet de métadonnées de propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En spécifiant le type ou une référence d’objet est nécessaire, car les métadonnées de toute propriété de dépendance peuvent varier de l’inscription d’origine due aux <xref:System.Windows.DependencyProperty.AddOwner%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appels qui peuvent restreindre les métadonnées de propriété car elle existe sur un type.  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance selon son <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur générée en interne qui identifie uniquement la propriété de dépendance.</summary>
        <value>Identificateur numérique unique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est un entier, pas un identificateur global unique (GUID). En règle générale, à l’aide de cette valeur d’index n’est pas obligatoire, et il n’existe aucun accès d’index aux tables de toutes les propriétés de dépendance. Propriétés de dépendance doivent plutôt être référencées par leurs champs d’identificateur.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> est utilisé en interne pour un accès plus rapide aux structures de données qui utilisent le <xref:System.Windows.DependencyProperty.GlobalIndex%2A> comme un index de tableau de base zéro. Une utilisation semblable peut avoir des applications pour les concepteurs ou d’outils.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à contrôler.</param>
        <summary>Détermine si une valeur spécifiée est acceptable pour le type de cette propriété de dépendance, comme vérifié par rapport au type de propriété fourni dans l'inscription de propriété de dépendance d'origine.</summary>
        <returns><see langword="true" /> si la valeur spécifiée est le type de propriété inscrit ou un type dérivé acceptable ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur `null` est un type valide pour les propriétés de dépendance de type référence ou pour un <xref:System.Nullable%601> propriété de dépendance et retournerait `true` pour ces cas. Dans le cas où la propriété de dépendance n’est ni une référence ni un <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> retournera `false` pour une valeur null au lieu de déclencher une exception.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.DependencyProperty.IsValidType%2A> en tant qu’une vérification avant d’appeler <xref:System.Windows.DependencyObject.SetValue%2A> sur la propriété de dépendance.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à contrôler.</param>
        <summary>Détermine si la valeur fournie est acceptée pour le type de propriété à travers la vérification de type de base, et également si elle se trouve dans la plage de valeurs autorisée pour ce type.</summary>
        <returns><see langword="true" /> si la valeur est acceptable et est du type correct ou un type dérivé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour une propriété de dépendance, une plage autorisée de valeurs pour ce type peut être spécifiée via un <xref:System.Windows.ValidateValueCallback> qui est fourni dans l’inscription de propriété de dépendance.  
  
 Cette méthode appelle <xref:System.Windows.DependencyProperty.IsValidType%2A> en interne. Si la propriété de dépendance en question n’a pas <xref:System.Windows.ValidateValueCallback>, puis l’appel de cette méthode équivaut à appeler <xref:System.Windows.DependencyProperty.IsValidType%2A>. Si la propriété de dépendance a un <xref:System.Windows.ValidateValueCallback>et si <xref:System.Windows.DependencyProperty.IsValidType%2A> a retourné `true`, puis la valeur retournée sera tel qu’implémenté dans le rappel.  
  
 Une valeur null est une valeur valide pour les propriétés de dépendance de type référence ou pour un <xref:System.Nullable%601> propriété de dépendance et retournerait `true` pour ces cas. Dans le cas où la propriété de dépendance n’est ni une référence ni un <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> retournera `false` pour une valeur null au lieu de déclencher une exception.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.DependencyProperty.IsValidValue%2A> en tant qu’une vérification avant d’appeler <xref:System.Windows.DependencyObject.SetValue%2A> sur la propriété de dépendance.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de la propriété de dépendance.</summary>
        <value>Nom de la propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient le nom fourni en tant que le `name` paramètre lors de l’inscription de propriété de dépendance. Ce nom est immuable et ne peut pas être `null` ou une chaîne vide. Les enregistrements de nom dupliqué sur le même type de propriétaire ne sont pas autorisées et lèvent une exception lorsque vous essayez d’inscrire le doublon.  
  
> [!IMPORTANT]
>  Le <xref:System.Windows.DependencyProperty.Name%2A> d’une dépendance de propriété doit suivre la convention de mise en correspondance le nom de son identificateur de propriété de dépendance sans le suffixe « Propriété ». Pour plus d’informations, consultez [Propriétés de dépendance personnalisées](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 L’exemple suivant interroge plusieurs caractéristiques d’un identificateur de propriété de dépendance, y compris le <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fournit des métadonnées de remplacement pour cette propriété de dépendance quand elle est présente sur des instances d’un type spécifié, différentes des métadonnées qui ont été fournies dans l’inscription de la propriété de dépendance initiale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Type où cette propriété de dépendance est héritée et emplacement où les métadonnées de remplacement fournies sont appliquées.</param>
        <param name="typeMetadata">Métadonnées à appliquer à la propriété de dépendance sur le type de substitution.</param>
        <summary>Spécifie les métadonnées de remplacement pour cette propriété de dépendance quand elle est présente sur des instances d’un type spécifié, substituant les métadonnées qui existaient pour la propriété de dépendance quand elle a été héritée de types de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Métadonnées de propriété de dépendance doivent être remplacée avant que le système de propriétés utilise la propriété de dépendance. Cela équivaut à l’heure à laquelle les instances spécifiques sont créées à l’aide de la classe qui inscrit la propriété de dépendance. Les appels à <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> doit uniquement être effectuée dans les constructeurs statiques du type qui fournit lui-même comme le `forType` paramètre de cette méthode, ou à travers une instanciation semblable. Tente de modifier les métadonnées une fois que les instances du type propriétaire existent ne déclenche pas d’exceptions, mais entraîne des comportements incohérents dans le système de propriétés.  
  
 Une fois que les métadonnées pour un remplacement de la classe dérivée particulière sont établie avec cette méthode, les tentatives suivantes de substituer des métadonnées sur cette même classe dérivée lève une exception.  
  
 Métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base. Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine seront persistantes ; seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées remplacent les caractéristiques des métadonnées de base. Certaines caractéristiques, telles que <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sont remplacés si spécifié dans les nouvelles métadonnées. D’autres, tels que <xref:System.Windows.PropertyChangedCallback>, sont combinées. Au final, le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour le remplacement, donc le comportement décrit ici concerne les classes de métadonnées de propriété existantes utilisées par [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés de dépendance. Pour plus d’informations, consultez [les métadonnées de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-metadata.md) et [les métadonnées de propriété de Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous avez essayé de substituer des métadonnées sur une propriété de dépendance en lecture seule (vous ne pouvez pas effectuer cette opération à l’aide de cette signature).</exception>
        <exception cref="T:System.ArgumentException">Des métadonnées ont déjà été établies pour la propriété de dépendance telle qu’elle existe sur le type fourni.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Type où cette propriété de dépendance est héritée et emplacement où les métadonnées de remplacement fournies sont appliquées.</param>
        <param name="typeMetadata">Métadonnées à appliquer à la propriété de dépendance sur le type de substitution.</param>
        <param name="key">Clé d’accès pour une propriété de dépendance en lecture seule.</param>
        <summary>Fournit des métadonnées de remplacement pour une propriété de dépendance en lecture seule quand elle est présente sur des instances d’un type spécifié, substituant les métadonnées fournies dans l’inscription de la propriété de dépendance initiale. Vous devez passer <see cref="T:System.Windows.DependencyPropertyKey" /> pour la propriété de dépendance en lecture seule pour éviter de lever une exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette signature fournit l’implémentation sous-jacente pour un identificateur de propriété de dépendance en lecture seule (<xref:System.Windows.DependencyPropertyKey>) (méthode). Si la substitution de métadonnées pour une propriété de dépendance en lecture-écriture, utilisez <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Métadonnées de propriété de dépendance doivent être remplacée avant que le système de propriétés utilise la propriété de dépendance. Cela équivaut à la fois des objets spécifiques sont créés pour la classe qui inscrit la propriété de dépendance. Les appels à <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> doit uniquement être effectuée dans les constructeurs statiques du type qui fournit lui-même comme le `forType` paramètre de cette méthode, ou à travers une instanciation semblable. Tente de modifier les métadonnées une fois que les instances du type propriétaire existent ne déclenche pas d’exceptions, mais entraîne des comportements incohérents dans le système de propriétés.  
  
 Une fois que les métadonnées pour un remplacement de la classe dérivée particulière sont établie avec cette méthode, les tentatives suivantes de substituer des métadonnées sur cette même classe dérivée lève une exception.  
  
 Métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base. Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine seront persistantes ; seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées remplacent les caractéristiques des métadonnées de base. Certaines caractéristiques, telles que <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sont remplacés si spécifié dans les nouvelles métadonnées. D’autres, tels que <xref:System.Windows.PropertyChangedCallback>, sont combinées. Le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour le remplacement. Pour plus d’informations, consultez [les métadonnées de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-metadata.md) et [les métadonnées de propriété de Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de l’objet qui a inscrit la propriété de dépendance avec le système de propriétés ou qui s’est ajouté comme propriétaire de la propriété.</summary>
        <value>Type de l’objet qui a inscrit la propriété ou qui s’est ajouté comme propriétaire de la propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur a été fournie pendant l’inscription de propriété. Le propriétaire sera soit le type d’inscription d’origine dans le cas d’un <xref:System.Windows.DependencyProperty> identificateur généré à partir d’un <xref:System.Windows.DependencyProperty.Register%2A> appel, ou le type qui l’a ajouté en tant que propriétaire de l’un <xref:System.Windows.DependencyProperty> identificateur généré à partir d’un <xref:System.Windows.DependencyProperty.AddOwner%2A> appeler.  
  
 Le <xref:System.Windows.DependencyProperty.OwnerType%2A> sur n’importe quel donné <xref:System.Windows.DependencyProperty> est immuable et ne peut pas être `null` dans valide <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de propriétaire selon un identificateur de propriété de dépendance `dp`et puis obtient des métadonnées sur le type de propriétaire pour ce même identificateur. Cette opération revient en fait à obtenir <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> sur `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type que la propriété de dépendance utilise pour sa valeur.</summary>
        <value><see cref="T:System.Type" /> de la valeur de la propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique le type de valeur de la propriété comme déclaré par l’inscription de propriété d’origine, via le `propertyType` paramètre. Similaire à la <xref:System.Windows.DependencyProperty.Name%2A>, le type de propriété d’une propriété de dépendance est immuable après l’inscription.  
  
   
  
## Examples  
 L’exemple suivant interroge plusieurs caractéristiques d’un identificateur de propriété de dépendance, y compris le <xref:System.Windows.DependencyProperty.PropertyType%2A>. La chaîne de nom de type de la <xref:System.Windows.DependencyProperty.PropertyType%2A> est obtenu à partir de retourné <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la propriété de dépendance identifié par cette instance <see cref="T:System.Windows.DependencyProperty" /> est une propriété de dépendance en lecture seule.</summary>
        <value><see langword="true" /> si la propriété de dépendance est en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés de dépendance en lecture seule sont enregistrées dans le système de propriétés en appelant le <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> (méthode), par opposition à la <xref:System.Windows.DependencyProperty.Register%2A> (méthode). Propriétés jointes peuvent également être enregistrées en lecture seule ; consultez <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Propriétés de dépendance en lecture seule requièrent un <xref:System.Windows.DependencyPropertyKey> identificateur plutôt qu’un <xref:System.Windows.DependencyProperty> identificateur pour effectuer des opérations de métadonnées telles que la substitution des métadonnées ou la définition de la valeur. Si vous avez obtenu une collection de <xref:System.Windows.DependencyProperty> identificateurs via un appel à <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> ou un autre [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] qui expose des identificateurs, vérifiez la <xref:System.Windows.DependencyProperty.ReadOnly%2A> valeur avant d’essayer d’appeler <xref:System.Windows.DependencyObject.SetValue%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> à les utiliser identificateur de propriété de dépendance en tant que paramètre d’entrée, pour vérifier que la propriété de dépendance qui représente l’identificateur n’est pas en lecture seule. Si la valeur de <xref:System.Windows.DependencyProperty.ReadOnly%2A> est `true` sur une propriété de dépendance, il n’existe aucun moyen de programmation pour obtenir une référence à la <xref:System.Windows.DependencyPropertyKey> identificateur de cette propriété de dépendance à partir des métadonnées ou à partir de la <xref:System.Windows.DependencyProperty> identificateur ; l’identificateur doit être disponible comme un champ statique pour pouvoir appeler <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> par rapport à une propriété de dépendance en lecture seule.  
  
 Lorsque vous créez une propriété de dépendance personnalisée et inscrivez en lecture seule, vous devez définir uniquement un accesseur get pour le [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] propriété wrapper. Sinon, votre classe possède un modèle d’objet déroutant pour le wrapper de propriété par rapport à l’accès à la propriété de dépendance de sauvegarde. Pour plus d’informations, consultez [propriétés de dépendance personnalisées](~/docs/framework/wpf/advanced/custom-dependency-properties.md) ou [propriétés de dépendance en lecture seule](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 L’exemple suivant obtienne les métadonnées par défaut et les propriétés d’identificateur de propriété de dépendance à partir de différents champs de propriété de dépendance et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une propriété de dépendance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire. Le nom doit être unique dans l’espace de noms d’inscription du type de propriétaire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <summary>Inscrit une propriété de dépendance avec le nom de propriété, le type de propriété et le type de propriétaire spécifiés.</summary>
        <returns>Identificateur de propriété de dépendance qui doit être utilisé pour définir la valeur d’un champ <see langword="public static readonly" /> dans votre classe. Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="typeMetadata">Métadonnées de propriété de la propriété de dépendance.</param>
        <summary>Inscrit une propriété de dépendance avec le nom de propriété, le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</summary>
        <returns>Identificateur de propriété de dépendance qui doit être utilisé pour définir la valeur d’un champ <see langword="public static readonly" /> dans votre classe. Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="typeMetadata">Métadonnées de propriété de la propriété de dépendance.</param>
        <param name="validateValueCallback">Référence à un rappel qui doit exécuter toute validation personnalisée de la valeur de propriété de dépendance au-delà de la validation de type standard.</param>
        <summary>Inscrit une propriété de dépendance avec le nom de propriété, le type de propriétaire et les métadonnées de propriété spécifiés, ainsi qu’un rappel de validation de valeur pour la propriété.</summary>
        <returns>Identificateur de propriété de dépendance qui doit être utilisé pour définir la valeur d’un champ <see langword="public static readonly" /> dans votre classe. Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant inscrit une propriété de dépendance, y compris un rappel de validation (la définition de rappel n’est pas affichée ; pour plus d’informations sur la définition de rappel, consultez <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une propriété jointe avec le système de propriétés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <summary>Inscrit une propriété jointe avec le nom de propriété, le type de propriété et le type de propriétaire spécifiés.</summary>
        <returns>Identificateur de propriété de dépendance qui doit être utilisé pour définir la valeur d’un champ <see langword="public static readonly" /> dans votre classe. Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété jointe est un concept de propriété défini par [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente des propriétés jointes en tant que propriétés de dépendance. Étant donné que le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés jointes sont des propriétés de dépendance, ils peuvent avoir des métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour les opérations telles que les caractéristiques de mise en page de création de rapports. Pour plus d’informations, consultez [Vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant inscrit une propriété jointe sur une classe abstraite à l’aide de ce <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="defaultMetadata">Métadonnées de la propriété de dépendance. Cela peut inclure la valeur par défaut, ainsi que d’autres caractéristiques.</param>
        <summary>Inscrit une propriété jointe avec le nom de propriété, le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</summary>
        <returns>Identificateur de propriété de dépendance qui doit être utilisé pour définir la valeur d’un champ <see langword="public static readonly" /> dans votre classe. Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété jointe est un concept de propriété défini par [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente des propriétés jointes en tant que propriétés de dépendance. Étant donné que le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés jointes sont des propriétés de dépendance, ils peuvent avoir des métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour les opérations telles que les caractéristiques de mise en page de création de rapports. Pour plus d’informations, consultez [Vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> au lieu de <xref:System.Windows.DependencyProperty.Register%2A> doit prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="defaultMetadata">Métadonnées de la propriété de dépendance. Cela peut inclure la valeur par défaut, ainsi que d’autres caractéristiques.</param>
        <param name="validateValueCallback">Référence à un rappel qui doit exécuter toute validation personnalisée de la valeur de propriété de dépendance au-delà de la validation de type standard.</param>
        <summary>Inscrit une propriété jointe avec le type de propriété, le type de propriétaire, les métadonnées de propriété et le rappel de validation de valeur spécifiés pour la propriété.</summary>
        <returns>Identificateur de propriété de dépendance qui doit être utilisé pour définir la valeur d’un champ <see langword="public static readonly" /> dans votre classe. Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété jointe est un concept de propriété défini par [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente des propriétés jointes en tant que propriétés de dépendance. Étant donné que le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés jointes sont des propriétés de dépendance, ils peuvent avoir des métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour les opérations telles que les caractéristiques de mise en page de création de rapports. Pour plus d’informations, consultez [Vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> au lieu de <xref:System.Windows.DependencyProperty.Register%2A> doit prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 L’exemple suivant inscrit une propriété jointe sur une classe abstraite à l’aide de ce <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature. Cette propriété jointe est une propriété de type énumération, et l’inscription ajoute un rappel de validation pour vérifier que la valeur fournie est une valeur de l’énumération.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une propriété jointe en lecture seule.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="defaultMetadata">Métadonnées de propriété de la propriété de dépendance.</param>
        <summary>Inscrit une propriété jointe en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</summary>
        <returns>Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Les propriétés jointes en lecture seule sont un scénario rare, étant donné que le scénario principal pour une propriété jointe est son utilisation dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sans accesseur Set public, une propriété jointe ne peut pas être définie dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance comme attachée consiste à prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="defaultMetadata">Métadonnées de propriété de la propriété de dépendance.</param>
        <param name="validateValueCallback">Référence à un rappel créé par l’utilisateur qui doit exécuter les validations personnalisées de la valeur de la propriété de dépendance au-delà de la validation de type standard.</param>
        <summary>Inscrit une propriété jointe en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés, ainsi qu’un rappel de validation.</summary>
        <returns>Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Les propriétés jointes en lecture seule sont un scénario rare, étant donné que le scénario principal pour une propriété jointe est son utilisation dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sans accesseur Set public, une propriété jointe ne peut pas être définie dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance comme attachée à la place de <xref:System.Windows.DependencyProperty.Register%2A> doit prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit une propriété de dépendance en tant que propriété de dépendance en lecture seule.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="typeMetadata">Métadonnées de propriété de la propriété de dépendance.</param>
        <summary>Inscrit une propriété de dépendance en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</summary>
        <returns>Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Propriétés de dépendance en lecture seule sont un scénario assez courant dans l’espace [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] et pour les scénarios de personnalisation, étant donné qu’autres [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fonctionnalités peuvent nécessiter une propriété de dépendance même si cette propriété n’est pas destinée à être définissable par appelants. Vous pouvez utiliser la valeur d’une propriété de dépendance en lecture seule comme base pour d’autres opérations de système de propriété qui prennent une propriété de dépendance, telles que baser un <xref:System.Windows.Trigger> sur la propriété de dépendance dans un style.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant inscrit un `AquariumSize` propriété de dépendance en lecture seule. L’exemple définit `AquariumSizeKey` comme une clé interne (afin que d’autres classes dans l’assembly peuvent substituer les métadonnées) et expose l’identificateur de propriété de dépendance selon cette clé comme `AquariumSizeProperty`. En outre, un wrapper est créé pour `AquariumSize`, avec uniquement un accesseur get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété de dépendance à inscrire.</param>
        <param name="propertyType">Type de la propriété.</param>
        <param name="ownerType">Type du propriétaire qui inscrit la propriété de dépendance.</param>
        <param name="typeMetadata">Métadonnées de propriété de la propriété de dépendance.</param>
        <param name="validateValueCallback">Référence à un rappel créé par l’utilisateur qui doit exécuter les validations personnalisées de la valeur de la propriété de dépendance au-delà de la validation de type standard.</param>
        <summary>Inscrit une propriété de dépendance en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés, ainsi qu’un rappel de validation.</summary>
        <returns>Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Propriétés de dépendance en lecture seule sont un scénario assez courant. Vous pouvez utiliser la valeur d’une propriété de dépendance en lecture seule comme base pour d’autres opérations de système de propriété qui prennent une propriété de dépendance, telles que baser un <xref:System.Windows.Trigger> sur la propriété de dépendance dans un style.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
 Validation sur une propriété de dépendance en lecture seule peut être moins importante. Le niveau d’accès non public que vous spécifiez pour la clé réduit la probabilité pour arbitraire entrée non valide.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la représentation sous forme de chaîne de la propriété de dépendance.</summary>
        <returns>Représentation sous forme de chaîne de la propriété de dépendance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation retourne la <xref:System.Windows.DependencyProperty.Name%2A> valeur de propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie une valeur statique qui est utilisée par le système de propriétés [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] plutôt que <see langword="null" /> pour indiquer que la propriété existe, mais sa valeur n'est pas définie par le système de propriétés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> est une valeur de sentinelle qui est utilisée pour les scénarios où le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés est impossible de déterminer un demandée <xref:System.Windows.DependencyProperty> valeur. <xref:System.Windows.DependencyProperty.UnsetValue> est utilisé au lieu de `null`, car `null` peut être une valeur de propriété valide, mais aussi valide (et fréquemment utilisé) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> n’est jamais retourné hors <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Lorsque vous appelez <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> sur une propriété de dépendance sur un <xref:System.Windows.DependencyObject> instance, une des options suivantes s’applique :  
  
-   Une propriété de dépendance a une valeur par défaut établie dans les métadonnées et cette valeur est retournée. Cette valeur peut provenir <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Une autre valeur a été établie par le système de propriétés, et la valeur par défaut n’est plus pertinente. Pour plus d’informations, consultez [Priorité de la valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Définissant un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> de <xref:System.Windows.DependencyProperty.UnsetValue> est interdite spécifiquement.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Retourne <xref:System.Windows.DependencyProperty.UnsetValue> lorsque la propriété demandée n'a pas été définie localement.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> a une signification particulière lorsqu’il est utilisé comme valeur de retour d’un <xref:System.Windows.CoerceValueCallback>. Pour plus d’informations, consultez [Validation et rappels de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Si vous liez à une base de données, notez que <xref:System.Windows.DependencyProperty.UnsetValue> n’est pas équivalent à <xref:System.DBNull.Value>, de manière similaire à la manière dont <xref:System.DBNull.Value> n’est pas équivalent à une vraie valeur null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le rappel de validation de valeur pour la propriété de dépendance.</summary>
        <value>Rappel de validation de valeur pour cette propriété de dépendance, comme fourni pour le paramètre <paramref name="validateValueCallback" /> dans l'inscription de propriété de dépendance d'origine.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété contiendra `null` pour n’importe quelle propriété de dépendance sans rappel de validation inscrit.  
  
 Valider des rappels de valeur doivent agir dans un sens statique : validation appliquée à travers le <xref:System.Windows.ValidateValueCallback> ne peut pas déterminer si la valeur fournie est valide pour toute instance particulière. Le rappel peut uniquement déterminer si tous les objets qui possèdent la propriété de dépendance doivent ou ne doivent pas accepter la valeur fournie comme étant valide. Si vous avez besoin effectuer la validation qui s’appuie sur la connaissance des valeurs d’autres propriétés de dépendance sur une instance particulière, utilisez un <xref:System.Windows.CoerceValueCallback> à la place. Le <xref:System.Windows.CoerceValueCallback> est inscrit dans le cadre des métadonnées de propriété de dépendance, plutôt que directement dans l’identificateur de propriété de dépendance. Pour plus d’informations, consultez [Validation et rappels de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>