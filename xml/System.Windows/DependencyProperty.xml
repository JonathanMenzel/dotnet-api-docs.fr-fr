<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyProperty.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b891ec5d-4b60-42d7-ac21-95eab9e3ef823e36dd257b906b7c94742536f4e333ac2cac8cd0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e36dd257b906b7c94742536f4e333ac2cac8cd0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">058bfa0b75b777d3171411d35da8f11617fc06b0</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/04/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</source>
          <target state="translated">Représente une propriété qui peut être définie par le biais de méthodes, par exemple style, liaison de données, animation et héritage.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> supports the following capabilities in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> prend en charge les fonctionnalités suivantes dans <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set in a style.</source>
          <target state="translated">La propriété peut être définie dans un style.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Application d’un style et création de modèles<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set through data binding.</source>
          <target state="translated">La propriété peut être définie via la liaison de données.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information about data binding dependency properties, see <bpt id="p1">[</bpt>How to: Bind the Properties of Two Controls<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les propriétés de dépendance de liaison de données, consultez <bpt id="p1">[</bpt>Comment : lier les propriétés de deux contrôles<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set with a dynamic resource reference.</source>
          <target state="translated">La propriété peut être définie avec une référence de ressource dynamique.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Ressources XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can inherit its value automatically from a parent element in the element tree.</source>
          <target state="translated">La propriété peut hériter automatiquement sa valeur d’un élément parent dans l’arborescence d’éléments.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Héritage de valeur de propriété<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be animated.</source>
          <target state="translated">La propriété peut être animée.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Vue d’ensemble de l’animation<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can report when the previous value of the property has been changed and the property value can be coerced.</source>
          <target state="translated">La propriété peut signaler lorsque la valeur précédente de la propriété a été modifiée et que la valeur de propriété peut être forcée.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Validation et rappels de propriétés de dépendance<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property reports information to <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, such as whether changing a property value should require the layout system to recompose the visuals for an element.</source>
          <target state="translated">La propriété signale des informations à <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, par exemple si la modification d’une valeur de propriété doit requérir que le système de disposition recompose les éléments visuels d’un élément.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property receives support in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</source>
          <target state="translated">La propriété reçoit la prise en charge dans le <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For example, the property can be edited in the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window.</source>
          <target state="translated">Par exemple, la propriété peut être modifiée dans le <bpt id="p1">**</bpt>propriétés<ept id="p1">**</ept> fenêtre.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about dependency properties, see <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
          <target state="translated">Pour en savoir plus sur les propriétés de dépendance, consultez <bpt id="p1">[</bpt>vue d’ensemble des propriétés de dépendance<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</source>
          <target state="translated">Si vous souhaitez que les propriétés de vos types personnalisés pour prendre en charge les fonctionnalités de la liste précédente, vous devez créer une propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn how to create custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Pour savoir comment créer des propriétés de dépendance personnalisées, consultez <bpt id="p1">[</bpt>des propriétés de dépendance personnalisées<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a property that enables any object to report information to the type that defines the attached property.</source>
          <target state="translated">Une propriété jointe est une propriété qui permet à n’importe quel objet pour signaler des informations pour le type qui définit la propriété jointe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, any type that inherits from <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> can use an attached property regardless of whether the type inherits from the type that defines the property.</source>
          <target state="translated">Dans <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, n’importe quel type qui hérite de <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> peut utiliser une propriété jointe indépendamment de si le type hérite du type qui définit la propriété.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</source>
          <target state="translated">Une propriété jointe est une fonctionnalité de le <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To set an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, use the <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> syntax.</source>
          <target state="translated">Pour définir une propriété jointe dans <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, utilisez le <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt> propertyName<ept id="p2">*</ept> syntaxe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An example of an attached property is the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Un exemple d’une propriété jointe est le <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want to create a property that can be used on all <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, then you should create an attached property.</source>
          <target state="translated">Si vous souhaitez créer une propriété qui peut être utilisée sur tous les <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, vous devez créer une propriété jointe.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about attached properties, including how to create them, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les propriétés jointes, notamment comment les créer, consultez <bpt id="p1">[</bpt>joint la vue d’ensemble des propriétés<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Attribute Usage</source>
          <target state="translated">Utilisation d'attributs XAML</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Values</source>
          <target state="translated">Valeurs XAML</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> of the desired dependency property.</source>
          <target state="translated">Chaîne qui spécifie le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> de la propriété de dépendance souhaitée.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</source>
          <target state="translated">Cela peut être précédée d’un préfixe d’espace de noms XML si la propriété n’est pas dans l’espace de noms XML par défaut (pour plus d’informations, consultez <bpt id="p1">[</bpt>espaces de noms XAML et Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></source>
          <target state="translated"><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies an owner type of a dependency property, a dot (.), then the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Chaîne qui spécifie un type de propriétaire d’une propriété de dépendance, un point (.), puis le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`ownerType`</ph> peut également être précédé d’un préfixe d’espace de noms XML.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the <ph id="ph1">`TargetType`</ph> is not yet known.</source>
          <target state="translated">Cette utilisation est particulière à liaison tardive styles et modèles, où le propriétaire de la propriété de dépendance doit être spécifié pour l’analyse de contexte, car le <ph id="ph1">`TargetType`</ph> n’est pas encore connu.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Application d’un style et création de modèles<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</source>
          <target state="translated">Chaîne qui spécifie le propriétaire d’une propriété attachée, un point (.), puis le nom de la propriété jointe.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> peut également être précédé d’un préfixe d’espace de noms XML.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Adds another type as an owner of a dependency property that has already been registered to a type.</source>
          <target state="translated">Ajoute un autre type en tant que propriétaire d’une propriété de dépendance qui a déjà été inscrite à un type.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The type to add as an owner of this dependency property.</source>
          <target state="translated">Type à ajouter en tant que propriétaire de cette propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Adds another type as an owner of a dependency property that has already been registered.</source>
          <target state="translated">Ajoute un autre type en tant que propriétaire d’une propriété de dépendance qui a déjà été inscrite.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Référence à l’identificateur <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> d’origine qui identifie la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Cet identificateur doit être exposé par la classe d’ajout en tant que champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Cette méthode permet au système de propriétés de reconnaître une propriété de dépendance sur un type qui n’a pas initialement inscrit cette propriété de dépendance particulière.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Typically, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</source>
          <target state="translated">En règle générale, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> est utilisé pour ajouter des propriétés de dépendance aux classes qui n’exposent pas déjà cette propriété de dépendance via l’héritage de classe managée (héritage de classe provoque les propriétés de wrapper héritées par la classe dérivée et par conséquent fournit l’accès général de tableau de membres pour la propriété de dépendance déjà).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> permet au système de propriétés de reconnaître une propriété de dépendance sur un type qui n’a pas initialement inscrit cette propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This signature does not allow for specifying metadata.</source>
          <target state="translated">Cette signature ne permet pas de spécifier les métadonnées.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>When you use this method, the metadata is automatically generated for the new <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> and its owner type.</source>
          <target state="translated">Lorsque vous utilisez cette méthode, les métadonnées sont générées automatiquement pour le nouveau <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> et son type de propriétaire.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</source>
          <target state="translated">Les métadonnées générées automatiquement sont le résultat des métadonnées fusionnées à partir de tous les types de base qui ont cette propriété est définie.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If no merged metadata is available, then the default metadata for the property is used.</source>
          <target state="translated">Si aucune métadonnée fusionnée n’est disponible, les métadonnées par défaut pour la propriété sont utilisée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If the property is registered by using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, then the default metadata is the same as the metadata that is created when <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> was called.</source>
          <target state="translated">Si cette propriété est enregistrée à l’aide de la <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> (méthode), les métadonnées par défaut est le même que les métadonnées qui sont créée lorsque <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> a été appelée.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object is created with the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> property set to the property type's default and all other properties of the <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> is set to <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dans le cas contraire, le <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> objet est créé avec le <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> propriété définie sur la valeur par défaut du type de propriété et toutes les autres propriétés de la <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> a la valeur <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> signature si vous souhaitez fournir des métadonnées pour la version de la propriété de dépendance comme ajouté au type fourni.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</source>
          <target state="translated">La valeur de retour de cette méthode est généralement utilisée pour déclarer et exposer la propriété de dépendance en stockant un identificateur de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The identifier provides access to the dependency property if you want to call property system <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> against the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">L’identificateur fournit l’accès à la propriété de dépendance si vous voulez appeler le système de propriétés <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> par rapport à la propriété de dépendance, en particulier, tel qu’il existe sur la classe propriétaire d’ajout.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Le même nom de propriété pour le propriétaire d’origine et le propriétaire ajouté doit être utilisé pour indiquer les fonctionnalités semblables.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> return value of the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> method to define the dependency property identifier, and also to declare <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Vous devez utiliser le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> valeur de retour de la <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> méthode pour définir l’identificateur de propriété de dépendance et également déclarer <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating the dependency properties that are declared within <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> méthodologie recommandée ci-dessus est utilisée lors de la création de propriétés de dépendance qui sont déclarées dans <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Par exemple, les deux <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> définir un <ph id="ph3">`BorderBrush`</ph> propriété de dépendance, qui ont des fonctionnalités similaires.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> based on the original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> définit son <ph id="ph2">`BorderBrush`</ph> propriété au système de propriétés en appelant <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> basée sur le propriétaire d’origine <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> et son enregistré <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> identificateur de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a new static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> retournent la valeur est ensuite utilisée pour établir un nouvelle statique <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> champ (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) pour cette propriété sur le propriétaire ajouté et un <ph id="ph4">`BorderBrush`</ph> wrapper de propriété est également déclaré.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The type to add as owner of this dependency property.</source>
          <target state="translated">Type à ajouter en tant que propriétaire de cette propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata that qualifies the dependency property as it exists on the provided type.</source>
          <target state="translated">Métadonnées qui qualifient la propriété de dépendance telle qu’elle existe sur le type fourni.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</source>
          <target state="translated">Ajoute un autre type en tant que propriétaire d’une propriété de dépendance déjà inscrite, et fournit des métadonnées de propriété de dépendance à la propriété de dépendance telle qu’elle existe sur le type de propriétaire fourni.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Référence à l’identificateur <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> d’origine qui identifie la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Cet identificateur doit être exposé par la classe d’ajout en tant que champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Cette méthode permet au système de propriétés de reconnaître une propriété de dépendance sur un type qui n’a pas initialement inscrit cette propriété de dépendance particulière.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">La valeur de retour de cette méthode est utilisée pour déclarer et exposer la propriété de dépendance, en particulier car il existe sur la classe propriétaire d’ajout.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">En règle générale, le même nom de propriété pour le propriétaire d’origine et le propriétaire ajouté doit être utilisé pour indiquer les fonctionnalités semblables.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>It is good practice to expose the identifiers, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Il est recommandé d’exposer les identificateurs, ainsi que de nouvelles <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> declared within <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> méthodologie recommandée ci-dessus est utilisée lors de la création <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> déclarée dans <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Par exemple, les deux <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> et <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> définir un <ph id="ph3">`BorderBrush`</ph> propriété de dépendance, qui ont des fonctionnalités similaires.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> on original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> définit son <ph id="ph2">`BorderBrush`</ph> propriété au système de propriétés en appelant <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> propriétaire d’origine <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> et son enregistré <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> identificateur de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>)for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> retournent la valeur est ensuite utilisée pour établir un mappage statique <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> champ (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) pour cette propriété sur le propriétaire ajouté et un <ph id="ph4">`BorderBrush`</ph> wrapper de propriété est également déclaré.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The added owner's dependency property identifier should be used for operations such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</source>
          <target state="translated">Identificateur de propriété de dépendance du propriétaire ajouté doit être utilisé pour les opérations comme <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</source>
          <target state="translated">Toutefois, les opérations spécifiques au type qui impliquent des types ou des instances de la classe qui a été ajouté comme propriétaire avec des métadonnées différentes est toujours retournent le résultats attendus, même si d’origine (pas le propriétaire ajouté) identificateur de propriété de dépendance est spécifié dans appels aux méthodes telles que <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata for the added owner is perpetuated by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</source>
          <target state="translated">Les métadonnées pour le propriétaire ajouté sont perpétuées par le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> s’appeler lui-même, pas nécessairement référencées exclusivement par le champ d’identificateur de classe propriétaire Ajout.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Nevertheless, it is good practice to expose the  identifier, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, because failing to do so creates disparity between the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> and <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> representations of your properties.</source>
          <target state="translated">Néanmoins, il est recommandé d’exposer l’identificateur, ainsi que de nouvelles <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, car sinon, crée une disparité entre les <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> et <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> représentations sous forme de vos propriétés.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Les métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist.</source>
          <target state="translated">Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine sont conservées.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées substitueront les caractéristiques des métadonnées de base.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics, such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are replaced if they are specified in the new metadata.</source>
          <target state="translated">Certaines caractéristiques, telles que <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, sont remplacées si elles sont spécifiées dans les nouvelles métadonnées.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">D’autres, tels que <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, sont combinées.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Enfin, le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour la substitution, donc le comportement décrit ici correspond aux classes de métadonnées de propriété existantes utilisées par <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> propriétés de dépendance.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>les métadonnées de propriété de dépendance<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> et <bpt id="p2">[</bpt>les métadonnées de propriété Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>Gets the default metadata of the dependency property.</source>
          <target state="translated">Obtient les métadonnées par défaut de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata of the dependency property.</source>
          <target state="translated">Métadonnées par défaut de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> call.</source>
          <target state="translated">Les métadonnées de la valeur par défaut sont les métadonnées de propriété qui sont disponible pour cet objet particulier ou un objet d’un type dérivé où aucune métadonnée de remplacement a été fournie par un texte explicite <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> appeler.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If the original owner applied metadata to the first <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call that established the dependency property, then that metadata is returned as <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Si le propriétaire d’origine applique les métadonnées pour la première <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> appel qui a établi la propriété de dépendance, alors que les métadonnées sont retournée en tant que <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If no metadata was applied in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, then default metadata is generated from within the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call and this value is returned as the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Si aucune métadonnée n’a été appliquée à la version d’origine <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> appeler, puis les métadonnées par défaut sont générée à partir du <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> appel et cette valeur est retournée en tant que le <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The main purpose of having default metadata associated with a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is to supply a default value for this property on any <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> or a derived type.</source>
          <target state="translated">L’objectif principal de l’association de métadonnées par défaut avec un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> consiste à fournir une valeur par défaut de cette propriété sur n’importe quel <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> ou un type dérivé.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type, even if the property was originally registered with a derived metadata type.</source>
          <target state="translated">Pour les propriétés non jointes, le type de métadonnées retourné par cette propriété ne peut pas être casté en types dérivés de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type, même si la propriété a été inscrite avec un type de métadonnées dérivées.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If you want the originally registered metadata including its original possibly derived metadata type, call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> instead, passing the original registering type as a parameter.</source>
          <target state="translated">Si vous souhaitez que les métadonnées inscrits à l’origine, y compris son type de métadonnées pouvant être dérivé d’origine, appelez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> au lieu de cela, en passant l’enregistrement d’origine de type en tant que paramètre.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For attached properties, the type of the metadata returned by this property will match the type given in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> registration method.</source>
          <target state="translated">Pour les propriétés jointes, le type de métadonnées retourné par cette propriété correspond au type donné dans la version d’origine <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> méthode d’inscription.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>Returns a hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Retourne un code de hachage pour ce <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Code de hachage pour cette <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The property system uses its own unique identifier <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, and the value of that property is returned by <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Le système de propriétés utilise son propre identificateur <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, et la valeur de cette propriété est retournée par <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Returns the metadata associated with this dependency property as it exists for a particular type.</source>
          <target state="translated">Retourne les métadonnées associées à cette propriété de dépendance telles qu’elles existent pour un type particulier.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</source>
          <target state="translated">Il peut s’agir du type où la propriété de dépendance a été inscrite initialement, un type auquel elle a été ajoutée par la suite, ou un type où la propriété de dépendance a été obtenue par le biais de l’héritage mais où les métadonnées ont été substituées de manière spécifique.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The specific type from which to retrieve the dependency property metadata.</source>
          <target state="translated">Type spécifique à partir duquel récupérer les métadonnées de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Returns the metadata for this dependency property as it exists on a specified existing type.</source>
          <target state="translated">Retourne les métadonnées pour cette propriété de dépendance telle qu’elles existent sur un type existant spécifié.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>A property metadata object.</source>
          <target state="translated">Objet de métadonnées de propriété.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that alter the metadata of the dependency property as it exists on a type.</source>
          <target state="translated">Spécifiez le type ou une référence d’objet à utiliser comme type est nécessaire, car les métadonnées peuvent varier de l’inscription d’origine due aux <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> les appels qui modifient les métadonnées de la propriété de dépendance telle qu’elle existe sur un type.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The following example gets metadata for a dependency property based on its type.</source>
          <target state="translated">L’exemple suivant obtient des métadonnées pour une propriété de dépendance selon son type.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The type is obtained by using a <ph id="ph1">`typeof`</ph> operator.</source>
          <target state="translated">Le type est obtenu en utilisant un <ph id="ph1">`typeof`</ph> opérateur.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</source>
          <target state="translated">Objet de dépendance dont le type est vérifié pour déterminer de quelle version spécifique au type de la propriété de dépendance les métadonnées doivent provenir.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Returns the metadata for this dependency property as it exists on the specified object instance.</source>
          <target state="translated">Retourne les métadonnées pour cette propriété de dépendance telle qu’elles existent sur l’instance d’objet spécifiée.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A property metadata object.</source>
          <target state="translated">Objet de métadonnées de propriété.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Spécifier le type ou une référence d’objet est nécessaire, car les métadonnées de toute propriété de dépendance peuvent varier de l’inscription d’origine due aux <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> les appels qui peuvent restreindre les métadonnées de propriété car elle existe sur un type.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</source>
          <target state="translated">Lorsque vous demandez des métadonnées de propriété basées sur une instance, vous passez simplement l’instance afin que son type puisse être évalué en interne.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</source>
          <target state="translated">Les métadonnées de propriété de dépendance ne varient pas par instance ; Il est toujours cohérent pour n’importe quelle combinaison de la propriété de type donné.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>The following example gets metadata for a dependency property based on a specific <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
          <target state="translated">L’exemple suivant obtient des métadonnées pour une propriété de dépendance basée sur un spécifique <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A specific object that records the dependency object type from which the dependency property metadata is desired.</source>
          <target state="translated">Objet spécifique qui enregistre le type d’objet de dépendance à partir duquel les métadonnées de propriété de dépendance sont souhaitées.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Returns the metadata for this dependency property as it exists on a specified type.</source>
          <target state="translated">Retourne les métadonnées pour cette propriété de dépendance telle qu’elles existent sur un type spécifié.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A property metadata object.</source>
          <target state="translated">Objet de métadonnées de propriété.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Spécifier le type ou une référence d’objet est nécessaire, car les métadonnées de toute propriété de dépendance peuvent varier de l’inscription d’origine due aux <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> les appels qui peuvent restreindre les métadonnées de propriété car elle existe sur un type.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>The following example gets metadata for a dependency property based on its <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant obtient des métadonnées pour une propriété de dépendance basée sur son <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Gets an internally generated value that uniquely identifies the dependency property.</source>
          <target state="translated">Obtient une valeur générée en interne qui identifie uniquement la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A unique numeric identifier.</source>
          <target state="translated">Identificateur numérique unique.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>This value is an integer, not a globally unique identifier (GUID).</source>
          <target state="translated">Cette valeur est un entier, pas un identificateur global unique (GUID).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</source>
          <target state="translated">En général, l’utilisation de cette valeur d’index n’est pas obligatoire, et il n’existe aucun accès d’index aux tables de toutes les propriétés de dépendance.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Dependency properties should instead be referenced by their identifier fields.</source>
          <target state="translated">Propriétés de dépendance doivent plutôt être référencées par leurs champs d’identificateur.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> is used internally for faster access to data structures that use the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> as a zero-based array index.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> est utilisé en interne pour un accès plus rapide aux structures de données qui utilisent le <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> en tant qu’un index de tableau de base zéro.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A similar usage might have applications for designers or tools.</source>
          <target state="translated">Une utilisation semblable peut avoir des applications pour les concepteurs ou les outils.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Valeur à contrôler.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</source>
          <target state="translated">Détermine si une valeur spécifiée est acceptable pour le type de cette propriété de dépendance, comme vérifié par rapport au type de propriété fourni dans l'inscription de propriété de dépendance d'origine.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is the registered property type or an acceptable derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la valeur spécifiée est le type de propriété inscrit ou un type dérivé acceptable ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>A value of <ph id="ph1">`null`</ph> is a valid type for reference type dependency properties, or for a <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph3">`true`</ph> for these cases.</source>
          <target state="translated">La valeur <ph id="ph1">`null`</ph> est un type valide pour les propriétés de dépendance de type référence ou pour un <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> propriété de dépendance et retournerait <ph id="ph3">`true`</ph> pour ces cas.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">Dans le cas où la propriété de dépendance n’est ni une référence ni un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> retournera <ph id="ph3">`false`</ph> pour une valeur null au lieu de déclencher une exception.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">L’exemple suivant utilise <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> en tant qu’une vérification avant d’appeler <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> sur la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Valeur à contrôler.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</source>
          <target state="translated">Détermine si la valeur fournie est acceptée pour le type de propriété à travers la vérification de type de base, et également si elle se trouve dans la plage de valeurs autorisée pour ce type.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value is acceptable and is of the correct type or a derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la valeur est acceptable et est du type correct ou un type dérivé ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>For a dependency property, an allowed range of values for that type can be specified through a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> that is provided in the dependency property registration.</source>
          <target state="translated">Pour une propriété de dépendance, une plage autorisée des valeurs pour ce type peut être spécifiée via un <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> qui est fourni dans l’inscription de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>This method calls <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> internally.</source>
          <target state="translated">Cette méthode appelle <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> en interne.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property in question has no <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>,then calling this method is effectively equivalent to calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</source>
          <target state="translated">Si la propriété de dépendance en question n’a pas <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, puis l’appel de cette méthode équivaut à appeler la méthode <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property does have a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, and if <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> would have returned <ph id="ph3">`true`</ph>, then the value returned will be as implemented in the callback.</source>
          <target state="translated">Si la propriété de dépendance a un <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>et si <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> a retourné <ph id="ph3">`true`</ph>, alors la valeur retournée est comme implémentée dans le rappel.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>A null value is a valid value for reference type dependency properties, or for a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph2">`true`</ph> for these cases.</source>
          <target state="translated">Une valeur null est une valeur valide pour les propriétés de dépendance de type référence, ou pour un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> propriété de dépendance et retournerait <ph id="ph2">`true`</ph> pour ces cas.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">Dans le cas où la propriété de dépendance n’est ni une référence ni un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> retournera <ph id="ph3">`false`</ph> pour une valeur null au lieu de déclencher une exception.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">L’exemple suivant utilise <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> en tant qu’une vérification avant d’appeler <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> sur la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.Name">
          <source>Gets the name of the dependency property.</source>
          <target state="translated">Obtient le nom de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The name of the property.</source>
          <target state="translated">Nom de la propriété.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This property gets the name provided as the <ph id="ph1">`name`</ph> parameter during dependency property registration.</source>
          <target state="translated">Cette propriété obtient le nom fourni en tant que le <ph id="ph1">`name`</ph> paramètre lors de l’inscription de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This name is immutable, and cannot be <ph id="ph1">`null`</ph> or an empty string.</source>
          <target state="translated">Ce nom est immuable et ne peut pas être <ph id="ph1">`null`</ph> ou une chaîne vide.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</source>
          <target state="translated">Les enregistrements de nom dupliqué sur le même type de propriétaire ne sont pas autorisées et lèvent une exception lorsque vous essayez d’inscrire le doublon.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> d’une dépendance de propriété doit suivre la convention de correspondance du nom de son identificateur de propriété de dépendance moins le suffixe « Propriété ».</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Propriétés de dépendance personnalisées<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</source>
          <target state="translated">L’exemple suivant interroge plusieurs caractéristiques d’un identificateur de propriété de dépendance, y compris le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Fournit des métadonnées de remplacement pour cette propriété de dépendance quand elle est présente sur des instances d’un type spécifié, différentes des métadonnées qui ont été fournies dans l’inscription de la propriété de dépendance initiale.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Type où cette propriété de dépendance est héritée et emplacement où les métadonnées de remplacement fournies sont appliquées.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Métadonnées à appliquer à la propriété de dépendance sur le type de substitution.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</source>
          <target state="translated">Spécifie les métadonnées de remplacement pour cette propriété de dépendance quand elle est présente sur des instances d’un type spécifié, substituant les métadonnées qui existaient pour la propriété de dépendance quand elle a été héritée de types de base.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Les métadonnées de propriété de dépendance doivent être remplacée avant que le système de propriétés utilise la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This equates to the time that specific instances are created using the class that registers the dependency property.</source>
          <target state="translated">Cela équivaut à la fois des instances spécifiques sont créées à l’aide de la classe qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Les appels à <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> doivent être exécutés uniquement dans les constructeurs statiques du type qui fournit en tant que le <ph id="ph2">`forType`</ph> paramètre de cette méthode, ou par instanciation semblable.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Tentative de modification des métadonnées après que les instances du type propriétaire existent ne déclenche pas d’exceptions, mais entraîne des comportements incohérents dans le système de propriétés.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Une fois les métadonnées pour un remplacement de la classe dérivée particulière sont établie avec cette méthode, les tentatives ultérieures de remplacer les métadonnées sur cette même classe dérivée lève une exception.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Les métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine sont conservées ; seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées substitueront les caractéristiques des métadonnées de base.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Certaines caractéristiques, telles que <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> sont remplacés si spécifié dans les nouvelles métadonnées.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">D’autres, tels que <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, sont combinées.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Enfin, le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour la substitution, donc le comportement décrit ici correspond aux classes de métadonnées de propriété existantes utilisées par <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> propriétés de dépendance.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>les métadonnées de propriété de dépendance<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> et <bpt id="p2">[</bpt>les métadonnées de propriété Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</source>
          <target state="translated">Vous avez essayé de substituer des métadonnées sur une propriété de dépendance en lecture seule (vous ne pouvez pas effectuer cette opération à l’aide de cette signature).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the dependency property as it exists on the provided type.</source>
          <target state="translated">Des métadonnées ont déjà été établies pour la propriété de dépendance telle qu’elle existe sur le type fourni.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Type où cette propriété de dépendance est héritée et emplacement où les métadonnées de remplacement fournies sont appliquées.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Métadonnées à appliquer à la propriété de dépendance sur le type de substitution.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The access key for a read-only dependency property.</source>
          <target state="translated">Clé d’accès pour une propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Fournit des métadonnées de remplacement pour une propriété de dépendance en lecture seule quand elle est présente sur des instances d’un type spécifié, substituant les métadonnées fournies dans l’inscription de la propriété de dépendance initiale.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>You must pass the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> for the read-only dependency property to avoid raising an exception.</source>
          <target state="translated">Vous devez passer le <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> pour la propriété de dépendance en lecture seule pour éviter de déclencher une exception.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This signature provides underlying implementation for a read-only dependency property identifier (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) method.</source>
          <target state="translated">Cette signature fournit l’implémentation sous-jacente pour un identificateur de propriété de dépendance en lecture seule (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) méthode.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>If overriding metadata for a read-write dependency property, use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Si la substitution de métadonnées pour une propriété de dépendance en lecture-écriture, utilisez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Les métadonnées de propriété de dépendance doivent être remplacée avant que le système de propriétés utilise la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This equates to the time that specific objects are created for the class that registers the dependency property.</source>
          <target state="translated">Cela équivaut à la fois des objets spécifiques sont créés pour la classe qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Les appels à <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> doivent être exécutés uniquement dans les constructeurs statiques du type qui fournit en tant que le <ph id="ph2">`forType`</ph> paramètre de cette méthode, ou par instanciation semblable.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Tentative de modification des métadonnées après que les instances du type propriétaire existent ne déclenche pas d’exceptions, mais entraîne des comportements incohérents dans le système de propriétés.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Une fois les métadonnées pour un remplacement de la classe dérivée particulière sont établie avec cette méthode, les tentatives ultérieures de remplacer les métadonnées sur cette même classe dérivée lève une exception.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Les métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine sont conservées ; seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées substitueront les caractéristiques des métadonnées de base.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Certaines caractéristiques, telles que <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> sont remplacés si spécifié dans les nouvelles métadonnées.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">D’autres, tels que <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, sont combinées.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The merge behavior depends on the property metadata type being used for the override.</source>
          <target state="translated">Le comportement de fusion varie selon le type de métadonnées de propriété qui est utilisé pour le remplacement.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>les métadonnées de propriété de dépendance<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> et <bpt id="p2">[</bpt>les métadonnées de propriété Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</source>
          <target state="translated">Obtient le type de l’objet qui a inscrit la propriété de dépendance avec le système de propriétés ou qui s’est ajouté comme propriétaire de la propriété.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The type of the object that registered the property or added itself as owner of the property.</source>
          <target state="translated">Type de l’objet qui a inscrit la propriété ou qui s’est ajouté comme propriétaire de la propriété.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This value was provided during property registration.</source>
          <target state="translated">Cette valeur a été fournie pendant l’inscription de la propriété.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The owner will be either the original registering type in the case of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, or the type that added itself as owner in the case of a <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from an <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
          <target state="translated">Le propriétaire sera soit le type de l’enregistrement d’origine dans le cas d’un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur généré à partir d’un <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> appel ou le type qui l’a ajouté comme propriétaire dans le cas d’un <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur généré à partir d’une <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> appeler.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> on any given <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is immutable, and cannot be <ph id="ph3">`null`</ph> in a valid <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> sur n’importe quel donné <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> est immuable et ne peut pas être <ph id="ph3">`null`</ph> dans valide <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The following example gets the owner type based on a dependency property identifier <ph id="ph1">`dp`</ph>, and then gets metadata on the owner type for that same identifier.</source>
          <target state="translated">L’exemple suivant obtient le type de propriétaire basé sur un identificateur de propriété de dépendance <ph id="ph1">`dp`</ph>, puis obtient les métadonnées sur le type de propriétaire pour ce même identificateur.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This operation is actually equivalent to getting <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> on <ph id="ph2">`dp`</ph>.</source>
          <target state="translated">Cette opération est en fait équivalente à l’obtention de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> sur <ph id="ph2">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Gets the type that the dependency property uses for its value.</source>
          <target state="translated">Obtient le type que la propriété de dépendance utilise pour sa valeur.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the property value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> de la valeur de la propriété.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>This property reports the type of the property's value as declared by the original property registration, through the <ph id="ph1">`propertyType`</ph> parameter.</source>
          <target state="translated">Cette propriété indique le type de valeur de la propriété comme déclaré par l’inscription de la propriété d’origine, via le <ph id="ph1">`propertyType`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Similar to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, the property type of a dependency property is immutable after registration.</source>
          <target state="translated">Similaire à la <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, le type de propriété d’une propriété de dépendance est immuable après l’inscription.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</source>
          <target state="translated">L’exemple suivant interroge plusieurs caractéristiques d’un identificateur de propriété de dépendance, y compris le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The type name string of the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> is obtained from the returned <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">La chaîne du nom de type du <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> est obtenu à partir de retourné <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Gets a value that indicates whether the dependency property identified by this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> instance is a read-only dependency property.</source>
          <target state="translated">Obtient une valeur qui indique si la propriété de dépendance identifié par cette instance <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> est une propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propriété de dépendance est en lecture seule ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties are registered within the property system by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> method as opposed to the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method.</source>
          <target state="translated">Propriétés de dépendance en lecture seule sont inscrites dans le système de propriétés en appelant le <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> méthode par opposition à la <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Attached properties can also be registered as read-only; see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated">Propriétés jointes peuvent également être inscrits en lecture seule ; consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties require a <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier rather than a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier to perform metadata operations such as overriding the metadata or setting the value.</source>
          <target state="translated">Propriétés de dépendance en lecture seule requièrent un <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identificateur plutôt qu’un <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur pour effectuer des opérations de métadonnées telles que la substitution des métadonnées ou la définition de la valeur.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If you obtained a collection of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers through a call to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> or another <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> that exposes identifiers, check the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> value before attempting to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> or <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</source>
          <target state="translated">Si vous avez obtenu une collection de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateurs via un appel à <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> ou un autre <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> qui expose des identificateurs, vérifiez la <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> valeur avant d’essayer d’appeler <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> ou <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> en utilisant ce identificateur de propriété de dépendance en tant que paramètre d’entrée, pour vérifier que la propriété de dépendance qui représente de l’identificateur n’est pas en lecture seule.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If the value of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> is <ph id="ph2">`true`</ph> on a dependency property, there is no programmatic way to obtain a reference to the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier of that dependency property, from the metadata or from the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier; the identifier must be available as a static field in order to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> against a read-only dependency property.</source>
          <target state="translated">Si la valeur de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> est <ph id="ph2">`true`</ph> sur une propriété de dépendance, il n’existe aucun moyen de programmation pour obtenir une référence à la <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identificateur de cette propriété de dépendance à partir des métadonnées ou à partir de la <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificateur ; l’identificateur doit être disponible comme un champ statique afin d’appeler <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> par rapport à une propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper property.</source>
          <target state="translated">Lorsque vous créez une propriété de dépendance personnalisée et enregistrez comme étant en lecture seule, vous devez définir uniquement un accesseur get pour le <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> propriété wrapper.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</source>
          <target state="translated">Sinon, votre classe possède un modèle objet confus pour le wrapper de propriété par rapport à l’accès à la propriété de dépendance de sauvegarde.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> or <bpt id="p2">[</bpt>Read-Only Dependency Properties<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>propriétés de dépendance personnalisées<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> ou <bpt id="p2">[</bpt>propriétés de dépendance en lecture seule<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">L’exemple suivant obtienne les métadonnées par défaut et les propriétés d’identificateur de propriété de dépendance à partir de différents champs de propriété de dépendance et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property.</source>
          <target state="translated">Inscrit une propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name must be unique within the registration namespace of the owner type.</source>
          <target state="translated">Le nom doit être unique dans l’espace de noms d’inscription du type de propriétaire.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>Registers a dependency property with the specified property name, property type, and owner type.</source>
          <target state="translated">Inscrit une propriété de dépendance avec le nom de propriété, le type de propriété et le type de propriétaire spécifiés.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificateur de la propriété de dépendance qui doit être utilisé pour définir la valeur d'un champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> dans votre classe.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de propriété de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Inscrit une propriété de dépendance avec le nom de propriété, le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificateur de la propriété de dépendance qui doit être utilisé pour définir la valeur d'un champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> dans votre classe.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de propriété de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Référence à un rappel qui doit exécuter toute validation personnalisée de la valeur de propriété de dépendance au-delà de la validation de type standard.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</source>
          <target state="translated">Inscrit une propriété de dépendance avec le nom de propriété, le type de propriétaire et les métadonnées de propriété spécifiés, ainsi qu’un rappel de validation de valeur pour la propriété.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificateur de la propriété de dépendance qui doit être utilisé pour définir la valeur d'un champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> dans votre classe.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</source>
          <target state="translated">L’exemple suivant inscrit une propriété de dépendance, y compris un rappel de validation (la définition de rappel n’est pas affiché ; pour plus d’informations sur la définition de rappel, consultez <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers an attached property with the property system.</source>
          <target state="translated">Inscrit une propriété jointe avec le système de propriétés.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Registers an attached property with the specified property name, property type, and owner type.</source>
          <target state="translated">Inscrit une propriété jointe avec le nom de propriété, le type de propriété et le type de propriétaire spécifiés.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificateur de la propriété de dépendance qui doit être utilisé pour définir la valeur d'un champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> dans votre classe.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Une propriété jointe est un concept de propriété défini par <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implémente des propriétés jointes comme propriétés de dépendance.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Étant donné que le <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> propriétés jointes sont des propriétés de dépendance, ils peuvent avoir les métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour des opérations telles que les caractéristiques de mise en page.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Vue d’ensemble des propriétés jointes<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">L’exemple suivant inscrit une propriété jointe sur une classe abstraite à l’aide de ce <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Cela peut inclure la valeur par défaut, ainsi que d’autres caractéristiques.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers an attached property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Inscrit une propriété jointe avec le nom de propriété, le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificateur de la propriété de dépendance qui doit être utilisé pour définir la valeur d'un champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> dans votre classe.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Une propriété jointe est un concept de propriété défini par <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implémente des propriétés jointes comme propriétés de dépendance.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Étant donné que le <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> propriétés jointes sont des propriétés de dépendance, ils peuvent avoir les métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour des opérations telles que les caractéristiques de mise en page.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Vue d’ensemble des propriétés jointes<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Un scénario particulier pour inscrire une propriété de dépendance avec <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> au lieu de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> doit prendre en charge l’héritage de valeur de propriété.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> même si la classe définit des accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché accesseurs de propriété prise en charge.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Bien que l’héritage de valeur de propriété puisse sembler fonctionner pour les propriétés de dépendance non attachées, le comportement d’héritage d’une propriété non attachée par certaines limites de l’élément dans l’arborescence d’exécution n’est pas défini.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Enregistrement de la propriété comme attaché efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne au-delà des limites dans une arborescence d’éléments.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Toujours utiliser <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> pour inscrire des propriétés où vous spécifiez <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Héritage de valeur de propriété<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Cela peut inclure la valeur par défaut, ainsi que d’autres caractéristiques.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Référence à un rappel qui doit exécuter toute validation personnalisée de la valeur de propriété de dépendance au-delà de la validation de type standard.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</source>
          <target state="translated">Inscrit une propriété jointe avec le type de propriété, le type de propriétaire, les métadonnées de propriété et le rappel de validation de valeur spécifiés pour la propriété.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificateur de la propriété de dépendance qui doit être utilisé pour définir la valeur d'un champ <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> dans votre classe.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Cet identificateur est ensuite utilisé pour faire référence ultérieurement à la propriété de dépendance, pour des opérations comme la définition de sa valeur par programmation ou l’obtention de métadonnées.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Une propriété jointe est un concept de propriété défini par <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implémente des propriétés jointes comme propriétés de dépendance.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Étant donné que le <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> propriétés jointes sont des propriétés de dépendance, ils peuvent avoir les métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour des opérations telles que les caractéristiques de mise en page.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Vue d’ensemble des propriétés jointes<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Un scénario particulier pour inscrire une propriété de dépendance avec <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> au lieu de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> doit prendre en charge l’héritage de valeur de propriété.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> même si la classe définit des accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché accesseurs de propriété prise en charge.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Bien que l’héritage de valeur de propriété puisse sembler fonctionner pour les propriétés de dépendance non attachées, le comportement d’héritage d’une propriété non attachée par certaines limites de l’élément dans l’arborescence d’exécution n’est pas défini.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Enregistrement de la propriété comme attaché efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne au-delà des limites dans une arborescence d’éléments.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Toujours utiliser <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> pour inscrire des propriétés où vous spécifiez <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Héritage de valeur de propriété<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">L’exemple suivant inscrit une propriété jointe sur une classe abstraite à l’aide de ce <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</source>
          <target state="translated">Cette propriété jointe est une propriété de type énumération, et l’inscription ajoute un rappel de validation pour vérifier que la valeur fournie est une valeur de l’énumération.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a read-only attached property.</source>
          <target state="translated">Inscrit une propriété jointe en lecture seule.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de propriété de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Inscrit une propriété jointe en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Cette méthode retourne le type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, alors que <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> retourne le type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de classe.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> comme un <ph id="ph2">`public static readonly`</ph> de votre classe.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Les propriétés jointes en lecture seule sont un scénario rare, parce que le scénario principal d’une propriété jointe est son utilisation en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Sans accesseur Set public, une propriété jointe ne peut pas être définie dans <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntaxe.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property as attached is to support property value inheritance.</source>
          <target state="translated">Un scénario particulier pour inscrire une propriété de dépendance comme jointe est de prendre en charge l’héritage de valeur de propriété.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> même si la classe définit des accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché accesseurs de propriété prise en charge.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Bien que l’héritage de valeur de propriété puisse sembler fonctionner pour les propriétés de dépendance non attachées, le comportement d’héritage d’une propriété non attachée par certaines limites de l’élément dans l’arborescence d’exécution n’est pas défini.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Enregistrement de la propriété comme attaché efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne au-delà des limites dans une arborescence d’éléments.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Toujours utiliser <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> pour inscrire des propriétés où vous spécifiez <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Héritage de valeur de propriété<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de propriété de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Référence à un rappel créé par l’utilisateur qui doit exécuter les validations personnalisées de la valeur de la propriété de dépendance au-delà de la validation de type standard.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Inscrit une propriété jointe en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés, ainsi qu’un rappel de validation.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Cette méthode retourne le type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, alors que <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> retourne le type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent the type <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">En règle générale, les clés qui représentent le type <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de classe.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> comme un <ph id="ph2">`public static readonly`</ph> de votre classe.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Les propriétés jointes en lecture seule sont un scénario rare, parce que le scénario principal d’une propriété jointe est son utilisation en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Sans accesseur Set public, une propriété jointe ne peut pas être définie dans <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntaxe.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property as attached instead of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Un scénario particulier pour inscrire une propriété de dépendance associé à la place de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> doit prendre en charge l’héritage de valeur de propriété.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> même si la classe définit des accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché accesseurs de propriété prise en charge.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Bien que l’héritage de valeur de propriété puisse sembler fonctionner pour les propriétés de dépendance non attachées, le comportement d’héritage d’une propriété non attachée par certaines limites de l’élément dans l’arborescence d’exécution n’est pas défini.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Enregistrement de la propriété comme attaché efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne au-delà des limites dans une arborescence d’éléments.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Toujours utiliser <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> pour inscrire des propriétés où vous spécifiez <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> dans les métadonnées.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Héritage de valeur de propriété<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property as a read-only dependency property.</source>
          <target state="translated">Inscrit une propriété de dépendance en tant que propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de propriété de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Inscrit une propriété de dépendance en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Cette méthode retourne le type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, alors que <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> retourne le type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de classe.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> comme un <ph id="ph2">`public static readonly`</ph> de votre classe.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only dependency properties are a fairly typical scenario both in the existing <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> and for customization scenarios, because other <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features might require a dependency property even if that property is not intended to be settable by callers.</source>
          <target state="translated">Propriétés de dépendance en lecture seule sont un scénario assez typique dans existants <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> et pour les scénarios de personnalisation, étant donné qu’autres <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> fonctionnalités peuvent requérir une propriété de dépendance même si cette propriété n’est pas destinée à être définissable par appelants.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Vous pouvez utiliser la valeur d’une propriété de dépendance en lecture seule comme base pour d’autres opérations de système de propriété qui prennent une propriété de dépendance, par exemple en basant une <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> sur la propriété de dépendance dans un style.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The following example registers an <ph id="ph1">`AquariumSize`</ph> dependency property as read-only.</source>
          <target state="translated">L’exemple suivant inscrit une <ph id="ph1">`AquariumSize`</ph> propriété de dépendance en lecture seule.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The example defines <ph id="ph1">`AquariumSizeKey`</ph> as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as <ph id="ph2">`AquariumSizeProperty`</ph>.</source>
          <target state="translated">L’exemple définit <ph id="ph1">`AquariumSizeKey`</ph> comme une clé interne (afin que d’autres classes dans l’assembly peuvent substituer les métadonnées) et expose l’identificateur de propriété de dépendance selon cette clé comme <ph id="ph2">`AquariumSizeProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Also, a wrapper is created for <ph id="ph1">`AquariumSize`</ph>, with only a get accessor.</source>
          <target state="translated">En outre, un wrapper est créé pour <ph id="ph1">`AquariumSize`</ph>, avec uniquement un accesseur get.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nom de la propriété de dépendance à inscrire.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Type de la propriété.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Type du propriétaire qui inscrit la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Métadonnées de propriété de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Référence à un rappel créé par l’utilisateur qui doit exécuter les validations personnalisées de la valeur de la propriété de dépendance au-delà de la validation de type standard.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Inscrit une propriété de dépendance en lecture seule, avec le type de propriété, le type de propriétaire et les métadonnées de propriété spécifiés, ainsi qu’un rappel de validation.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Clé de propriété de dépendance qui doit être utilisée pour définir la valeur d’un champ statique en lecture seule dans votre classe, qui est ensuite utilisée pour faire référence à la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Cette méthode retourne le type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, alors que <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> retourne le type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de classe.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> comme un <ph id="ph2">`public static readonly`</ph> de votre classe.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only dependency properties are a fairly typical scenario.</source>
          <target state="translated">Propriétés de dépendance en lecture seule sont un scénario assez typique.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Vous pouvez utiliser la valeur d’une propriété de dépendance en lecture seule comme base pour d’autres opérations de système de propriété qui prennent une propriété de dépendance, par exemple en basant une <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> sur la propriété de dépendance dans un style.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Validation on a read-only dependency property might be less important.</source>
          <target state="translated">La validation sur une propriété de dépendance en lecture seule peut être moins importante.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</source>
          <target state="translated">Le niveau d’accès non public que vous spécifiez pour la clé réduit la probabilité pour les entrées arbitraires non valides.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>Returns the string representation of the dependency property.</source>
          <target state="translated">Retourne la représentation sous forme de chaîne de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>The string representation of the dependency property.</source>
          <target state="translated">Représentation sous forme de chaîne de la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.ToString">
          <source>This implementation returns the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> property value.</source>
          <target state="translated">Cette implémentation retourne la <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> valeur de propriété.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Specifies a static value that is used by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system rather than <ph id="ph2">&lt;see langword="null" /&gt;</ph> to indicate that the property exists, but does not have its value set by the property system.</source>
          <target state="translated">Spécifie une valeur statique qui est utilisée par le système de propriétés <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> plutôt que <ph id="ph2">&lt;see langword="null" /&gt;</ph> pour indiquer que la propriété existe, mais sa valeur n'est pas définie par le système de propriétés.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is a sentinel value that is used for scenarios where the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system is unable to determine a requested <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> est une valeur de sentinelle qui est utilisée pour les scénarios où le <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> système de propriétés est impossible de déterminer un demandée <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> valeur.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is used rather than <ph id="ph2">`null`</ph>, because <ph id="ph3">`null`</ph> could be a valid property value, as well as a valid (and frequently used) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> est utilisé au lieu de <ph id="ph2">`null`</ph>, car <ph id="ph3">`null`</ph> peut être une valeur de propriété valide, mais aussi valide (et fréquemment utilisé) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is never returned out of <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> n’est jamais retourné de <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> on a dependency property on a <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, one of the following applies:</source>
          <target state="translated">Lorsque vous appelez <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> sur une propriété de dépendance sur un <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, une des options suivantes s’applique :</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>A dependency property has a default value established in metadata and that value is returned.</source>
          <target state="translated">Une propriété de dépendance a la valeur par défaut établie dans les métadonnées et cette valeur est retournée.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>This value might come from <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Cette valeur peut provenir de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Some other value was established by the property system, and the default value is no longer relevant.</source>
          <target state="translated">Une autre valeur a été établie par le système de propriétés, et la valeur par défaut n’est plus pertinente.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Priorité de la valeur de propriété de dépendance<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is specifically disallowed.</source>
          <target state="translated">Définir un <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> de <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> est interdite spécifiquement.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> when the requested property has not been locally set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> Retourne <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> lorsque la propriété demandée n'a pas été définie localement.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has a special meaning when used as the return value of a <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> a une signification particulière lorsqu’il est utilisé en tant que valeur de retour d’un <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>rappels de propriété de dépendance et la Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>If you are binding to a database, note that <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is not equivalent to <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, in a similar way to how <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> is not equivalent to a true null.</source>
          <target state="translated">Si vous établissez une liaison à une base de données, notez que <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> n’est pas équivalent à <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, d’une manière similaire à la manière dont <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> n’est pas équivalent à une valeur null true.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Gets the value validation callback for the dependency property.</source>
          <target state="translated">Obtient le rappel de validation de valeur pour la propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The value validation callback for this dependency property, as provided for the <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> parameter in the original dependency property registration.</source>
          <target state="translated">Rappel de validation de valeur pour cette propriété de dépendance, comme fourni pour le paramètre <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> dans l'inscription de propriété de dépendance d'origine.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>This property will contain <ph id="ph1">`null`</ph> for any dependency property with no registered validation callback.</source>
          <target state="translated">Cette propriété contient <ph id="ph1">`null`</ph> pour n’importe quelle propriété de dépendance sans rappel de validation inscrit.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Validate value callbacks must act in a static sense: validation applied through the <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> cannot determine whether the provided value is valid for any particular instance.</source>
          <target state="translated">Valider des rappels de valeur doivent agir dans un sens statique : validation appliquée à travers le <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> ne peut pas déterminer si la valeur fournie est valide pour toute instance particulière.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</source>
          <target state="translated">Le rappel peut déterminer uniquement si tous les objets qui possèdent la propriété de dépendance doivent ou ne doivent pas accepter la valeur fournie comme étant valide.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> instead.</source>
          <target state="translated">Si vous avez besoin effectuer une validation qui s’appuie sur la connaissance des valeurs d’autres propriétés de dépendance sur une instance particulière, utilisez un <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> est enregistré dans le cadre des métadonnées de propriété de dépendance, plutôt que directement dans l’identificateur de propriété de dépendance.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>rappels de propriété de dépendance et la Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>