<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f9af7c7588dee4a02565170423aec4646b42e947" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37550307" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyProperty> prend en charge les fonctionnalités suivantes dans [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   La propriété peut être définie dans un style. Pour plus d’informations, consultez [Application d’un style et création de modèles](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   La propriété peut être définie via la liaison de données. Pour plus d’informations sur les propriétés de dépendance de liaison de données, consultez [Comment : lier les propriétés de deux contrôles](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   La propriété peut être définie avec une référence de ressource dynamique. Pour plus d’informations, consultez [Ressources XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   La propriété peut hériter automatiquement sa valeur d’un élément parent dans l’arborescence d’éléments. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   La propriété peut être animée. Pour plus d’informations, consultez [Vue d’ensemble de l’animation](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   La propriété peut signaler lorsque la valeur précédente de la propriété a été modifiée et que la valeur de propriété peut être forcée. Pour plus d’informations, consultez [Validation et rappels de propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   La propriété signale des informations à [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], telles que si la modification d’une valeur de propriété doit requérir que le système de disposition recompose les visuels d’un élément.  
  
-   La propriété reçoit la prise en charge dans le [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Par exemple, la propriété peut être modifiée dans le **propriétés** fenêtre.  
  
 Pour en savoir plus sur les propriétés de dépendance, consultez [vue d’ensemble des propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Si vous souhaitez que les propriétés de vos types personnalisés pour prendre en charge les fonctionnalités dans la liste précédente, vous devez créer une propriété de dépendance.  Pour savoir comment créer des propriétés de dépendance personnalisées, consultez [des propriétés de dépendance personnalisées](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Une propriété jointe est une propriété qui permet à n’importe quel objet pour signaler des informations pour le type qui définit la propriété jointe. Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], n’importe quel type qui hérite de <xref:System.Windows.DependencyObject> pouvez utiliser une propriété jointe, quel que soit l’indique si le type hérite du type qui définit la propriété. Une propriété jointe est une fonctionnalité de le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] langage.  Pour définir une propriété jointe dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], utilisez le *TypePropriétaire*.* propertyName* syntaxe. Un exemple d’une propriété jointe est le <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> propriété. Si vous souhaitez créer une propriété qui peut être utilisée sur tous les <xref:System.Windows.DependencyObject> types, vous devez créer une propriété jointe. Pour en savoir plus sur les propriétés jointes, notamment comment les créer, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `dependencyPropertyName`  
 Chaîne qui spécifie le <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> de la propriété de dépendance souhaitée. Cela peut être précédée d’un préfixe d’espace de noms XML si la propriété n’est pas dans l’espace de noms XML par défaut (pour plus d’informations, consultez [espaces de noms XAML et Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Chaîne qui spécifie un type de propriétaire d’une propriété de dépendance, un point (.), puis le <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` peut également être précédé par un préfixe d’espace de noms XML. Cette utilisation est particulière à liaison tardive styles et modèles, où le propriétaire de la propriété de dépendance doit être spécifié pour l’analyse de contexte, car le `TargetType` n’est pas encore connu. Pour plus d’informations, consultez [Application d’un style et création de modèles](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Chaîne qui spécifie le propriétaire d’une propriété jointe, un point (.), puis le nom de la propriété jointe. `attachedPropertyOwnerType` peut également être précédé par un préfixe d’espace de noms XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds another type as an owner of a dependency property that has already been registered to a type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as an owner of this dependency property.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet le système de propriétés identifier une propriété de dépendance sur un type qui n’a pas inscrit initialement cette propriété de dépendance particulière.  
  
 En règle générale, <xref:System.Windows.DependencyProperty.AddOwner%2A> est utilisé pour ajouter des propriétés de dépendance à des classes qui n’exposent pas déjà cette propriété de dépendance via l’héritage de classe managée (héritage de classe provoque les propriétés de wrapper être héritée par la classe dérivée et par conséquent fournit l’accès général de table des membres à la propriété de dépendance déjà). <xref:System.Windows.DependencyProperty.AddOwner%2A> permet le système de propriétés identifier une propriété de dépendance sur un type qui n’a pas inscrit initialement cette propriété de dépendance.  
  
 Cette signature ne permet pas pour la spécification des métadonnées.  Lorsque vous utilisez cette méthode, les métadonnées sont générées automatiquement pour le nouveau <xref:System.Windows.DependencyProperty> et son type de propriétaire. Les métadonnées générées automatiquement sont le résultat des métadonnées fusionnées à partir de tous les types de base qui ont cette propriété est définie. Si aucune métadonnée fusionnée n’est disponible, les métadonnées par défaut pour la propriété sont utilisée. Si la propriété est inscrite à l’aide de la <xref:System.Windows.DependencyProperty.RegisterAttached%2A> (méthode), les métadonnées par défaut est le même que les métadonnées qui sont créée lorsque <xref:System.Windows.DependencyProperty.RegisterAttached%2A> a été appelée. Sinon, le <xref:System.Windows.PropertyMetadata> objet est créé avec le <xref:System.Windows.PropertyMetadata.DefaultValue%2A> propriété la valeur par défaut du type de propriété et toutes les autres propriétés de la <xref:System.Windows.PropertyMetadata> est défini sur `null`. Utilisez le <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> signature si vous souhaitez fournir des métadonnées pour la version de la propriété de dépendance comme ajouté au type fourni.  
  
 La valeur de retour de cette méthode est généralement utilisée pour déclarer et exposer la propriété de dépendance en stockant un identificateur de propriété de dépendance. L’identificateur fournit l’accès à la propriété de dépendance si vous souhaitez appeler le système de propriétés [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] par rapport à la propriété de dépendance, en particulier, tel qu’il existe sur la classe propriétaire d’ajout. Le même nom de propriété pour le propriétaire d’origine et ajout d’un propriétaire doit être utilisé pour indiquer les fonctionnalités semblables. Vous devez utiliser le <xref:System.Windows.DependencyProperty> valeur de retour de la <xref:System.Windows.DependencyProperty.AddOwner%2A> méthode pour définir l’identificateur de propriété de dépendance et également déclarer [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Le <xref:System.Windows.DependencyProperty.AddOwner%2A> méthodologie recommandée ci-dessus est utilisée lors de la création de propriétés de dépendance sont déclarées dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Par exemple, les deux <xref:System.Windows.Controls.Border> et <xref:System.Windows.Controls.Control> définir un `BorderBrush` propriété de dépendance, qui ont des fonctionnalités similaires. <xref:System.Windows.Controls.Control> définit son `BorderBrush` propriété au système de propriétés en appelant <xref:System.Windows.DependencyProperty.AddOwner%2A> basée sur le propriétaire d’origine <xref:System.Windows.Controls.Border> et son inscrit <xref:System.Windows.Controls.Border.BorderBrushProperty> identificateur de propriété de dépendance. Le <xref:System.Windows.DependencyProperty.AddOwner%2A> retourner la valeur est ensuite utilisée pour établir un nouvelle statique <xref:System.Windows.DependencyProperty> champ (<xref:System.Windows.Controls.Control.BorderBrushProperty>) de cette propriété sur l’ajout d’un propriétaire et un `BorderBrush` wrapper de propriété est également déclaré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as owner of this dependency property.</param>
        <param name="typeMetadata">The metadata that qualifies the dependency property as it exists on the provided type.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet le système de propriétés identifier une propriété de dépendance sur un type qui n’a pas inscrit initialement cette propriété de dépendance particulière.  
  
 La valeur de retour de cette méthode est utilisée pour déclarer et exposer la propriété de dépendance, en particulier car elle existe sur la classe propriétaire d’ajout. En règle générale, le même nom de propriété pour le propriétaire d’origine et ajout d’un propriétaire doit être utilisé pour indiquer les fonctionnalités semblables. Il est recommandé d’exposer les identificateurs, comme pour les nouveaux [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Le <xref:System.Windows.DependencyProperty.AddOwner%2A> méthodologie recommandée ci-dessus est utilisée lors de la création [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] déclarés dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Par exemple, les deux <xref:System.Windows.Controls.Border> et <xref:System.Windows.Controls.Control> définir un `BorderBrush` propriété de dépendance, qui ont des fonctionnalités similaires. <xref:System.Windows.Controls.Control> définit son `BorderBrush` propriété au système de propriétés en appelant <xref:System.Windows.DependencyProperty.AddOwner%2A> propriétaire d’origine <xref:System.Windows.Controls.Border> et son inscrit <xref:System.Windows.Controls.Border.BorderBrushProperty> identificateur de propriété de dépendance. Le <xref:System.Windows.DependencyProperty.AddOwner%2A> retourner la valeur est ensuite utilisée pour établir un mappage statique <xref:System.Windows.DependencyProperty> champ (<xref:System.Windows.Controls.Control.BorderBrushProperty>) de cette propriété sur l’ajout d’un propriétaire et un `BorderBrush` wrapper de propriété est également déclaré.  
  
 Identificateur de propriété de dépendance de l’ajout d’un propriétaire doit être utilisé pour les opérations telles que <xref:System.Windows.DependencyObject.GetValue%2A>. Toutefois, les opérations spécifiques au type impliquant des types ou des instances de la classe qui a été ajouté comme propriétaire avec des métadonnées différentes est toujours retournent le résultats attendus, même si la version d’origine (pas le propriétaire ajouté) identificateur de propriété de dépendance est spécifié dans appels aux méthodes telles que <xref:System.Windows.DependencyObject.GetValue%2A> ou <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Les métadonnées pour l’ajout d’un propriétaire sont conservés après par le <xref:System.Windows.DependencyProperty.AddOwner%2A> s’appeler lui-même, pas nécessairement référencés exclusivement par le champ d’identificateur de classe propriétaire Ajout. Néanmoins, il est conseillé pour exposer l’identificateur, comme pour les nouveaux [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] des wrappers de propriété pour les propriétés de dépendance qui sont ajoutées aux types à l’aide de <xref:System.Windows.DependencyProperty.AddOwner%2A>, car sinon, crée une disparité entre les [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] représentations sous forme de vos propriétés.  
  
 Métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base. Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine seront conservé. Seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées remplacent les caractéristiques des métadonnées de base. Certaines caractéristiques, telles que <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, sont remplacées si elles sont spécifiées dans les nouvelles métadonnées. D’autres, tels que <xref:System.Windows.PropertyChangedCallback>, sont combinées. Au final, le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour le remplacement, donc le comportement décrit ici concerne les classes de métadonnées de propriété existantes utilisées par [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés de dépendance. Pour plus d’informations, consultez [les métadonnées de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-metadata.md) et [les métadonnées de propriété de Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default metadata of the dependency property.</summary>
        <value>Les métadonnées par défaut de la propriété de dépendance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les métadonnées par défaut correspond aux métadonnées de propriété qui sont disponible pour cet objet particulier ou un objet d’un type dérivé où aucune métadonnée de remplacement a été fournie par explicite <xref:System.Windows.DependencyProperty.Register%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appeler.  
  
 Si le propriétaire d’origine applique les métadonnées pour la première <xref:System.Windows.DependencyProperty.Register%2A> appel qui a établi la propriété de dépendance, alors que les métadonnées sont retournée en tant que <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Si aucune métadonnée n’a été appliquée dans la version d’origine <xref:System.Windows.DependencyProperty.Register%2A> appeler, les métadonnées par défaut sont alors généré depuis le <xref:System.Windows.DependencyProperty.Register%2A> appel et cette valeur est retournée en tant que le <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 L’objectif principal de l’association de métadonnées par défaut avec un <xref:System.Windows.DependencyProperty> consiste à fournir une valeur par défaut de cette propriété sur n’importe quel <xref:System.Windows.DependencyObject> ou un type dérivé.  
  
 Pour les propriétés non jointes, le type de métadonnées retourné par cette propriété ne peut pas être casté aux types dérivés de <xref:System.Windows.PropertyMetadata> tapez, même si la propriété a été inscrite avec un type de métadonnées dérivées. Si vous souhaitez que les métadonnées inscrite à l’origine, notamment son type de métadonnées dérivées éventuellement d’origine, appelez <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> au lieu de cela, en passant l’enregistrement d’origine de type en tant que paramètre.  
  
 Pour les propriétés jointes, le type de métadonnées retourné par cette propriété correspond au type donné dans la version d’origine <xref:System.Windows.DependencyProperty.RegisterAttached%2A> méthode d’inscription.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le système de propriétés utilise son propre identificateur unique <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, et la valeur de cette propriété est retournée par <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the metadata associated with this dependency property as it exists for a particular type. This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">The specific type from which to retrieve the dependency property metadata.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified existing type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifiez le type ou une référence d’objet à utiliser comme type est nécessaire, car les métadonnées peuvent varier de l’inscription d’origine due aux <xref:System.Windows.DependencyProperty.AddOwner%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appels qui modifient les métadonnées de la propriété de dépendance telle qu’elle existe sur un type.  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance selon son type. Le type est obtenu en utilisant un `typeof` opérateur.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</param>
        <summary>Returns the metadata for this dependency property as it exists on the specified object instance.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En spécifiant le type ou une référence d’objet est nécessaire, car les métadonnées de toute propriété de dépendance peuvent varier de l’inscription d’origine due aux <xref:System.Windows.DependencyProperty.AddOwner%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appels qui peuvent restreindre les métadonnées de propriété car elle existe sur un type.  
  
 Lorsque vous demandez des métadonnées de propriété basées sur une instance, vous passez simplement l’instance afin que son type peut être évalué en interne. Métadonnées de propriété de dépendance ne varient pas par instance ; Il est toujours cohérent pour n’importe quelle combinaison de la propriété de type donnée.  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance basée sur un spécifique <xref:System.Windows.DependencyObject> instance.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">A specific object that records the dependency object type from which the dependency property metadata is desired.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En spécifiant le type ou une référence d’objet est nécessaire, car les métadonnées de toute propriété de dépendance peuvent varier de l’inscription d’origine due aux <xref:System.Windows.DependencyProperty.AddOwner%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> appels qui peuvent restreindre les métadonnées de propriété car elle existe sur un type.  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance selon son <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an internally generated value that uniquely identifies the dependency property.</summary>
        <value>Un identificateur numérique unique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est un entier, pas un identificateur global unique (GUID). En règle générale, à l’aide de cette valeur d’index n’est pas obligatoire, et il n’existe aucun accès d’index aux tables de toutes les propriétés de dépendance. Propriétés de dépendance doivent plutôt être référencées par leurs champs d’identificateur.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> est utilisé en interne pour un accès plus rapide aux structures de données qui utilisent le <xref:System.Windows.DependencyProperty.GlobalIndex%2A> comme un index de tableau de base zéro. Une utilisation semblable peut avoir des applications pour les concepteurs ou d’outils.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</summary>
        <returns>
          <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur `null` est un type valide pour les propriétés de dépendance de type référence ou pour un <xref:System.Nullable%601> propriété de dépendance et retournerait `true` pour ces cas. Dans le cas où la propriété de dépendance n’est ni une référence ni un <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> retournera `false` pour une valeur null au lieu de déclencher une exception.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.DependencyProperty.IsValidType%2A> en tant qu’une vérification avant d’appeler <xref:System.Windows.DependencyObject.SetValue%2A> sur la propriété de dépendance.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</summary>
        <returns>
          <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour une propriété de dépendance, une plage autorisée de valeurs pour ce type peut être spécifiée via un <xref:System.Windows.ValidateValueCallback> qui est fourni dans l’inscription de propriété de dépendance.  
  
 Cette méthode appelle <xref:System.Windows.DependencyProperty.IsValidType%2A> en interne. Si la propriété de dépendance en question n’a pas <xref:System.Windows.ValidateValueCallback>, puis l’appel de cette méthode équivaut à appeler <xref:System.Windows.DependencyProperty.IsValidType%2A>. Si la propriété de dépendance a un <xref:System.Windows.ValidateValueCallback>et si <xref:System.Windows.DependencyProperty.IsValidType%2A> a retourné `true`, puis la valeur retournée sera tel qu’implémenté dans le rappel.  
  
 Une valeur null est une valeur valide pour les propriétés de dépendance de type référence ou pour un <xref:System.Nullable%601> propriété de dépendance et retournerait `true` pour ces cas. Dans le cas où la propriété de dépendance n’est ni une référence ni un <xref:System.Nullable%601> type, <xref:System.Windows.DependencyProperty.IsValidType%2A> retournera `false` pour une valeur null au lieu de déclencher une exception.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.DependencyProperty.IsValidValue%2A> en tant qu’une vérification avant d’appeler <xref:System.Windows.DependencyObject.SetValue%2A> sur la propriété de dépendance.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the dependency property.</summary>
        <value>Nom de la propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient le nom fourni en tant que le `name` paramètre lors de l’inscription de propriété de dépendance. Ce nom est immuable et ne peut pas être `null` ou une chaîne vide. Les enregistrements de nom dupliqué sur le même type de propriétaire ne sont pas autorisées et lèvent une exception lorsque vous essayez d’inscrire le doublon.  
  
> [!IMPORTANT]
>  Le <xref:System.Windows.DependencyProperty.Name%2A> d’une dépendance de propriété doit suivre la convention de mise en correspondance le nom de son identificateur de propriété de dépendance sans le suffixe « Propriété ». Pour plus d’informations, consultez [Propriétés de dépendance personnalisées](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 L’exemple suivant interroge plusieurs caractéristiques d’un identificateur de propriété de dépendance, y compris le <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <summary>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Métadonnées de propriété de dépendance doivent être remplacée avant que le système de propriétés utilise la propriété de dépendance. Cela équivaut à l’heure à laquelle les instances spécifiques sont créées à l’aide de la classe qui inscrit la propriété de dépendance. Les appels à <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> doit uniquement être effectuée dans les constructeurs statiques du type qui fournit lui-même comme le `forType` paramètre de cette méthode, ou à travers une instanciation semblable. Tente de modifier les métadonnées une fois que les instances du type propriétaire existent ne déclenche pas d’exceptions, mais entraîne des comportements incohérents dans le système de propriétés.  
  
 Une fois que les métadonnées pour un remplacement de la classe dérivée particulière sont établie avec cette méthode, les tentatives suivantes de substituer des métadonnées sur cette même classe dérivée lève une exception.  
  
 Métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base. Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine seront persistantes ; seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées remplacent les caractéristiques des métadonnées de base. Certaines caractéristiques, telles que <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sont remplacés si spécifié dans les nouvelles métadonnées. D’autres, tels que <xref:System.Windows.PropertyChangedCallback>, sont combinées. Au final, le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour le remplacement, donc le comportement décrit ici concerne les classes de métadonnées de propriété existantes utilisées par [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés de dépendance. Pour plus d’informations, consultez [les métadonnées de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-metadata.md) et [les métadonnées de propriété de Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</exception>
        <exception cref="T:System.ArgumentException">Metadata was already established for the dependency property as it exists on the provided type.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <param name="key">The access key for a read-only dependency property.</param>
        <summary>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration. You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette signature fournit l’implémentation sous-jacente pour un identificateur de propriété de dépendance en lecture seule (<xref:System.Windows.DependencyPropertyKey>) (méthode). Si la substitution de métadonnées pour une propriété de dépendance en lecture-écriture, utilisez <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Métadonnées de propriété de dépendance doivent être remplacée avant que le système de propriétés utilise la propriété de dépendance. Cela équivaut à la fois des objets spécifiques sont créés pour la classe qui inscrit la propriété de dépendance. Les appels à <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> doit uniquement être effectuée dans les constructeurs statiques du type qui fournit lui-même comme le `forType` paramètre de cette méthode, ou à travers une instanciation semblable. Tente de modifier les métadonnées une fois que les instances du type propriétaire existent ne déclenche pas d’exceptions, mais entraîne des comportements incohérents dans le système de propriétés.  
  
 Une fois que les métadonnées pour un remplacement de la classe dérivée particulière sont établie avec cette méthode, les tentatives suivantes de substituer des métadonnées sur cette même classe dérivée lève une exception.  
  
 Métadonnées fournies sont fusionnées avec les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le propriétaire de base. Des caractéristiques qui ont été spécifiées dans les métadonnées de base d’origine seront persistantes ; seules ces caractéristiques qui ont été modifiés en particulier dans les nouvelles métadonnées remplacent les caractéristiques des métadonnées de base. Certaines caractéristiques, telles que <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sont remplacés si spécifié dans les nouvelles métadonnées. D’autres, tels que <xref:System.Windows.PropertyChangedCallback>, sont combinées. Le comportement de fusion varie selon le type de métadonnées de propriété utilisé pour le remplacement. Pour plus d’informations, consultez [les métadonnées de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-metadata.md) et [les métadonnées de propriété de Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</summary>
        <value>Type de l’objet qui a inscrit la propriété ou qui s’est ajouté comme propriétaire de la propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur a été fournie pendant l’inscription de propriété. Le propriétaire sera soit le type d’inscription d’origine dans le cas d’un <xref:System.Windows.DependencyProperty> identificateur généré à partir d’un <xref:System.Windows.DependencyProperty.Register%2A> appel, ou le type qui l’a ajouté en tant que propriétaire de l’un <xref:System.Windows.DependencyProperty> identificateur généré à partir d’un <xref:System.Windows.DependencyProperty.AddOwner%2A> appeler.  
  
 Le <xref:System.Windows.DependencyProperty.OwnerType%2A> sur n’importe quel donné <xref:System.Windows.DependencyProperty> est immuable et ne peut pas être `null` dans valide <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de propriétaire selon un identificateur de propriété de dépendance `dp`et puis obtient des métadonnées sur le type de propriétaire pour ce même identificateur. Cette opération revient en fait à obtenir <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> sur `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that the dependency property uses for its value.</summary>
        <value>Le <see cref="T:System.Type" /> de la valeur de propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique le type de valeur de la propriété comme déclaré par l’inscription de propriété d’origine, via le `propertyType` paramètre. Similaire à la <xref:System.Windows.DependencyProperty.Name%2A>, le type de propriété d’une propriété de dépendance est immuable après l’inscription.  
  
   
  
## Examples  
 L’exemple suivant interroge plusieurs caractéristiques d’un identificateur de propriété de dépendance, y compris le <xref:System.Windows.DependencyProperty.PropertyType%2A>. La chaîne de nom de type de la <xref:System.Windows.DependencyProperty.PropertyType%2A> est obtenu à partir de retourné <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</summary>
        <value>
          <see langword="true" /> Si la propriété de dépendance est en lecture seule ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés de dépendance en lecture seule sont enregistrées dans le système de propriétés en appelant le <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> (méthode), par opposition à la <xref:System.Windows.DependencyProperty.Register%2A> (méthode). Propriétés jointes peuvent également être enregistrées en lecture seule ; consultez <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Propriétés de dépendance en lecture seule requièrent un <xref:System.Windows.DependencyPropertyKey> identificateur plutôt qu’un <xref:System.Windows.DependencyProperty> identificateur pour effectuer des opérations de métadonnées telles que la substitution des métadonnées ou la définition de la valeur. Si vous avez obtenu une collection de <xref:System.Windows.DependencyProperty> identificateurs via un appel à <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> ou un autre [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] qui expose des identificateurs, vérifiez la <xref:System.Windows.DependencyProperty.ReadOnly%2A> valeur avant d’essayer d’appeler <xref:System.Windows.DependencyObject.SetValue%2A> ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> à les utiliser identificateur de propriété de dépendance en tant que paramètre d’entrée, pour vérifier que la propriété de dépendance qui représente l’identificateur n’est pas en lecture seule. Si la valeur de <xref:System.Windows.DependencyProperty.ReadOnly%2A> est `true` sur une propriété de dépendance, il n’existe aucun moyen de programmation pour obtenir une référence à la <xref:System.Windows.DependencyPropertyKey> identificateur de cette propriété de dépendance à partir des métadonnées ou à partir de la <xref:System.Windows.DependencyProperty> identificateur ; l’identificateur doit être disponible comme un champ statique pour pouvoir appeler <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> par rapport à une propriété de dépendance en lecture seule.  
  
 Lorsque vous créez une propriété de dépendance personnalisée et inscrivez en lecture seule, vous devez définir uniquement un accesseur get pour le [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] propriété wrapper. Sinon, votre classe possède un modèle d’objet déroutant pour le wrapper de propriété par rapport à l’accès à la propriété de dépendance de sauvegarde. Pour plus d’informations, consultez [propriétés de dépendance personnalisées](~/docs/framework/wpf/advanced/custom-dependency-properties.md) ou [propriétés de dépendance en lecture seule](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 L’exemple suivant obtienne les métadonnées par défaut et les propriétés d’identificateur de propriété de dépendance à partir de différents champs de propriété de dépendance et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register. The name must be unique within the registration namespace of the owner type.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant inscrit une propriété de dépendance, y compris un rappel de validation (la définition de rappel n’est pas affichée ; pour plus d’informations sur la définition de rappel, consultez <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers an attached property with the property system.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers an attached property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété jointe est un concept de propriété défini par [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente des propriétés jointes en tant que propriétés de dépendance. Étant donné que le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés jointes sont des propriétés de dépendance, ils peuvent avoir des métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour les opérations telles que les caractéristiques de mise en page de création de rapports. Pour plus d’informations, consultez [Vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant inscrit une propriété jointe sur une classe abstraite à l’aide de ce <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <summary>Registers an attached property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété jointe est un concept de propriété défini par [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente des propriétés jointes en tant que propriétés de dépendance. Étant donné que le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés jointes sont des propriétés de dépendance, ils peuvent avoir des métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour les opérations telles que les caractéristiques de mise en page de création de rapports. Pour plus d’informations, consultez [Vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> au lieu de <xref:System.Windows.DependencyProperty.Register%2A> doit prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété jointe est un concept de propriété défini par [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémente des propriétés jointes en tant que propriétés de dépendance. Étant donné que le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propriétés jointes sont des propriétés de dépendance, ils peuvent avoir des métadonnées appliquées qui peuvent être utilisée par le système de propriétés général pour les opérations telles que les caractéristiques de mise en page de création de rapports. Pour plus d’informations, consultez [Vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> au lieu de <xref:System.Windows.DependencyProperty.Register%2A> doit prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 L’exemple suivant inscrit une propriété jointe sur une classe abstraite à l’aide de ce <xref:System.Windows.DependencyProperty.RegisterAttached%2A> signature. Cette propriété jointe est une propriété de type énumération, et l’inscription ajoute un rappel de validation pour vérifier que la valeur fournie est une valeur de l’énumération.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a read-only attached property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Les propriétés jointes en lecture seule sont un scénario rare, étant donné que le scénario principal pour une propriété jointe est son utilisation dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sans accesseur Set public, une propriété jointe ne peut pas être définie dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance comme attachée consiste à prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Les propriétés jointes en lecture seule sont un scénario rare, étant donné que le scénario principal pour une propriété jointe est son utilisation dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sans accesseur Set public, une propriété jointe ne peut pas être définie dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilisez RegisterAttached pour les propriétés de dépendance héritant d’une valeur  
 Un scénario particulier pour inscrire une propriété de dépendance comme attachée à la place de <xref:System.Windows.DependencyProperty.Register%2A> doit prendre en charge l’héritage de valeur de propriété. Vous devez enregistrer les propriétés de dépendance héritant d’une valeur avec <xref:System.Windows.DependencyProperty.RegisterAttached%2A> même si la classe définit les accesseurs de wrapper de propriété qui exposent la propriété de dépendance, et même si vous ne souhaitez pas exposer des méthodes statiques Get * et Set * pour fournir true attaché prise en charge les accesseurs de propriété.   Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines limites d’éléments dans l’arborescence d’exécution est indéfini. Enregistrement de la propriété jointe efficacement rend la propriété jointe à une propriété globale pour le système de propriétés et garantit que l’héritage de valeur de propriété fonctionne sur toutes les limites dans une arborescence d’éléments. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées. Pour plus d’informations, consultez [Héritage de valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property as a read-only dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Propriétés de dépendance en lecture seule sont un scénario assez courant dans l’espace [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] et pour les scénarios de personnalisation, étant donné qu’autres [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fonctionnalités peuvent nécessiter une propriété de dépendance même si cette propriété n’est pas destinée à être définissable par appelants. Vous pouvez utiliser la valeur d’une propriété de dépendance en lecture seule comme base pour d’autres opérations de système de propriété qui prennent une propriété de dépendance, telles que baser un <xref:System.Windows.Trigger> sur la propriété de dépendance dans un style.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L’exemple suivant inscrit un `AquariumSize` propriété de dépendance en lecture seule. L’exemple définit `AquariumSizeKey` comme une clé interne (afin que d’autres classes dans l’assembly peuvent substituer les métadonnées) et expose l’identificateur de propriété de dépendance selon cette clé comme `AquariumSizeProperty`. En outre, un wrapper est créé pour `AquariumSize`, avec uniquement un accesseur get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le type <xref:System.Windows.DependencyPropertyKey>, tandis que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> retourne le type <xref:System.Windows.DependencyProperty>. En règle générale, les clés qui représentent les propriétés en lecture seule ne sont pas rendues publiques, car les clés peuvent être utilisées pour définir la valeur de propriété de dépendance en appelant <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Votre conception de classe affecte vos exigences, mais il est généralement recommandé de limiter l’accès et la visibilité de n’importe quel <xref:System.Windows.DependencyPropertyKey> uniquement aux parties de votre code qui sont nécessaires pour définir cette propriété de dépendance dans le cadre de la logique d’application ou de la classe. Il est également recommandé d’exposer un identificateur de propriété de dépendance pour la propriété de dépendance en lecture seule, en exposant la valeur de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> comme un `public static readonly` champ sur votre classe.  
  
 Propriétés de dépendance en lecture seule sont un scénario assez courant. Vous pouvez utiliser la valeur d’une propriété de dépendance en lecture seule comme base pour d’autres opérations de système de propriété qui prennent une propriété de dépendance, telles que baser un <xref:System.Windows.Trigger> sur la propriété de dépendance dans un style.  
  
 Pour plus d’informations sur l’inscription de propriété de dépendance, consultez <xref:System.Windows.DependencyProperty>.  
  
 Validation sur une propriété de dépendance en lecture seule peut être moins importante. Le niveau d’accès non public que vous spécifiez pour la clé réduit la probabilité pour arbitraire entrée non valide.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the string representation of the dependency property.</summary>
        <returns>The string representation of the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation retourne la <xref:System.Windows.DependencyProperty.Name%2A> valeur de propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> est une valeur de sentinelle qui est utilisée pour les scénarios où le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés est impossible de déterminer un demandée <xref:System.Windows.DependencyProperty> valeur. <xref:System.Windows.DependencyProperty.UnsetValue> est utilisé au lieu de `null`, car `null` peut être une valeur de propriété valide, mais aussi valide (et fréquemment utilisé) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> n’est jamais retourné hors <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Lorsque vous appelez <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> sur une propriété de dépendance sur un <xref:System.Windows.DependencyObject> instance, une des options suivantes s’applique :  
  
-   Une propriété de dépendance a une valeur par défaut établie dans les métadonnées et cette valeur est retournée. Cette valeur peut provenir <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Une autre valeur a été établie par le système de propriétés, et la valeur par défaut n’est plus pertinente. Pour plus d’informations, consultez [Priorité de la valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Définissant un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> de <xref:System.Windows.DependencyProperty.UnsetValue> est interdite spécifiquement.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Retourne <xref:System.Windows.DependencyProperty.UnsetValue> lorsque la propriété demandée n'a pas été définie localement.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> a une signification particulière lorsqu’il est utilisé comme valeur de retour d’un <xref:System.Windows.CoerceValueCallback>. Pour plus d’informations, consultez [Validation et rappels de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Si vous liez à une base de données, notez que <xref:System.Windows.DependencyProperty.UnsetValue> n’est pas équivalent à <xref:System.DBNull.Value>, de manière similaire à la manière dont <xref:System.DBNull.Value> n’est pas équivalent à une vraie valeur null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value validation callback for the dependency property.</summary>
        <value>Le rappel de validation de valeur pour cette propriété de dépendance, comme fourni pour le <paramref name="validateValueCallback" /> paramètre dans l’inscription de propriété de dépendance d’origine.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété contiendra `null` pour n’importe quelle propriété de dépendance sans rappel de validation inscrit.  
  
 Valider des rappels de valeur doivent agir dans un sens statique : validation appliquée à travers le <xref:System.Windows.ValidateValueCallback> ne peut pas déterminer si la valeur fournie est valide pour toute instance particulière. Le rappel peut uniquement déterminer si tous les objets qui possèdent la propriété de dépendance doivent ou ne doivent pas accepter la valeur fournie comme étant valide. Si vous avez besoin effectuer la validation qui s’appuie sur la connaissance des valeurs d’autres propriétés de dépendance sur une instance particulière, utilisez un <xref:System.Windows.CoerceValueCallback> à la place. Le <xref:System.Windows.CoerceValueCallback> est inscrit dans le cadre des métadonnées de propriété de dépendance, plutôt que directement dans l’identificateur de propriété de dépendance. Pour plus d’informations, consultez [Validation et rappels de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>