<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1d1529115d328a1d811aa8b586bd2a77931b537" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460239" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="01d9d-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="01d9d-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-103">La <xref:System.Windows.Freezable> classe fournit des fonctionnalités spéciales qui peuvent aider à améliorent les performances de l’application lors de l’utilisation des objets qui sont coûteux à modifier ou à copier.</span><span class="sxs-lookup"><span data-stu-id="01d9d-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="01d9d-104">Exemples de <xref:System.Windows.Freezable> objets incluent les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="01d9d-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="01d9d-105">Dérivation de Freezable</span><span class="sxs-lookup"><span data-stu-id="01d9d-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="01d9d-106">Une classe qui dérive de <xref:System.Windows.Freezable> acquiert les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="01d9d-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="01d9d-107">États spéciaux : (un en lecture seule figé) et un état accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="01d9d-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="01d9d-108">Sécurité des threads : figé <xref:System.Windows.Freezable> objet peut être partagé entre plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="01d9d-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="01d9d-109">Notification de modifications détaillée : contrairement à d’autres <xref:System.Windows.DependencyObject> objets, un <xref:System.Windows.Freezable> objet fournit des notifications de modifications lorsque les valeurs de sous-propriété changent.</span><span class="sxs-lookup"><span data-stu-id="01d9d-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="01d9d-110">Clonage facile : la classe Freezable a déjà implémenté plusieurs méthodes qui génèrent des clones complets.</span><span class="sxs-lookup"><span data-stu-id="01d9d-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="01d9d-111">Pour plus d’informations sur l’utilisation et en créant votre propre <xref:System.Windows.Freezable> , consultez [vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="01d9d-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="01d9d-112">N’importe quel public <see langword="static" /> de ce type sont thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="01d9d-113">Il n'est pas garanti que les membres d'instance soient thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="01d9d-114">Lorsque le <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> objet sont accessibles uniquement à partir du thread sur lequel il a été créé.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="01d9d-115">Tente d’y accéder à partir d’un autre thread lève une <see cref="T:System.InvalidOperationException" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="01d9d-116">Le <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> et <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> méthodes fournissent une prise en charge pour marshaler le thread correct.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="01d9d-117">Lors de leur <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objets sont libres de threads.</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="01d9d-118">Pour plus d’informations, consultez [Freezable objets Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      <span class="sxs-lookup">
        <span data-stu-id="01d9d-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-120">Il s’agit du constructeur à accessibilité protégée d’une classe abstraite.</span><span class="sxs-lookup"><span data-stu-id="01d9d-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="01d9d-122">
            <see langword="true" /> si l’objet actif peut être rendu non modifiable ou s’il l’est déjà ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-123">
            <para>Cette implémentation de méthode utilise le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> méthode avec <paramref name="isChecking" /> la valeur <see langword="true" /> pour déterminer si un <see cref="T:System.Windows.Freezable" /> peut être rendue non modifiable. Pour modifier le comportement de cette propriété dans une classe dérivée, substituez la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (méthode).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-123">
              <para>This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-124">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-124">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-125">Si vous tentez d’ajouter ou supprimer des gestionnaires d’événements lorsque l’objet actuel n’est pas modifiable (lorsque le <xref:System.Windows.Freezable.IsFrozen%2A> propriété est `true`), une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-125">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-126">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-126">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="01d9d-127">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-127">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-128">A modifiable clone of the current object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-128">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="01d9d-129">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-129">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-130">Le <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes génèrent des clones modifiables de figé <xref:System.Windows.Freezable> objets (les méthodes également clonent <xref:System.Windows.Freezable> les objets qui ne sont pas gelés).</span><span class="sxs-lookup"><span data-stu-id="01d9d-130">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="01d9d-131">Le clone est en fait une copie complète de l’objet actuel.</span><span class="sxs-lookup"><span data-stu-id="01d9d-131">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="01d9d-132">Le tableau suivant résume les différences entre les <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="01d9d-132">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="01d9d-133">Action</span><span class="sxs-lookup"><span data-stu-id="01d9d-133">Action</span></span>|<span data-ttu-id="01d9d-134">Comportement de la méthode clone</span><span class="sxs-lookup"><span data-stu-id="01d9d-134">Clone method behavior</span></span>|<span data-ttu-id="01d9d-135">Méthode CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="01d9d-135">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="01d9d-136">Copie d’une propriété de dépendance qui possède une expression</span><span class="sxs-lookup"><span data-stu-id="01d9d-136">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="01d9d-137">L’expression est copiée, mais peut ne plus pouvoir se résoudre.</span><span class="sxs-lookup"><span data-stu-id="01d9d-137">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="01d9d-138">Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="01d9d-138">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="01d9d-139">La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.</span><span class="sxs-lookup"><span data-stu-id="01d9d-139">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="01d9d-140">Copie d’une propriété de dépendance animée</span><span class="sxs-lookup"><span data-stu-id="01d9d-140">Copying an animated dependency property</span></span>|<span data-ttu-id="01d9d-141">La valeur de propriété base (non animée) est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-141">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="01d9d-142">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-142">Animations are not copied.</span></span>|<span data-ttu-id="01d9d-143">Valeur animée actuelle de la propriété est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-143">The property's current animated value is copied.</span></span> <span data-ttu-id="01d9d-144">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-144">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="01d9d-145">Notez que les propriétés non définies ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-145">Note that unset properties are not copied.</span></span> <span data-ttu-id="01d9d-146">Si une propriété non définie a une valeur par défaut est figé <xref:System.Windows.Freezable>, que la valeur de propriété reste figée dans le clone modifiable.</span><span class="sxs-lookup"><span data-stu-id="01d9d-146">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="01d9d-147">Déplacement de Freezable entre les Threads</span><span class="sxs-lookup"><span data-stu-id="01d9d-147">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="01d9d-148">Cette méthode peut être utile pour déplacer un <xref:System.Windows.Freezable> entre les threads.</span><span class="sxs-lookup"><span data-stu-id="01d9d-148">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="01d9d-149">Tout d’abord, vérifiez le <xref:System.Windows.Freezable> non modifiable en appelant sa <xref:System.Windows.Freezable.Freeze%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-149">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="01d9d-150">Maintenant un autre thread peut accéder à la <xref:System.Windows.Freezable> et faire un local <xref:System.Windows.Freezable.Clone%2A> auxquels il peut accéder.</span><span class="sxs-lookup"><span data-stu-id="01d9d-150">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-151">
            <para>Cette méthode utilise <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> pour générer le clone. Pour modifier le comportement de cette méthode dans une classe dérivée, substituez la <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> (méthode).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-151">
              <para>This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone. To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="01d9d-152">The object to clone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-152">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-153">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-153">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-154">Cette méthode est appelée par le <xref:System.Windows.Freezable.Clone%2A> (méthode) et ne doit pas être appelée directement depuis votre code, excepté lorsque vous appelez l’implémentation de base lors de la substitution de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="01d9d-154">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="01d9d-155">Pour créer une copie modifiable de l’objet actuel, appelez <xref:System.Windows.Freezable.Clone%2A> au lieu d’appeler cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="01d9d-155">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-156">
            <para>Si vous dérivez de <see cref="T:System.Windows.Freezable" />, vous devrez peut-être remplacer cette méthode. Pour remplacer des raisons sont les suivantes :-votre classe dérivée comporte des données qui ne sont pas exposées via les propriétés de dépendance.  -Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être exécutée en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui ne requièrent pas à effectuer une initialisation supplémentaire n’avez pas besoin de substituer <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent uniquement effectuer un travail qui n’est pas effectué par l’implémentation par défaut. L’implémentation par défaut effectue des copies complètes de toutes les propriétés définies localement, accessible en écriture, y compris des expressions internes.  Si l’objet a des propriétés de dépendance liées aux données, les expressions sont copiées mais peuvent ne plus pouvoir se résoudre. Pour plus d’informations sur les objets liés aux données de clonage, consultez [Freezable objets Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si l’objet a des propriétés de dépendance animées, la valeur de base (non animée) de ces propriétés est copiée. Animations ne sont pas copiées.  Notez que les propriétés non définies ne sont pas copiées, ni sont des propriétés en lecture seule. Si cette propriété a la valeur par défaut qui est figé <see cref="T:System.Windows.Freezable" />, que la valeur de propriété reste figée dans le clone modifiable.  La liste suivante résume le comportement attendu pour cette méthode :-la copie générée contienne des copies de tous les <see cref="T:System.Windows.Freezable" /> sous-objets.  -Propriétés non définies en lecture seule et ne sont pas copiées.  -Les expressions sont copiées.  -Aucun de ces sous-objets sont figées lors de la création.  -La copie elle-même n’est pas figée.  -Les animations ne sont pas copiées.  -Seules les valeurs de base propriété sont copiés, pas en cours de valeurs animées.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-156">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties, including internal expressions.  If the object has data-bound dependency properties, the expressions are copied but might no longer resolve. For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) value of those properties is copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method:  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   Expressions are copied.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.  -   Animations are not copied.  -   Only property base values are copied, not current animated values.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-157">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-157">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-158">A modifiable clone of the current object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-158">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="01d9d-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-160">Le <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes génèrent des clones modifiables de figé <xref:System.Windows.Freezable> objets (les méthodes également clonent <xref:System.Windows.Freezable> les objets qui ne sont pas gelés).</span><span class="sxs-lookup"><span data-stu-id="01d9d-160">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="01d9d-161">Le clone est en fait une copie complète de l’objet actuel.</span><span class="sxs-lookup"><span data-stu-id="01d9d-161">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="01d9d-162">Le tableau suivant résume les différences entre les <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="01d9d-162">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="01d9d-163">Action</span><span class="sxs-lookup"><span data-stu-id="01d9d-163">Action</span></span>|<span data-ttu-id="01d9d-164">Comportement de la méthode clone</span><span class="sxs-lookup"><span data-stu-id="01d9d-164">Clone method behavior</span></span>|<span data-ttu-id="01d9d-165">Méthode CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="01d9d-165">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="01d9d-166">Copie d’une propriété de dépendance qui possède une expression</span><span class="sxs-lookup"><span data-stu-id="01d9d-166">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="01d9d-167">L’expression est copiée, mais peut ne plus pouvoir se résoudre.</span><span class="sxs-lookup"><span data-stu-id="01d9d-167">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="01d9d-168">Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="01d9d-168">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="01d9d-169">La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.</span><span class="sxs-lookup"><span data-stu-id="01d9d-169">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="01d9d-170">Copie d’une propriété de dépendance animée</span><span class="sxs-lookup"><span data-stu-id="01d9d-170">Copying an animated dependency property</span></span>|<span data-ttu-id="01d9d-171">La valeur de propriété base (non animée) est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-171">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="01d9d-172">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-172">Animations are not copied.</span></span>|<span data-ttu-id="01d9d-173">Valeur animée actuelle de la propriété est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-173">The property's current animated value is copied.</span></span> <span data-ttu-id="01d9d-174">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-174">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="01d9d-175">Notez que les propriétés non définies ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-175">Note that unset properties are not copied.</span></span> <span data-ttu-id="01d9d-176">Si une propriété non définie a une valeur par défaut est figé <xref:System.Windows.Freezable>, que la valeur de propriété reste figée dans le clone modifiable.</span><span class="sxs-lookup"><span data-stu-id="01d9d-176">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="01d9d-177">Déplacement de Freezable entre les Threads</span><span class="sxs-lookup"><span data-stu-id="01d9d-177">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="01d9d-178">Cette méthode peut être utile pour déplacer un <xref:System.Windows.Freezable> entre les threads.</span><span class="sxs-lookup"><span data-stu-id="01d9d-178">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="01d9d-179">Tout d’abord, vérifiez le <xref:System.Windows.Freezable> non modifiable à l’aide de son <xref:System.Windows.Freezable.Freeze%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-179">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="01d9d-180">Maintenant un autre thread peut accéder à la <xref:System.Windows.Freezable> et générer un clone local qu’il peut accéder.</span><span class="sxs-lookup"><span data-stu-id="01d9d-180">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-181">
            <para>Cette méthode utilise le <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> pour générer le clone ; (méthode) <see cref="T:System.Windows.Freezable" /> implémenteurs de substituent <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> doit s’assurer que la copie n’est pas figée lors de la création.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-181">
              <para>This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="01d9d-182">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-182">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-183">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-183">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-184">Cette méthode est appelée par le <xref:System.Windows.Freezable.CloneCurrentValue%2A> (méthode) et ne doit pas être appelée directement depuis votre code, excepté lorsque vous appelez l’implémentation de base lors de la substitution de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="01d9d-184">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="01d9d-185">Pour créer une copie modifiable de l’objet actuel, appelez <xref:System.Windows.Freezable.CloneCurrentValue%2A> au lieu d’appeler cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="01d9d-185">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-186">
            <para>Si vous dérivez de <see cref="T:System.Windows.Freezable" />, vous devrez peut-être remplacer cette méthode. Pour remplacer des raisons sont les suivantes :-votre classe dérivée comporte des données qui ne sont pas exposées via les propriétés de dépendance.  -Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être exécutée en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui ne requièrent pas à effectuer une initialisation supplémentaire n’avez pas besoin de substituer <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent uniquement effectuer un travail qui n’est pas effectué par l’implémentation par défaut. L’implémentation par défaut effectue des copies complètes de toutes les propriétés définies localement, accessible en écriture. Si l’objet contient les propriétés de dépendance avec des expressions (par exemple, une liaison de données), la valeur actuelle de l’expression est copiée mais pas l’expression elle-même.  Si l’objet a des propriétés de dépendance animées, la valeur animée actuelle de ces propriétés est copiée, mais les animations ne sont pas.  Notez que les propriétés non définies ne sont pas copiées, ni sont des propriétés en lecture seule. Si cette propriété a la valeur par défaut qui est figé <see cref="T:System.Windows.Freezable" />, que la valeur de propriété reste figée dans le clone modifiable.  La liste suivante récapitule le comportement attendu pour cette méthode.  -La copie générée contienne des copies de tous les <see cref="T:System.Windows.Freezable" /> sous-objets.  -Propriétés non définies en lecture seule et ne sont pas copiées.  -Si une propriété est animée, sa valeur actuelle est copiée, mais l’animation proprement dite n’est pas.  -Aucun de ces sous-objets sont figées lors de la création.  -La copie elle-même n’est pas figée.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-186">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties. If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.  If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method.  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   If a property is animated, its current value is copied, but the animation itself is not.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-187">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-187">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-188">The new instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-188">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-189">Il s’agit d’une méthode protégée, et les implémentations spécifiques à l’objet actuel pour le comportement sont dépendantes de l’implémentation de substitution de la <xref:System.Windows.Freezable.CreateInstanceCore%2A> méthode, cette méthode appelle en interne.</span><span class="sxs-lookup"><span data-stu-id="01d9d-189">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-190">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-190">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-191">The new instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-191">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-192">N’appelez pas cette méthode directement (sauf lorsque vous appelez base dans une implémentation).</span><span class="sxs-lookup"><span data-stu-id="01d9d-192">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="01d9d-193">Cette méthode est appelée en interne par le <xref:System.Windows.Freezable.CreateInstance%2A> méthode chaque fois qu’une nouvelle instance de la <xref:System.Windows.Freezable> est créé.</span><span class="sxs-lookup"><span data-stu-id="01d9d-193">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01d9d-194">L’exemple suivant montre une implémentation classique des <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span><span class="sxs-lookup"><span data-stu-id="01d9d-194">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-195">
            <para>Chaque <see cref="T:System.Windows.Freezable" /> classe dérivée doit implémenter cette méthode. Une implémentation classique consiste à simplement appeler le constructeur par défaut et retournent le résultat.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-195">
              <para>Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method. A typical implementation is to simply call the default constructor and return the result.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-196">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-196">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-197">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-197">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-198">Pour éviter la possibilité d’une <xref:System.InvalidOperationException> lorsque vous appelez cette méthode, vérifiez la <xref:System.Windows.Freezable.CanFreeze%2A> propriété pour déterminer si le <xref:System.Windows.Freezable> peut être rendue non modifiable avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="01d9d-198">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="01d9d-199">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-199">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-200">
            <para>Cette méthode utilise le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> méthode pour rendre le <see cref="T:System.Windows.Freezable" /> non modifiable. Pour modifier le comportement de gel, substituez le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (méthode).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-200">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="01d9d-201">The object to check or make unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-201">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="01d9d-202">If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-202">If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="01d9d-203">If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-203">If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="01d9d-204">
            <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-204">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-205">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-205">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="01d9d-206">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-206">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-207">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-207">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="01d9d-208">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-208">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-209">N’appelez pas cette méthode, sauf si vous dérivez de <xref:System.Windows.Freezable> et en remplaçant le <xref:System.Windows.Freezable.FreezeCore%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-209">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="01d9d-210">Cette méthode peut être utilisée dans les <xref:System.Windows.Freezable.FreezeCore%2A> méthode pour figer les données membres de classe qui sont elles-mêmes <xref:System.Windows.Freezable> objets.</span><span class="sxs-lookup"><span data-stu-id="01d9d-210">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="01d9d-211">Il est très bien pour appeler cette méthode à nouveau sur un <xref:System.Windows.Freezable> objet qui est déjà figé (non modifiable).</span><span class="sxs-lookup"><span data-stu-id="01d9d-211">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="01d9d-212">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-212">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-213">
            <para>Cette méthode utilise le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> méthode pour rendre le <see cref="T:System.Windows.Freezable" /> non modifiable. Pour modifier le comportement de gel, substituez le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (méthode).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-213">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="01d9d-214">
            <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-214">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-215">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-215">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-216">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-216">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="01d9d-217">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-217">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-218">N’appelez pas cette méthode directement (sauf lorsque vous appelez base dans une implémentation).</span><span class="sxs-lookup"><span data-stu-id="01d9d-218">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="01d9d-219">Cette méthode est appelée en interne par le <xref:System.Windows.Freezable.CanFreeze%2A> propriété (avec `isChecking` égal à `true`) et le <xref:System.Windows.Freezable.Freeze%2A> (méthode) (avec `isChecking` égale à `false`).</span><span class="sxs-lookup"><span data-stu-id="01d9d-219">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-220">
            <para>
              <see cref="T:System.Windows.Freezable" /> les implémenteurs doivent substituer cette méthode lorsque la classe contient des données qui ne sont pas stockées à l’aide des propriétés de dépendance.  Une implémentation classique serait appeler la base, puis appelez la méthode statique <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> méthode sur tous les <see cref="T:System.Windows.Freezable" /> propriétés qui contient la classe, en retournant typées <see langword="true" /> uniquement si toutes les propriétés figées (ou auraient pu être figées, dans le cas de spécification <see langword="true" /> pour <paramref name="isChecking" />).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-220">
              <para>
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.  A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-221">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-221">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="01d9d-222">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-222">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-223">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-223">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="01d9d-224">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-224">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-225">Vous devez vérifier le <xref:System.Windows.Freezable.CanFreeze%2A> propriété avant d’appeler cette méthode pour vérifier que le <xref:System.Windows.Freezable> peut être figée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-225">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="01d9d-226">À l’aide de cette méthode est similaire à la création d’une copie à l’aide de la <xref:System.Windows.Freezable.Clone%2A> et figer ensuite avec le <xref:System.Windows.Freezable.Freeze%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-226">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="01d9d-227">Le <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes peuvent améliorer les performances de copie, car ils ne clonent pas <xref:System.Windows.Freezable> sous-objets qui sont déjà figé ; elles les copient seulement par référence.</span><span class="sxs-lookup"><span data-stu-id="01d9d-227">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="01d9d-228">Le tableau suivant résume les différences entre les <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="01d9d-228">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="01d9d-229">Action</span><span class="sxs-lookup"><span data-stu-id="01d9d-229">Action</span></span>|<span data-ttu-id="01d9d-230">Méthode GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="01d9d-230">GetAsFrozen method behavior</span></span>|<span data-ttu-id="01d9d-231">Méthode GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="01d9d-231">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="01d9d-232">Copie d’une propriété de dépendance qui possède une expression</span><span class="sxs-lookup"><span data-stu-id="01d9d-232">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="01d9d-233">La méthode lève un <xref:System.InvalidOperationException> , car il ne peut pas <xref:System.Windows.Freezable.Freeze%2A> la propriété.</span><span class="sxs-lookup"><span data-stu-id="01d9d-233">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="01d9d-234">La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.</span><span class="sxs-lookup"><span data-stu-id="01d9d-234">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="01d9d-235">Copie d’une propriété de dépendance animée</span><span class="sxs-lookup"><span data-stu-id="01d9d-235">Copying an animated dependency property</span></span>|<span data-ttu-id="01d9d-236">La valeur de propriété base (non animée) est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-236">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="01d9d-237">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-237">Animations are not copied.</span></span>|<span data-ttu-id="01d9d-238">Valeur animée actuelle de la propriété est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-238">The property's current animated value is copied.</span></span> <span data-ttu-id="01d9d-239">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-239">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="01d9d-240">Notez que les propriétés non définies ne sont pas copiées, ni sont des propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="01d9d-240">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="01d9d-241">Pour créer une copie de la <xref:System.Windows.Freezable> qui est non figé, utilisez la <xref:System.Windows.Freezable.Clone%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-241">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="01d9d-242">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-242">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-243">
            <para>Cette méthode utilise le serveur virtuel <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> méthode pour générer le clone.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-243">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="01d9d-244">The instance to copy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-244">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-245">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-245">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-246">Cette méthode est appelée par le <xref:System.Windows.Freezable.GetAsFrozen%2A> (méthode) et ne doit pas être appelée directement depuis votre code, excepté lorsque vous appelez l’implémentation de base lors de la substitution de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="01d9d-246">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="01d9d-247">Pour créer une copie figée de l’objet actuel, appelez <xref:System.Windows.Freezable.GetAsFrozen%2A> au lieu d’appeler cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="01d9d-247">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-248">
            <para>Si vous dérivez de <see cref="T:System.Windows.Freezable" /> vous devrez peut-être remplacer cette méthode. Pour remplacer des raisons sont les suivantes :-votre classe dérivée comporte des données qui ne sont pas exposées via les propriétés de dépendance.  -Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être exécutée en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui ne requièrent pas à effectuer une initialisation supplémentaire n’avez pas besoin de substituer <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent uniquement effectuer un travail qui n’est pas effectué par l’implémentation par défaut. L’implémentation par défaut effectue des copies complètes de toutes les objets Freezable non figées et une copie superficielle de tous les autres accessible en écriture, localement définir les propriétés qu’il contient. Si l’objet a des propriétés de dépendance liées aux données, les expressions sont copiées mais risquent de ne plus se résoudre ; Pour plus d’informations sur les objets liés aux données de clonage, consultez [Freezable objets Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si l’objet a des propriétés de dépendance animées, les valeurs de base (non animée) de ces propriétés sont copiées. Animations ne sont pas copiées.  Notez que les propriétés non définies ne sont pas copiées, ni sont des propriétés en lecture seule.  Si vous substituez cette méthode, vous devez appeler l’implémentation de base.  Vous n’avez pas besoin <see cref="M:System.Windows.Freezable.Freeze" /> valeurs comme ils sont copiés.  Le résultat est figé par <see cref="M:System.Windows.Freezable.GetAsFrozen" /> avant d’être retourné.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-248">
              <para>If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) values of those properties are copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-249">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-249">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="01d9d-250">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-250">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="01d9d-251">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-251">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="01d9d-252">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-252">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-253">À l’aide de cette méthode est similaire à la création d’une copie à l’aide de la <xref:System.Windows.Freezable.CloneCurrentValue%2A> et figer ensuite avec le <xref:System.Windows.Freezable.Freeze%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-253">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="01d9d-254">Le <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes peuvent améliorer les performances de copie, car ils ne clonent pas <xref:System.Windows.Freezable> sous-objets qui sont déjà figé ; elles les copient seulement par référence.</span><span class="sxs-lookup"><span data-stu-id="01d9d-254">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="01d9d-255">Le tableau suivant résume les différences entre les <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="01d9d-255">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="01d9d-256">Action</span><span class="sxs-lookup"><span data-stu-id="01d9d-256">Action</span></span>|<span data-ttu-id="01d9d-257">Méthode GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="01d9d-257">GetAsFrozen method behavior</span></span>|<span data-ttu-id="01d9d-258">Méthode GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="01d9d-258">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="01d9d-259">Copie d’une propriété de dépendance qui possède une expression</span><span class="sxs-lookup"><span data-stu-id="01d9d-259">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="01d9d-260">La méthode lève un <xref:System.InvalidOperationException> , car il ne peut pas <xref:System.Windows.Freezable.Freeze%2A> la propriété.</span><span class="sxs-lookup"><span data-stu-id="01d9d-260">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="01d9d-261">La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.</span><span class="sxs-lookup"><span data-stu-id="01d9d-261">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="01d9d-262">Copie d’une propriété de dépendance animée</span><span class="sxs-lookup"><span data-stu-id="01d9d-262">Copying an animated dependency property</span></span>|<span data-ttu-id="01d9d-263">La valeur de propriété base (non animée) est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-263">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="01d9d-264">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-264">Animations are not copied.</span></span>|<span data-ttu-id="01d9d-265">Valeur animée actuelle de la propriété est copiée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-265">The property's current animated value is copied.</span></span> <span data-ttu-id="01d9d-266">Animations ne sont pas copiées.</span><span class="sxs-lookup"><span data-stu-id="01d9d-266">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="01d9d-267">Notez que les propriétés non définies ne sont pas copiées, ni sont des propriétés en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="01d9d-267">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="01d9d-268">Pour créer une copie de la <xref:System.Windows.Freezable> qui est non figé, utilisez la <xref:System.Windows.Freezable.CloneCurrentValue%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-268">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-269">
            <para>Cette méthode utilise le serveur virtuel <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> méthode pour générer le clone.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-269">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="01d9d-270">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-270">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-271">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-271">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="01d9d-272">If the object has animated dependency properties, their current animated values are copied.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-272">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-273">Cette méthode est appelée par le <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> (méthode) et ne doit pas être appelée directement depuis votre code, excepté lorsque vous appelez l’implémentation de base lors de la substitution de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="01d9d-273">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="01d9d-274">Pour créer une copie figée de l’objet actuel, appelez <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> au lieu d’appeler cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="01d9d-274">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-275">
            <para>Si vous dérivez de <see cref="T:System.Windows.Freezable" />, vous devrez peut-être remplacer cette méthode. Pour remplacer des raisons sont les suivantes :-votre classe dérivée comporte des données qui ne sont pas exposées via les propriétés de dépendance.  -Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être exécutée en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui ne requièrent pas à effectuer une initialisation supplémentaire n’avez pas besoin de substituer <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent uniquement effectuer un travail qui n’est pas effectué par l’implémentation par défaut. L’implémentation par défaut crée un nouveau <see cref="T:System.Windows.Freezable" /> à l’aide de la <see cref="M:System.Windows.Freezable.CreateInstance" /> (méthode) et en fait des copies complètes des objets Freezable non figées et une copie superficielle de tous les autres accessible en écriture, il contient des propriétés définies localement. Si l’objet a des propriétés de dépendance liées aux données, les liaisons de données sont copiés, mais peuvent ne plus être résolues ; Pour plus d’informations sur les objets liés aux données de clonage, consultez [Freezable objets Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si l’objet a des propriétés de dépendance animées, la valeur animée actuelle de ces propriétés est copiée, mais les animations ne sont pas.  Propriétés de dépendance en lecture seule dans un <see cref="T:System.Windows.Freezable" /> ne sont pas copiées par cette implémentation par défaut.  Si vous substituez cette méthode, vous devez appeler l’implémentation de base.  Vous n’avez pas besoin <see cref="M:System.Windows.Freezable.Freeze" /> valeurs comme ils sont copiés.  Le résultat est figé par <see cref="M:System.Windows.Freezable.GetAsFrozen" /> avant d’être retourné.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-275">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-276">Gets a value that indicates whether the object is currently modifiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-276">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="01d9d-277">
            <see langword="true" /> Si l’objet est figé et ne peut pas être modifié ; <see langword="false" /> si l’objet peut être modifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-277">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-278">Tente de modifier un objet lorsque son <xref:System.Windows.Freezable.IsFrozen%2A> propriété `true` lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="01d9d-278">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="01d9d-279">Cette propriété est en lecture seule à partir du point de vue du modèle objet.</span><span class="sxs-lookup"><span data-stu-id="01d9d-279">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="01d9d-280">De la documentation sur <xref:System.Windows.Freezable> comportements peuvent mentionner « définit <xref:System.Windows.Freezable.IsFrozen%2A> à `true`» ou langage similaire lors de la discussion sur le comportement d’autres méthodes de <xref:System.Windows.Freezable>, mais ce comportement se produit en interne dans les instances de classes Lorsque les méthodes de l’instance manipulent les variables privées qui existent au sein de la classe abstraite.</span><span class="sxs-lookup"><span data-stu-id="01d9d-280">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="01d9d-281">Pour définir la valeur de cette propriété, vous devez appeler <xref:System.Windows.Freezable.Freeze%2A>.</span><span class="sxs-lookup"><span data-stu-id="01d9d-281">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="01d9d-282">Il s’agit en réalité une opération unique pour modifier la <xref:System.Windows.Freezable.IsFrozen%2A> propriété à partir de la valeur par défaut initiale `false` l’état du `true` état.</span><span class="sxs-lookup"><span data-stu-id="01d9d-282">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="01d9d-283">Il n’existe aucun moyen disponibles pour définir la valeur à `false`.</span><span class="sxs-lookup"><span data-stu-id="01d9d-283">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="01d9d-284">Au lieu de cela, vous pouvez modifier toute copie complète effectuée à partir de la version d’origine (voir la <xref:System.Windows.Freezable.Clone%2A> méthode).</span><span class="sxs-lookup"><span data-stu-id="01d9d-284">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="01d9d-285">Il s’agit par conception et comment une classe dérivée doit se comporter quand il est appliqué aux cas où le <xref:System.Windows.Freezable> modèle est utile.</span><span class="sxs-lookup"><span data-stu-id="01d9d-285">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-286">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-286">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-287">Cette méthode est appelée chaque fois que le <xref:System.Windows.Freezable.Changed> événement se produit.</span><span class="sxs-lookup"><span data-stu-id="01d9d-287">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-288">
            <para>Lorsque vous implémentez une classe qui dérive de <see cref="T:System.Windows.Freezable" />, vous pouvez substituer cette méthode pour effectuer des tâches.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-288">
              <para>When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-289">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-289">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="01d9d-290">The previous value of the data member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-290">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="01d9d-291">The current value of the data member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-291">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-292">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-292">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-293">Cette méthode doit être appelée par <xref:System.Windows.Freezable> l’attention des héritiers chaque fois qu’un <xref:System.Windows.DependencyObject> membre de données qui n’est pas stockée en tant qu’un <xref:System.Windows.DependencyProperty> est définie.</span><span class="sxs-lookup"><span data-stu-id="01d9d-293">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="01d9d-294">Cette méthode ne doit pas être appelé pour <xref:System.Windows.DependencyObject> les membres de données qui sont stockées en utilisant un <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="01d9d-294">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="01d9d-295">The previous value of the data member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-295">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="01d9d-296">The current value of the data member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-296">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="01d9d-297">The property that changed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-297">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-298">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-298">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="01d9d-299">Event data that contains information about which property changed, and its old and new values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-299">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="01d9d-300">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-300">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-301">Les données d’événement contient des informations concernant uniquement le <xref:System.Windows.Freezable> lui-même.</span><span class="sxs-lookup"><span data-stu-id="01d9d-301">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="01d9d-302">Toutes les informations de sous-propriété doivent être obtenues via le <xref:System.Windows.Freezable.Changed> gestionnaires.</span><span class="sxs-lookup"><span data-stu-id="01d9d-302">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-303">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-303">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="01d9d-304">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-304">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-305">
            <para>Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doit appeler le <see cref="M:System.Windows.Freezable.ReadPreamble" /> méthode avant de tenter d’accéder à des membres qui ne sont pas des propriétés de dépendance. Le <see cref="M:System.Windows.Freezable.WritePreamble" /> méthode doit être appelée avant que tous les membres de ce type sont écrites dans.  Cette méthode ne fait rien que pour appeler <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-305">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties. The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.  This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-306">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-306">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="01d9d-307">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-307">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-308">
            <para>Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doivent appeler cette méthode à la fin de toute API qui modifie un membre de classe qui n’est pas stocké comme un <see cref="T:System.Windows.DependencyProperty" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-308">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="01d9d-309">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-309">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="01d9d-310">
            <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-310">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01d9d-311">Cette méthode appelle <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> pour vérifier le contexte de thread est accessible et qu’il lève une exception si le <xref:System.Windows.Freezable> instance est déjà figée.</span><span class="sxs-lookup"><span data-stu-id="01d9d-311">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="01d9d-312">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-312">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="01d9d-313">
            <para>Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doit appeler <see cref="M:System.Windows.Freezable.WritePreamble" /> avant de tenter d’écrire tous les membres qui ne sont pas des propriétés de dépendance. Si vous appelez <see cref="M:System.Windows.Freezable.WritePreamble" /> dans une [ ! Include[TLA#tla_api](~/Includes/tlasharptla-API-MD.MD)], vous pouvez omettre un appel à <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="01d9d-313">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties. If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>