<Type Name="DataTemplate" FullName="System.Windows.DataTemplate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="36b880efe30a49a2aebb2ba25c051c93ae0e7642" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53473655" /></Metadata><TypeSignature Language="C#" Value="public class DataTemplate : System.Windows.FrameworkTemplate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataTemplate extends System.Windows.FrameworkTemplate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DataTemplate" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTemplate&#xA;Inherits FrameworkTemplate" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTemplate : System::Windows::FrameworkTemplate" />
  <TypeSignature Language="F#" Value="type DataTemplate = class&#xA;    inherit FrameworkTemplate" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkTemplate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("DataTemplateKey")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Décrit la structure visuelle d'un objet de données.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez un <xref:System.Windows.DataTemplate> pour spécifier la visualisation de vos objets de données. <xref:System.Windows.DataTemplate> les objets sont particulièrement utiles lorsque vous liez un <xref:System.Windows.Controls.ItemsControl> comme un <xref:System.Windows.Controls.ListBox> à une collection entière. Sans instructions spécifiques, un <xref:System.Windows.Controls.ListBox> affiche la représentation sous forme de chaîne des objets dans une collection. Dans ce cas, vous pouvez utiliser un <xref:System.Windows.DataTemplate> pour définir l’apparence de vos objets de données. Le contenu de votre <xref:System.Windows.DataTemplate> devient la structure visuelle de vos objets de données.  
  
 Pour une présentation détaillée, consultez [vue d’ensemble de la création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Windows.DataTemplate> inline. Le <xref:System.Windows.DataTemplate> Spécifie que chaque élément de données s’affiche sous forme de trois <xref:System.Windows.Controls.TextBlock> éléments au sein d’un <xref:System.Windows.Controls.StackPanel>. Dans cet exemple, l’objet de données est une classe appelée `Task`. Notez que chaque <xref:System.Windows.Controls.TextBlock> élément dans ce modèle est lié à une propriété de la `Task` classe.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 Il est plus courant pour définir un <xref:System.Windows.DataTemplate> dans la section de ressources afin d’en faire un objet réutilisable, comme dans l’exemple suivant :  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 Vous pouvez à présent utiliser `myTaskTemplate` comme ressource, comme dans l’exemple suivant :  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Vous trouverez l’exemple complet sur la page [Présentation d’un exemple de création de modèles de données](https://github.com/Microsoft/WPF-Samples/tree/master/Data%20Binding/DataTemplatingIntro).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.Binding" />
    <altmember cref="T:System.Windows.Controls.DataTemplateSelector" />
    <altmember cref="T:System.Windows.HierarchicalDataTemplate" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=163703">Démonstration de liaison de données</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DataTemplate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DataTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate (object dataType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataType As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate(System::Object ^ dataType);" />
      <MemberSignature Language="F#" Value="new System.Windows.DataTemplate : obj -&gt; System.Windows.DataTemplate" Usage="new System.Windows.DataTemplate dataType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataType" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataType">Si le modèle est conçu pour les données de l'objet, il correspond au nom du type de l'objet de donnée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DataTemplate" /> contenant la propriété <see cref="P:System.Windows.DataTemplate.DataType" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour faire référence au nom de Type de la classe, utilisez le [x : Type Markup Extension](~/docs/framework/xaml-services/x-type-markup-extension.md). Si le modèle est destiné à [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] données, il s’agit de la chaîne qui représente le nom de balise des données.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataTemplateKey">
      <MemberSignature Language="C#" Value="public object DataTemplateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataTemplateKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataTemplateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataTemplateKey As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataTemplateKey { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataTemplateKey : obj" Usage="System.Windows.DataTemplate.DataTemplateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la clé par défaut de <see cref="T:System.Windows.DataTemplate" />.</summary>
        <value>Clé par défaut de <see cref="T:System.Windows.DataTemplate" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous ne définissez pas la [Directive x : Key](~/docs/framework/xaml-services/x-key-directive.md) sur un <xref:System.Windows.DataTemplate> qui se trouve dans un <xref:System.Windows.ResourceDictionary>, le <xref:System.Windows.DataTemplate.DataTemplateKey%2A> est utilisé comme clé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataType">
      <MemberSignature Language="C#" Value="public object DataType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataType" />
      <MemberSignature Language="VB.NET" Value="Public Property DataType As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataType { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataType : obj with get, set" Usage="System.Windows.DataTemplate.DataType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type auquel ce <see cref="T:System.Windows.DataTemplate" /> est destiné.</summary>
        <value>La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est très similaire à la <xref:System.Windows.Style.TargetType%2A> propriété de la <xref:System.Windows.Style> classe. Lorsque vous définissez cette propriété pour le type de données sans spécifier un `x:Key`, le <xref:System.Windows.DataTemplate> est appliqué automatiquement aux objets de données de ce type. Notez que lorsque vous le faire la `x:Key` est définie implicitement. Par conséquent, si vous affectez cette <xref:System.Windows.DataTemplate> un `x:Key` valeur, vous substituez l’implicite `x:Key` et <xref:System.Windows.DataTemplate> ne s’applique pas automatiquement.  
  
 Notez également que si vous liez un <xref:System.Windows.Controls.ContentControl> à une collection de `Task` objets, le <xref:System.Windows.Controls.ContentControl> n’utilise pas le <xref:System.Windows.DataTemplate> automatiquement. Il s’agit, car la liaison sur un <xref:System.Windows.Controls.ContentControl> nécessite davantage d’informations pour déterminer si vous souhaitez lier à une collection entière ou des objets individuels. Si votre <xref:System.Windows.Controls.ContentControl> est suivi de la sélection d’un <xref:System.Windows.Controls.ItemsControl> type, vous pouvez définir le <xref:System.Windows.Data.Binding.Path%2A> propriété de la <xref:System.Windows.Controls.ContentControl> liaison à «`/`» pour indiquer que vous êtes intéressé par l’élément actuel. Pour obtenir un exemple, consultez [Comment : Lier à une Collection et les informations d’affichage en fonction de sélection](~/docs/framework/wpf/data/how-to-bind-to-a-collection-and-display-information-based-on-selection.md). Sinon, vous devez spécifier le <xref:System.Windows.DataTemplate> explicitement en définissant le <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> propriété.  
  
 Le <xref:System.Windows.DataTemplate.DataType%2A> propriété est particulièrement utile lorsque vous avez un <xref:System.Windows.Data.CompositeCollection> de différents types d’objets de données.  
  
 Si cette propriété cible un élément XML qui n’est pas dans l’espace de noms par défaut, vous devez faire précéder le nom d’élément avec l’espace de noms ou d’un indicateur d’espace de noms. Pour le XML exposé via LINQ pour XML, l’espace de noms apparaît entre accolades, précédés d’une séquence d’échappement d’accolade :  
  
```xaml  
<DataTemplate DataType="{}{http://myNamespace}Details">  
```  
  
 Pour le XML exposé via XPath, le nom d’élément est précédé d’un indicateur d’espace de noms établi par une instance de <xref:System.Windows.Data.XmlNamespaceMapping>:  
  
```xaml  
<DataTemplate DataType="mn:Details">  
```  
  
<a name="xamlAttributeUsage_DataType"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object DataType="typeName"/>  
```  
  
<a name="xamlValues_DataType"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *typeName*  
 Si le modèle est conçu pour les données d’objet, cette propriété contient le nom de type de l’objet de données (en tant que chaîne). Pour faire référence au nom de type de la classe, utilisez le [x : Type Markup Extension](~/docs/framework/xaml-services/x-type-markup-extension.md). Si le modèle est destiné à [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] données, cette propriété contient le nom d’élément XML. Consultez les notes de la documentation pour plus d’informations sur la spécification d’un espace de noms non définis par défaut pour l’élément XML.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Introduction aux modèles de données exemple</related>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.DataTemplate.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DependsOn("VisualTree")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DependsOn("Template")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de déclencheurs qui appliquent des valeurs de propriétés ou effectuent des actions selon une ou plusieurs conditions.</summary>
        <value>Collection d'objets déclencheurs. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous créez des déclencheurs dans un modèle de données, les accesseurs Set des déclencheurs doivent définir des propriétés qui se trouvent dans l’étendue du modèle de données. Sinon, il peut être plus approprié de créer des déclencheurs à l’aide d’un style qui cible le type qui contient les données. Par exemple, si vous liez un <xref:System.Windows.Controls.ListBox> contrôle, les conteneurs sont <xref:System.Windows.Controls.ListBoxItem> objets. Si vous utilisez des déclencheurs pour définir les propriétés qui ne sont pas dans l’étendue de la <xref:System.Windows.DataTemplate>, il peut être plus approprié de créer un <xref:System.Windows.Controls.ListBoxItem> de style et de créer des déclencheurs dans ce style. Pour plus d’informations, consultez ce qui appartient à un DataTemplate ? dans le [vue d’ensemble de création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
> [!NOTE]
>  Cette propriété peut uniquement être définie [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] via la syntaxe de collection indiquée, ou en accédant à l’objet de collection et en utilisant ses différentes méthodes telles que Add. La propriété pour accéder à l’objet de collection lui-même est en lecture seule, la collection elle-même est en lecture-écriture.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Triggers>  
    OneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *oneOrMoreTriggers*  
 Zéro ou plusieurs <xref:System.Windows.TriggerBase> objets.  
  
   
  
## Examples  
 Ce qui suit <xref:System.Windows.DataTemplate> illustre l’utilisation de la <xref:System.Windows.DataTemplate.Triggers%2A> propriété.  
  
 [!code-xaml[DataBindingLab#AuctionItemDataTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/DataBindingLabApp.xaml#auctionitemdatatemplate)]  
  
 Pour obtenir un exemple complet, consultez [démonstration de liaison de données](https://go.microsoft.com/fwlink/?LinkID=163703).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.MultiDataTrigger" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Introduction aux modèles de données exemple</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateTemplatedParent">
      <MemberSignature Language="C#" Value="protected override void ValidateTemplatedParent (System.Windows.FrameworkElement templatedParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ValidateTemplatedParent(class System.Windows.FrameworkElement templatedParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ValidateTemplatedParent (templatedParent As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ValidateTemplatedParent(System::Windows::FrameworkElement ^ templatedParent);" />
      <MemberSignature Language="F#" Value="override this.ValidateTemplatedParent : System.Windows.FrameworkElement -&gt; unit" Usage="dataTemplate.ValidateTemplatedParent templatedParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templatedParent" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="templatedParent">Élément auquel est appliqué le modèle.</param>
        <summary>Vérifie le parent basé sur des modèles par rapport à un ensemble de règles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode utilise les règles suivantes :  
  
-   Le `templatedParent` doit être une valeur non null <xref:System.Windows.FrameworkElement>.  
  
-   Le <xref:System.Windows.DataTemplate> doit être appliqué à un <xref:System.Windows.Controls.ContentPresenter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>