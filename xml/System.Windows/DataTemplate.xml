<Type Name="DataTemplate" FullName="System.Windows.DataTemplate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cffbeb8fcc8f02b552d5ae620f2af8c77273c146" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30678653" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTemplate : System.Windows.FrameworkTemplate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataTemplate extends System.Windows.FrameworkTemplate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DataTemplate" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTemplate&#xA;Inherits FrameworkTemplate" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTemplate : System::Windows::FrameworkTemplate" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkTemplate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("DataTemplateKey")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Décrit la structure visuelle d'un objet de données.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez un <xref:System.Windows.DataTemplate> pour spécifier la visualisation de vos objets de données. <xref:System.Windows.DataTemplate> les objets sont particulièrement utiles lorsque vous liez un <xref:System.Windows.Controls.ItemsControl> comme un <xref:System.Windows.Controls.ListBox> à une collection entière. Sans instructions spécifiques, un <xref:System.Windows.Controls.ListBox> affiche la représentation sous forme de chaîne des objets dans une collection. Dans ce cas, vous pouvez utiliser un <xref:System.Windows.DataTemplate> pour définir l’apparence de vos objets de données. Le contenu de votre <xref:System.Windows.DataTemplate> devient la structure visuelle de vos objets de données.  
  
 Pour une discussion détaillée, consultez [vue d’ensemble de la création de modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un <xref:System.Windows.DataTemplate> inline. Le <xref:System.Windows.DataTemplate> Spécifie que chaque élément de données apparaît sous forme de trois <xref:System.Windows.Controls.TextBlock> éléments au sein d’un <xref:System.Windows.Controls.StackPanel>. Dans cet exemple, l’objet de données est une classe appelée `Task`. Notez que chaque <xref:System.Windows.Controls.TextBlock> élément dans ce modèle est lié à une propriété de la `Task` classe.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 Il est plus courant de définir un <xref:System.Windows.DataTemplate> dans la section de ressources afin d’en faire un objet réutilisable, comme dans l’exemple suivant :  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 Vous pouvez à présent utiliser `myTaskTemplate` comme ressource, comme dans l’exemple suivant :  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Vous trouverez l’exemple complet sur la page [Présentation d’un exemple de création de modèles de données](http://go.microsoft.com/fwlink/?LinkID=160009).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.Binding" />
    <altmember cref="T:System.Windows.Controls.DataTemplateSelector" />
    <altmember cref="T:System.Windows.HierarchicalDataTemplate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DataTemplate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DataTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate (object dataType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataType As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate(System::Object ^ dataType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataType" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataType">Si le modèle est conçu pour les données de l'objet, il correspond au nom du type de l'objet de donnée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DataTemplate" /> contenant la propriété <see cref="P:System.Windows.DataTemplate.DataType" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour faire référence au nom de Type de la classe, utilisez le [x : Type, Extension de balisage](~/docs/framework/xaml-services/x-type-markup-extension.md). Si le modèle est conçu pour [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] des données, il s’agit de la chaîne qui représente le nom de balise des données.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataTemplateKey">
      <MemberSignature Language="C#" Value="public object DataTemplateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataTemplateKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataTemplateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataTemplateKey As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataTemplateKey { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la clé par défaut de <see cref="T:System.Windows.DataTemplate" />.</summary>
        <value>Clé par défaut de <see cref="T:System.Windows.DataTemplate" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous ne définissez pas le [x : Key, Directive](~/docs/framework/xaml-services/x-key-directive.md) sur un <xref:System.Windows.DataTemplate> qui se trouve dans un <xref:System.Windows.ResourceDictionary>, le <xref:System.Windows.DataTemplate.DataTemplateKey%2A> est utilisé comme clé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataType">
      <MemberSignature Language="C#" Value="public object DataType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataType" />
      <MemberSignature Language="VB.NET" Value="Public Property DataType As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataType { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type auquel ce <see cref="T:System.Windows.DataTemplate" /> est destiné.</summary>
        <value>La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est très similaire à la <xref:System.Windows.Style.TargetType%2A> propriété de la <xref:System.Windows.Style> classe. Lorsque vous définissez cette propriété pour le type de données sans spécifier un `x:Key`, le <xref:System.Windows.DataTemplate> obtient automatiquement appliqués aux objets de données de ce type. Notez que lorsque vous procédez ainsi que la `x:Key` est définie implicitement. Par conséquent, si vous affectez <xref:System.Windows.DataTemplate> un `x:Key` valeur, vous substituez implicite `x:Key` et <xref:System.Windows.DataTemplate> ne peuvent pas être appliquées automatiquement.  
  
 Notez également que si vous liez un <xref:System.Windows.Controls.ContentControl> à une collection de `Task` objets, la <xref:System.Windows.Controls.ContentControl> n’utilise pas le <xref:System.Windows.DataTemplate> automatiquement. C’est parce que la liaison sur un <xref:System.Windows.Controls.ContentControl> a besoin de plus d’informations pour déterminer si vous souhaitez lier à une collection entière ou des objets individuels. Si votre <xref:System.Windows.Controls.ContentControl> effectue le suivi de la sélection d’un <xref:System.Windows.Controls.ItemsControl> , vous pouvez définir le type le <xref:System.Windows.Data.Binding.Path%2A> propriété de la <xref:System.Windows.Controls.ContentControl> liaison à «`/`» pour indiquer que vous êtes intéressé par l’élément actuel. Pour obtenir un exemple, consultez [Comment : lier à une Collection et afficher les informations en fonction de sélection](~/docs/framework/wpf/data/how-to-bind-to-a-collection-and-display-information-based-on-selection.md). Dans le cas contraire, vous devez spécifier le <xref:System.Windows.DataTemplate> explicitement en définissant le <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> propriété.  
  
 Le <xref:System.Windows.DataTemplate.DataType%2A> propriété est particulièrement utile lorsque vous avez un <xref:System.Windows.Data.CompositeCollection> de différents types d’objets de données.  
  
 Si cette propriété cible un élément XML qui n’est pas dans l’espace de noms par défaut, vous devez faire précéder le nom de l’élément avec l’espace de noms ou d’un indicateur d’espace de noms. Pour le XML exposé via LINQ pour XML, l’espace de noms apparaît entre accolades, précédés d’une séquence d’échappement accolade :  
  
```xaml  
<DataTemplate DataType="{}{http://myNamespace}Details">  
```  
  
 Pour le XML exposé via XPath, le nom de l’élément est précédé d’un indicateur d’espace de noms établi par une instance de <xref:System.Windows.Data.XmlNamespaceMapping>:  
  
```xaml  
<DataTemplate DataType="mn:Details">  
```  
  
<a name="xamlAttributeUsage_DataType"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object DataType="typeName"/>  
```  
  
<a name="xamlValues_DataType"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *typeName*  
 Si le modèle est conçu pour les données d’objet, cette propriété contient le nom de type de l’objet de données (en tant que chaîne). Pour faire référence au nom de type de la classe, utilisez le [x : Type, Extension de balisage](~/docs/framework/xaml-services/x-type-markup-extension.md). Si le modèle est destiné à [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] données, cette propriété contient le nom d’élément XML. Consultez les notes de la documentation pour plus d’informations sur la spécification d’un espace de noms par défaut pour l’élément XML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.DependsOn("VisualTree")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.DependsOn("Template")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de déclencheurs qui appliquent des valeurs de propriétés ou effectuent des actions selon une ou plusieurs conditions.</summary>
        <value>Collection d'objets déclencheurs. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous créez des déclencheurs dans un modèle de données, les accesseurs Set des déclencheurs doivent définir des propriétés qui se trouvent dans l’étendue du modèle de données. Dans le cas contraire, il peut être plus adapté créer des déclencheurs à l’aide d’un style qui cible le type qui contient les données. Par exemple, si vous liez un <xref:System.Windows.Controls.ListBox> (contrôle), les conteneurs sont <xref:System.Windows.Controls.ListBoxItem> objets. Si vous utilisez des déclencheurs pour définir les propriétés qui ne sont pas dans l’étendue de la <xref:System.Windows.DataTemplate>, il peut être plus adapté créer un <xref:System.Windows.Controls.ListBoxItem> de style et de créer des déclencheurs dans ce style. Pour plus d’informations, consultez ce qui appartient à un DataTemplate ? dans le [vue d’ensemble des modèles de données](~/docs/framework/wpf/data/data-templating-overview.md).  
  
> [!NOTE]
>  Cette propriété peut uniquement être définie dans [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] via la syntaxe de collection indiquée, ou en accédant à l’objet de collection et en utilisant ses différentes méthodes telles que Add. La propriété pour accéder à l’objet collection lui-même est en lecture seule, la collection est en lecture-écriture.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Triggers>  
    OneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *OneOrMoreTriggers*  
 Zéro ou plusieurs <xref:System.Windows.TriggerBase> objets.  
  
   
  
## Examples  
 Les éléments suivants <xref:System.Windows.DataTemplate> illustre l’utilisation de la <xref:System.Windows.DataTemplate.Triggers%2A> propriété.  
  
 [!code-xaml[DataBindingLab#AuctionItemDataTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/DataBindingLabApp.xaml#auctionitemdatatemplate)]  
  
 Pour obtenir un exemple complet, consultez [démo de liaison de données](http://go.microsoft.com/fwlink/?LinkID=163703).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.MultiDataTrigger" />
      </Docs>
    </Member>
    <Member MemberName="ValidateTemplatedParent">
      <MemberSignature Language="C#" Value="protected override void ValidateTemplatedParent (System.Windows.FrameworkElement templatedParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ValidateTemplatedParent(class System.Windows.FrameworkElement templatedParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ValidateTemplatedParent (templatedParent As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ValidateTemplatedParent(System::Windows::FrameworkElement ^ templatedParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templatedParent" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="templatedParent">Élément auquel est appliqué le modèle.</param>
        <summary>Vérifie le parent basé sur des modèles par rapport à un ensemble de règles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode utilise les règles suivantes :  
  
-   Le `templatedParent` doit être une valeur non null <xref:System.Windows.FrameworkElement>.  
  
-   Le <xref:System.Windows.DataTemplate> doivent être appliquées à un <xref:System.Windows.Controls.ContentPresenter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>