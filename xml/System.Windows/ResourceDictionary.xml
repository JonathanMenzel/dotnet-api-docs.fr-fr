<Type Name="ResourceDictionary" FullName="System.Windows.ResourceDictionary">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c722d5cf7122ab5f51ab92908278b0df828819c" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/05/2018" />
    <Meta Name="ms.locfileid" Value="34758897" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResourceDictionary : System.Collections.IDictionary, System.ComponentModel.ISupportInitialize, System.Windows.Markup.INameScope, System.Windows.Markup.IUriContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ResourceDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ComponentModel.ISupportInitialize, class System.Windows.Markup.INameScope, class System.Windows.Markup.IUriContext" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ResourceDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceDictionary&#xA;Implements IDictionary, INameScope, ISupportInitialize, IUriContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceDictionary : System::Collections::IDictionary, System::ComponentModel::ISupportInitialize, System::Windows::Markup::INameScope, System::Windows::Markup::IUriContext" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IUriContext</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.Ambient</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une implémentation de table de hachage/dictionnaire qui contient des ressources WPF utilisées par les composants et par d’autres éléments d’une application WPF.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments dans un <xref:System.Windows.ResourceDictionary> ne sont pas traités immédiatement lorsque le code de l’application est chargé par un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] chargeur. Au lieu de cela, le <xref:System.Windows.ResourceDictionary> persiste en tant qu’objet, et les valeurs individuelles sont traitées uniquement lorsqu’elles sont spécifiquement demandées.  
  
 Le <xref:System.Windows.ResourceDictionary> classe n’est pas dérivée de <xref:System.Collections.DictionaryBase>. Au lieu de cela, le <xref:System.Windows.ResourceDictionary> la classe implémente <xref:System.Collections.IDictionary> mais s’appuie sur un <xref:System.Collections.Hashtable> en interne.  
  
 Dans [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], le <xref:System.Windows.ResourceDictionary> classe est en général un élément de collection implicite qui est la valeur d’élément objet de plusieurs `Resources` des propriétés, dans la syntaxe d’élément de propriété. Pour plus d’informations sur des collections implicites dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consultez [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Une exception est lorsque vous souhaitez spécifier un dictionnaire fusionné ; Pour plus d’informations, consultez [dictionnaires de ressources fusionnés](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 Un autre possible [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utilisation consiste à déclarer un dictionnaire de ressources comme une discrète [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] fichier et le charger au moment de l’exécution avec <xref:System.Windows.Markup.XamlReader.Load%2A> ou inclure dans un projet (confiance totale) comme une ressource ou un fichier. Dans ce cas, <xref:System.Windows.ResourceDictionary> peut être déclaré comme un élément objet, servant d’élément racine de la [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Vous devez mapper les valeurs d’espace de noms XML appropriées (par défaut pour le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] espace de noms et généralement `x:` pour le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] espace de noms) sur le <xref:System.Windows.ResourceDictionary> élément si vous envisagez d’utiliser comme élément racine. Vous pouvez alors ajouter des éléments enfants qui définissent les ressources, chacun avec un [x : Key](~/docs/framework/xaml-services/x-key-directive.md) valeur.  
  
<a name="xamlImplicitCollectionUsage_ResourceDictionary"></a>   
## <a name="xaml-implicit-collection-usage"></a>Utilisation des collections implicites XAML  
  
```  
<object>  
  <object.resourcesProperty>  
    oneOrMoreResources  
  </object.resourcesProperty>  
</object>  
```  
  
<a name="xamlValues_ResourceDictionary"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *resourcesProperty*  
 Une propriété qui spécifie un élément de propriété, où le type de valeur de cette propriété est <xref:System.Windows.ResourceDictionary>. En règle générale, il s’agit du `Resources` propriété du <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>, ou de <xref:System.Windows.Application> dans un cas de ressources d’application.  
  
 *oneOrMoreResources*  
 Une ou plusieurs ressources spécifiées comme éléments de l’objet. Chaque ressource que vous spécifiez doit avoir un [x : Key, Directive](~/docs/framework/xaml-services/x-key-directive.md) attribué.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.FrameworkElement.Resources" />
    <altmember cref="P:System.Windows.Application.Resources" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Le nom de la clé à ajouter.</param>
        <param name="value">La valeur de la ressource à ajouter.</param>
        <summary>Ajoute une ressource par clé à ce <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tentative d’ajout d’une clé dupliquée lève une exception.  
  
 Les clés sont toujours ajoutés au dictionnaire de base. Les clés dans <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> dans actuel <xref:System.Windows.ResourceDictionary> ne sont pas vérifiées pour la duplication, seul le dictionnaire de base est vérifié pour les doublons.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Windows.ResourceDictionary" /> est verrouillé ou en lecture seule.</exception>
        <exception cref="T:System.ArgumentException">Un élément possédant la même clé existe déjà dans <see cref="T:System.Collections.Hashtable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence la phase d'initialisation pour ce <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est une indication que le contenu de la <xref:System.Windows.ResourceDictionary> doivent être chargées. L’étape suivante du processus consiste à appeler <xref:System.Windows.ResourceDictionary.EndInit%2A>.  
  
 N’appelez pas <xref:System.Windows.ResourceDictionary.BeginInit%2A> plusieurs fois, avant d’appeler <xref:System.Windows.ResourceDictionary.EndInit%2A>. Cela déclenchera une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.ResourceDictionary.BeginInit" /> a été appelé plus d'une fois avant que <see cref="M:System.Windows.ResourceDictionary.EndInit" /> n'ait été appelé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les clés (et valeurs) dans le <see cref="T:System.Windows.ResourceDictionary" /> de base. Cela n'efface aucun élément de dictionnaire fusionné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin effacer des éléments de dictionnaire fusionnés, récupérez le dictionnaire particulier à partir de <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> collection et appelez spécifiquement <xref:System.Windows.ResourceDictionary.Clear%2A> sur qui <xref:System.Windows.ResourceDictionary>, bien qu’en général, les dictionnaires sont à distance et vous n’avez ne peut-être pas accès. Vous pouvez également supprimer l’ensemble du <xref:System.Windows.ResourceDictionary> de <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> en appelant supprimer sur la collection générique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Windows.ResourceDictionary" />.</param>
        <summary>Détermine si <see cref="T:System.Windows.ResourceDictionary" /> contient un élément avec la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Windows.ResourceDictionary" /> contient une paire clé-valeur avec la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé demandée n’est pas dans ce dictionnaire de ressources, la logique de recherche de ressources vérifiera également les dictionnaires fusionnés.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Le tableau unidimensionnel qui constitue la destination des objets <see cref="T:System.Collections.DictionaryEntry" /> copiés à partir de l'instance <see cref="T:System.Windows.ResourceDictionary" />. Ce tableau doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro de <c>array</c> où la copie commence.</param>
        <summary>Copie les entrées des éléments <see cref="T:System.Windows.ResourceDictionary" /> dans un <see cref="T:System.Collections.DictionaryEntry" /> à une dimension à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il copie uniquement le dictionnaire de base. Le tableau de résultats n’aura aucun <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> s’il est reconstitué à un <xref:System.Windows.ResourceDictionary> à nouveau.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Place le nombre d'entrées dans le <see cref="T:System.Windows.ResourceDictionary" /> de base.</summary>
        <value>Le nombre actuel d'entrées dans le dictionnaire de base.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="DeferrableContent">
      <MemberSignature Language="C#" Value="public System.Windows.DeferrableContent DeferrableContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DeferrableContent DeferrableContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.DeferrableContent" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferrableContent As DeferrableContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DeferrableContent ^ DeferrableContent { System::Windows::DeferrableContent ^ get(); void set(System::Windows::DeferrableContent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DeferrableContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contenu à reporter pour ce dictionnaire de ressources.</summary>
        <value>Retourne toujours <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine la phase d'initialisation et invalide l'arborescence précédente afin de tenir compte de toutes les modifications effectuées sur les clés pendant la phase d'initialisation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ResourceDictionary.BeginInit%2A> et <xref:System.Windows.ResourceDictionary.EndInit%2A> suivent un modèle de transaction. <xref:System.Windows.ResourceDictionary.BeginInit%2A> marque le dictionnaire non initialisé et <xref:System.Windows.ResourceDictionary.EndInit%2A> marque comme initialisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identificateur de nom de l’objet demandé.</param>
        <summary>Non pris en charge par cette implémentation de dictionnaire.</summary>
        <returns>Retourne toujours <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.ResourceDictionary> classe ne prend pas en charge l’inscription par nom. Il utilise des clés à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Collections.IDictionaryEnumerator" /> pouvant être utilisé pour itérer au sein du <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <returns>Un énumérateur spécialisé pour le <see cref="T:System.Windows.ResourceDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’itérateur est pour le dictionnaire de base.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidatesImplicitDataTemplateResources">
      <MemberSignature Language="C#" Value="public bool InvalidatesImplicitDataTemplateResources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.InvalidatesImplicitDataTemplateResources" />
      <MemberSignature Language="VB.NET" Value="Public Property InvalidatesImplicitDataTemplateResources As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvalidatesImplicitDataTemplateResources { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les invalidations déclenchées par l’objet <see cref="T:System.Windows.ResourceDictionary" /> font en sorte que les objets <see cref="T:System.Windows.Controls.ContentPresenter" /> réévaluent leur choix de modèle. Les invalidations se produisent quand une ressource de modèle de données implicite change.</summary>
        <value>
          <see langword="true" /> si les invalidations font en sorte que les objets <see cref="T:System.Windows.Controls.ContentPresenter" /> réévaluent leur choix de modèle ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient si ce <see cref="T:System.Windows.ResourceDictionary" /> est de taille fixe.</summary>
        <value>
          <see langword="true" /> si la table de hachage est de taille fixe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne la <xref:System.Collections.Hashtable> par défaut, c'est-à-dire `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient si ce <see cref="T:System.Windows.ResourceDictionary" /> est en lecture seule.</summary>
        <value>
          <see langword="true" /> si la table de hachage est en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne le <xref:System.Collections.Hashtable> par défaut, c'est-à-dire `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">La clé souhaitée à obtenir ou à définir.</param>
        <summary>Obtient ou définit la valeur associée à la clé donnée.</summary>
        <value>Valeur de la clé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé demandée n’est pas dans ce dictionnaire de ressources, le système de ressources framework vérifiera également les dictionnaires fusionnés.  
  
 Vérifier un <xref:System.Windows.ResourceDictionary> par élément ou index n’est pas généralement le meilleur moyen de récupérer des ressources. Vous devez appeler à la place des méthodes qui sont capables de participer au processus de recherche de ressources complet, rechercher des ressources par leurs clés et de rechercher les ressources dans les applications ou les thèmes. <xref:System.Windows.FrameworkElement.FindResource%2A> une telle méthode et est présent sur n’importe quel <xref:System.Windows.FrameworkElement>. Dans le cas contraire, votre tentative de recherche de la ressource ne correspond pas au comportement d’exécution true.  
  
 Toutefois, obtention des ressources directement à partir d’un dictionnaire individuel peut être appropriée si vous récupérez des ressources d’un autre <xref:System.Windows.ResourceDictionary> emplacement et faites pour éviter les conséquences possibles de performance et de portée de la recherche de clé d’exécution.  
  
 Vous n’utilisez pas d’indexeurs pour définir des membres de la collection dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Au lieu de cela, vous créez enfant éléments dans le balisage. Les éléments enfants sont des éléments enfants de <xref:System.Windows.ResourceDictionary>, ou d’un élément de propriété où le type de propriété est `ResourceDictionary`. Pour plus d’informations, consultez la [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sections d’utilisation dans <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de toutes les clés contenues dans ce <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>La collection de toutes les clés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété existe car elle est requise par <xref:System.Collections.IDictionary>, mais <xref:System.Windows.ResourceDictionary.Keys%2A> n’est généralement pas utiles pour la plupart des <xref:System.Windows.ResourceDictionary> scénarios.  
  
 Les clés retournées n’incluent pas de clés dans le <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. La collection de clés est également un instantané des clés dans le dictionnaire de base. Si vous apportez des modifications par la suite à cette <xref:System.Windows.ResourceDictionary>, un stockées <xref:System.Windows.ResourceDictionary.Keys%2A> ne reflète pas les modifications.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="MergedDictionaries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt; MergedDictionaries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.ResourceDictionary&gt; MergedDictionaries" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedDictionaries As Collection(Of ResourceDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ MergedDictionaries { System::Collections::ObjectModel::Collection&lt;System::Windows::ResourceDictionary ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.ResourceDictionary&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection des dictionnaires <see cref="T:System.Windows.ResourceDictionary" /> qui constituent les différents dictionnaires de ressources dans les dictionnaires fusionnés.</summary>
        <value>La collection de dictionnaires fusionnés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les dictionnaires sont fusionnés en ajoutant un <xref:System.Windows.ResourceDictionary> à la collection générique référencée par <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Une fusion <xref:System.Windows.ResourceDictionary> n’a pas d’éléments de ressource définis dans le balisage. Au lieu de cela, le dictionnaire fusionné est un <xref:System.Windows.ResourceDictionary> sans éléments enfants de balise définis (ou sans éléments ajoutés via le code), mais avec un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] spécifiée pour <xref:System.Windows.ResourceDictionary.Source%2A>. Le <xref:System.Windows.ResourceDictionary.Source%2A> désignation permet au dictionnaire fusionné provenir d’une source externe, telle qu’un assembly de ressources distinct est fourni avec l’application, « libre [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]», une localisation spécifique ou un assembly de ressources globales.  
  
 Spécification d’éléments de ressource dans un <xref:System.Windows.ResourceDictionary> qui a <xref:System.Windows.ResourceDictionary.Source%2A> spécifié n’est pas pris en charge.  
  
 Comportement de recherche dans les <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> collection recherche le dernier ajouté <xref:System.Windows.ResourceDictionary> première et la recherche s’arrête dès qu’une clé demandée est trouvée. Les clés en double dans la collection de dictionnaires fusionnés ne sont pas non conformes. Pour plus d’informations sur le comportement de dictionnaire fusionné, consultez [les dictionnaires de ressources fusionnés](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_MergedDictionaries"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.MergedDictionaries>  
    oneOrMoreResourceDictionaries  
  </object.MergedDictionaries>  
</object>  
  
```  
  
<a name="xamlValues_MergedDictionaries"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *oneOrMoreResourceDictionaries*  
 Un ou plusieurs <xref:System.Windows.ResourceDictionary> éléments objet. A <xref:System.Windows.ResourceDictionary> utilisé pour <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> n’a pas de contenu d’une collection et spécifie un <xref:System.Windows.ResourceDictionary.Source%2A> attribut qui fait référence à l’ensemble <xref:System.Windows.ResourceDictionary> à distance.  
  
   
  
## Examples  
 L’exemple suivant spécifie deux <xref:System.Windows.ResourceDictionary> éléments devant être fusionnées dans le serveur principal <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.Source" />
      </Docs>
    </Member>
    <Member MemberName="OnGettingValue">
      <MemberSignature Language="C#" Value="protected virtual void OnGettingValue (object key, ref object value, out bool canCache);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGettingValue(object key, object&amp; value, [out] bool&amp; canCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.OnGettingValue(System.Object,System.Object@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGettingValue (key As Object, ByRef value As Object, ByRef canCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGettingValue(System::Object ^ key, System::Object ^ % value, [Runtime::InteropServices::Out] bool % canCache);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="canCache" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Clé de la ressource à obtenir.</param>
        <param name="value">Valeur de la ressource demandée.</param>
        <param name="canCache">
          <see langword="true" /> si la ressource peut être stockée et utilisée ultérieurement ; sinon, <see langword="false" />.</param>
        <summary>Se produit lorsque le <see cref="T:System.Windows.ResourceDictionary" /> reçoit une demande pour une ressource.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Non pris en charge.</param>
        <param name="scopedElement">Non pris en charge.</param>
        <summary>Non pris en charge par cette implémentation de dictionnaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.ResourceDictionary> classe ne prend pas en charge l’inscription par nom. Il utilise des clés à la place. Les méthodes de la portée de nom XAML sont implémentées comme versions inopérantes dans <xref:System.Windows.ResourceDictionary> pour indiquer clairement ce code XAML noms ne s’appliquent pas aux ressources.  
  
 Appeler cette méthode entraîne un <xref:System.NotSupportedException> levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dans tous les cas lorsque cette méthode est appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'entrée à supprimer.</param>
        <summary>Supprime du dictionnaire de base l'entrée avec la clé spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.ResourceDictionary> ne contient pas d’élément avec la clé spécifiée, la <xref:System.Windows.ResourceDictionary> demeure inchangée. Aucune exception n’est levée.  
  
 Cette méthode ne supprime pas les clés à partir de la <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. Vous devez vous procurer spécifique au <xref:System.Windows.ResourceDictionary> à partir de la collection pour supprimer ces clés, mais qui peuvent être pas possible car vous accédez généralement à distance à un tel dictionnaire.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Windows.ResourceDictionary" /> est verrouillé ou en lecture seule.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] à partir duquel charger les ressources.</summary>
        <value>Emplacement source d’un dictionnaire de ressources externe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, <xref:System.Windows.ResourceDictionary.Source%2A> est spécifié comme un URI à en-tête Pack, qui fait référence à l’emplacement d’un dictionnaire de ressources qui est inclus en tant qu’une action de génération de ressource ou de contenu non compilée par votre projet de création d’application. Pour plus d’informations sur le format d’URI à en-tête Pack, consultez [URI à en-tête Pack dans WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md).  
  
 En règle générale, les <xref:System.Windows.ResourceDictionary.Source%2A> propriété est définie uniquement pour un <xref:System.Windows.ResourceDictionary> qui est spécifié pour le <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A> propriété (comme un élément de propriété dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], ou en tant qu’un <xref:System.Windows.ResourceDictionary> élément de la collection dans le code). Dans ce contexte, la valeur de <xref:System.Windows.ResourceDictionary.Source%2A> fusionne le contenu de dictionnaire trouvé à l’élément [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] dans la zone actuelle <xref:System.Windows.ResourceDictionary>. Les échecs de chargement provoquera une exception levée.  
  
   
  
## Examples  
 L’exemple suivant spécifie deux <xref:System.Windows.ResourceDictionary> éléments devant être fusionnées dans le serveur principal <xref:System.Windows.ResourceDictionary>.  
  
 [!code-xaml[ResourceMergeDictionary#MergedXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ResourceMergeDictionary/CS/default.xaml#mergedxaml)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ResourceDictionary.MergedDictionaries" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Un élément de base zéro <see cref="T:System.Array" /> qui reçoit les éléments copiés à partir de <see cref="T:System.Windows.Markup.Localizer.BamlLocalizationDictionary" />.</param>
        <param name="arrayIndex">Première position du <see cref="T:System.Array" /> spécifié à recevoir le contenu copié.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.ResourceDictionary> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
        <value>
          <see langword="true" /> si l'accès à <see cref="T:System.Windows.ResourceDictionary" /> est synchronisé (thread-safe) ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.ResourceDictionary> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Windows.ResourceDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.ResourceDictionary> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
        <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.ResourceDictionary> est castée en interface <xref:System.Collections.IEnumerable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ResourceDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IUriContext.BaseUri">
      <MemberSignature Language="C#" Value="Uri System.Windows.Markup.IUriContext.BaseUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri System.Windows.Markup.IUriContext.BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.System#Windows#Markup#IUriContext#BaseUri" />
      <MemberSignature Language="VB.NET" Value=" Property BaseUri As Uri Implements IUriContext.BaseUri" />
      <MemberSignature Language="C++ CLI" Value="property Uri ^ System.Windows.Markup.IUriContext.BaseUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IUriContext.BaseUri</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.Windows.Markup.IUriContext.BaseUri" />.</summary>
        <value>La base [ ! Include[TLA2#tla_uri](~/Includes/tla2sharptla-URI-MD.MD)] du contexte actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.ResourceDictionary> est castée en interface <xref:System.Windows.Markup.IUriContext>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ResourceDictionary.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Non pris en charge.</param>
        <summary>Non pris en charge par cette implémentation de dictionnaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.ResourceDictionary> classe ne prend pas en charge l’inscription par nom. Il utilise des clés à la place. Appel de cette méthode ne fait rien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ResourceDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de toutes les valeurs associée aux clés contenues dans ce <see cref="T:System.Windows.ResourceDictionary" />.</summary>
        <value>La collection de toutes les valeurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété existe car elle est requise par <xref:System.Collections.IDictionary>, mais il est généralement pas utiles pour la plupart des <xref:System.Windows.ResourceDictionary> scénarios.  
  
 Les valeurs renvoyées n’incluent pas de valeurs dans le <xref:System.Windows.ResourceDictionary.MergedDictionaries%2A>. La collection est également un instantané des valeurs dans le dictionnaire de base. Si vous apportez des modifications par la suite à cette <xref:System.Windows.ResourceDictionary>, un stockées <xref:System.Windows.ResourceDictionary.Values%2A> ne reflète pas les modifications.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>