<Type Name="EventManager" FullName="System.Windows.EventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dc3413d869bd9f89dc87256eb510a9e917751c9d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549847" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EventManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EventManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.EventManager" />
  <TypeSignature Language="VB.NET" Value="Public Class EventManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventManager abstract sealed" />
  <TypeSignature Language="F#" Value="type EventManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides event-related utility methods that register routed events for class owners and add class handlers.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe est couramment utilisée pour inscrire un nouvel événement routé, avec <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.  
  
 Le deuxième plus courantes [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] utilisation est <xref:System.Windows.EventManager.RegisterClassHandler%2A>. Cette méthode vous permet d’activer la gestion de classe d’un événement routé sur la classe ou un événement attaché. Pour plus d’informations, consultez [marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette classe pour inscrire un nouvel événement routé comme un membre de classe, ainsi que de la technique de « wrapper » d’événement routé de substitution de l’ajouter et supprimer des implémentations pour un [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] événement.  
  
 [!code-csharp[DPCustom#EventManagerClass](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#eventmanagerclass)]
 [!code-vb[DPCustom#EventManagerClass](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#eventmanagerclass)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetRoutedEvents">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent[] GetRoutedEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent[] GetRoutedEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.GetRoutedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRoutedEvents () As RoutedEvent()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Windows::RoutedEvent ^&gt; ^ GetRoutedEvents();" />
      <MemberSignature Language="F#" Value="static member GetRoutedEvents : unit -&gt; System.Windows.RoutedEvent[]" Usage="System.Windows.EventManager.GetRoutedEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns identifiers for routed events that have been registered to the event system.</summary>
        <returns>An array of type <see cref="T:System.Windows.RoutedEvent" /> that contains the registered objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plus <xref:System.Windows.RoutedEvent> objets peuvent être enregistrés ultérieurement. Cette méthode obtient une capture instantanée et la collection d’événements routés est accessible en écriture tout au long de durée de vie d’une application. La collection retournée peut être assez volumineuse. Seulement avec les événements qui font partie de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], le décompte de collections est centaines.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRoutedEventsForOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent[] GetRoutedEventsForOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent[] GetRoutedEventsForOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.GetRoutedEventsForOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRoutedEventsForOwner (ownerType As Type) As RoutedEvent()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Windows::RoutedEvent ^&gt; ^ GetRoutedEventsForOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member GetRoutedEventsForOwner : Type -&gt; System.Windows.RoutedEvent[]" Usage="System.Windows.EventManager.GetRoutedEventsForOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to start the search with. Base classes are included in the search.</param>
        <summary>Finds all routed event identifiers for events that are registered with the provided owner type.</summary>
        <returns>An array of matching routed event identifiers if any match is found; otherwise, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClassHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a class handler for a particular routed event.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClassHandler">
      <MemberSignature Language="C#" Value="public static void RegisterClassHandler (Type classType, System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassHandler(class System.Type classType, class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterClassHandler(System.Type,System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassHandler(Type ^ classType, System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="static member RegisterClassHandler : Type * System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="System.Windows.EventManager.RegisterClassHandler (classType, routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classType" Type="System.Type" />
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="classType">The type of the class that is declaring class handling.</param>
        <param name="routedEvent">The routed event identifier of the event to handle.</param>
        <param name="handler">A reference to the class handler implementation.</param>
        <summary>Registers a class handler for a particular routed event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestion de classe est une fonctionnalité qui est disponible pour les événements routés, y compris les événements attachés qui sont implémentés avec la sauvegarde d’événement routé. Un gestionnaire de classe ressemble à un gestionnaire statique qui existe pour toutes les instances de la classe. Étant donné que le gestionnaire est statique, vous ne pouvez pas modifier les propriétés d’instance directement avec un gestionnaire de classe, mais vous pouvez accéder aux instances via le `sender` paramètre et/ou les données d’événement.  
  
 Gestionnaires de classe sont appelés avant les gestionnaires d’instance. Vous pouvez implémenter un gestionnaire de classe qui a le comportement de marquer l’événement comme géré. Par conséquent, les gestionnaires d’instance pour un événement géré à la classe ne sont pas appelés à moins que les gestionnaires d’instance inscrire spécifiquement pour les événements gérés.  
  
 Un grand nombre de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] les événements d’élément de base fournissent des méthodes virtuelles de gestion de classe. En substituant ces méthodes dans les classes qui héritent des classes de base, vous pouvez implémenter la gestion de classe sans appeler <xref:System.Windows.EventManager.RegisterClassHandler%2A> dans les constructeurs statiques. En règle générale, ces méthodes de gestion de classe existent pour les événements d’entrée et ont des noms qui commencent par « On » et se terminent par le nom de l’événement de classe.  
  
 Pour plus d’informations sur la gestion de classe, consultez [marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 À l’aide de cette signature, les gestionnaires de classe seront inscrit pour appeler uniquement en réponse aux événements non gérés. Vous pouvez également inscrire des gestionnaires de classe à appeler même si les arguments d’événement sont marqué comme gérés, à l’aide de la <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature, avec `handledEventsToo` défini sur `true`.  
  
   
  
## Examples  
 L’exemple suivant ajoute un gestionnaire pour <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>, l’appel <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 [!code-csharp[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#staticandregisterclasshandler)]
 [!code-vb[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#staticandregisterclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassHandler">
      <MemberSignature Language="C#" Value="public static void RegisterClassHandler (Type classType, System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassHandler(class System.Type classType, class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterClassHandler(System.Type,System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassHandler(Type ^ classType, System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="static member RegisterClassHandler : Type * System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="System.Windows.EventManager.RegisterClassHandler (classType, routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classType" Type="System.Type" />
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="classType">The type of the class that is declaring class handling.</param>
        <param name="routedEvent">The routed event identifier of the event to handle.</param>
        <param name="handler">A reference to the class handler implementation.</param>
        <param name="handledEventsToo">
          <see langword="true" /> to invoke this class handler even if arguments of the routed event have been marked as handled; <see langword="false" /> to retain the default behavior of not invoking the handler on any marked-handled event.</param>
        <summary>Registers a class handler for a particular routed event, with the option to handle events where event data is already marked handled.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gestion de classe est une fonctionnalité qui est disponible pour les événements routés, y compris les événements attachés qui sont implémentés avec la sauvegarde d’événement routé. Un gestionnaire de classe ressemble à un gestionnaire statique qui existe pour toutes les instances de la classe. Étant donné que le gestionnaire est statique, vous ne pouvez pas modifier les propriétés d’instance directement avec un gestionnaire de classe, mais vous pouvez accéder aux instances via le `sender` paramètre et/ou les données d’événement.  
  
 Gestionnaires de classe sont appelés avant les gestionnaires d’instance. Vous pouvez implémenter un gestionnaire de classe qui a le comportement de marquer l’événement comme géré. Par conséquent, les gestionnaires d’instance pour un événement géré à la classe ne sont pas appelés à moins que les gestionnaires d’instance inscrire spécifiquement pour les événements gérés.  
  
 Un grand nombre de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] les événements d’élément de base fournissent des méthodes virtuelles de gestion de classe. En substituant ces méthodes dans les classes qui héritent des classes de base, vous pouvez implémenter la gestion de classe sans appeler <xref:System.Windows.EventManager.RegisterClassHandler%2A> dans les constructeurs statiques. En règle générale, ces méthodes de gestion de classe existent pour les événements d’entrée et ont des noms qui commencent par « On » et se terminent par le nom de l’événement de classe.  
  
 Pour plus d’informations sur la gestion de classe, consultez [marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 À l’aide de cette signature, les gestionnaires de classe peuvent être enregistrés pour appeler des événements gérés, en définissant `handledEventsToo` défini sur `true`. En règle générale, vous devez le faire uniquement s’il existe un problème de gestion connu que vous voulez contourner, tels que système d’entrée gestion à partir d’événements de souris ou le clavier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRoutedEvent">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent RegisterRoutedEvent (string name, System.Windows.RoutingStrategy routingStrategy, Type handlerType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent RegisterRoutedEvent(string name, valuetype System.Windows.RoutingStrategy routingStrategy, class System.Type handlerType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterRoutedEvent(System.String,System.Windows.RoutingStrategy,System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::RoutedEvent ^ RegisterRoutedEvent(System::String ^ name, System::Windows::RoutingStrategy routingStrategy, Type ^ handlerType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterRoutedEvent : string * System.Windows.RoutingStrategy * Type * Type -&gt; System.Windows.RoutedEvent" Usage="System.Windows.EventManager.RegisterRoutedEvent (name, routingStrategy, handlerType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="routingStrategy" Type="System.Windows.RoutingStrategy" />
        <Parameter Name="handlerType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the routed event. The name must be unique within the owner type and cannot be <see langword="null" /> or an empty string.</param>
        <param name="routingStrategy">The routing strategy of the event as a value of the enumeration.</param>
        <param name="handlerType">The type of the event handler. This must be a delegate type and cannot be <see langword="null" />.</param>
        <param name="ownerType">The owner class type of the routed event. This cannot be <see langword="null" />.</param>
        <summary>Registers a new routed event with the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] event system.</summary>
        <returns>The identifier for the newly registered routed event. This identifier object can now be stored as a static field in a class and then used as a parameter for methods that attach handlers to the event. The routed event identifier is also used for other event system [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour de cette méthode permet de créer la déclaration statique pour un unique <xref:System.Windows.RoutedEvent> champ d’identificateur. Ce champ doit être stocké dans le type de propriétaire.  
  
 Il existe un nombre considérable de conventions et meilleures pratiques associés aux événements routés comment doivent être nommés, inscrit et exposées dans une classe. Pour plus d’informations, consultez [vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>