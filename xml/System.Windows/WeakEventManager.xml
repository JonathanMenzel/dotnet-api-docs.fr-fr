<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7c50f8e21321e058314ffb0c59534252db4eb2aa" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52232394" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit une classe de base pour le gestionnaire d’événements utilisé dans le *modèle d’événement faible*. Le gestionnaire ajoute et supprime des écouteurs pour les événements (ou rappels) qui utilisent également le modèle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez généralement le modèle d’événement faible lorsque la source de l’événement a une durée de vie d’objet qui est indépendante des écouteurs d’événements. À l’aide de la distribution de d’événement central un <xref:System.Windows.WeakEventManager> permet aux gestionnaires de l’écouteur d’être nettoyées même si l’objet source est persistant. En revanche, une accroche d’événement classique à l’aide du `+=` opérateur entraîne la source potentiellement déconnectée stocker une référence aux écouteurs. Cela empêche le récepteur de garbage collecté en temps voulu.  
  
 Une situation courante où les relations de durée de vie entre les sources et les écouteurs doivent utiliser de modèle d’événement faible est la gestion des événements de mise à jour provenant de liaisons de données.  
  
 Le modèle d’événement faible peut également servir pour les rappels et les événements normaux.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Pour obtenir un exemple de personnalisé <see cref="T:System.Windows.WeakEventManager" />, consultez [modèles d’événement faible](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise des valeurs de classe de base en cas d'utilisation comme initialiseur par le constructeur d'une classe dérivée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">L'objet sur lequel l'événement est géré.</param>
        <param name="args"><see cref="T:System.EventArgs" /> qui contient les données d'événement à remettre.</param>
        <summary>Remet l'événement qui est géré à chaque écouteur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.WeakEventManager.DeliverEvent%2A> méthode à partir de gestionnaires d’événements qui sont ajoutés ou supprimés par le <xref:System.Windows.WeakEventManager.StartListening%2A> et <xref:System.Windows.WeakEventManager.StopListening%2A> implémentations de sous-classes.  
  
 Si vous appelez le <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> méthode dans votre `AddListener` implémentation de votre classe, la liste des écouteurs qui reçoivent l’événement est conservée dans une collection sous-jacente. (`AddListener` ne fait pas partie d’un contrat d’interface ou classe. `AddListener` est le nom suggéré pour la méthode de votre classe de gestionnaire qui appelle <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> et ajoute des écouteurs de modèle d’événement faible pour l’événement.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Ajoute des écouteurs à une liste unique. Si votre implémentation de gestionnaire maintient plusieurs listes d’écouteurs par événement, n’utilisez pas <xref:System.Windows.WeakEventManager.DeliverEvent%2A> ou <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Au lieu de cela, votre implémentation doit créer ses propres <xref:System.Windows.WeakEventManager.ListenerList> instances, `AddListener` doit ajouter des écouteurs à la liste appropriée, et les événements doivent être remis à la liste d’écouteurs appropriée en appelant <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">L'objet sur lequel l'événement est géré.</param>
        <param name="args"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <param name="list">Le <see cref="T:System.Windows.WeakEventManager.ListenerList" /> fourni.</param>
        <summary>Remet l'événement qui est géré à chaque écouteur dans la liste fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est nécessaire si votre implémentation de gestionnaire maintient des listes d’écouteurs distincts en fonction des informations qui sont capturées dans les données d’événement. Si vous utilisez cette technique avancée, vous devez créer et maintenir les listes séparées dans le cadre de votre implémentation de gestionnaire, et vous devez fournir un moyen pour ajouter des écouteurs à une liste spécifique. Votre implémentation de gestionnaire qui écoute l’événement brut doit agir sur la condition que vous utilisez pour différencier les listes et remettre l’événement uniquement à l’ou les listes appropriées.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Le type pour qui obtenir le <see cref="T:System.Windows.WeakEventManager" />.</param>
        <summary>Retourne l'implémentation <see cref="T:System.Windows.WeakEventManager" /> utilisée pour le type fourni.</summary>
        <returns>L'implémentation <see cref="T:System.Windows.WeakEventManager" /> correspondante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implémentations appellent cette méthode à l’aide de leurs passé `managerType`. Retourné <xref:System.Windows.WeakEventManager> est ensuite utilisée comme différentiateur pour déterminer l’événement qui a été reçu et quel gestionnaire de classe privée à appeler.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Index de base zéro de la source demandée.</param>
        <summary>Obtient ou définit les données qui sont stockées pour la source spécifiée.</summary>
        <value>Données qui sont stockées par le gestionnaire pour cette source.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées peuvent choisir quelles données et le type à stocker dans cet indexeur. En général, cela est implémenté comme un <xref:System.Windows.WeakEventManager.ListenerList>, qui est une liste de références faibles aux écouteurs. Vous devez uniquement modifier ce type si le <xref:System.Windows.WeakEventManager.ListenerList> type ne peut pas contenir vos informations requises. Si, par conséquent, vous devrez remplacer le <xref:System.Windows.WeakEventManager.Purge%2A> méthode afin que tout le nettoyage du type sous-jacent est effectuée correctement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nouvel objet destiné à contenir des écouteurs sur un événement.</summary>
        <returns>Nouvel objet destiné à contenir des écouteurs sur un événement.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Objet source auquel le délégué de gestionnaire est abonné.</param>
        <param name="handler">Délégué qui gère l'événement déclenché par <paramref name="source" />.</param>
        <summary>Ajoute le délégué spécifié en tant que gestionnaire d'événements de la source spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">La source à laquelle joindre des écouteurs.</param>
        <param name="listener">La classe d'écoute (qui doit implémenter <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Ajoute l'écouteur fourni à la source fournie pour l'événement qui est géré.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode au sein de votre classe de gestionnaire `AddListener` méthodes sur <xref:System.Windows.WeakEventManager> implémentations. `AddListener` est le nom suggéré pour la méthode statique que vous définissez sur votre classe de gestionnaire pour permettre à d’autres classes ajouter un écouteur pour votre modèle d’événement faible. `AddListener` doit prendre deux paramètres : le `source` où l’écouteur est joint et le `listener` instance. Pour votre `AddListener` implémentation, appelez le <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> méthode sur le gestionnaire actuel, en passant les deux mêmes paramètres.  
  
 Si la liste d’écouteurs a été précédemment vide, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> appelle le <xref:System.Windows.WeakEventManager.StartListening%2A> méthode en interne, qui appellera votre propre <xref:System.Windows.WeakEventManager.StartListening%2A> à travers le polymorphisme.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Ajoute des écouteurs à un seul interne <xref:System.Windows.WeakEventManager.ListenerList> par `source`. Si votre implémentation de gestionnaire gère plusieurs listes d’écouteurs pour chaque combinaison de source d’événement, n’utilisez pas <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Au lieu de cela, votre implémentation doit créer ses propres <xref:System.Windows.WeakEventManager.ListenerList> instances, `AddListener` doit ajouter des écouteurs à la liste appropriée, et les événements doivent être remis à la liste d’écouteurs appropriée en appelant le <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> événement au lieu du <xref:System.Windows.WeakEventManager.DeliverEvent%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Source à supprimer du gestionnaire.</param>
        <param name="handler">Délégué à supprimer à partir de <paramref name="source" />.</param>
        <summary>Supprime de la source spécifiée le gestionnaire ajouté précédemment.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">La source à partir de laquelle supprimer des écouteurs.</param>
        <param name="listener">La classe d'écoute (qui doit implémenter <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Supprime un écouteur ajouté précédemment depuis la source fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode au sein de votre classe de gestionnaire `RemoveListener` méthodes sur <xref:System.Windows.WeakEventManager> implémentations. `RemoveListener` est le nom suggéré pour la méthode statique que vous définissez sur votre classe de gestionnaire pour permettre à d’autres classes de supprimer un écouteur pour votre modèle d’événement faible. `RemoveListener` doit prendre deux paramètres : le `source` où l’écouteur est supprimé et le `listener` classe. Pour votre `RemoveListener` implémentation, appelez le <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> méthode sur le gestionnaire actuel, en passant les deux mêmes paramètres.  
  
 Si un appel à <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> supprime le dernier écouteur dans la liste, <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> appelle le <xref:System.Windows.WeakEventManager.StopListening%2A> méthode en interne, qui appellera votre propre <xref:System.Windows.WeakEventManager.StopListening%2A> à travers le polymorphisme.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Supprime des écouteurs à partir d’une seule interne <xref:System.Windows.WeakEventManager.ListenerList> par `source`. Si votre implémentation de gestionnaire gère plusieurs listes d’écouteurs pour chaque combinaison de source d’événement, n’utilisez pas <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Au lieu de cela, votre implémentation doit créer ses propres <xref:System.Windows.WeakEventManager.ListenerList> instances, `RemoveListener` doit supprimer des écouteurs de la liste appropriée, et les événements doivent être remis à la liste d’écouteurs appropriée en appelant le <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> méthode au lieu de la <xref:System.Windows.WeakEventManager.DeliverEvent%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Source des événements qui sont écoutés.</param>
        <param name="data">Les données à vérifier. Cet objet est supposé être une implémentation <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <param name="purgeAll"><see langword="true" /> pour cesser d'écouter la <paramref name="source" /> et supprimer entièrement toutes les entrées de <paramref name="data" />.</param>
        <summary>Supprime des entrées d'écouteur inactives dans la liste de données pour la source fournie. Retourne la valeur <see langword="true" /> si certaines entrées ont été supprimées réellement de la liste.</summary>
        <returns><see langword="true" /> si certaines entrées ont été réellement supprimées ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.WeakEventManager.Purge%2A> méthode a une implémentation par défaut qui supprimera toutes les entrées lorsque les données sont un <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si le type sous-jacent pour le <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> est différent de <see cref="T:System.Windows.WeakEventManager.ListenerList" />, ou contient des données au-delà d’un <see cref="T:System.Windows.WeakEventManager.ListenerList" />, vous devez substituer la <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> (méthode). La substitution doit fournir le comportement de vidage pour obtenir la liste d’éléments de type alternatif. En règle générale, la substitution doit fournir le comportement sans appeler l’implémentation de base. Si un spécifique <see cref="T:System.Windows.WeakEventManager.ListenerList" /> a toujours besoin d’effacement, appel <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Établit un verrou de lecture sur la table de données sous-jacente et retourne un <see cref="T:System.IDisposable" />.</summary>
        <value>Objet qui peut être utilisé pour établir un verrou sur les membres de la table de données, puis être supprimé de manière appropriée avec une construction <see langword="using" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans les classes dérivées, les requêtes sur la table contenue dans <xref:System.Windows.WeakEventManager.Item%2A> doivent toujours avoir lieu au sein d’un `using (ReadLock) { ... }` clause, à l’exception des requêtes qui sont déjà dans un verrou d’écriture. Ces requêtes peuvent être nécessaires si votre classe prend en charge un plus sophistiquées `AddListener` implémentation qui requiert plus de données au-delà de la `source` et `listener`et utilise le <xref:System.Windows.WeakEventManager.Item%2A> collection pour stocker les informations supplémentaires.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">La source pour laquelle supprimer des informations d'écouteur.</param>
        <summary>Supprime tous les écouteurs pour la source spécifiée.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Demande qu'un vidage d'entrées inutilisées dans la liste d'écouteur sous-jacente soit effectué sur un thread de basse priorité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelant le <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> méthode ressemble à appeler le <xref:System.Windows.WeakEventManager.Purge%2A> méthode sur la liste du gestionnaire actuel, à la priorité de thread, avec le `purgeAll` paramètre défini sur `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Type utilisé pour définir le nouveau gestionnaire d'événements.</param>
        <param name="manager">Le nouveau gestionnaire d'événement.</param>
        <summary>Définit le gestionnaire actuel pour le type de gestionnaire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> méthode pour initialiser un gestionnaire, si cela est requis par un appel à votre `CurrentManager` propriété sur un <xref:System.Windows.WeakEventManager> implémentation.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">La source sur laquelle commencer à écouter.</param>
        <summary>En cas de substitution dans une classe dérivée, commence à écouter pour l'événement qui est géré. Après avoir d'abord appelé la méthode <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />, le gestionnaire doit être dans l'état d'appeler <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> ou <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> à chaque fois que l'événement pertinent de la source fournie est géré.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> remplacements doivent ajouter un gestionnaire à la collection <paramref name="source" />. Le gestionnaire est déclaré par le gestionnaire lui-même. Le Gestionnaire de classe ne peut pas être public, et elle doit uniquement être appelée en réponse à l’événement qui est géré. Le Gestionnaire de classe doit appeler le <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> méthode ou le <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> méthode en conséquence.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">La source sur laquelle arrêter d'écouter.</param>
        <summary>En cas de substitution dans une classe dérivée, cesse d'écouter sur la source fournie pour l'événement qui est géré.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> les implémentations doivent supprimer le Gestionnaire de classe comme ajouté par le <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> (méthode). Suppression d’un écouteur ne doit pas effacer la liste d’écouteurs. Au lieu de cela, il doit uniquement se déconnecter le Gestionnaire de classe (peut-être temporairement). Autres méthodes sont disponibles pour effacer l’intégralité de la liste, tels que le <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> méthode avec le <paramref name="purgeAll" /> paramètre défini sur <see langword="true" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Établit un verrou d’écriture sur la table de données sous-jacente et retourne un <see cref="T:System.IDisposable" />.</summary>
        <value>Objet qui peut être utilisé pour établir un verrou sur les membres de la table de données, puis être supprimé de manière appropriée avec une construction <see langword="using" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans les classes dérivées, toutes les modifications apportées à la table de données sous-jacente doivent se produire dans un `using (WriteLock) { ... }` clause. Ces modifications peuvent être nécessaires si votre classe prend en charge un plus sophistiquée `AddListener` implémentation qui requiert plus de données au-delà de la `source` et `listener`et utilise le <xref:System.Windows.WeakEventManager.Item%2A> collection pour stocker les informations supplémentaires.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>