<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3096061908923e7cf781983beaab620533614144" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460252" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Signale ou applique des métadonnées pour une propriété de dépendance, en ajoutant des caractéristiques de propriétés système spécifiques à l’infrastructure.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe dérive <xref:System.Windows.PropertyMetadata> (via <xref:System.Windows.UIPropertyMetadata>). La plupart des cas de développement d’applications au niveau de l’infrastructure WPF, <xref:System.Windows.FrameworkPropertyMetadata> est le type utilisé pour les métadonnées de propriété de dépendance, plutôt que les types de métadonnées de base <xref:System.Windows.PropertyMetadata> ou <xref:System.Windows.UIPropertyMetadata>. Cela est vrai pour les propriétés de dépendance existantes et pour la plupart des scénarios de propriété de dépendance personnalisée.  
  
 Les membres déclarés par cette classe qui complètent la <xref:System.Windows.PropertyMetadata> classe de base incluent différentes propriétés booléennes qui spécifient ou signalent le comportement de système de propriété de niveau infrastructure WPF telles que l’héritage de propriété, la liaison de données et la disposition.  
  
 Plusieurs signatures de constructeur pour créer un <xref:System.Windows.FrameworkPropertyMetadata> instance prennent un <xref:System.Windows.FrameworkPropertyMetadataOptions> paramètre. Le <xref:System.Windows.FrameworkPropertyMetadataOptions> énumération est utilisée uniquement pour spécifier le comportement initial dans le constructeur et n’est pas exposée après <xref:System.Windows.FrameworkPropertyMetadata> est construit. À partir d’une instance construite, vous pouvez obtenir ou définir les informations correspondantes à travers différentes propriétés qui partagent le nom des valeurs d’énumération utilisées dans l’appel de constructeur.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Cette classe n’est pas utilisée en général dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance sur un propriétaire particulier en tant que la première base <xref:System.Windows.PropertyMetadata> type. Ces métadonnées sont effectuée en <xref:System.Windows.FrameworkPropertyMetadata>. Si la conversion a retourné un valide <xref:System.Windows.FrameworkPropertyMetadata>, puis diverses <xref:System.Windows.FrameworkPropertyMetadata> valeurs de propriété sont signalés via une interface simple (non affichée).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette signature initialise toutes les valeurs de <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> à leurs valeurs par défaut de la propriété. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sera `null`et les différentes <xref:System.Windows.FrameworkPropertyMetadata> propriétés booléennes sera `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec le rappel <see cref="T:System.Windows.PropertyChangedCallback" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez ensuite modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’a pas encore été appliquées à une opération de système de propriétés spécifique.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut fournie et le rappel <see cref="T:System.Windows.PropertyChangedCallback" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Une référence à l'implémentation d'un gestionnaire sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> pour cette propriété de dépendance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation appelle un initialiseur de base, puis ajoute le `coerceValueCallback` en définissant la propriété sur l’instance de base.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, et le rappel <see cref="T:System.Windows.PropertyChangedCallback" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’a pas encore été appliquées à une opération de système de propriétés spécifique.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> pour cette propriété de dépendance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut fournie et les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> à l'aide de cette propriété.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, et les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’a pas encore été appliquées à une opération de système de propriétés spécifique.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> sur cette propriété de dépendance.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> pour éviter que le système de propriétés anime la propriété à laquelle ces métadonnées sont appliquées. De telles propriétés déclenchent une exception runtime qui provient du système de propriétés si des tentatives d'animation ont lieu. <see langword="false" /> pour autoriser l'animation de la propriété. La valeur par défaut est <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, les rappels spécifiés et une valeur booléenne qui peut être utilisée pour empêcher l'animation de la propriété.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Le `isAnimationProhibited` paramètre définit la valeur initiale de la <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriété déclarée par la base immédiate <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’a pas encore été appliquées à une opération de système de propriétés spécifique.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> à l'aide de cette propriété.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> pour éviter que le système de propriétés anime la propriété à laquelle ces métadonnées sont appliquées. De telles propriétés déclenchent une exception runtime qui provient du système de propriétés si des tentatives d'animation ont lieu. La valeur par défaut est <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> à utiliser lorsque les liaisons pour cette propriété sont appliquées et dont la valeur de leur <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> est <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, les rappels spécifiés, une valeur booléenne qui peut être utilisée pour empêcher l'animation de la propriété, et un déclencheur de mise à jour de liaison de données par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui seront appliquées à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables lors de la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de propriété/type de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Le `isAnimationProhibited` paramètre définit la valeur initiale de la <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriété déclarée par la base immédiate <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Pour plus d’informations sur le comportement de source de mise à jour pour les liaisons, consultez [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’a pas encore été appliquées à une opération de système de propriétés spécifique.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de réorganisation durant les opérations du moteur de disposition.</summary>
        <value>
          <see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de réorganisation ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> la valeur `true` va lancer une demande différée pour invalider les visuels de cet élément (un appel à <xref:System.Windows.UIElement.InvalidateArrange%2A>). Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de mise en page de niveau infrastructure WPF.  
  
 Personnalisé <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> est `true`.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées de la dépendance différents champs de propriété, la valeur de différentes des requêtes <xref:System.Windows.FrameworkPropertyMetadata> propriétés et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de mesure pendant des opérations du moteur de présentation.</summary>
        <value>
          <see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de mesure ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> la valeur `true` va lancer une demande différée pour invalider les visuels de cet élément. Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de mise en page de niveau infrastructure WPF.  
  
 Personnalisé <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> est `true`.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées de la dépendance différents champs de propriété, la valeur de différentes des requêtes <xref:System.Windows.FrameworkPropertyMetadata> propriétés et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de réorganisation de la disposition de son élément parent durant les opérations du moteur de disposition.</summary>
        <value>
          <see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de réorganisation spécifiquement sur son élément parent ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> la valeur `true` va lancer une demande différée pour invalider les visuels de l’élément parent.  
  
 En règle générale, vous n’avez pas besoin de signaler les modifications d’un <xref:System.Windows.FrameworkElement> propriété à un élément parent à l’aide <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , car l’élément lui-même aurait déjà son propre <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> comme `true`. Qui est généralement suffisant, car les modifications apportées à l’élément enfant déclenchent généralement une organisation du parent lorsque cela est approprié. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> est parfois utilisé pour une <xref:System.Windows.FrameworkContentElement> classe dérivée. Dans ce cas, l’élément enfant définit une propriété, mais qu’une <xref:System.Windows.FrameworkContentElement> classe dérivée ne contrôle pas son propre rendu. Le rendu est contrôlé par un <xref:System.Windows.FrameworkElement> élément parent qui sert de l’hôte de contenu. Par exemple, une modification à la valeur de la <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propriété attachée à un élément enfant invalide organisation du parent, parce que la position de l’enfant du parent doit être modifiée. Par conséquent, le <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propriété jointe possède des métadonnées où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> est `true`. Un autre exemple est <xref:System.Windows.Controls.Control.Padding%2A>; lorsque cette propriété est modifiée, le parent peut modifier le positionnement de l’enfant, en fonction de l’espace disponible.  
  
 Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de mise en page de niveau infrastructure WPF.  
  
 Personnalisé <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> est `true`.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de mesure de la disposition de son élément parent durant les opérations du moteur de disposition.</summary>
        <value>
          <see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de mesure spécifiquement sur son élément parent ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> la valeur `true` va lancer une demande différée pour invalider les visuels de l’élément parent. Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de mise en page de niveau infrastructure WPF.  
  
 En règle générale, vous n’avez pas besoin de signaler les modifications d’un <xref:System.Windows.FrameworkElement> propriété à un élément parent à l’aide <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , car l’élément lui-même aurait déjà son propre <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> comme `true`. Qui est généralement suffisant, car les modifications dans l’élément enfant déclenchent généralement une passe de mesure parent lorsque cela est approprié. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est parfois utilisé pour une <xref:System.Windows.FrameworkContentElement> classe dérivée. Dans ce cas, l’élément enfant définit une propriété, mais qu’une <xref:System.Windows.FrameworkContentElement> classe dérivée ne contrôle pas son propre rendu. Le rendu est contrôlé par un <xref:System.Windows.FrameworkElement> élément parent qui sert de l’hôte de contenu. Par exemple, une modification à la valeur de la <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriété par un élément enfant invalide la mesure du parent, parce que l’espacement relatif des paragraphes peut changer et peut augmenter ou diminuer la taille de l’hôte de contenu. Par conséquent, le <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriété possède des métadonnées où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est `true`.  
  
 Éléments de l’hôte de contenu fréquemment rechercher les modifications apportées à des propriétés de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est `true`, dans le cadre de la logique de rendu de l’hôte. Par exemple, le <xref:System.Windows.Controls.TextBox> élément doit répondre à certaines modifications dans le texte qui peut requérir que le cadre englobant de le <xref:System.Windows.Controls.TextBox> lui-même soit modifié.  
  
 Personnalisé <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est `true`.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la disposition générale d’une façon qui n’influence pas spécifiquement l’organisation ou la mesure, mais qui nécessiterait un nouveau dessin.</summary>
        <value>
          <see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent affecte le rendu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> la valeur `true` va lancer une demande différée pour invalider les visuels de cet élément. Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de mise en page de niveau infrastructure WPF.  
  
 Personnalisé <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> est `true`.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées de la dépendance différents champs de propriété, la valeur de différentes des requêtes <xref:System.Windows.FrameworkPropertyMetadata> propriétés et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la propriété établit une liaison bidirectionnelle par défaut.</summary>
        <value>
          <see langword="true" /> si la propriété de dépendance sur laquelle figurent ces métadonnées établit une liaison bidirectionnelle par défaut ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En l’absence de cette propriété en cours de `true`, mises à jour de la liaison sont unidirectionnelles par défaut, en fonction du comportement par défaut de la <xref:System.Windows.Data.Binding> constructeurs ou équivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe.  
  
 Dans les éléments existants, vous trouvez généralement cette propriété définie sur `true` dans les métadonnées pour les propriétés de dépendance qui signalent l’état et sont modifiables par l’utilisateur, par exemple <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 En règle générale, cette propriété indique uniquement les caractéristiques de mise à jour de liaison par défaut de la propriété de dépendance. Toute liaison définie sur cette propriété sur une instance peut définir localement la <xref:System.Windows.Data.Binding.Mode%2A> propriété de la liaison et modifier cette valeur par défaut.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées de la dépendance différents champs de propriété, la valeur de différentes des requêtes <xref:System.Windows.FrameworkPropertyMetadata> propriétés et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur par défaut pour <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> à utiliser lorsque les liaisons pour la propriété avec ces métadonnées sont appliquées, lesquelles ont leur <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> dont la valeur est <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Valeur de l'énumération, autre que <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Cette propriété a la valeur <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> ; la valeur que vous définissez est supposée devenir la valeur par défaut lorsqu'elle est demandée par des liaisons.</exception>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la valeur de la propriété de dépendance peut être héritée.</summary>
        <value>
          <see langword="true" /> si la valeur de propriété peut être héritée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’héritage de valeur de propriété est une fonctionnalité de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés au niveau de l’infrastructure WPF, dans laquelle certaines propriétés de dépendance peuvent être définies localement sur un élément à ou près de la racine d’un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] élément d’arborescence et ont leur valeur héritée par tous les éléments dans l’arborescence logique d’éléments enfants qui possèdent également cette propriété. L’héritage de valeur de propriété n’est pas activé par défaut, et son activation a certaines implications en matière de performances. Pour plus d’informations, consultez [Héritage de la valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Bien que l’héritage de valeur de propriété puisse sembler fonctionner pour les propriétés de dépendance non attachées, le comportement d’héritage d’une propriété non attachée par certaines divisions objet-objet dans l’arborescence d’exécution n’est pas défini. Toujours utiliser <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées de la dépendance différents champs de propriété, la valeur de différentes des requêtes <xref:System.Windows.FrameworkPropertyMetadata> propriétés et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la liaison de données est prise en charge pour la propriété de dépendance.</summary>
        <value>
          <see langword="true" /> si la liaison de données est prise en charge sur la propriété de dépendance à laquelle ces métadonnées s'appliquent ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété signale `false` pour l’une des deux conditions possibles : liaison de données à une propriété de dépendance n’est pas autorisée, car la propriété de dépendance est en lecture seule (comme indiqué dans l’identificateur de propriété de dépendance, pas les métadonnées), ou la valeur de une autre propriété de métadonnées, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, a la valeur `true` dans ces métadonnées. Cette propriété est exposée en tant que pour des raisons pratiques afin que les appelants ne disposent pas activer les deux <xref:System.Windows.DependencyProperty.ReadOnly%2A> et <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Si vous tentez de créer des métadonnées qui spécifie qu’une propriété en lecture/écriture ne doit pas prendre en charge la liaison de données, spécifiez l’indicateur <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Notez la légère différence de convention d’affectation de noms et <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées de la dépendance différents champs de propriété, la valeur de différentes des requêtes <xref:System.Windows.FrameworkPropertyMetadata> propriétés et utilise ces informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la propriété de dépendance prend en charge la liaison de données.</summary>
        <value>
          <see langword="true" /> si la propriété ne prend pas en charge la liaison de données ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que cette propriété de métadonnées a la valeur `true` spécifiquement pour les propriétés qui ne doivent pas prendre en charge la liaison de données, en dépit de propriétés en lecture-écriture. Il est courant que la plupart des cas où une propriété de dépendance est déclarée, liaison de données est souhaitée, car la liaison de données est un des principaux scénarios où une propriété de dépendance est utile. Contrairement à <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, cela ne change pas simplement une valeur par défaut peut être modifiée ultérieurement sur une liaison spécifique. Définition de cette propriété `true` dans les métadonnées pour une propriété de dépendance les métadonnées désactivera toutes les liaisons de l’application de leurs valeurs à travers des expressions à cette propriété de dépendance.  
  
 Propriétés de dépendance en lecture seule ne prennent pas en charge une liaison de données (car ils n’ont aucun accesseur Set peut appliquer des valeurs modifiées), mais ils signalent `false` pour <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. C’est parce que les propriétés qui correspondent à un <xref:System.Windows.FrameworkPropertyMetadataOptions> valeurs signalent la parité de la façon dont les métadonnées étaient réellement établies, au lieu de toujours signaler le comportement de résultat final que la désignation de la propriété peut impliquer. Pour déterminer si une propriété de dépendance donnée autorise la liaison de données, vous devez vérifier généralement <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> à la place. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> est une commodité pour la vérification à la fois <xref:System.Windows.DependencyProperty.ReadOnly%2A> et <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> comme une seule opération, générant le résultat attendu.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si cette propriété contient des informations de journalisation que les applications peuvent ou doivent stocker dans le cadre d’une implémentation de journalisation.</summary>
        <value>
          <see langword="true" /> Si la journalisation doit être effectuée sur la propriété de dépendance ces métadonnées sont appliquées ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Métadonnées de base à fusionner.</param>
        <param name="dp">Propriété de dépendance à laquelle ces métadonnées sont appliquées.</param>
        <summary>Active une fusion des métadonnées sources avec des métadonnées de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée en interne lorsque les métadonnées sont substituées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les classes qui dérivent de <see cref="T:System.Windows.PropertyMetadata" /> (ou cette classe en particulier) doivent substituer cette méthode pour prendre en compte pour toutes les propriétés de métadonnées qu’ils ont ajoutées dans leurs implémentations. Par exemple, votre implémentation peut ajouter une nouvelle valeur de l’énumération d’indicateurs et le <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implémentation doit pouvoir ensuite combiner ces indicateurs correctement.  Appelez toujours l’implémentation de base avant votre propre implémentation, car l’implémentation de base prend en charge de la fusion de toutes les propriétés déjà définies sur les types précédents dans la hiérarchie.  Le comportement ajouté par le <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> mise en œuvre dans <see cref="T:System.Windows.FrameworkPropertyMetadata" /> est que les propriétés de niveau infrastructure WPF spécifiques dans les métadonnées comme <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> sont combinées dans une opération de bits ou l’opération.  Le <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportement implémente également le comportement lorsque vous substituez les métadonnées de propriété sur une propriété de dépendance existante en appelant <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., à l’aide de métadonnées de substitution qui sont <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Propriété de dépendance à laquelle les métadonnées ont été appliquées.</param>
        <param name="targetType">Type associé à ces métadonnées s'il s'agit de métadonnées spécifiques au type. S'il s'agit de métadonnées par défaut, cette valeur peut être <see langword="null" />.</param>
        <summary>Appelé lorsque ces métadonnées ont été appliquées à une propriété qui indique que les métadonnées sont sealed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute mutabilité de la structure de données d’un <xref:System.Windows.FrameworkPropertyMetadata> instance doit être marquée comme étant immuable lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implémentation de cette méthode n’a aucun effet au-delà de l’appel de l’implémentation de base.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l’évaluation de l’héritage de valeur de propriété doit s’étendre sur certaines limites de contenu dans l’arborescence logique d’éléments.</summary>
        <value>
          <see langword="true" /> si l'héritage de la valeur de propriété doit s'étendre sur certaines limites de contenu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces métadonnées signalent une modification de comportement de l’héritage de valeur de propriété rarement appliqué au-delà des limites d’élément spécial parent-enfant de l’élément. L’exemple canonique d’une telle limite est le contenu d’un <xref:System.Windows.Controls.Frame>, où le <xref:System.Windows.Controls.Frame> contenu peut être rechargé indépendamment de l’existence de la <xref:System.Windows.Controls.Frame>. Le comportement de système de propriété de votre choix est que l’héritage de valeur de propriété ne doit pas parcourir le contenu de la <xref:System.Windows.Controls.Frame>, car ces éléments de l’application qui héberge la trame ne possède ni contrôler peut être. Spécification des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> la valeur `true`, ainsi <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en tant que `true`, entraîne la propriété sur laquelle les métadonnées sont appliquées pour être héritées même à travers la <xref:System.Windows.Controls.Frame> limite ou des limites semblables.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les sous-propriétés de la propriété de dépendance n’affectent pas le rendu de l’objet conteneur.</summary>
        <value>
          <see langword="true" /> si les modifications des valeurs de sous-propriété n'affectent pas le rendu si celui-ci est modifié ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette option de métadonnées est pertinente pour les propriétés de dépendance qui sont des types de référence, où ce type a ses propres valeurs de propriété. En règle générale, la logique de système de disposition est de supposer que n’importe quelle propriété de dépendance avec des sous-propriétés peut affecter la disposition, car la vérification de toutes les sous-propriétés de modifications est beaucoup plus de temps que l’exécution une autre passe de rendu. Cette option `true` est utile pour optimiser les performances de l’implémentation de système de disposition de niveau infrastructure WPF.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définis dans le modèle objet en lecture-écriture. Il s’agit afin qu’ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur les métadonnées de cette instance lève une exception.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>