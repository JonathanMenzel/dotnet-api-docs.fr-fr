<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1e91c552a9f1092824655c7f0620903bf1542f2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53474422" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Signale ou applique des métadonnées pour une propriété de dépendance, en ajoutant des caractéristiques de propriétés système spécifiques à l’infrastructure.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe est dérivée de <xref:System.Windows.PropertyMetadata> (via <xref:System.Windows.UIPropertyMetadata>). La plupart des cas de développement d’applications au niveau du framework WPF, <xref:System.Windows.FrameworkPropertyMetadata> est le type utilisé pour les métadonnées de propriété de dépendance, plutôt que les types de métadonnées de base <xref:System.Windows.PropertyMetadata> ou <xref:System.Windows.UIPropertyMetadata>. Cela est vrai pour les propriétés de dépendance existantes et pour la plupart des scénarios de propriété de dépendance personnalisée.  
  
 Les membres déclarés par cette classe qui complètent la <xref:System.Windows.PropertyMetadata> classe de base incluent différentes propriétés booléennes qui spécifient ou le comportement de système de propriété de niveau infrastructure WPF telles que l’héritage de propriété de liaison de données et de mise en page de rapport.  
  
 Plusieurs signatures de constructeur pour créer un <xref:System.Windows.FrameworkPropertyMetadata> instance prennent un <xref:System.Windows.FrameworkPropertyMetadataOptions> paramètre. Le <xref:System.Windows.FrameworkPropertyMetadataOptions> énumération est utilisée uniquement pour spécifier le comportement initial dans le constructeur et n’est pas exposée après <xref:System.Windows.FrameworkPropertyMetadata> est construit. À partir d’une instance construite, vous pouvez obtenir ou définir les informations correspondantes à travers différentes propriétés qui partagent le nom des valeurs d’énumération utilisé dans l’appel de constructeur.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Cette classe n’est généralement pas utilisée dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant obtient des métadonnées pour une propriété de dépendance sur un propriétaire particulier en tant que la première base <xref:System.Windows.PropertyMetadata> type. Ces métadonnées sont castée en <xref:System.Windows.FrameworkPropertyMetadata>. Si la conversion a retourné un valide <xref:System.Windows.FrameworkPropertyMetadata>, puis diverses <xref:System.Windows.FrameworkPropertyMetadata> valeurs de propriété sont signalés via une interface simple (non illustrée).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette signature initialise toutes les valeurs de <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> à leurs valeurs par défaut de la propriété. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sera `null`et les différentes <xref:System.Windows.FrameworkPropertyMetadata> propriétés booléennes sera `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec le rappel <see cref="T:System.Windows.PropertyChangedCallback" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez ensuite modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’ont pas encore été appliquées à une opération de système de propriétés spécifiques.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut fournie et le rappel <see cref="T:System.Windows.PropertyChangedCallback" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Une référence à l'implémentation d'un gestionnaire sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> pour cette propriété de dépendance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation appelle un initialiseur de base, puis ajoute le `coerceValueCallback` en définissant la propriété sur l’instance de base.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme valeur d'un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, et le rappel <see cref="T:System.Windows.PropertyChangedCallback" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’ont pas encore été appliquées à une opération de système de propriétés spécifiques.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> pour cette propriété de dépendance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut fournie et les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> à l'aide de cette propriété.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, et les rappels spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’ont pas encore été appliquées à une opération de système de propriétés spécifiques.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> sur cette propriété de dépendance.</param>
        <param name="isAnimationProhibited"><see langword="true" /> pour éviter que le système de propriétés anime la propriété à laquelle ces métadonnées sont appliquées. De telles propriétés déclenchent une exception runtime qui provient du système de propriétés si des tentatives d'animation ont lieu. <see langword="false" /> pour autoriser l'animation de la propriété. La valeur par défaut est <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, les rappels spécifiés et une valeur booléenne qui peut être utilisée pour empêcher l'animation de la propriété.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Le `isAnimationProhibited` paramètre définit la valeur initiale de la <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriété déclarée par la base immédiate <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’ont pas encore été appliquées à une opération de système de propriétés spécifiques.  
  
   
  
## Examples  
 L’exemple suivant appelle cette signature de constructeur :  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut de la propriété de dépendance, habituellement fournie comme un type spécifique.</param>
        <param name="flags">Indicateurs d'option de métadonnées (combinaison des valeurs <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Ces options spécifient les caractéristiques de la propriété de dépendance qui interagissent avec les systèmes tels qu'une présentation ou une liaison de données.</param>
        <param name="propertyChangedCallback">Référence à l'implémentation d'un gestionnaire que le système de propriétés appelle à chaque fois que la valeur effective de la propriété change.</param>
        <param name="coerceValueCallback">Référence à l'implémentation d'un gestionnaire qui sera appelée à chaque fois que le système de propriétés appelle <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> à l'aide de cette propriété.</param>
        <param name="isAnimationProhibited"><see langword="true" /> pour éviter que le système de propriétés anime la propriété à laquelle ces métadonnées sont appliquées. De telles propriétés déclenchent une exception runtime qui provient du système de propriétés si des tentatives d'animation ont lieu. La valeur par défaut est <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" /> à utiliser lorsque les liaisons pour cette propriété sont appliquées et dont la valeur de leur <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> est <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> avec la valeur par défaut et les options de métadonnées au niveau de l'infrastructure fournies, les rappels spécifiés, une valeur booléenne qui peut être utilisée pour empêcher l'animation de la propriété, et un déclencheur de mise à jour de liaison de données par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de la valeur fournie pour `defaultValue` doit correspondre ou être lié au type spécifié dans l’inscription d’origine de la propriété de dépendance qui s’appliqueront à ces métadonnées. Les incompatibilités entre le type de valeur par défaut de métadonnées et le type de la propriété de dépendance qu'il est appliqué peuvent être difficiles à déboguer, car elles ne sont pas détectables pendant la compilation. Le système de propriétés n’évalue pas la valeur effective d’une propriété jusqu’au moment de l’exécution, le résultat d’une incompatibilité de type de types et des propriétés de valeur par défaut est une erreur d’exécution.  
  
 La valeur <xref:System.Windows.DependencyProperty.UnsetValue> a une signification spéciale dans le système de propriétés et ne peut pas être utilisé comme une valeur par défaut de propriété de dépendance.  
  
 Le `isAnimationProhibited` paramètre définit la valeur initiale de la <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriété déclarée par la base immédiate <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Pour plus d’informations sur le comportement de source de mise à jour pour les liaisons, consultez [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Les valeurs marquées comme indicateurs définis dans le `flags` paramètre définit la valeur booléenne de <xref:System.Windows.FrameworkPropertyMetadata> propriétés qui correspondent au <xref:System.Windows.FrameworkPropertyMetadataOptions> nom de cet indicateur `true`. Vous pouvez toujours modifier les valeurs des propriétés dans les métadonnées, tant que les métadonnées n’ont pas encore été appliquées à une opération de système de propriétés spécifiques.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> a la valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de réorganisation durant les opérations du moteur de disposition.</summary>
        <value><see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de réorganisation ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> définie sur `true` lance une demande différée pour invalider les visuels de cet élément (un appel à <xref:System.Windows.UIElement.InvalidateArrange%2A>). Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de disposition de niveau framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> est `true`.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées à partir de la dépendance différents champs de propriété, interroge la valeur de divers <xref:System.Windows.FrameworkPropertyMetadata> propriétés dessus et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de mesure pendant des opérations du moteur de présentation.</summary>
        <value><see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de mesure ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> la valeur `true` lance une demande différée pour invalider les visuels de cet élément. Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de disposition de niveau framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> est `true`.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées à partir de la dépendance différents champs de propriété, interroge la valeur de divers <xref:System.Windows.FrameworkPropertyMetadata> propriétés dessus et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de réorganisation de la disposition de son élément parent durant les opérations du moteur de disposition.</summary>
        <value><see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de réorganisation spécifiquement sur son élément parent ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> la valeur `true` lance une demande différée pour invalider les visuels de l’élément parent.  
  
 En règle générale, vous n’avez pas besoin pour signaler les modifications d’un <xref:System.Windows.FrameworkElement> propriété à un élément parent à l’aide <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , car l’élément lui-même aurait déjà son propre <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> comme `true`. C’est généralement suffisant, car les modifications dans l’élément enfant déclenchent généralement une organisation du parent lorsque cela est approprié. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> est parfois utilisé pour un <xref:System.Windows.FrameworkContentElement> classe dérivée. Dans ce cas, l’élément enfant définit une propriété, mais qu’un <xref:System.Windows.FrameworkContentElement> classe dérivée ne contrôle pas son propre rendu. Le rendu est géré par un <xref:System.Windows.FrameworkElement> élément parent qui sert de l’hôte de contenu. Par exemple, une modification à la valeur de la <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propriété jointe par un élément enfant invalide organisation du parent, parce que la position de l’enfant dans le parent doit être modifiée. Par conséquent, le <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propriété jointe possède des métadonnées où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> est `true`. Un autre exemple est <xref:System.Windows.Controls.Control.Padding%2A>; lorsque cette propriété change, le parent peut modifier le positionnement de l’enfant, en fonction de l’espace disponible.  
  
 Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de disposition de niveau framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> est `true`.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la passe de mesure de la disposition de son élément parent durant les opérations du moteur de disposition.</summary>
        <value><see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent peut affecter la passe de mesure spécifiquement sur son élément parent ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> la valeur `true` lance une demande différée pour invalider les visuels de l’élément parent. Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de disposition de niveau framework WPF.  
  
 En règle générale, vous n’avez pas besoin pour signaler les modifications d’un <xref:System.Windows.FrameworkElement> propriété à un élément parent à l’aide <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , car l’élément lui-même aurait déjà son propre <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> comme `true`. Qui est généralement suffisant, car les modifications dans l’élément enfant déclenchent généralement une passe de mesure parent lorsque cela est approprié. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est parfois utilisé pour un <xref:System.Windows.FrameworkContentElement> classe dérivée. Dans ce cas, l’élément enfant définit une propriété, mais qu’un <xref:System.Windows.FrameworkContentElement> classe dérivée ne contrôle pas son propre rendu. Le rendu est géré par un <xref:System.Windows.FrameworkElement> élément parent qui sert de l’hôte de contenu. Par exemple, une modification à la valeur de la <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriété par un élément enfant invalide la mesure du parent, étant donné que l’espacement relatif des paragraphes peut changer et peut augmenter ou diminuer la taille de l’hôte de contenu. Par conséquent, le <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriété possède des métadonnées où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est `true`.  
  
 Éléments de l’hôte de contenu recherchez aussi fréquemment des modifications dans les propriétés de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est `true`, dans le cadre de la logique de rendu d’hôte de contenu. Par exemple, le <xref:System.Windows.Controls.TextBox> élément doit répondre à certaines modifications dans le texte qui peut requérir que le cadre englobant de la <xref:System.Windows.Controls.TextBox> lui-même soit modifié.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> est `true`.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une propriété de dépendance peut affecter la disposition générale d’une façon qui n’influence pas spécifiquement l’organisation ou la mesure, mais qui nécessiterait un nouveau dessin.</summary>
        <value><see langword="true" /> si la propriété de dépendance sur laquelle ces métadonnées existent affecte le rendu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> et <xref:System.Windows.FrameworkContentElement> incluent une implémentation de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> qui surveille les modifications de valeur effective de toutes les propriétés de dépendance qui existent sur un élément. Dans le cadre de cette logique, des propriétés de dépendance qui modifient l’effet valeur et qui ont des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> la valeur `true` lance une demande différée pour invalider les visuels de cet élément. Étant donné que cette implémentation de niveau infrastructure WPF est déjà en place, en général inutile rechercher des propriétés de dépendance avec <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> , sauf si vous sont essentiellement de remplacer ou de modifier le comportement de disposition de niveau framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implémentations peuvent choisir d’avoir un comportement similaire pour les modifications de propriété de dépendance où <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> est `true`.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées à partir de la dépendance différents champs de propriété, interroge la valeur de divers <xref:System.Windows.FrameworkPropertyMetadata> propriétés dessus et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la propriété établit une liaison bidirectionnelle par défaut.</summary>
        <value><see langword="true" /> si la propriété de dépendance sur laquelle figurent ces métadonnées établit une liaison bidirectionnelle par défaut ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En l’absence de cette propriété en cours `true`, mises à jour de liaison sont unidirectionnelles par défaut, en fonction du comportement par défaut de la <xref:System.Windows.Data.Binding> constructeurs ou équivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe.  
  
 Dans les éléments existants, vous trouverez généralement cette propriété définie sur `true` dans les métadonnées pour les propriétés de dépendance qui signalent l’état et sont modifiables par l’utilisateur, par exemple <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 En règle générale, cette propriété signale uniquement les caractéristiques de mise à jour de liaison par défaut de la propriété de dépendance. Toute liaison définie sur cette propriété sur une instance peut définir localement la <xref:System.Windows.Data.Binding.Mode%2A> propriété de la liaison et modifier cette valeur par défaut.  
  
 Propriétés de toutes les classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées à partir de la dépendance différents champs de propriété, interroge la valeur de divers <xref:System.Windows.FrameworkPropertyMetadata> propriétés dessus et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur par défaut pour <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> à utiliser lorsque les liaisons pour la propriété avec ces métadonnées sont appliquées, lesquelles ont leur <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> dont la valeur est <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Valeur de l'énumération, autre que <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Cette propriété a la valeur <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> ; la valeur que vous définissez est supposée devenir la valeur par défaut lorsqu'elle est demandée par des liaisons.</exception>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la valeur de la propriété de dépendance peut être héritée.</summary>
        <value><see langword="true" /> si la valeur de la propriété peut être héritée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’héritage de valeur de propriété est une fonctionnalité de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés au niveau du framework WPF, par laquelle certaines propriétés de dépendance peuvent être définies localement sur un élément à ou près de la racine un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] élément d’arborescence et ont leur valeur héritée par tous les éléments dans l’arborescence logique d’éléments enfants qui possèdent également cette propriété. L’héritage de valeur de propriété n’est pas activé par défaut, et son activation a certaines conséquences sur les performances. Pour plus d’informations, consultez [Héritage de la valeur de propriété](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Bien que l’héritage de valeur de propriété peut sembler fonctionner pour les propriétés de dépendance non jointes, le comportement de l’héritage d’une propriété non jointes par certaines divisions objet-objet dans l’arborescence d’exécution est indéfini. Utilisez toujours <xref:System.Windows.DependencyProperty.RegisterAttached%2A> pour inscrire des propriétés où vous spécifiez <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> dans les métadonnées.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées à partir de la dépendance différents champs de propriété, interroge la valeur de divers <xref:System.Windows.FrameworkPropertyMetadata> propriétés dessus et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la liaison de données est prise en charge pour la propriété de dépendance.</summary>
        <value><see langword="true" /> si la liaison de données est prise en charge sur la propriété de dépendance à laquelle ces métadonnées s’appliquent ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété signale `false` pour l’une des deux conditions possibles : liaison de données à une propriété de dépendance n’est pas autorisée, car la propriété de dépendance est en lecture seule (comme indiqué dans l’identificateur de propriété de dépendance, pas les métadonnées), ou la valeur de une autre propriété de métadonnées, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, a la valeur `true` dans ces métadonnées. Cette propriété est exposée en tant que pour des raisons pratiques afin que les appelants n’aient pas à vérifier les deux <xref:System.Windows.DependencyProperty.ReadOnly%2A> et <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Si vous essayez de créer des métadonnées qui spécifie qu’une propriété en lecture/écriture ne doit pas prendre en charge la liaison de données, spécifiez l’indicateur <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Notez la légère différence de convention d’affectation de noms et <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L’exemple suivant récupère les métadonnées à partir de la dépendance différents champs de propriété, interroge la valeur de divers <xref:System.Windows.FrameworkPropertyMetadata> propriétés dessus et utilise les informations pour remplir une table pour implémenter un « navigateur de métadonnées ».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la propriété de dépendance prend en charge la liaison de données.</summary>
        <value><see langword="true" /> si la propriété ne prend pas en charge la liaison de données ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que cette propriété de métadonnées est définie sur `true` spécifiquement pour les propriétés qui ne doivent pas prendre en charge la liaison de données, en dépit d’en cours de propriétés en lecture-écriture. L’attente est que dans la plupart des cas où une propriété de dépendance est déclarée, liaison de données est souhaitée, car la liaison de données est un des principaux scénarios où une propriété de dépendance est utile. Contrairement à <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, cela ne change pas simplement une valeur par défaut qui peut être modifié ultérieurement sur une liaison spécifique. Définition de cette propriété `true` dans les métadonnées pour une propriété de dépendance les métadonnées désactivera toutes les liaisons de l’application de leurs valeurs via des expressions à cette propriété de dépendance.  
  
 Propriétés de dépendance en lecture seule ne prennent pas en charge une liaison de données (parce qu’elles n’ont pas d’accesseur Set qui peuvent appliquer des valeurs modifiées), mais ils signalent `false` pour <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Il s’agit, car les propriétés qui correspondent à un <xref:System.Windows.FrameworkPropertyMetadataOptions> valeurs signalent la parité de la façon dont les métadonnées a été réellement établies, au lieu de toujours signaler le comportement de résultat final que la désignation de la propriété peut impliquer. Pour déterminer si une propriété de dépendance donnée autorise la liaison de données, vous devez vérifier généralement <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> à la place. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> est une commodité pour la vérification à la fois <xref:System.Windows.DependencyProperty.ReadOnly%2A> et <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> comme une seule opération, on obtient le résultat attendu.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si cette propriété contient des informations de journalisation que les applications peuvent ou doivent stocker dans le cadre d’une implémentation de journalisation.</summary>
        <value><see langword="true" /> si la journalisation doit être exécutée sur la propriété de dépendance à laquelle ces métadonnées sont appliquées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Métadonnées de base à fusionner.</param>
        <param name="dp">Propriété de dépendance à laquelle ces métadonnées sont appliquées.</param>
        <summary>Active une fusion des métadonnées sources avec des métadonnées de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée en interne lorsque les métadonnées sont substituées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les classes qui dérivent de <see cref="T:System.Windows.PropertyMetadata" /> (ou cette classe en particulier) doivent substituer cette méthode pour prendre en compte pour les propriétés de métadonnées qu’ils ont ajoutées dans leurs implémentations. Par exemple, votre implémentation peut ajouter une nouvelle valeur d’énumération d’indicateurs et le <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implémentation doit ensuite être en mesure de combiner ces indicateurs correctement.  
  
Appelez toujours l’implémentation de base avant votre propre implémentation, car l’implémentation de base prend en charge de la fusion de toutes les propriétés déjà définies sur des types précédents dans la hiérarchie.  
  
Le comportement ajouté par le <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> mise en œuvre dans <see cref="T:System.Windows.FrameworkPropertyMetadata" /> est que les propriétés de niveau infrastructure WPF spécifiques dans les métadonnées comme <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> sont combinées dans une opération de bits ou opération.  
  
Le <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportement implémente également le comportement lorsque vous substituez les métadonnées de propriété sur une propriété de dépendance existante en appelant <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, à l’aide de métadonnées de remplacement sont <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Propriété de dépendance à laquelle les métadonnées ont été appliquées.</param>
        <param name="targetType">Type associé à ces métadonnées s'il s'agit de métadonnées spécifiques au type. S'il s'agit de métadonnées par défaut, cette valeur peut être <see langword="null" />.</param>
        <summary>Appelé lorsque ces métadonnées ont été appliquées à une propriété qui indique que les métadonnées sont sealed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute mutabilité de la structure de données d’un <xref:System.Windows.FrameworkPropertyMetadata> instance doit être marquée comme immuable lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Le <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implémentation de cette méthode n’a aucun effet au-delà de l’appel de l’implémentation de base.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l’évaluation de l’héritage de valeur de propriété doit s’étendre sur certaines limites de contenu dans l’arborescence logique d’éléments.</summary>
        <value><see langword="true" /> si l’héritage de valeur de propriété doit s’étendre sur certaines limites de contenu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces métadonnées signalent une modification rarement appliqué au comportement d’héritage de valeur de propriété entre les limites d’éléments enfants de l’élément parent spécial. L’exemple canonique d’une telle limite est le contenu d’un <xref:System.Windows.Controls.Frame>, où le <xref:System.Windows.Controls.Frame> contenu peut être rechargé indépendamment de l’existence de la <xref:System.Windows.Controls.Frame>. Le comportement de système de propriété souhaitée est que l’héritage de valeur de propriété ne doit pas parcourir le contenu de la <xref:System.Windows.Controls.Frame>, car ces peut être des éléments de l’application qui héberge le frame de ne pas posséder ou contrôler. Spécifiant des métadonnées avec <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> définie sur `true`, ainsi que la spécification <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> comme `true`, entraîne la propriété sur laquelle les métadonnées sont appliquées pour qu’elle soit héritable même lorsque les le <xref:System.Windows.Controls.Frame> limite ou des limites semblables.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les sous-propriétés de la propriété de dépendance n’affectent pas le rendu de l’objet conteneur.</summary>
        <value><see langword="true" /> si les valeurs de sous-propriété n’affectent pas le rendu si elles sont modifiées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette option de métadonnées est pertinente pour les propriétés de dépendance qui sont des types de référence, où ce type a ses propres valeurs de propriété. En règle générale, la logique de système de disposition est de supposer que n’importe quelle propriété de dépendance avec des sous-propriétés peut affecter la disposition, car il est beaucoup plus de temps que l’exécution de la vérification de toutes les sous-propriétés pour les modifications une autre passe de rendu. Définir cette option sur `true` est utile pour optimiser les performances de l’implémentation de système de disposition de niveau framework WPF.  
  
 Propriétés des classes dérivées de <xref:System.Windows.PropertyMetadata> sont généralement définies dans le modèle objet en lecture-écriture. Il s’agit donc ils peuvent être ajustées après initialisation de l’instance. Toutefois, une fois que les métadonnées sont consommées dans le cadre d’un appel à <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, le système de propriétés scelle l’instance des métadonnées et propriétés qui transmettent les caractéristiques des métadonnées sont maintenant considérées comme immuables. Tentative de définition de cette propriété après <xref:System.Windows.PropertyMetadata.IsSealed%2A> est `true` sur ces métadonnées instance lève une exception.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Membres de cette classe ne sont généralement pas utilisés dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Les métadonnées ont déjà été appliquées à une opération de propriété de dépendance : elles sont donc sealed et les propriétés des métadonnées ne peuvent pas être définies.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>