<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cdad856ca1190b53eeb702e6825901cbd349d2ed" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55320237" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un objet qui participe au système des propriétés de dépendance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.DependencyObject> classe active [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] services de système de propriétés sur ses nombreuses classes dérivées.  
  
 Fonction principale du système de propriétés consiste à calculer les valeurs des propriétés et pour fournir une notification système sur les valeurs qui ont été modifiés. Une autre classe clé qui est inclus dans le système de propriétés est <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> Active l’inscription de propriétés de dépendance dans le système de propriétés et fournit des informations d’identification et sur chaque propriété de dépendance, tandis que <xref:System.Windows.DependencyObject> comme une classe de base permet aux objets d’utiliser les propriétés de dépendance.  
  
 <xref:System.Windows.DependencyObject> services et les caractéristiques suivantes :  
  
-   Prise en charge l’hébergement de propriété de dépendance. Vous inscrivez une propriété de dépendance en appelant le <xref:System.Windows.DependencyProperty.Register%2A> (méthode) et en stockant la valeur de retour de la méthode comme un champ statique public dans votre classe.  
  
-   Prise en charge de l’hébergement de la propriété jointe. Vous inscrivez une propriété jointe en appelant le <xref:System.Windows.DependencyProperty.RegisterAttached%2A> (méthode) et en stockant la valeur de retour de la méthode comme un champ statique public en lecture seule dans votre classe. (Il existe également des spécifications de membre supplémentaires ; Notez que cela représente un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implémentation spécifique pour les propriétés jointes. Pour plus d’informations, consultez [vue d’ensemble des propriétés jointes](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Votre propriété jointe peut ensuite être définie sur n’importe quelle classe qui dérive de <xref:System.Windows.DependencyObject>.  
  
-   Get, set et supprimez des méthodes utilitaires pour les valeurs de toutes les propriétés de dépendance qui existent sur le <xref:System.Windows.DependencyObject>.  
  
-   Métadonnées, forcer la prise en charge de la valeur, la notification de modification de propriété et les rappels de remplacement pour les propriétés de dépendance ou des propriétés jointes. En outre, la <xref:System.Windows.DependencyObject> classe facilite les métadonnées de propriété par propriétaire pour une propriété de dépendance.  
  
-   Une classe de base commune pour les classes dérivées de <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, ou <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, une autre classe d’élément de base, a une hiérarchie de classes qui inclut <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 L’exemple suivant dérive <xref:System.Windows.DependencyObject> pour créer une classe abstraite. Ensuite, la classe inscrit une propriété jointe et inclut la prise en charge des membres de cette propriété jointe.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Efface la valeur locale d’une propriété.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Propriété de dépendance à effacer, identifiée par une référence d’objet <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Efface la valeur locale d’une propriété. La propriété à effacer est spécifiée par un identificateur <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Effacement de la valeur de propriété en appelant <xref:System.Windows.DependencyObject.ClearValue%2A> ne donne pas nécessairement une propriété de dépendance la valeur par défaut qui est spécifiée dans les métadonnées de propriété de dépendance. Désactivez la propriété uniquement spécifiquement efface toute valeur de proximité ont pu être appliqué. Pour plus d’informations, consultez [Priorité de la valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 L’exemple suivant itère toutes les propriétés qui ont des valeurs locales définies sur un objet, puis appelle <xref:System.Windows.DependencyObject.ClearValue%2A> pour effacer les valeurs de chacune de ces propriétés.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentative d’appel à <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> sur un <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de la propriété de dépendance à effacer.</param>
        <summary>Efface la valeur locale d’une propriété en lecture seule. La propriété à effacer est spécifiée par <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyPropertyKey> identifie une propriété de dépendance en lecture seule pour les opérations de système de propriétés. Les classes qui définissent les propriétés de dépendance en lecture seule ne doivent pas exposer cette clé avec un accès public. Une clé exposée publiquement fournirait une voie d’accès de code publique qui inverser le caractère en lecture seule de la propriété, si des méthodes telles que <xref:System.Windows.DependencyObject.ClearValue%2A> ou <xref:System.Windows.DependencyObject.SetValue%2A> peut être appelée en dehors de la classe ou d’un assembly, en référençant la clé.  
  
 Effacement de la valeur de propriété en appelant <xref:System.Windows.DependencyObject.ClearValue%2A> ne donne pas nécessairement une propriété de dépendance la valeur par défaut qui est spécifiée dans les métadonnées de propriété de dépendance. Effacement de la valeur uniquement spécifiquement efface toute valeur de proximité ont pu être appliqué. Pour plus d’informations, consultez [Priorité de la valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentative d’appel à <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> sur un <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificateur de la propriété de dépendance à forcer.</param>
        <summary>Convertit la valeur de la propriété de dépendance spécifiée. Pour cela, on appelle toute fonction <see cref="T:System.Windows.CoerceValueCallback" /> spécifiée dans les métadonnées de propriété pour la propriété de dépendance telle qu’elle existe sur le <see cref="T:System.Windows.DependencyObject" /> appelant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En plus d’être appelé explicitement via l’appel <xref:System.Windows.DependencyObject.CoerceValue%2A>, le <xref:System.Windows.CoerceValueCallback> pour une dépendance de la propriété est également appelée en interne chaque fois que la valeur de propriété de dépendance est réévaluée par le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés.  
  
 Lorsque vous appelez le <xref:System.Windows.DependencyObject.CoerceValue%2A> (méthode), vous appelez finalement le rappel de forçage de valeur pour la propriété que vous spécifiez. En règle générale, vous appellerez <xref:System.Windows.DependencyObject.CoerceValue%2A> uniquement si vous savez qu’un rappel de valeur forcée existe, et si vous connaissez les critères du rappel pour la contrainte.  
  
 Le scénario le plus courant d’appeler <xref:System.Windows.DependencyObject.CoerceValue%2A> se trouve dans la classe manipulation ou propriété les rappels de modification des propriétés connexes qui influencent les valeurs entre eux de façon dépendante. Pour plus d’informations, consultez [Validation et rappels de propriétés de dépendance](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 L’exemple suivant appelle <xref:System.Windows.DependencyObject.CoerceValue%2A> au sein d’un <xref:System.Windows.PropertyChangedCallback> implémentation qui est utilisée comme le <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> un différentes propriétés de dépendance sur la même classe. Il s’agit d’un modèle courant pour introduire des dépendances de la valeur true entre les propriétés de dépendance.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <paramref name="dp" /> spécifié ou sa valeur n’est pas valide ou n’existe pas.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.DependencyObjectType" /> qui encapsule le type [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] de cette instance.</summary>
        <value>Un <see cref="T:System.Windows.DependencyObjectType" /> qui encapsule le type [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] de cette instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utile si un objet qui est retourné à partir d’une méthode a un type de valeur de retour de <xref:System.Windows.DependencyObject> et que vous souhaitez effectuer des opérations de système de propriétés spécifiques dessus selon son type. Par exemple, il est plus efficace d’appeler <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> à l’aide de la <xref:System.Windows.DependencyObjectType> plutôt que [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] type. <xref:System.Windows.DependencyObjectType> facilite la recherche plus rapide.  
  
   
  
## Examples  
 Dans l’exemple de pseudo-code suivant, `MySubClass` anticipe que les classes dérivées supplémentaires peuvent modifier la valeur par défaut de la `MyCustom` propriété de dépendance. La classe implémente un constructeur par défaut qui peut déterminer la classe dérivée réelle en tirant parti du polymorphisme la <xref:System.Windows.DependencyObjectType> valeur chaque fois que ce constructeur est utilisé comme instanciateur de classe dérivée.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.DependencyObject" /> à comparer à l'instance en cours.</param>
        <summary>Détermine si un <see cref="T:System.Windows.DependencyObject" /> fourni est équivalent au <see cref="T:System.Windows.DependencyObject" /> réel.</summary>
        <returns><see langword="true" /> si les deux instances sont identiques ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation est une égalité de référence uniquement et n’essaie pas d’évaluer l’égalité des valeurs des propriétés de relation contenant-contenues.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> substitue et puis scelle deux basic <see cref="T:System.Object" /> méthodes : <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> et <see cref="M:System.Windows.DependencyObject.GetHashCode" />. L’appel de remplacements le <see cref="T:System.Object" /> implémentations, ce qui entraîne un comportement de l’égalité d’objet. L’objectif de ces substitutions délibérées consiste à empêcher les classes dérivées d’essayer de définir une égalité de valeur pour un <see cref="T:System.Windows.DependencyObject" />. Égalités de valeur pour <see cref="T:System.Windows.DependencyObject" /> ne seront jamais exactes en raison des capacités de modification de valeur de propriété intégrée dès le départ d’un <see cref="T:System.Windows.DependencyObject" /> et ses propriétés de dépendance. Cela inclut les fondamentaux [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fonctionnalités telles que la liaison de données et la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un code de hachage pour ce <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Code de hachage d’un entier 32 bits signé.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> substitue et puis scelle deux <see cref="T:System.Object" /> méthodes : <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> et <see cref="M:System.Windows.DependencyObject.GetHashCode" />. L’appel de remplacements le <see cref="T:System.Object" /> implémentations, ce qui entraîne un comportement de l’égalité d’objet. L’objectif de ces substitutions délibérées consiste à empêcher les classes dérivées d’essayer de définir une égalité de valeur pour un <see cref="T:System.Windows.DependencyObject" />. Égalités de valeur pour <see cref="T:System.Windows.DependencyObject" /> ne seront jamais exactes en raison des capacités de modification de valeur de propriété intégrée dès le départ d’un <see cref="T:System.Windows.DependencyObject" /> et ses propriétés de dépendance. Cela inclut les fondamentaux [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fonctionnalités telles que la liaison de données et la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un énumérateur spécialisé pour déterminer quelles propriétés de dépendance ont des valeurs définies localement sur ce <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Un énumérateur de valeur de proximité spécialisé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *valeur locale* est toute valeur de propriété de dépendance qui a été défini par <xref:System.Windows.DependencyObject.SetValue%2A>, contrairement à d’autres aspects du système de propriétés.  
  
 Le <xref:System.Windows.LocalValueEnumerator> obtenu en appelant <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> peut être utilisé pour énumérer les propriétés qui ont un définie localement valeur sur un <xref:System.Windows.DependencyObject> instance. Chacune de ces propriétés est représentée dans l’énumérateur par un <xref:System.Windows.LocalValueEntry> object, qui a des propriétés qui référencent les spécifiques <xref:System.Windows.DependencyProperty> et ses valeurs. Cette technique d’énumération sur définie localement valeurs peuvent être utilisées pour l’optimisation ou pour une autre gestion de valeurs de proximité, comme pour déterminer quelles valeurs de propriété d’un <xref:System.Windows.DependencyObject> pourrait être modifié si elles ont été effacées.  
  
> [!IMPORTANT]
>  Retourné <xref:System.Windows.LocalValueEnumerator> peut contenir <xref:System.Windows.LocalValueEntry> enregistrements pour les propriétés de dépendance qui sont en lecture seule, ou les propriétés de dépendance où les valeurs sont calculées par le système de propriétés. Par exemple, un élément d’infrastructure visuel qui a une largeur établie via la mise en page signalera une valeur locale pour <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Si vous obtenez des valeurs locales pour les réinitialiser, vérifiez la <xref:System.Windows.DependencyProperty.ReadOnly%2A> valeur sur l’identificateur de propriété de chaque <xref:System.Windows.LocalValueEntry> pour vérifier que le <xref:System.Windows.DependencyProperty> en question n’est pas en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant itère toutes les propriétés qui ont des valeurs locales définies sur un objet, puis appelle <xref:System.Windows.DependencyObject.ClearValue%2A> pour effacer les valeurs de chacune de ces propriétés.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificateur <see cref="T:System.Windows.DependencyProperty" /> de la propriété pour laquelle récupérer la valeur.</param>
        <summary>Retourne la valeur effective actuelle d’une propriété de dépendance sur cette instance d’un <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Retourne la valeur effective actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le *valeur effective* est la valeur de la propriété qui est retournée par le système de propriétés à tout appelant qui demande la valeur. La valeur effective est le résultat du système de propriétés ayant évalué toutes les entrées possibles qui participent à la priorité de valeur de propriété système. Cela inclut la contrainte et l’animation. Pour plus d’informations, consultez [Priorité de la valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Cette méthode ne retourne jamais <xref:System.Windows.DependencyProperty.UnsetValue>. Le <xref:System.Windows.DependencyProperty.UnsetValue> est une valeur de sentinelle pour le système de propriétés qui est utilisée dans plusieurs fonctions en interne et parfois également exposées via des rappels de forçage de type.  
  
 Si vous n’êtes pas sûr de ce qui doit être le type de propriété, vous pouvez interroger l’identificateur de la propriété de dépendance demandée pour déterminer s’il existe un plus spécifique <xref:System.Windows.DependencyProperty.PropertyType%2A> qui la valeur de retour peut être convertie en.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <paramref name="dp" /> spécifié ou sa valeur n’était pas valide, ou le <paramref name="dp" /> spécifié n’existe pas.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">L'identificateur <see cref="T:System.Windows.DependencyProperty" /> de la propriété à invalider.</param>
        <summary>Réévalue la valeur effective pour la propriété de dépendance spécifiée</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, toute associées et applicables <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> fonctions enregistrées pour cette propriété de dépendance peuvent être appelées.  
  
 Appel de <xref:System.Windows.DependencyObject.InvalidateProperty%2A> sur une propriété a la valeur locale définie aura aucun effet, car la valeur locale est prioritaire sur les autres entrées de système de propriétés, à l’exception des animations. Toutefois, vous pouvez appeler <xref:System.Windows.DependencyObject.ClearValue%2A>, puis appelez <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Pour plus d’informations, consultez [Priorité de la valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Appel <xref:System.Windows.DependencyObject.InvalidateProperty%2A> n’est pas nécessairement applicable pour de nombreux scénarios de propriété de dépendance. Si une propriété de dépendance est invalidée en raison des modifications de valeur dans un des composants, le système de propriétés invalide et réévalue automatiquement la propriété de dépendance. Toutefois, il existe toujours des scénarios appropriés où <xref:System.Windows.DependencyObject.InvalidateProperty%2A> est utile. En particulier, vous pouvez utiliser <xref:System.Windows.DependencyObject.InvalidateProperty%2A> à l’intérieur de la valeur forcée ou la propriété rappel de modification pour une propriété de dépendance différente. Vous pouvez également utiliser <xref:System.Windows.DependencyObject.InvalidateProperty%2A> pour forcer la réévaluation d’une liaison par rapport à une source de données qui n’est pas en mesure d’implémenter l’architecture recommandée <xref:System.ComponentModel.INotifyPropertyChanged> mécanisme de notification (par exemple si l’utilisation des classes de données qui ne peut pas être dérivé ou où les données sont de type statique membre).  
  
   
  
## Examples  
 L’exemple suivant appelle <xref:System.Windows.DependencyObject.InvalidateProperty%2A> sur une propriété personnalisée, chaque fois que modifier les propriétés qui sont impliquées dans les calculs de la propriété invalidée. Il s’agit d’une autre technique à appeler le <xref:System.Windows.DependencyObject.CoerceValue%2A> méthode, car l’invalidation de la propriété appellera également tout inscrite <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère une valeur qui indique si cette instance est actuellement sealed (en lecture seule).</summary>
        <value><see langword="true" /> si cette instance est sealed ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est définie en interne.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d’événement qui contiennent l’identificateur de propriété de dépendance présentant un intérêt, les métadonnées de propriété pour le type ainsi que les valeurs anciennes et nouvelles.</param>
        <summary>Méthode appelée chaque fois que la valeur effective d’une propriété de dépendance de ce <see cref="T:System.Windows.DependencyObject" /> est mise à jour. La propriété de dépendance spécifique qui a changé est signalée dans les données d’événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas destinée à généralement détecter les modifications apportées aux propriétés individuelles ou effectuer des invalidations de propriétés au cas par cas. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> au lieu de cela concerne les modifications du modèle d’invalidation général, si certaines informations sont connues de larges classifications de propriétés. Par exemple, les modifications dans un <xref:System.Windows.Freezable> peuvent être des modifications dans les types de valeur de la <xref:System.Windows.Freezable>, ou peuvent être des sous-propriétés, où les modifications sont dans d’autres <xref:System.Windows.Freezable> références. Le <xref:System.Windows.Freezable> substituer l’implémentation de <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> utilise des informations internes pour déterminer si les propriétés sont des sous-propriétés et fournit la logique de la classe de base appropriée dans les deux cas.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> est appelé potentiellement plusieurs fois pendant la durée de vie d’un objet. Par conséquent, vous pouvez obtenir de meilleures performances pour le système de propriétés global si vous substituez les métadonnées de propriétés spécifiques puis attachez <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> fonctions pour les propriétés individuelles. Toutefois, vous utiliseriez cette méthode si un <xref:System.Windows.DependencyObject> inclut un nombre important de propriétés de dépendance mises en corrélation par valeur, ou si elle inclut la logique comme comportement de rendu qui doit être réexécuté pour plusieurs cas d’invalidations de propriétés connexes.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Appelez toujours l’implémentation de base. Entier sera considérablement désactivé dans le cas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés, à l’origine du signalement des valeurs incorrectes.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificateur <see cref="T:System.Windows.DependencyProperty" /> de la propriété pour laquelle récupérer la valeur.</param>
        <summary>Retourne la valeur locale d’une propriété de dépendance, si elle existe.</summary>
        <returns>Retourne la valeur locale ou la valeur de la sentinelle <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> si aucune valeur locale n’est définie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez utiliser <xref:System.Windows.DependencyObject.GetValue%2A> pour les opérations « get » plus courantes pour une propriété de dépendance. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> ne retourne pas la valeur effective pour diverses circonstances où la valeur n’a pas été définie localement.  
  
 Les valeurs qui sont définies par les styles, les thèmes, les modèles, la valeur par défaut à partir des métadonnées, ou l’héritage de valeur de propriété n’a pas sont considérés comme valeurs locales. Toutefois, les liaisons et autres expressions sont considérés comme des valeurs locales, une fois qu’ils ont été évaluées.  
  
 Lorsque aucune valeur locale n’est définie, cette méthode retourne <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Si la valeur retournée est différente <xref:System.Windows.DependencyProperty.UnsetValue>, vous pouvez interroger les métadonnées de la propriété de dépendance demandée pour déterminer s’il existe un type plus spécifique qui la valeur de retour peut être convertie en.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identificateur de la propriété de dépendance à définir.</param>
        <param name="value">Nouvelle valeur locale.</param>
        <summary>Définit la valeur d’une propriété de dépendance sans modifier sa valeur source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée par un composant qui définit par programmation la valeur de l’un de ses propres propriétés sans désactiver l’utilisation d’une application de la propriété. Le <xref:System.Windows.DependencyObject.SetCurrentValue%2A> méthode modifie la valeur effective des propriété, mais les déclencheurs existants, des liaisons de données et styles continueront à fonctionner.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous avez tenté de modifier une propriété de dépendance en lecture seule ou une propriété sur un <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ne correspond pas au type inscrit pour la propriété <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la valeur locale d’une propriété de dépendance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identificateur de la propriété de dépendance à définir.</param>
        <param name="value">Nouvelle valeur locale.</param>
        <summary>Définit la valeur locale d’une propriété de dépendance, spécifiée par son identificateur de propriété de dépendance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le type fourni ne correspond pas au type déclaré pour la propriété de dépendance car il a été inscrit à l’origine, une exception est levée. Le `value` paramètre doit toujours être fourni comme le type approprié.  
  
 Les conditions d’exception sont influencées potentiellement par le <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> rappel existe sur l’identificateur de propriété de dépendance de la propriété de dépendance qui est définie. Sinon, la valeur fournie est possible en échec des conditions générales la vérification de type (par exemple, en passant une chaîne lorsque le type natif est Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous avez tenté de modifier une propriété de dépendance en lecture seule ou une propriété sur un <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ne correspond pas au type inscrit pour la propriété <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur <see cref="T:System.Windows.DependencyPropertyKey" /> de la propriété à définir.</param>
        <param name="value">Nouvelle valeur locale.</param>
        <summary>Définit la valeur locale d’une propriété de dépendance en lecture seule, spécifiée par l’identificateur <see cref="T:System.Windows.DependencyPropertyKey" /> de la propriété de dépendance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette signature est généralement utilisée lorsque vous définissez des valeurs pour les propriétés de dépendance en lecture seule qui sont définies par vos classes personnalisées. En règle générale, <xref:System.Windows.DependencyObject.SetValue%2A> est appelée uniquement à partir du type qui inscrit cette propriété de dépendance, qui implémente la logique interne qui fournit la valeur déterminée pour la propriété de dépendance. Pour plus d’informations, consultez [Propriétés de dépendance en lecture seule](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Si le type fourni ne correspond pas au type déclaré pour la propriété de dépendance car il a été inscrit à l’origine, une exception est levée. Le `value` paramètre doit toujours être fourni comme le type approprié. Les conditions d’exception sont influencées potentiellement par le <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> rappel existe sur l’identificateur de propriété de dépendance de la propriété de dépendance qui est définie.  
  
   
  
## Examples  
 L’exemple suivant définit une propriété de dépendance en lecture seule, avec un `public static readonly` <xref:System.Windows.DependencyProperty> qui fournit l’exposition d’en lecture seule nécessaire aux consommateurs de propriété et l’accesseur get pour la [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificateur de la propriété de dépendance qui doit être sérialisé.</param>
        <summary>Retourne une valeur qui indique si les processus de sérialisation doivent sérialiser la valeur de la propriété de dépendance fournie.</summary>
        <returns><see langword="true" /> si la propriété de dépendance fournie doit être sérialisée par valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne `true` pour tous les cas dans lequel une propriété de dépendance avait une valeur locale établie sur la <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Remplacements de cette méthode peuvent gérer les propriétés de dépendance spécifiques différemment.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>