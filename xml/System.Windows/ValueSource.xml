<Type Name="ValueSource" FullName="System.Windows.ValueSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5805f4ddbc46f2fe95a7cd95d5adac5ac93260ed" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39968540" /></Metadata><TypeSignature Language="C#" Value="public struct ValueSource" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ValueSource extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ValueSource" />
  <TypeSignature Language="VB.NET" Value="Public Structure ValueSource" />
  <TypeSignature Language="C++ CLI" Value="public value class ValueSource" />
  <TypeSignature Language="F#" Value="type ValueSource = struct" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Signale les informations retournées par <see cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plupart des informations qui <xref:System.Windows.ValueSource> transmet est contenue dans le <xref:System.Windows.ValueSource.BaseValueSource%2A> propriété. Cette propriété contient une valeur d’énumération qui spécifie un aspect global [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés qui est responsable de la valeur effective d’une propriété de dépendance.  
  
 Outre la valeur de base, les autres informations qui peuvent s’avérer intéressantes sur une valeur de propriété de dépendance sont est animée, et si la valeur implique une expression (par exemple, une liaison ou une référence de ressource dynamique). Ces informations sont signalées par <xref:System.Windows.ValueSource.IsAnimated%2A> et <xref:System.Windows.ValueSource.IsExpression%2A> respectivement. En outre, si le forçage de type agit sur une valeur de propriété, la propriété conserve la valeur souhaitée et la valeur de propriété va tenter d’atteindre cette valeur souhaitée si les contraintes de la contrainte spécifique sont modifiés ou levées. Une propriété forcée n’est pas la valeur souhaitée signalera que <xref:System.Windows.ValueSource.IsCoerced%2A> est `true`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
    <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
  </Docs>
  <Members>
    <Member MemberName="BaseValueSource">
      <MemberSignature Language="C#" Value="public System.Windows.BaseValueSource BaseValueSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.BaseValueSource BaseValueSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.BaseValueSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseValueSource As BaseValueSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::BaseValueSource BaseValueSource { System::Windows::BaseValueSource get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseValueSource : System.Windows.BaseValueSource" Usage="System.Windows.ValueSource.BaseValueSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.BaseValueSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur de l'énumération <see cref="T:System.Windows.BaseValueSource" /> qui signale la source ayant fourni le système de propriétés de dépendance avec une valeur.</summary>
        <value>Valeur de l’énumération.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de base n’est pas la valeur effective si la contrainte ou animation agit sur la propriété. Vérifiez <xref:System.Windows.ValueSource.IsAnimated%2A> et <xref:System.Windows.ValueSource.IsCoerced%2A> si vous souhaitez déterminer si la valeur de base est la valeur effective.  
  
 Vous souhaiterez également vérifier <xref:System.Windows.ValueSource.IsExpression%2A> pour voir si la valeur de base a été évaluée à partir d’une expression.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="valueSource.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objet à comparer à ce <see cref="T:System.Windows.ValueSource" />.</param>
        <summary>Retourne une valeur indiquant si <see cref="T:System.Windows.ValueSource" /> équivaut à un objet spécifié.</summary>
        <returns><see langword="true" /> si l'objet fourni est équivalent au <see cref="T:System.Windows.ValueSource" /> actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation prend en charge l’égalité des valeurs, en fonction de chacune des valeurs de propriété de chaque <xref:System.Windows.ValueSource> structure.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="valueSource.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour ce <see cref="T:System.Windows.ValueSource" />.</summary>
        <returns>Code de hachage d’un entier non signé 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce code de hachage est basé sur le <xref:System.Windows.ValueSource.BaseValueSource%2A> valeur.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="IsAnimated">
      <MemberSignature Language="C#" Value="public bool IsAnimated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnimated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsAnimated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnimated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnimated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnimated : bool" Usage="System.Windows.ValueSource.IsAnimated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui déclare si la propriété est animée.</summary>
        <value><see langword="true" /> si la propriété est animée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour toute propriété qui est actuellement en cours d’animation, la source est signalée par <xref:System.Windows.ValueSource.BaseValueSource%2A> ne concerne pas immédiatement, car l’animation fonctionne au niveau de la propriété de dépendance plus élevée que la valeur de base. Pour plus d’informations sur la priorité et les animations, consultez [priorité de valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCoerced">
      <MemberSignature Language="C#" Value="public bool IsCoerced { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCoerced" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCoerced" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCoerced As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCoerced { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCoerced : bool" Usage="System.Windows.ValueSource.IsCoerced" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui déclare si cette valeur est le résultat d’une implémentation de <see cref="T:System.Windows.CoerceValueCallback" /> appliquée à une propriété de dépendance.</summary>
        <value><see langword="true" /> si la valeur provient d'une implémentation <see cref="T:System.Windows.CoerceValueCallback" /> appliquée à une propriété de dépendance ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le forçage de type agit sur une valeur de propriété, la propriété conserve la valeur souhaitée et la valeur de propriété va tenter d’atteindre cette valeur souhaitée si les contraintes de la contrainte spécifique sont modifiés ou levées. Une propriété forcée n’est pas la valeur souhaitée signalera que <xref:System.Windows.ValueSource.IsCoerced%2A> est `true`.  
  
 Forçage de type agit à priorité plus élevée que la valeur de base et n’est pas à proprement parler un participant dans la façon dont la valeur de base est définie. Par conséquent, l’état de forçage est signalé par cette propriété, plutôt que par une valeur de la <xref:System.Windows.BaseValueSource> énumération. Pour plus d’informations sur la contrainte, les valeurs de base et les priorités, consultez [priorité de valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrent">
      <MemberSignature Language="C#" Value="public bool IsCurrent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsCurrent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCurrent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCurrent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrent : bool" Usage="System.Windows.ValueSource.IsCurrent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si la valeur a été définie par la méthode <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />.</summary>
        <value><see langword="true" /> si la valeur a été définie par la méthode <see cref="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" /> ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExpression">
      <MemberSignature Language="C#" Value="public bool IsExpression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExpression" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ValueSource.IsExpression" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExpression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExpression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExpression : bool" Usage="System.Windows.ValueSource.IsExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui déclare si cette valeur provient d'une expression évaluée. Il peut s’agir d’une <see cref="T:System.Windows.Data.BindingExpression" /> qui prend en charge une liaison ou d’une expression interne qui prend en charge [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md).</summary>
        <value><see langword="true" /> si la valeur provient d'une expression évaluée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une expression évaluée signale également la valeur de base spécifique, définition de condition dans laquelle l’expression a été appliquée, en tant que valeur dans <xref:System.Windows.ValueSource.BaseValueSource%2A>. Le <xref:System.Windows.ValueSource.BaseValueSource%2A> est toujours très utile pour n’importe quelle propriété où <xref:System.Windows.ValueSource.IsExpression%2A> est `true`. Savoir si une valeur provient d’une expression peut être particulièrement utile si la valeur a été définie indirectement, par exemple via un modèle ou une valeur de propriété héritée.  
  
 Si une expression n’est pas évaluée (la liaison a échoué ; aucune ressource portant ce nom a été trouvée), la valeur proviendra d’un autre participant dans le système de propriétés, probablement la valeur par défaut. Cette source est ensuite signalée dans <xref:System.Windows.ValueSource.BaseValueSource%2A>. Évaluations de l’expression qui a échoué retournera `false` pour <xref:System.Windows.ValueSource.IsExpression%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.ValueSource.BaseValueSource" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Equality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="vs1 = vs2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Premier <see cref="T:System.Windows.ValueSource" /> à comparer.</param>
        <param name="vs2">Deuxième <see cref="T:System.Windows.ValueSource" /> à comparer.</param>
        <summary>Détermine si deux instances <see cref="T:System.Windows.ValueSource" /> ont la même valeur.</summary>
        <returns><see langword="true" /> si les deux instances <see cref="T:System.Windows.ValueSource" /> sont équivalentes ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation appelle <xref:System.Windows.ValueSource.Equals%2A>, et prend en charge l’égalité basée sur toutes les propriétés de la valeur <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.ValueSource vs1, System.Windows.ValueSource vs2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.ValueSource vs1, valuetype System.Windows.ValueSource vs2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ValueSource.op_Inequality(System.Windows.ValueSource,System.Windows.ValueSource)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (vs1 As ValueSource, vs2 As ValueSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::ValueSource vs1, System::Windows::ValueSource vs2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.ValueSource * System.Windows.ValueSource -&gt; bool" Usage="System.Windows.ValueSource.op_Inequality (vs1, vs2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vs1" Type="System.Windows.ValueSource" />
        <Parameter Name="vs2" Type="System.Windows.ValueSource" />
      </Parameters>
      <Docs>
        <param name="vs1">Premier <see cref="T:System.Windows.ValueSource" /> à comparer.</param>
        <param name="vs2">Deuxième <see cref="T:System.Windows.ValueSource" /> à comparer.</param>
        <summary>Détermine si deux instances de <see cref="T:System.Windows.ValueSource" /> n'ont pas la même valeur.</summary>
        <returns><see langword="true" /> si les deux instances de <see cref="T:System.Windows.ValueSource" /> ne sont pas équivalentes ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation appelle <xref:System.Windows.ValueSource.Equals%2A>, retournant son opposé et prend en charge l’égalité des valeurs en fonction de toutes les propriétés de <xref:System.Windows.ValueSource>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyHelper" />
        <altmember cref="M:System.Windows.DependencyPropertyHelper.GetValueSource(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
  </Members>
</Type>