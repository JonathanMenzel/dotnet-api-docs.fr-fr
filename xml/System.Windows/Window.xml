<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f805a8dedd189924a31c53379179c725286ba810" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695008" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permet de créer, configurer, afficher et gérer la durée de vie des fenêtres et boîtes de dialogue.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’interaction entre un utilisateur et une application autonome est une fenêtre. A [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] fenêtre se compose de deux zones distinctes :  
  
-   Une zone non cliente, qui héberge les ornements de windows, y compris une icône, le titre, le menu système, les boutons réduire, agrandir le bouton, bouton Restaurer, bouton Fermer et une bordure.  
  
-   Une zone client, qui héberge le contenu spécifique à l’application.  
  
 Une fenêtre standard est illustrée dans la figure suivante :  
  
 ![Éléments de la fenêtre](~/add/media/windowoverviewfigure1.PNG "éléments de fenêtre")  
  
 <xref:System.Windows.Window> encapsule la capacité de créer, configurer, afficher et gérer la durée de vie des fenêtres et boîtes de dialogue et fournit les services clés suivants :  
  
 **Gestion de la durée de vie**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Gestion des fenêtres**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Apparence et comportement**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Boîtes de dialogue**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 En outre, <xref:System.Windows.Application> expose la prise en charge spéciale pour la gestion de toutes les fenêtres dans une application :  
  
-   Application conserve une liste de toutes les fenêtres actuellement instanciées dans l’application. Cette liste est exposée par le <xref:System.Windows.Application.Windows%2A> propriété.  
  
-   Par défaut, <xref:System.Windows.Application.MainWindow%2A> est automatiquement définie avec une référence à la première <xref:System.Windows.Window> qui est instancié dans une application. Ce qui contribuent à la fenêtre de la fenêtre principale de l’application.  
  
 Un <xref:System.Windows.Window> peut être implémentée à l’aide du balisage, balisage et code-behind ou le code.  
  
 <xref:System.Windows.Window> est principalement utilisé pour afficher les fenêtres et boîtes de dialogue pour les applications autonomes. Toutefois, pour les applications qui requièrent une navigation au niveau de la fenêtre, telles que des Assistants, vous pouvez utiliser <xref:System.Windows.Navigation.NavigationWindow> à la place. <xref:System.Windows.Navigation.NavigationWindow> dérive <xref:System.Windows.Window> et ajoute la prise en charge de la navigation de type navigateur.  
  
> [!NOTE]
>  Îlots de contenu de navigation peuvent être incorporés dans d’autres conteneurs de contenu et le contenu à l’aide de <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> doit `UnmanagedCode` autorisation de sécurité pour être instancié. Cela a les conséquences suivantes :  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-applications autonomes déployées demande l’élévation d’autorisations lors du lancement de zones Internet ou Intranet Local.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] qui demandent inférieur à toutes les autorisations ne seront pas en mesure d’instancier des fenêtres ou boîtes de dialogue.  
  
 Pour plus d’informations sur les considérations de sécurité et de déploiement d’applications autonomes, consultez [stratégie de sécurité de WPF - sécurité de la plate-forme](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 A <xref:System.Windows.Window> est un <xref:System.Windows.Controls.ContentControl>, ce qui signifie qu’il peut contenir un seul objet de tout type (par exemple, une chaîne, une image ou un panneau de configuration). Pour plus d'informations, consultez la classe <xref:System.Windows.Controls.ContentControl>. En outre, <xref:System.Windows.Window> est un élément racine et, par conséquent, ne peut pas y être partie du contenu d’un autre élément.  
  
> [!NOTE]
>  Le <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, et <xref:System.Windows.Window.Left%2A> propriétés définies sur un <xref:System.Windows.Window> via un style ne seront pas appliquées au moment de l’exécution.  
  
## <a name="customizing-the-window-control"></a>Personnalisation du contrôle de fenêtre  
 Pour appliquer les mêmes paramètres de propriété à plusieurs <xref:System.Windows.Window> contrôles, utilisez le <xref:System.Windows.FrameworkElement.Style%2A> propriété. Vous pouvez modifier la valeur par défaut <xref:System.Windows.Controls.ControlTemplate> pour donner une apparence unique au contrôle. Pour plus d’informations sur la création d’un <xref:System.Windows.Controls.ControlTemplate>, consultez [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Pour afficher les parties et les États qui sont spécifiques à la <xref:System.Windows.Window>, consultez [les modèles et les Styles de fenêtre](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut.  Si une propriété est définie par un style par défaut, la propriété peut changer sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’application est en cours d’exécution.  Pour plus d’informations, consultez [par défaut des thèmes WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Définition d’une propriété visuelle uniquement aura un effet si ces propriétés sont toutes deux présentes dans <xref:System.Windows.Window> contrôle du modèle par défaut et est définie à l’aide d’un. Vous trouverez une liste de propriétés visual dans la section « Modification le Visual Structure d’un contrôle » [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment une fenêtre standard est défini à l’aide de balisage uniquement :  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 L’exemple suivant montre comment une fenêtre standard est définie en utilisant uniquement un code :  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 L’exemple suivant montre comment une fenêtre standard est défini à l’aide d’une combinaison de balisage et code-behind.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur initialise la <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, et <xref:System.Windows.Window.Left%2A> propriétés leurs valeurs par défaut <xref:System.Windows.Window> valeurs.  
  
 Si une fenêtre est créée dans une <xref:System.AppDomain> qui a un <xref:System.Windows.Application> de l’objet, le constructeur ajoute le <xref:System.Windows.Window> objet à l’ensemble de <xref:System.Windows.Application>-gérés windows via le <xref:System.Windows.Application.Windows%2A> propriété de la <xref:System.Windows.Application> objet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation pour cet objet appeler des méthodes natives non sécurisées. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Essaie de mettre la fenêtre au premier plan et l'active.</summary>
        <returns>
          <see langword="true" /> si la <see cref="T:System.Windows.Window" /> a pu être activée ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les règles qui déterminent si la fenêtre est activée sont les mêmes que celles utilisées par le [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` (fonction) (User32.dll).  
  
 Si la fenêtre est activée dans une application Windows Presentation Foundation qui n’est pas application de premier plan de l’utilisateur, <xref:System.Windows.Application.Activated> événement est déclenché.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation d’activer une fenêtre. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une fenêtre devient la fenêtre de premier plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre est activée (devient la fenêtre de premier plan) lorsque :  
  
-   La première ouverture de la fenêtre.  
  
-   Un utilisateur bascule vers une fenêtre en la sélectionnant avec la souris, en appuyant sur ALT + TAB, ou le Gestionnaire de tâches.  
  
-   Un utilisateur clique sur le bouton de fenêtre barre des tâches.  
  
 Fenêtres qui doivent détecter quand elles deviennent actives peuvent gérer le <xref:System.Windows.Window.Activated> événement.  
  
 Après qu’une fenêtre est activée tout d’abord, peuvent être désactivé et réactivé autant de fois au cours de sa durée de vie. Si le comportement ou l’état d’une application dépend de son état d’activation, il peut inspecter <xref:System.Windows.Window.IsActive%2A> pour déterminer l’état d’activation dans.  
  
 Une application peut également être <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la zone cliente d'une fenêtre prend en charge la transparence.</summary>
        <value>
          <see langword="true" /> si la fenêtre prend en charge la transparence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Controls.Control.Background%2A> d’une fenêtre est définie sur un transparent à l’aide de la couleur <xref:System.Windows.Media.Brushes.Transparent%2A> , par exemple, la fenêtre reste opaque. Cela signifie que le bureau et les applications en cours d’exécution « sous « la fenêtre ne sont pas visibles. Pour activer ce type de transparence, <xref:System.Windows.Window.AllowsTransparency%2A> doit avoir la valeur `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> Pour faciliter la création de fenêtres non rectangulaires, il existe et, par conséquent, lorsque <xref:System.Windows.Window.AllowsTransparency%2A> a la valeur `true`, d’une fenêtre <xref:System.Windows.Window.WindowStyle%2A> propriété doit être définie sur <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Fenêtre qui a une valeur <see cref="P:System.Windows.Window.WindowStyle" /> autre que <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.AllowsTransparency" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">
          <see cref="T:System.Windows.Size" /> qui reflète la taille finale que la fenêtre doit utiliser pour se réorganiser elle et ses enfants.</param>
        <summary>Substituez cette méthode pour réorganiser et dimensionner une fenêtre et ses éléments enfants.</summary>
        <returns>
          <see cref="T:System.Windows.Size" /> qui reflète la taille réelle utilisée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> n’est pas appelée lorsque le <xref:System.Windows.UIElement.Visibility%2A> propriété a la valeur <xref:System.Windows.Visibility.Collapsed>. Si la valeur de la <xref:System.Windows.UIElement.Visibility%2A> propriété est <xref:System.Windows.Visibility.Hidden> ou <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> est appelée.  
  
> [!NOTE]
>  Lorsque soit <xref:System.Windows.Window.Show%2A> ou <xref:System.Windows.Window.ShowDialog%2A> sont appelées, le <xref:System.Windows.UIElement.Visibility%2A> propriété d’un <xref:System.Windows.Window> a la valeur <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme manuellement une <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Window> peut être fermé à l’aide d’un des mécanismes bien connues, fournie par le système se trouve dans sa barre de titre, y compris :  
  
-   ALT + F4.  
  
-   Menu système &#124; **fermer**.  
  
-   **Fermer** bouton.  
  
 Un <xref:System.Windows.Window> peut également être fermé à l’aide d’un des mécanismes bien connus dans la zone cliente qui sont fournis par les développeurs, notamment :  
  
-   **Fichier** &#124; **Exit** sur une fenêtre principale.  
  
-   **Fichier** &#124; **fermer** ou un **fermer** bouton sur une fenêtre enfant.  
  
> [!NOTE]
>  **OK** et **Annuler** sont également des boutons sur une boîte de dialogue fourni par le développeur, bien que s’ils définissent probablement <xref:System.Windows.Window.DialogResult%2A>, qui ferme automatiquement une fenêtre qui a été ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ces mécanismes exigent que vous puissiez appeler explicitement <xref:System.Windows.Window.Close%2A> pour fermer une fenêtre.  
  
> [!NOTE]
>  Si une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>et avec un <xref:System.Windows.Controls.Button> avec son <xref:System.Windows.Controls.Button.IsCancel%2A> définie sur true, se fermera automatiquement lorsque le bouton est activé soit, ou ÉCHAP est enfoncée. Si la fenêtre a été ouverte à l’aide de <xref:System.Windows.Window.Show%2A>, toutefois, <xref:System.Windows.Window.Close%2A> doit être appelé explicitement, comme celui <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Gestionnaire d’événements pour le <xref:System.Windows.Controls.Button>.  
  
 Fermeture d’une fenêtre entraîne la <xref:System.Windows.Window.Closing> événement soit déclenché. Si le <xref:System.Windows.Window.Closing> événement n’est pas annulé, les éléments suivants se produisent :  
  
-   Le <xref:System.Windows.Window> est supprimé de <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (si un <xref:System.Windows.Application> objet existe).  
  
-   Le <xref:System.Windows.Window> est supprimée de la <xref:System.Windows.Window> si la relation parent/enfant a été établie avant l’enfant <xref:System.Windows.Window> a été indiqué et après le propriétaire <xref:System.Windows.Window> a été ouvert.  
  
-   L'événement <xref:System.Windows.Window.Closed> est déclenché.  
  
-   Ressources non managées créées par le <xref:System.Windows.Window> sont supprimés.  
  
-   Si <xref:System.Windows.Window.ShowDialog%2A> a été appelée pour afficher le <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> retourne.  
  
 Fermeture d’un <xref:System.Windows.Window> provoque des fenêtres qu’il détient pour être fermé. En outre, fermeture un <xref:System.Windows.Window> peut entraîner une application arrêter l’exécution en fonction de la façon dont le <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> est définie.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre un **fichier** &#124; **Exit** menu géré pour appeler explicitement <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation d’utiliser toutes les fenêtres et événements d’entrée d’utilisateur sans restriction. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la fenêtre est sur le point de se fermer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois que cet événement est déclenché, une fenêtre ne peut pas empêcher de fermer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> est défini, ou <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> ou <see cref="M:System.Windows.Window.Hide" /> est appelé pendant la fermeture d'une fenêtre.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit directement après l'appel de <see cref="M:System.Windows.Window.Close" /> et peut être géré pour annuler la fermeture de la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> peut être géré pour détecter la fermeture d’une fenêtre (par exemple, lorsque <xref:System.Windows.Window.Close%2A> est appelé). En outre, <xref:System.Windows.Window.Closing> peut être utilisé pour empêcher la fermeture d’une fenêtre. Pour empêcher une fenêtre de fermeture, vous pouvez définir le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> argument `true`.  
  
 Le <xref:System.Windows.Window.Closing> événement est déclenché lorsque <xref:System.Windows.Window.Close%2A> est appelée, si l’utilisateur clique sur le bouton Fermer d’une fenêtre, ou si l’utilisateur appuie sur ALT + F4.  
  
 Si une fenêtre enfant a été ouverte par sa fenêtre propriétaire en utilisant <xref:System.Windows.Window.Show%2A>et le propriétaire de la fenêtre est fermée, la fenêtre enfant <xref:System.Windows.Window.Closing> événement n’est pas déclenché. Si le propriétaire d’une fenêtre est fermé (consultez <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> n’est pas déclenché sur la fenêtre enfant.  
  
 Si <xref:System.Windows.Application.Shutdown%2A> est appelée, le <xref:System.Windows.Window.Closing> déclenché pour chaque fenêtre. Toutefois, si <xref:System.Windows.Window.Closing> est annulé, l’annulation est ignorée.  
  
 Si une session se termine, car un utilisateur se déconnecte ou arrête, <xref:System.Windows.Window.Closing> n’est pas déclenché ; gérer <xref:System.Windows.Application.SessionEnding> pour implémenter le code qui annule la fermeture de l’application.  
  
 Si vous souhaitez afficher et masquer une fenêtre plusieurs fois pendant la durée de vie d’une application, et vous ne souhaitez pas réinstancier la fenêtre chaque fois que vous l’afficher, vous pouvez gérer le <xref:System.Windows.Window.Closing> événement, Annuler et appeler le <xref:System.Windows.Window.Hide%2A> (méthode). Ensuite, vous pouvez appeler <xref:System.Windows.Window.Show%2A> sur la même instance pour la rouvrir.  
  
   
  
## Examples  
 L’exemple suivant montre un <xref:System.Windows.Window> qui détermine s’il doit l’intervention de l’utilisateur à fermer.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> est défini, ou <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> ou <see cref="M:System.Windows.Window.Close" /> est appelé pendant la fermeture d'une fenêtre.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que le contenu de la fenêtre a été affiché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la fenêtre n’a aucun contenu, cet événement n’est pas déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une fenêtre devient une fenêtre d'arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre est désactivée (devient une fenêtre d’arrière-plan) lorsque :  
  
-   Un utilisateur bascule vers une autre fenêtre de l’application actuelle.  
  
-   Un utilisateur bascule vers la fenêtre dans une autre application à l’aide des touches ALT + TAB ou à l’aide du Gestionnaire des tâches.  
  
-   Un utilisateur clique sur le bouton de barre des tâches pour une fenêtre dans une autre application.  
  
 Les fenêtres qui doivent détecter quand elles sont désactivées par la gestion de la <xref:System.Windows.Window.Deactivated> événement.  
  
 Après qu’une fenêtre est désactivée tout d’abord, il peut être réactivé et plusieurs reprises au cours de sa durée de vie. Si le comportement ou l’état d’une application dépend de son état d’activation, il peut inspecter <xref:System.Windows.Window.IsActive%2A> pour déterminer l’état d’activation dans.  
  
 Une application peut également être <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur du résultat de la boîte de dialogue, qui est la valeur retournée depuis la méthode <see cref="M:System.Windows.Window.ShowDialog" />.</summary>
        <value>Valeur <see cref="T:System.Nullable`1" /> de type <see cref="T:System.Boolean" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> peut être utilisé à partir du code qui a donné lieu à une boîte de dialogue pour déterminer si un utilisateur a accepté (`true`) ou annulée (`false`) la boîte de dialogue. Si une boîte de dialogue a été acceptée, cela signifie pour le code qui a ouvert la boîte de dialogue pour récupérer les données qui ont été collectées par l’utilisateur et le traiter. Si une boîte de dialogue a été annulée, toutefois, cela signifie que que le code appelant doit s’arrêter tout traitement ultérieur.  
  
 Par défaut, une boîte de dialogue est annulée lorsqu’un utilisateur effectue l’une des opérations suivantes :  
  
-   PressesALT + F4.  
  
-   Clique sur le **fermer** bouton.  
  
-   Sélectionne **fermer** dans le menu système.  
  
 Dans tous ces cas, <xref:System.Windows.Window.DialogResult%2A> est `false` par défaut.  
  
 Une boîte de dialogue fournit généralement un bouton spécial pour annuler une boîte de dialogue, qui est le bouton dont <xref:System.Windows.Controls.Button.IsCancel%2A> est définie sur `true`. Un bouton configuré de cette façon se fermera automatiquement une fenêtre lorsqu’elle est soit activée, ou lorsque la touche ÉCHAP est enfoncée. Dans les deux cas, <xref:System.Windows.Window.DialogResult%2A> reste `false`.  
  
 Une boîte de dialogue fournit en général également un bouton d’acceptation, le bouton dont <xref:System.Windows.Controls.Button.IsDefault%2A> est définie sur `true`. Un bouton configuré de cette manière déclenche son <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement lorsqu’il ou la touche entrée est enfoncée. Toutefois, il ne ferme pas automatiquement la boîte de dialogue, n’est pas la valeur <xref:System.Windows.Window.DialogResult%2A> à `true`. Vous devez écrire ce code manuellement, généralement à partir de la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Gestionnaire d’événements pour le bouton par défaut.  
  
 <xref:System.Windows.Window.DialogResult%2A> est `null` lorsque la boîte de dialogue s’affiche, mais ni acceptée ni annulée.  
  
 Une fois une boîte de dialogue se ferme, vous pouvez obtenir le résultat de la boîte de dialogue à partir de la valeur retournée par <xref:System.Windows.Window.ShowDialog%2A> (méthode), ou en inspectant le <xref:System.Windows.Window.DialogResult%2A> propriété.  
  
 <xref:System.Windows.Window.DialogResult%2A> peut uniquement être définie lorsque un <xref:System.Windows.Window> est ouvert en appelant son <xref:System.Windows.Window.ShowDialog%2A> (méthode).  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment configurer les boutons OK et un bouton Annuler pour retourner les <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> est défini avant qu'une fenêtre ne soit ouverte en appelant <see cref="M:System.Windows.Window.ShowDialog" />.  
  
 - ou -  
  
 <see cref="P:System.Windows.Window.DialogResult" /> est défini sur une fenêtre qui est ouverte en appelant <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après la modification de la résolution de l’écran d’affichage de la fenêtre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEvent" /> lorsque la résolution de l’écran de la fenêtre est modifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet de faire glisser une fenêtre à l'aide du bouton gauche de la souris au-dessus d'une zone exposée de la zone cliente de la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le bouton gauche de la souris doit être enfoncé lorsque <xref:System.Windows.Window.DragMove%2A> est appelée. La première consiste à détecter lorsque le bouton gauche de la souris est enfoncé pour gérer les <xref:System.Windows.UIElement.MouseLeftButtonDown> événement.  
  
 Lorsque <xref:System.Windows.Window.DragMove%2A> est appelée, la gauche bouton de la souris doit être relâché au-dessus d’une zone exposée de la zone cliente de la fenêtre.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> pour appeler <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le bouton gauche de la souris n'est pas enfoncé.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation de faire glisser une fenêtre. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objet de dépendance.</param>
        <summary>Retourne une référence à l'objet <see cref="T:System.Windows.Window" /> qui héberge l'arborescence de contenu à l'intérieur de laquelle se trouve l'objet de dépendance.</summary>
        <returns>Référence <see cref="T:System.Windows.Window" /> à la fenêtre hôte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend une fenêtre invisible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre n’est pas fermée lorsqu’elle est masquée et ni le <xref:System.Windows.Window.Closing> ni <xref:System.Windows.Window.Closed> événement est déclenché. Au lieu de cela, la fenêtre <xref:System.Windows.UIElement.Visibility%2A> est définie sur <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Si une fenêtre est l’application <xref:System.Windows.Application.MainWindow%2A> et l’application <xref:System.Windows.Application.ShutdownMode%2A> est <xref:System.Windows.ShutdownMode.OnMainWindowClose>, l’application ne s’arrête pas. De même, l’application ne s’arrête pas si une fenêtre est la seule fenêtre et mode arrêt de l’application est <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Si vous souhaitez afficher et masquer une fenêtre plusieurs fois pendant la durée de vie d’une application, et vous ne souhaitez pas ré-instancier la fenêtre à chaque fois que vous l’afficher, vous pouvez gérer le <xref:System.Windows.Window.Closing> événement, Annuler et appeler le <xref:System.Windows.Window.Hide%2A> (méthode). Ensuite, vous pouvez appeler <xref:System.Windows.Window.Show%2A> sur la même instance pour la rouvrir.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> est appelé sur une fenêtre qui se ferme (<see cref="E:System.Windows.Window.Closing" />) ou a été fermée (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une icône de fenêtre.</summary>
        <value>Objet <see cref="T:System.Windows.Media.ImageSource" /> qui représente l'icône.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les applications autonomes Windows Presentation Foundation (WPF) ont deux types d’icônes :  
  
-   Une icône d’assembly, qui est spécifiée à l’aide de le `<ApplicationIcon>` fichier de génération de propriété dans le projet de l’application. Cette icône est utilisée comme icône du bureau d’un assembly.  
  
    > [!NOTE]
    >  Lors du débogage dans Visual Studio, votre icône ne peut pas apparaître en raison du processus d’hébergement. Si vous exécutez le fichier exécutable, l’icône s’affiche. Pour plus d’informations, consultez [Processus d’hébergement (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Une icône par fenêtre spécifiée en définissant <xref:System.Windows.Window.Icon%2A>. Pour chaque fenêtre, cette icône est utilisée dans la barre de titre, son bouton de barre des tâches et dans son entrée de liste de sélection ALT-onglet application.  
  
 Une fenêtre WPF affiche toujours une icône. Quand un n’est pas fourni en définissant <xref:System.Windows.Window.Icon%2A>, WPF choisit une icône à afficher selon les règles suivantes :  
  
1.  Utilisez l’icône d’assembly, s’il est spécifié.  
  
2.  Si l’icône d’assembly n’est pas spécifié, utilisez l’icône de Microsoft Windows par défaut.  
  
 Si vous utilisez <xref:System.Windows.Window.Icon%2A> pour spécifier une icône de fenêtre personnalisée, vous pouvez restaurer l’icône de l’application par défaut en définissant <xref:System.Windows.Window.Icon%2A> à `null`.  
  
 Une icône peut être utilisée dans de différentes façons dans Windows, y compris est affiché dans la barre de titre d’une fenêtre, la barre des tâches pour une fenêtre, la liste de sélection de fichier ALT + TAB. Chacun de ces affiche l’icône à l’aide d’une taille différente ; une icône de 16 x 16 pixels s’affiche dans la barre de titre d’une fenêtre et dans la barre des tâches, une icône 32 x 32 pixels est affichée dans la liste de sélection de fichier ALT + TAB. Certaines applications, telles que [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], fournissez un **vue** menu qui vous permet de choisir la taille de l’icône que vous souhaitez afficher.  
  
 Pour prendre en charge les différentes tailles d’affichage, un fichier d’icône se compose d’un ou plusieurs icônes réelles représentant chacune une version de l’icône qui cible une profondeur de couleur et de taille spécifique. Par exemple, une icône peut avoir uniquement une seule icône de 16 x 16 pixels avec 16 couleurs, tandis qu’un autre peut contenir 16 x 16 pixels et des icônes de 32 x 32 pixels avec 16 couleurs et 256 couleurs.  
  
 Si les icônes pour toutes les tailles et couleurs profondeurs possibles existent dans un fichier d’icône <xref:System.Windows.Window> utilisera l’icône appropriée. Si un fichier icône contient uniquement un sous-ensemble de toutes les icônes possibles, <xref:System.Windows.Window> utilise l’icône la plus appropriée suivante par ordre décroissant de taille et profondeur de couleur.  
  
 Le résultat est qu’une icône sera toujours utilisée par <xref:System.Windows.Window>, même si le n’a pas la taille et la couleur la profondeur requise. Par exemple, une icône de 16 x 16 pixels avec 16 couleurs peut être utilisée pour l’affichage sous forme d’icône 32 x 32 pixels avec 256 couleurs. Cela peut entraîner des effets visuels indésirables, tels que pixellisation, mais peut être évité en créant des icônes pour tous les tailles et les palettes de couleurs.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.IconProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir une icône de fenêtre.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation définir l’icône. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Icon" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la fenêtre est active.</summary>
        <value>
          <see langword="true" /> si la fenêtre est active ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre active est la fenêtre de premier plan actuelle de l’utilisateur et a le focus, ce qui est signalé par l’apparence active de la barre de titre. Une fenêtre active est toujours le plus élevé de toutes les fenêtres de niveau supérieur ne définissez pas explicitement la <xref:System.Windows.Window.Topmost%2A> propriété.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.IsActiveProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.IsActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du bord gauche de la fenêtre par rapport au bureau.</summary>
        <value>Position du bord gauche de la fenêtre, en unités logiques (1/96e de pouce).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Window> est agrandie ou réduite, cette valeur représente le bord gauche de la restauration de point pour le <xref:System.Windows.Window>.  
  
 Cette propriété ne peut pas être définie via un style.  
  
 Si vous ne spécifiez pas une valeur, <xref:System.Windows.Window.Left%2A> est définie sur la valeur par défaut du système. Vous pouvez également spécifier la valeur système par défaut en définissant <xref:System.Windows.Window.Left%2A> à <xref:System.Double.NaN>. Ni <xref:System.Double.NegativeInfinity> ni <xref:System.Double.PositiveInfinity> est une valeur valide pour <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.LeftProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Left" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l’emplacement de la fenêtre est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emplacement d’une fenêtre change lorsque :  
  
-   Un utilisateur déplace une fenêtre en faisant glisser la barre de titre.  
  
-   Une fenêtre est déplacée après <xref:System.Windows.Window.DragMove%2A> est appelée.  
  
-   Soit le <xref:System.Windows.Window.Left%2A> ou <xref:System.Windows.Window.Top%2A> propriété est définie par programme.  
  
-   Le **déplacer** élément de menu du menu du système d’une fenêtre est sélectionnée.  
  
-   Le <xref:System.Windows.Window.WindowState%2A> propriété est modifiée.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reçoit un énumérateur pour les éléments enfants logiques d'une fenêtre.</summary>
        <value>
          <see cref="T:System.Collections.IEnumerator" /> des éléments enfants logiques d'une fenêtre.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">
          <see cref="T:System.Windows.Size" /> qui reflète la taille disponible que cette fenêtre peut donner à l'enfant. L'infini peut être renseigné comme valeur pour que la fenêtre soit redimensionnée en fonction du contenu disponible.</param>
        <summary>Substituez cette méthode pour mesurer la taille d'une fenêtre.</summary>
        <returns>
          <see cref="T:System.Windows.Size" /> qui reflète la taille dont la fenêtre estime avoir besoin pendant la disposition, en fonction du calcul de la taille de ses enfants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> n’est pas appelée lorsque le <xref:System.Windows.UIElement.Visibility%2A> propriété a la valeur <xref:System.Windows.Visibility.Collapsed>. Si la valeur de la <xref:System.Windows.UIElement.Visibility%2A> propriété est <xref:System.Windows.Visibility.Hidden> ou <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> est appelée.  
  
> [!NOTE]
>  Lorsque soit <xref:System.Windows.Window.Show%2A> ou <xref:System.Windows.Window.ShowDialog%2A> sont appelées, le <xref:System.Windows.UIElement.Visibility%2A> propriété d’un <xref:System.Windows.Window> a la valeur <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> déclenche l'événement <xref:System.Windows.Window.Activated>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnActivated%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnActivated%2A> sur la classe de base si <xref:System.Windows.Window.Activated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> déclenche l'événement <xref:System.Windows.Window.Closed>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnClosed%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnClosed%2A> sur la classe de base si <xref:System.Windows.Window.Closed> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.ComponentModel.CancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> déclenche l'événement <xref:System.Windows.Window.Closing>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnClosing%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnClosing%2A> sur la classe de base si <xref:System.Windows.Window.Closing> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Référence à la racine de l'ancienne arborescence de contenu.</param>
        <param name="newContent">Référence à la racine de la nouvelle arborescence de contenu.</param>
        <summary>Appelée lorsque la propriété <see cref="P:System.Windows.Controls.ContentControl.Content" /> est modifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> déclenche l'événement <xref:System.Windows.Window.ContentRendered>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnContentRendered%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnContentRendered%2A> sur la classe de base si <xref:System.Windows.Window.ContentRendered> doit être déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne un objet <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> pour ce <see cref="T:System.Windows.Window" />.</summary>
        <returns>Objet <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> pour ce <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> déclenche l'événement <xref:System.Windows.Window.Deactivated>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnDeactivated%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnDeactivated%2A> sur la classe de base si <xref:System.Windows.Window.Deactivated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Le paramètre d’échelle ppp précédent.</param>
        <param name="newDpi">Le nouveau paramètre d’échelle ppp.</param>
        <summary>Appelé lorsque la résolution d’affichage de cette fenêtre change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> déclenche l'événement <xref:System.Windows.Window.LocationChanged>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnLocationChanged%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnLocationChanged%2A> sur la classe de base si <xref:System.Windows.Window.LocationChanged> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données de l'événement.</param>
        <summary>Appelée lorsque l'événement <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> se produit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation ne modifie pas l’état géré (le <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété) de la <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> les données d’événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si vous substituez <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, appelez toujours l’implémentation de base votre <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implémentation. Faute d’appeler l’implémentation de base empêche les classes de base à partir de la gestion de l’événement, ce qui peut modifier le comportement d’exécution de la classe finale. Vous pouvez appeler l’implémentation de base avant ou après le traitement spécial, selon vos besoins.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.SourceInitialized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> déclenche l'événement <xref:System.Windows.Window.SourceInitialized>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnSourceInitialized%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnSourceInitialized%2A> sur la classe de base si <xref:System.Windows.Window.SourceInitialized> doit être déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.StateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> déclenche l'événement <xref:System.Windows.Window.StateChanged>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peut se substituer à <xref:System.Windows.Window.OnStateChanged%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnStateChanged%2A> sur la classe de base si <xref:System.Windows.Window.StateChanged> doit être déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Parent précédent. Valeur null si le <see cref="T:System.Windows.DependencyObject" /> n'avait pas de parent précédent.</param>
        <summary>Appelé lorsque le parent de la fenêtre est modifié.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de fenêtres dont cette fenêtre est propriétaire.</summary>
        <value>
          <see cref="T:System.Windows.WindowCollection" /> qui contient des références aux fenêtres dont cette fenêtre est propriétaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre enfant est une dont <xref:System.Windows.Window.Owner%2A> propriété est définie avec une référence à une autre fenêtre, qui est connue en tant que la fenêtre propriétaire. Pour rechercher toutes les fenêtres appartenant à une fenêtre propriétaire, vous pouvez énumérer <xref:System.Windows.WindowCollection> qui est retourné par la <xref:System.Windows.Window.OwnedWindows%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment énumérer <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la <see cref="T:System.Windows.Window" /> qui possède cette <see cref="T:System.Windows.Window" />.</summary>
        <value>Objet <see cref="T:System.Windows.Window" /> qui représente le propriétaire de cette <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand une fenêtre enfant est ouverte par une fenêtre parente en appelant <xref:System.Windows.Window.ShowDialog%2A>, une relation implicite est établie entre parent et enfant. Cette relation applique certains comportements, notamment en ce qui concerne la réduction, d’agrandissement et de restauration.  
  
 Quand une fenêtre enfant est créée par une fenêtre parente en appelant <xref:System.Windows.Window.Show%2A>, toutefois, la fenêtre enfant n’a pas de relation avec la fenêtre parente. Cela signifie que :  
  
-   La fenêtre enfant n’a pas une référence à la fenêtre parente.  
  
-   Le comportement de la fenêtre enfant n’est pas dépendant du comportement de la fenêtre parente. une fenêtre peut couvrir l’autre ou être réduite, agrandie et restaurée indépendamment de l’autre.  
  
 Vous permet de créer une relation entre une fenêtre enfant et une fenêtre parente, <xref:System.Windows.Window> prend en charge la notion de propriété. La propriété est établie lorsque le <xref:System.Windows.Window.Owner%2A> propriété d’une fenêtre (la fenêtre enfant) est définie avec une référence à une autre fenêtre (la fenêtre propriétaire).  
  
 Une fois que cette relation est établie, les comportements suivants sont d’application :  
  
-   Si une fenêtre propriétaire est réduite, ses fenêtres enfants sont également réduits.  
  
-   Si une fenêtre enfant est réduite, son propriétaire n’est pas limité.  
  
-   Si une fenêtre propriétaire est agrandie, la fenêtre propriétaire et ses fenêtres enfants sont restaurées.  
  
-   Une fenêtre propriétaire ne peut jamais couvrir une fenêtre enfant.  
  
-   Fenêtres enfants qui n’ont pas été ouvertes à l’aide de <xref:System.Windows.Window.ShowDialog%2A> ne sont pas modales. L’utilisateur peut interagir avec la fenêtre propriétaire.  
  
-   Si vous fermez une fenêtre propriétaire, ses fenêtres enfants sont également fermés.  
  
-   Si une fenêtre enfant a été ouverte par sa fenêtre propriétaire en utilisant <xref:System.Windows.Window.Show%2A>et le propriétaire de la fenêtre est fermée, la fenêtre enfant <xref:System.Windows.Window.Closing> événement n’est pas déclenché.  
  
 Lorsque vous ouvrez une fenêtre enfant en appelant <xref:System.Windows.Window.ShowDialog%2A>, vous devez également définir le <xref:System.Windows.Window.Owner%2A> propriété de la fenêtre enfant. Si vous ne le faites pas, vos utilisateurs ne sont pas être en mesure de restaurer la fenêtre enfant et fenêtre parente en appuyant sur le bouton de barre des tâches. Au lieu de cela, en appuyant sur le bouton de barre des tâches génèrera une liste de windows, y compris la fenêtre enfant et parent, pour les utilisateurs ; seule la fenêtre sélectionnée est restaurée.  
  
> [!IMPORTANT]
>  Vous devez également définir le <xref:System.Windows.Window.Owner%2A> propriété sur une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A> pour garantir un comportement correct avec.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment établir la relation parent/enfant.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une fenêtre essaie d'être son propre propriétaire.  
  
 - ou -  
  
 Deux fenêtres essaient de se posséder l'une l'autre.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Window.Owner" /> est définie sur une fenêtre visible affichée à l'aide de <see cref="M:System.Windows.Window.ShowDialog" />.  
  
 - ou -  
  
 La propriété <see cref="P:System.Windows.Window.Owner" /> est définie avec une fenêtre qui n'a pas été affichée auparavant.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation d’utiliser toutes les fenêtres et événements d’entrée d’utilisateur sans restriction. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode de redimensionnement.</summary>
        <value>Valeur <see cref="T:System.Windows.ResizeMode" /> spécifiant le mode de redimensionnement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe quatre options :  
  
-   **NoResize**. L’utilisateur ne peut pas redimensionner la fenêtre. Les cases Réduire et Agrandir ne sont pas affichés.  
  
-   **CanMinimize**. L’utilisateur peut uniquement réduire la fenêtre et restaurez-la à partir de la barre des tâches. Les cases Réduire et Agrandir sont affichées, mais seule la case réduire est activée.  
  
-   **CanResize**. L’utilisateur a la possibilité de complet pour redimensionner la fenêtre, en utilisant les cases Réduire et agrandir et un plan déplaçable autour de la fenêtre. Les cases Réduire et Agrandir sont affichés et activés. (Par défaut).  
  
-   **CanResizeWithGrip**. Cette option a la même fonctionnalité que <xref:System.Windows.ResizeMode.CanResize>, mais ajoute une poignée de dimensionnement « » à l’angle inférieur droit de la fenêtre.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.ResizeModeProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.ResizeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille et l'emplacement d'une fenêtre avant qu'elle ne soit réduite ou agrandie.</summary>
        <value>
          <see cref="T:System.Windows.Rect" /> qui spécifie la taille et l'emplacement d'une fenêtre avant sa réduction ou son agrandissement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le rectangle de restauration est la région occupée par la fenêtre avant qu’il a été réduite ou agrandie. Vous pouvez utiliser <xref:System.Windows.Window.RestoreBounds%2A> pour enregistrer la dernière taille et l’emplacement d’une fenêtre avant la fermeture d’une application et récupérer ces valeurs la prochaine fois qu’une application commence à la restauration d’une fenêtre à la façon dont un utilisateur l’a laissé.  
  
 Si vous interrogez <xref:System.Windows.Window.RestoreBounds%2A> avant que la fenêtre a été affichée, ou qui a été fermée, <xref:System.Windows.Rect.Empty%2A> est retourné.  
  
> [!NOTE]
>  Impossible d’obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.Window.RestoreBounds%2A> et le stockage isolé pour vous assurer de la taille et l’emplacement d’une fenêtre sont les mêmes que leur lors du dernier affichage de la fenêtre.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour obtenir l’autorisation interroger la taille et l’emplacement d’une fenêtre rectangle englobant. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ouvre une fenêtre et retourne sans attendre la fermeture de la nouvelle fenêtre ouverte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque la <xref:System.Windows.Window> classe est instanciée, elle n’est pas visible par défaut. <xref:System.Windows.Window.Show%2A> affiche une fenêtre et retourne immédiatement, sans attendre la fenêtre à fermer. Par conséquent, la fenêtre ouverte n’empêche pas les utilisateurs d’interagir avec les autres fenêtres dans l’application. Ce type de fenêtre est appelé une *non modale* fenêtre. Des exemples courants de fenêtres non modales sont palettes, boîtes à outils et fenêtres de propriétés. Pour empêcher un utilisateur à l’interaction avec une fenêtre spécifique, la fenêtre doit être ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Une fenêtre ouverte en appelant <xref:System.Windows.Window.Show%2A> est pas automatiquement ont une relation avec la fenêtre qui l’a ouvert ; plus précisément, la fenêtre ouverte ne sait pas quelle fenêtre ouverte. Cette relation peut être établie à l’aide de la <xref:System.Windows.Window.Owner%2A> propriété et gérés à l’aide de la <xref:System.Windows.Window.OwnedWindows%2A> propriété.  
  
 Appel de <xref:System.Windows.Window.Show%2A> donne le même résultat final en tant que paramètre <xref:System.Windows.UIElement.Visibility%2A> propriété de la <xref:System.Windows.Window> objet <xref:System.Windows.Visibility.Visible>. Toutefois, il est d’une différence entre les deux à partir d’une perspective de minutage.  
  
 Appel de <xref:System.Windows.Window.Show%2A> est une opération synchrone qui retourne uniquement une fois que le <xref:System.Windows.FrameworkElement.Loaded> sur la fenêtre enfant a été déclenché :  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Paramètre <xref:System.Windows.UIElement.Visibility%2A>, toutefois, est une opération asynchrone qui retourne immédiatement :  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Lors de la définition <xref:System.Windows.UIElement.Visibility%2A>, les événements de fenêtre enregistrés avant de définir <xref:System.Windows.UIElement.Visibility%2A> ne peut pas être déclenché jusqu'à ce que la méthode dans laquelle vous définissez <xref:System.Windows.UIElement.Visibility%2A> a terminé son exécution.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une fenêtre non modale.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> est appelé sur une fenêtre qui se ferme (<see cref="E:System.Windows.Window.Closing" />) ou a été fermée (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre est activée lors de son premier affichage.</summary>
        <value>
          <see langword="true" /> si une fenêtre est activée lors de son premier affichage ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une fenêtre avec sa <xref:System.Windows.Window.ShowActivated%2A> propriété `false` est ouvert, la fenêtre n’est pas activée et son <xref:System.Windows.Window.Activated> événement n’est pas déclenché manuellement que lorsqu’un utilisateur Active la fenêtre en la sélectionnant. Une fois que la fenêtre est activée, elle active et désactive normalement.  
  
 Pour empêcher une fenêtre d’en cours d’activation quand il s’ouvre, la <xref:System.Windows.Window.ShowActivated%2A> propriété doit être définie sur `false` avant que la fenêtre s’affiche (en appelant <xref:System.Windows.Window.Show%2A>) ; paramètre <xref:System.Windows.Window.ShowActivated%2A> à `false` après une fenêtre a aucun effet.  
  
 Paramètre <xref:System.Windows.Window.ShowActivated%2A> à `false` sur une fenêtre qui est ouvert de façon modale, en appelant <xref:System.Windows.Window.ShowDialog%2A>, n’a aucun impact réel. Bien que la fenêtre modale ne sera pas activée, la fenêtre modale empêche l’utilisateur d’activer d’autres fenêtres d’application ouverte.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.ShowActivatedProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la balise pour configurer une fenêtre pour être ouvert sans être activé.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 L’exemple suivant montre comment utiliser le code pour configurer une fenêtre à s’ouvrir sans être activée.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.ShowActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ouvre une fenêtre et retourne uniquement lorsque la nouvelle fenêtre ouverte est fermée.</summary>
        <returns>Valeur <see cref="T:System.Nullable`1" /> de type <see cref="T:System.Boolean" /> qui spécifie si l'activité a été acceptée (<see langword="true" />) ou annulée (<see langword="false" />). La valeur de retour est la valeur de la propriété <see cref="P:System.Windows.Window.DialogResult" /> avant la fermeture d'une fenêtre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un <xref:System.Windows.Window> classe est instanciée, elle n’est pas visible par défaut. <xref:System.Windows.Window.ShowDialog%2A> Affiche la fenêtre, désactive toutes les autres fenêtres dans l’application et retourne uniquement lorsque la fenêtre est fermée. Ce type de fenêtre est connu comme un *modale* fenêtre.  
  
 Les fenêtres modales sont principalement utilisées comme boîtes de dialogue. Une boîte de dialogue est un type spécial de fenêtre que les applications utilisent pour interagir avec les utilisateurs à effectuer des tâches, telles que l’ouverture de fichiers ou de l’impression de documents. Boîtes de dialogue permettent généralement aux utilisateurs d’accepter ou annuler la tâche pour laquelle ils ont été affichées avant la fermeture de la boîte de dialogue. <xref:System.Windows.Window.ShowDialog%2A> Retourne un <xref:System.Nullable%601> <xref:System.Boolean> valeur qui spécifie si l’activité a été acceptée ou annulée. La valeur de retour est la valeur de la propriété <xref:System.Windows.Window.DialogResult%2A> avant la fermeture d'une fenêtre. Pour plus d'informations, consultez <xref:System.Windows.Window.DialogResult%2A>.  
  
 Une fenêtre ouverte en appelant le <xref:System.Windows.Window.ShowDialog%2A> méthode n’a pas automatiquement une relation avec la fenêtre qui l’a ouvert ; plus précisément, la fenêtre ouverte ne sait pas quelle fenêtre ouverte. Cette relation peut être établie à l’aide de la <xref:System.Windows.Window.Owner%2A> propriété et gérés à l’aide de la <xref:System.Windows.Window.OwnedWindows%2A> propriété. Pour prendre en charge [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automation (consultez [UI Automation Overview](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> doit être définie pour une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Lorsqu’un modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fenêtre (une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>) est fermée, activée précédemment fenêtre est réactivé. Si un modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fenêtre a une fenêtre propriétaire (consultez <xref:System.Windows.Window.Owner%2A>), la fenêtre propriétaire n’est pas réactivée lorsque modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fenêtre est fermée, sauf si elle était la fenêtre précédemment activée.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une fenêtre modale.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> est appelé sur une fenêtre qui se ferme (<see cref="E:System.Windows.Window.Closing" />) ou a été fermée (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation d’activer une fenêtre. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la fenêtre possède un bouton dans la barre des tâches.</summary>
        <value>
          <see langword="true" /> si la fenêtre possède un bouton dans la barre des tâches ; sinon, <see langword="false" />. Ne s'applique pas lorsque la fenêtre est hébergée dans un navigateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Window.ShowInTaskbar%2A> a la valeur `true`, la fenêtre s’affiche également dans la liste de sélection d’application ALT + TAB.  
  
 L’icône qui est utilisée pour le bouton de barre des tâches et la liste de sélection d’application ALT + TAB est la valeur de la <xref:System.Windows.Window.Icon%2A> propriété.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.ShowInTaskbar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre est automatiquement redimensionnée en fonction de la taille de son contenu.</summary>
        <value>Valeur <see cref="T:System.Windows.SizeToContent" />. La valeur par défaut est <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.Window.SizeToContent%2A> a la valeur <xref:System.Windows.SizeToContent.WidthAndHeight>, paramètre <xref:System.Windows.FrameworkElement.Height%2A> ou <xref:System.Windows.FrameworkElement.Width%2A> n’a aucun effet ; les deux propriétés peuvent être définies, mais ils sont définis avec des valeurs ne sont pas appliquées à la fenêtre.  
  
 Lorsque <xref:System.Windows.Window.SizeToContent%2A> a la valeur <xref:System.Windows.SizeToContent.Height>, le paramètre <xref:System.Windows.FrameworkElement.Height%2A> ne modifie pas la hauteur de la fenêtre.  
  
 Lorsque <xref:System.Windows.Window.SizeToContent%2A> a la valeur <xref:System.Windows.SizeToContent.Width>, le paramètre <xref:System.Windows.FrameworkElement.Width%2A> ne modifie pas la largeur de la fenêtre.  
  
 Si <xref:System.Windows.Window.SizeToContent%2A> a une valeur autre que <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> est automatiquement défini sur <xref:System.Windows.SizeToContent.Manual> si un utilisateur redimensionne la fenêtre à l’aide de la poignée de redimensionnement ou en faisant glisser la bordure.  
  
-   Si la taille du contenu change d’une manière qui provoque le redimensionnement, la fenêtre <xref:System.Windows.FrameworkElement.SizeChanged> est déclenché.  
  
 Si une fenêtre est transparente (consultez <xref:System.Windows.Window.AllowsTransparency%2A>), vous devez envisager de définir <xref:System.Windows.Window.SizeToContent%2A> à <xref:System.Windows.SizeToContent.WidthAndHeight> pour vous assurer de la fenêtre ne dépasse pas son contenu visible.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.SizeToContentProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Window.SizeToContent%2A> propriété dans le code pour spécifier la manière dont une fenêtre se redimensionne en fonction de son contenu.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.SizeToContent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cet événement est déclenché afin de prendre en charge l'interopérabilité avec [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. Consultez <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la propriété <see cref="P:System.Windows.Window.WindowState" /> de la fenêtre change.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la miniature de barre des tâches [!INCLUDE[win7](~/includes/win7-md.md)] pour <see cref="T:System.Windows.Window" />.</summary>
        <value>Miniature de la barre des tâches [!INCLUDE[win7](~/includes/win7-md.md)] pour <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’utilisation de la [!INCLUDE[win7](~/includes/win7-md.md)] voir miniatures, de la barre des tâches du <xref:System.Windows.Shell.TaskbarItemInfo> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.TaskbarItemInfo" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le titre d’une fenêtre.</summary>
        <value>
          <see cref="T:System.String" /> qui contient le titre de la fenêtre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le titre d’un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, ou [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], peut également être définie à l’aide de <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.TitleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Title" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du bord supérieur de la fenêtre par rapport au bureau.</summary>
        <value>Position du haut de la fenêtre, en unités logiques (1/96").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Window> est agrandie ou réduite, cette valeur représente le bord supérieur de la restauration de point pour le <xref:System.Windows.Window>.  
  
 Cette propriété ne peut pas être définie via un style.  
  
 Si vous ne spécifiez pas une valeur, <xref:System.Windows.Window.Top%2A> est définie sur la valeur par défaut du système. Vous pouvez également spécifier la valeur système par défaut en définissant <xref:System.Windows.Window.Top%2A> à <xref:System.Double.NaN>. Ni <xref:System.Double.NegativeInfinity> ni <xref:System.Double.PositiveInfinity> est une valeur valide pour <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.TopProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre apparaît dans l'ordre de plan le plus haut.</summary>
        <value>
          <see langword="true" /> si la fenêtre est l'élément le plus haut ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre dont <xref:System.Windows.Window.Topmost%2A> est définie sur `true` apparaît au-dessus de toutes les fenêtres dont <xref:System.Windows.Window.Topmost%2A> propriétés sont définies sur `false`.  
  
 Dans le groupe de windows qui ont <xref:System.Windows.Window.Topmost%2A> est définie sur `true`, la fenêtre actuellement active est la fenêtre au premier plan. De même pour le groupe de windows qui ont <xref:System.Windows.Window.Topmost%2A> est définie sur `false`.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.TopmostProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Topmost" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Top" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position de la fenêtre lors de son premier affichage.</summary>
        <value>Valeur <see cref="T:System.Windows.WindowStartupLocation" /> qui spécifie la position supérieure gauche d'une fenêtre lorsqu'elle s'affiche pour la première fois. La valeur par défaut est <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Paramètre <xref:System.Windows.WindowStartupLocation> à <xref:System.Windows.WindowStartupLocation.Manual> provoque une fenêtre doit être placée en fonction de son <xref:System.Windows.Window.Left%2A> et <xref:System.Windows.Window.Top%2A> les valeurs de propriété. Si le <xref:System.Windows.Window.Left%2A> ou <xref:System.Windows.Window.Top%2A> propriétés ne sont pas spécifiées, leurs valeurs sont déterminées par Windows.  
  
 Paramètre <xref:System.Windows.WindowStartupLocation.CenterScreen> entraîne une fenêtre doit être placée dans le centre de l’écran qui contient le curseur de souris.  
  
 Paramètre <xref:System.Windows.WindowStartupLocation> à <xref:System.Windows.WindowStartupLocation.CenterOwner> provoque une fenêtre doit être placée au centre de sa fenêtre propriétaire (consultez <xref:System.Windows.Window.Owner%2A>), s’il est spécifié. La fenêtre propriétaire peut être soit une autre fenêtre WPF ou une fenêtre non-WPF.  
  
> [!NOTE]
>  Pour plus d’informations sur les fenêtres WPF avec les fenêtres non-WPF, consultez [WPF et Win32 interopérabilité](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) et <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Si une fenêtre propriétaire n’est pas spécifiée, la position de la fenêtre est déterminée de la même façon que si <xref:System.Windows.WindowStartupLocation> a la valeur <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Impossible de définir ou obtenir la valeur de cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre est restaurée, réduite ou agrandie.</summary>
        <value>
          <see cref="T:System.Windows.WindowState" /> qui détermine si une fenêtre est restaurée, réduite ou agrandie. La valeur par défaut est <see cref="F:System.Windows.WindowState.Normal" /> (restaurée).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant d’une fenêtre est réduite ou agrandie, sa taille et son emplacement sont stockés dans <xref:System.Windows.Window.RestoreBounds%2A>. Lorsqu’une fenêtre est restaurée par la suite, ses valeurs de taille et l’emplacement sont restaurés avec les valeurs de <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Lorsque le <xref:System.Windows.Window.WindowState%2A> propriété est modifiée, <xref:System.Windows.Window.StateChanged> est déclenché.  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.WindowStateProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style de bordure d’une fenêtre.</summary>
        <value>
          <see cref="T:System.Windows.WindowStyle" /> qui spécifie le style de bordure d'une fenêtre. La valeur par défaut est <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> peut s’agir de la <xref:System.Windows.WindowStyle> des valeurs d’énumération, y compris <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (valeur par défaut), et <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 L’illustration suivante montre les styles de fenêtre sur [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (thème Windows Vista Aero avec affichage transparent activé) :  
  
 ![Styles de fenêtre](~/add/media/windowoverviewfigure6.PNG "styles de fenêtre")  
  
> [!NOTE]
>  Impossible de définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.WindowStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.WindowStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>