<Type Name="ChannelDispatcher" FullName="System.ServiceModel.Dispatcher.ChannelDispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1212f4a3ae3d1bc89f872c2a7431978ac159be2f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36615053" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ChannelDispatcher : System.ServiceModel.Dispatcher.ChannelDispatcherBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ChannelDispatcher extends System.ServiceModel.Dispatcher.ChannelDispatcherBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class ChannelDispatcher&#xA;Inherits ChannelDispatcherBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChannelDispatcher : System::ServiceModel::Dispatcher::ChannelDispatcherBase" />
  <TypeSignature Language="F#" Value="type ChannelDispatcher = class&#xA;    inherit ChannelDispatcherBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Dispatcher.ChannelDispatcherBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Composant qui accepte les canaux et les associe à un service.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objet <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> associe un <xref:System.ServiceModel.Channels.IChannelListener> d'un URI particulier (appelé un URI d'écoute) à une instance d'un service. Chaque objet <xref:System.ServiceModel.ServiceHost> peut avoir de nombreux objets <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>, chacun étant associé à un écouteur et un URI d'écoute différents pour ce service.  
  
 Lorsqu'un message arrive, le <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> interroge chacun des objets <xref:System.ServiceModel.Dispatcher.EndpointDispatcher> associés pour déterminer si le point de terminaison peut accepter le message, et passe le message à celui-ci. L'objet <xref:System.ServiceModel.Dispatcher.EndpointDispatcher> est chargé du traitement des messages à partir d'un <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> lorsque l'adresse de destination d'un message correspond à la propriété <xref:System.ServiceModel.Dispatcher.EndpointDispatcher.AddressFilter%2A> et que l'action de message correspond à la propriété <xref:System.ServiceModel.Dispatcher.EndpointDispatcher.ContractFilter%2A>.  
  
 Toutes les propriétés qui contrôlent la durée de vie et le comportement d'une session de canal sont disponibles pour l'inspection ou la modification sur l'objet <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>. En plus du <xref:System.ServiceModel.Dispatcher.EndpointDispatcher>, ceux-ci incluent des objets <xref:System.ServiceModel.Dispatcher.IChannelInitializer> personnalisés, l'<xref:System.ServiceModel.Channels.IChannelListener>, l'<xref:System.ServiceModel.ServiceHost>, et le <xref:System.ServiceModel.InstanceContext> associé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/service.cs#0)]
 [!code-vb[S_UE_ChannelDispatcher#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/service.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ChannelDispatcher (System.ServiceModel.Channels.IChannelListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.IChannelListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.#ctor(System.ServiceModel.Channels.IChannelListener)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (listener As IChannelListener)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ChannelDispatcher(System::ServiceModel::Channels::IChannelListener ^ listener);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.ChannelDispatcher : System.ServiceModel.Channels.IChannelListener -&gt; System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="new System.ServiceModel.Dispatcher.ChannelDispatcher listener" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="listener" Type="System.ServiceModel.Channels.IChannelListener" />
      </Parameters>
      <Docs>
        <param name="listener">
          <see cref="T:System.ServiceModel.Channels.IChannelListener" /> pour le répartiteur de canal.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialise une nouvelle instance de la classe <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> à partir de l'écouteur fourni, avec les délais d'attente par défaut fournis par le système.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#1)]
 [!code-vb[S_UE_ChannelDispatcher#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="listener" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ChannelDispatcher (System.ServiceModel.Channels.IChannelListener listener, string bindingName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.IChannelListener listener, string bindingName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.#ctor(System.ServiceModel.Channels.IChannelListener,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (listener As IChannelListener, bindingName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ChannelDispatcher(System::ServiceModel::Channels::IChannelListener ^ listener, System::String ^ bindingName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.ChannelDispatcher : System.ServiceModel.Channels.IChannelListener * string -&gt; System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="new System.ServiceModel.Dispatcher.ChannelDispatcher (listener, bindingName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="listener" Type="System.ServiceModel.Channels.IChannelListener" />
        <Parameter Name="bindingName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="listener">
          <see cref="T:System.ServiceModel.Channels.IChannelListener" /> pour le répartiteur de canal.</param>
        <param name="bindingName">Nom de la liaison utilisée pour configurer le service.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialise une nouvelle instance de la classe <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> à partir de l'écouteur et de la liaison fournis, avec les délais d'attente par défaut fournis par le système.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#2)]
 [!code-vb[S_UE_ChannelDispatcher#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="listener" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ChannelDispatcher (System.ServiceModel.Channels.IChannelListener listener, string bindingName, System.ServiceModel.IDefaultCommunicationTimeouts timeouts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.IChannelListener listener, string bindingName, class System.ServiceModel.IDefaultCommunicationTimeouts timeouts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.#ctor(System.ServiceModel.Channels.IChannelListener,System.String,System.ServiceModel.IDefaultCommunicationTimeouts)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (listener As IChannelListener, bindingName As String, timeouts As IDefaultCommunicationTimeouts)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ChannelDispatcher(System::ServiceModel::Channels::IChannelListener ^ listener, System::String ^ bindingName, System::ServiceModel::IDefaultCommunicationTimeouts ^ timeouts);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.ChannelDispatcher : System.ServiceModel.Channels.IChannelListener * string * System.ServiceModel.IDefaultCommunicationTimeouts -&gt; System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="new System.ServiceModel.Dispatcher.ChannelDispatcher (listener, bindingName, timeouts)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="listener" Type="System.ServiceModel.Channels.IChannelListener" />
        <Parameter Name="bindingName" Type="System.String" />
        <Parameter Name="timeouts" Type="System.ServiceModel.IDefaultCommunicationTimeouts" />
      </Parameters>
      <Docs>
        <param name="listener">
          <see cref="T:System.ServiceModel.Channels.IChannelListener" /> pour le service.</param>
        <param name="bindingName">Nom de la liaison utilisée pour configurer le service.</param>
        <param name="timeouts">
          <see cref="T:System.ServiceModel.IDefaultCommunicationTimeouts" /> pour le service.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialise une nouvelle instance de la classe <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> à partir de l'écouteur et de la liaison fournis, avec les délais d'attente par défaut spécifiés.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#3)]
 [!code-vb[S_UE_ChannelDispatcher#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="listener" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsynchronousTransactedAcceptEnabled">
      <MemberSignature Language="C#" Value="public bool AsynchronousTransactedAcceptEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsynchronousTransactedAcceptEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.AsynchronousTransactedAcceptEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property AsynchronousTransactedAcceptEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsynchronousTransactedAcceptEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsynchronousTransactedAcceptEnabled : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.AsynchronousTransactedAcceptEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les appels de la méthode accept traitée sur l'écouteur sont asynchrones.</summary>
        <value>
          <see langword="true" /> si les appels de la méthode accept effectués sous une transaction sont asynchrones ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="protected override void Attach (System.ServiceModel.ServiceHostBase host);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Attach(class System.ServiceModel.ServiceHostBase host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.Attach(System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Attach (host As ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Attach(System::ServiceModel::ServiceHostBase ^ host);" />
      <MemberSignature Language="F#" Value="override this.Attach : System.ServiceModel.ServiceHostBase -&gt; unit" Usage="channelDispatcher.Attach host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="host">
          <see cref="T:System.ServiceModel.ServiceHostBase" /> pour le service.</param>
        <summary>Attache le répartiteur de canal à l'hôte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingName">
      <MemberSignature Language="C#" Value="public string BindingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BindingName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.BindingName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BindingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingName : string" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.BindingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de la liaison utilisée pour configurer le service.</summary>
        <value>Nom de liaison du service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisé pour obtenir le nom de liaison pour la liaison à laquelle ce répartiteur de canal est associé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#4)]
 [!code-vb[S_UE_ChannelDispatcher#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelInitializers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt; ChannelInitializers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IChannelInitializer&gt; ChannelInitializers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ChannelInitializers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelInitializers As SynchronizedCollection(Of IChannelInitializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IChannelInitializer ^&gt; ^ ChannelInitializers { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IChannelInitializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelInitializers : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt;" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ChannelInitializers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IChannelInitializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un ensemble d'objets <see cref="T:System.ServiceModel.Dispatcher.IChannelInitializer" /> que vous pouvez utiliser pour inspecter et ajouter l'état aux canaux lors de leur création.</summary>
        <value>Collection <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> d'objets de type <see cref="T:System.ServiceModel.Dispatcher.IChannelInitializer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour insérer un initialiseur de canal personnalisé dans la collection d’initialisation pour inspecter ou modifier l’état des canaux lors de leur création. Cette propriété est également utile pour exécuter le même comportement sur les canaux sortants si le contrat associé à un répartiteur est un contrat duplex.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#5)]
 [!code-vb[S_UE_ChannelDispatcher#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseInput">
      <MemberSignature Language="C#" Value="public override void CloseInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CloseInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.CloseInput" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CloseInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CloseInput();" />
      <MemberSignature Language="F#" Value="override this.CloseInput : unit -&gt; unit" Usage="channelDispatcher.CloseInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompt l'acceptation de nouveaux canaux par l'écouteur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel à cette méthode interrompt l'écoute.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected override TimeSpan DefaultCloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultCloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCloseTimeout : TimeSpan" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultCloseTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'intervalle de temps par défaut autorisé pour la fermeture du répartiteur de canal.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> qui spécifie l'intervalle de temps par défaut autorisé pour la fermeture du répartiteur de canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce délai d'attente de fermeture par défaut peut être défini à l'aide de <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.%23ctor%28System.ServiceModel.Channels.IChannelListener%2CSystem.String%2CSystem.ServiceModel.IDefaultCommunicationTimeouts%29>. Sinon, une valeur par défaut de modèle de service de 1 minute est utilisée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected override TimeSpan DefaultOpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultOpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultOpenTimeout : TimeSpan" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.DefaultOpenTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'intervalle de temps par défaut autorisé pour l'ouverture du répartiteur de canal.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> qui spécifie l'intervalle de temps par défaut autorisé pour la fermeture du répartiteur de canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce délai d'attente d'ouverture par défaut peut être défini à l'aide de <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.%23ctor%28System.ServiceModel.Channels.IChannelListener%2CSystem.String%2CSystem.ServiceModel.IDefaultCommunicationTimeouts%29>. Sinon, une valeur par défaut de modèle de service de 1 minute est utilisée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="protected override void Detach (System.ServiceModel.ServiceHostBase host);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Detach(class System.ServiceModel.ServiceHostBase host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.Detach(System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Detach (host As ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Detach(System::ServiceModel::ServiceHostBase ^ host);" />
      <MemberSignature Language="F#" Value="override this.Detach : System.ServiceModel.ServiceHostBase -&gt; unit" Usage="channelDispatcher.Detach host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="host">
          <see cref="T:System.ServiceModel.ServiceHostBase" /> pour le service.</param>
        <summary>Détache l'hôte de service du répartiteur de canal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceHostBase> peut uniquement être détachée lorsqu'une instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
 Affecte la valeur <xref:System.ServiceModel.ServiceHostBase> à l'`null` associé au répartiteur de canal.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#18)]
 [!code-vb[S_UE_ChannelDispatcher#18](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Endpoints">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.EndpointDispatcher&gt; Endpoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.EndpointDispatcher&gt; Endpoints" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.Endpoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Endpoints As SynchronizedCollection(Of EndpointDispatcher)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::EndpointDispatcher ^&gt; ^ Endpoints { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::EndpointDispatcher ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Endpoints : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.EndpointDispatcher&gt;" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.Endpoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.EndpointDispatcher&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les répartiteurs de point de terminaison qui transfèrent les messages aux points de terminaison de canal.</summary>
        <value>
          <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> de <see cref="T:System.ServiceModel.Dispatcher.EndpointDispatcher" /> qui transfère les messages aux points de terminaison de canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> a un <xref:System.ServiceModel.Dispatcher.EndpointDispatcher> distinct pour chaque point de terminaison que le canal peut prendre en charge.  
  
 Utilisez le <xref:System.ServiceModel.Dispatcher.EndpointDispatcher> pour obtenir l'accès aux propriétés d'exécution qui vous permettent de personnaliser l'exécution pour la totalité d'un point de terminaison.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#6)]
 [!code-vb[S_UE_ChannelDispatcher#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorHandlers">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Dispatcher.IErrorHandler&gt; ErrorHandlers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Dispatcher.IErrorHandler&gt; ErrorHandlers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ErrorHandlers As Collection(Of IErrorHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Dispatcher::IErrorHandler ^&gt; ^ ErrorHandlers { System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Dispatcher::IErrorHandler ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ErrorHandlers : System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Dispatcher.IErrorHandler&gt;" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Dispatcher.IErrorHandler&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un ensemble d'objets <see cref="T:System.ServiceModel.Dispatcher.IErrorHandler" /> qui peuvent être utilisés pour insérer les fonctionnalités de gestion des erreurs personnalisées pour un point de terminaison.</summary>
        <value>
          <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> d'objets <see cref="T:System.ServiceModel.Dispatcher.IErrorHandler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#7)]
 [!code-vb[S_UE_ChannelDispatcher#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.ServiceHostBase Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceHostBase Host" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.Host" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Host As ServiceHostBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ServiceModel::ServiceHostBase ^ Host { System::ServiceModel::ServiceHostBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : System.ServiceModel.ServiceHostBase" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceHostBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'hôte pour le service associé au répartiteur.</summary>
        <value>
          <see cref="T:System.ServiceModel.ServiceHostBase" /> pour le service associé au répartiteur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque objet <xref:System.ServiceModel.ServiceHost> peut avoir de nombreux objets <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>, chacun étant associé à un <xref:System.ServiceModel.Channels.IChannelListener> différent pour ce service.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#8)]
 [!code-vb[S_UE_ChannelDispatcher#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique s'il faut inclure les détails sur une exception dans une erreur.</summary>
        <value>
          <see langword="true" /> si les détails sur une exception sont inclus dans les erreurs ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#19)]
 [!code-vb[S_UE_ChannelDispatcher#19](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsTransactedAccept">
      <MemberSignature Language="C#" Value="public bool IsTransactedAccept { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTransactedAccept" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedAccept" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTransactedAccept As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTransactedAccept { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTransactedAccept : bool" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedAccept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les appels de la méthode accept sur l’écouteur sont effectués sous une transaction.</summary>
        <value>
          <see langword="true" /> si les appels de la méthode accept sur l'écouteur sont effectués sous une transaction ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#9)]
 [!code-vb[S_UE_ChannelDispatcher#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransactedReceive">
      <MemberSignature Language="C#" Value="public bool IsTransactedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTransactedReceive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTransactedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTransactedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTransactedReceive : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les appels de la méthode receive sur l’écouteur sont effectués sous une transaction.</summary>
        <value>
          <see langword="true" /> si les appels de la méthode receive sur l'écouteur sont effectués sous une transaction ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.IsTransactedReceive%2A> peut uniquement être définie lorsqu'une instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#10)]
 [!code-vb[S_UE_ChannelDispatcher#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listener">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener Listener { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.IChannelListener Listener" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.Listener" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Listener As IChannelListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ServiceModel::Channels::IChannelListener ^ Listener { System::ServiceModel::Channels::IChannelListener ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Listener : System.ServiceModel.Channels.IChannelListener" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.Listener" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'écouteur associé au répartiteur de canal.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.IChannelListener" /> associé au répartiteur de canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> associe un <xref:System.ServiceModel.Channels.IChannelListener> d'un URI particulier à une instance d'un service.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#11)]
 [!code-vb[S_UE_ChannelDispatcher#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManualAddressing">
      <MemberSignature Language="C#" Value="public bool ManualAddressing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ManualAddressing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ManualAddressing" />
      <MemberSignature Language="VB.NET" Value="Public Property ManualAddressing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ManualAddressing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ManualAddressing : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ManualAddressing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le répartiteur de canal ajoute des en-têtes d'adressage aux messages de demande/réponse.</summary>
        <value>
          <see langword="true" /> si le proxy n'ajoute pas d'en-tête d'adressage ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
 Affectez la valeur <xref:System.ServiceModel.Dispatcher.ClientRuntime.ManualAddressing%2A> à la propriété `true` si vous souhaitez empêcher le client d'ajouter les en-têtes d'adressage ID du message et Répondre à aux messages de demande/réponse de sorte que votre application puisse contrôler ces en-têtes.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#12)]
 [!code-vb[S_UE_ChannelDispatcher#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingReceives">
      <MemberSignature Language="C#" Value="public int MaxPendingReceives { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingReceives" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.MaxPendingReceives" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingReceives As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingReceives { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPendingReceives : int with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.MaxPendingReceives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les messages en attente maximaux par canal.</summary>
        <value>Entier qui représente un nombre maximal de messages.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxTransactedBatchSize">
      <MemberSignature Language="C#" Value="public int MaxTransactedBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransactedBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.MaxTransactedBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransactedBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransactedBatchSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxTransactedBatchSize : int with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.MaxTransactedBatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille maximale pour un lot traité.</summary>
        <value>Taille maximale pour un lot traité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.MaxTransactedBatchSize%2A> peut uniquement être définie lorsqu'une instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#13)]
 [!code-vb[S_UE_ChannelDispatcher#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure à zéro.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.MessageVersion MessageVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.MessageVersion MessageVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.MessageVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageVersion As MessageVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::MessageVersion ^ MessageVersion { System::ServiceModel::Channels::MessageVersion ^ get(); void set(System::ServiceModel::Channels::MessageVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageVersion : System.ServiceModel.Channels.MessageVersion with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.MessageVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.MessageVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le message SOAP et les versions WS-Addressing qui sont utilisées ou attendues.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.MessageVersion" /> qui est utilisée ou attendue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifie les versions de SOAP et WS-Addressing associées à un message et son échange.  
  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#20)]
 [!code-vb[S_UE_ChannelDispatcher#20](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected override void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnAbort" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAbort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAbort();" />
      <MemberSignature Language="F#" Value="override this.OnAbort : unit -&gt; unit" Usage="channelDispatcher.OnAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abandonne l'écouteur associé au répartiteur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnBeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override IAsyncResult ^ OnBeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="channelDispatcher.OnBeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution de l'opération de fermeture avant le dépassement du délai d'attente.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone de fermeture.</param>
        <param name="state">Objet, spécifié par l'application, qui contient les informations d'état associées à l'opération asynchrone de fermeture.</param>
        <summary>Commence une opération asynchrone pour fermer un écouteur de canal pour le répartiteur qui doit être terminée dans un intervalle de temps spécifié.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui référence l'opération asynchrone pour fermer un écouteur de canal pour le répartiteur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnBeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override IAsyncResult ^ OnBeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="channelDispatcher.OnBeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution de l'opération d'ouverture avant le dépassement du délai d'attente.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone d'ouverture.</param>
        <param name="state">Objet, spécifié par l'application, qui contient des informations d'état associées à l'opération d'ouverture asynchrone.</param>
        <summary>Commence une opération asynchrone pour ouvrir un écouteur de canal pour le répartiteur qui doit être terminée dans un intervalle de temps spécifié.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui référence l'opération asynchrone pour ouvrir un écouteur de canal pour le répartiteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répartiteur de canal doit être associé à un hôte de service qui n'a pas la valeur `null` lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'hôte ou la version de message a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected override void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnClose(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClose (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClose(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="override this.OnClose : TimeSpan -&gt; unit" Usage="channelDispatcher.OnClose timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie l'intervalle de temps autorisé pour la fermeture de l'écouteur.</param>
        <summary>Ferme l'écouteur de canal associé au répartiteur dans un intervalle de temps spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="channelDispatcher.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un suivi de la fermeture des répartiteurs de point de terminaison associés au répartiteur de canal.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected override void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnEndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndClose : IAsyncResult -&gt; unit" Usage="channelDispatcher.OnEndClose result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Termine une opération asynchrone pour fermer un écouteur de canal pour le répartiteur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected override void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnEndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndOpen : IAsyncResult -&gt; unit" Usage="channelDispatcher.OnEndOpen result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Termine une opération asynchrone pour ouvrir un écouteur de canal pour le répartiteur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpen">
      <MemberSignature Language="C#" Value="protected override void OnOpen (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpen(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnOpen(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpen (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpen(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="override this.OnOpen : TimeSpan -&gt; unit" Usage="channelDispatcher.OnOpen timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie l'intervalle de temps autorisé pour l'ouverture de l'écouteur.</param>
        <summary>Ouvre l'écouteur associé au répartiteur de canal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répartiteur de canal doit être associé à un hôte de service qui n'a pas la valeur `null` lorsque cette méthode est appelée et la valeur `null` ne doit pas être affectée à la version de message.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'hôte ou la version de message a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected override void OnOpened ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpened() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnOpened" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpened ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpened();" />
      <MemberSignature Language="F#" Value="override this.OnOpened : unit -&gt; unit" Usage="channelDispatcher.OnOpened " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remplit et valide la table de filtres utilisée pour distribuer aux points de terminaison.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répartiteur de canal doit être associé à un hôte de service qui n'a pas la valeur `null` lorsque cette méthode est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'hôte a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnOpening">
      <MemberSignature Language="C#" Value="protected override void OnOpening ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpening() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.ChannelDispatcher.OnOpening" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpening ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpening();" />
      <MemberSignature Language="F#" Value="override this.OnOpening : unit -&gt; unit" Usage="channelDispatcher.OnOpening " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie si le répartiteur de canal est attaché à un hôte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répartiteur de canal doit être associé à un hôte de service qui n'a pas la valeur `null` à l'ouverture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'hôte a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveContextEnabled : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveContextEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si ReceiveContext est activé.</summary>
        <value>
          <see langword="true" /> si ReceiveContext est activé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ReceiveContext contrôle la manière à laquelle les messages sont contrôlés par le service, en verrouillant par exemple le message aussi longtemps que nécessaire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveSynchronously">
      <MemberSignature Language="C#" Value="public bool ReceiveSynchronously { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveSynchronously { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveSynchronously : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si le répartiteur utilise des appels synchrones pour lire les messages de canaux.</summary>
        <value>
          <see langword="true" /> si le répartiteur utilise des méthodes synchrones pour lire les messages de canaux ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une liaison implémente <xref:System.ServiceModel.Channels.IBindingRuntimePreferences>, Windows Communication Foundation (WCF) affecte la valeur de la <xref:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously%2A> propriété à cette propriété. Si cette valeur est `true`, la valeur par défaut `false` de <xref:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously%2A> est donc substituée.  
  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#14)]
 [!code-vb[S_UE_ChannelDispatcher#14](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsynchronously">
      <MemberSignature Language="C#" Value="public bool SendAsynchronously { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendAsynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.SendAsynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Property SendAsynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendAsynchronously { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendAsynchronously : bool with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.SendAsynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si les messages sont envoyés de façon asynchrone.</summary>
        <value>
          <see langword="true" /> si les messages sont envoyés de façon asynchrone; sinon <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceThrottle">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.ServiceThrottle ServiceThrottle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.ServiceThrottle ServiceThrottle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.ServiceThrottle" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceThrottle As ServiceThrottle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::ServiceThrottle ^ ServiceThrottle { System::ServiceModel::Dispatcher::ServiceThrottle ^ get(); void set(System::ServiceModel::Dispatcher::ServiceThrottle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceThrottle : System.ServiceModel.Dispatcher.ServiceThrottle with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.ServiceThrottle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.ServiceThrottle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la limitation de service pour le service associé au répartiteur de canal.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Dispatcher.ServiceThrottle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela fournit l'accès aux contrôles utilisés pour optimiser la disponibilité et les performances d'un service.  
  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#15)]
 [!code-vb[S_UE_ChannelDispatcher#15](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le niveau d’isolement par défaut pour les transactions.</summary>
        <value>Une des valeurs de <see cref="T:System.Transactions.IsolationLevel" />. La valeur par défaut est <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionIsolationLevel%2A> pour obtenir ou définir le niveau d'isolement par défaut pour les transactions créées par le répartiteur pour le service.  
  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#16)]
 [!code-vb[S_UE_ChannelDispatcher#16](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le niveau d'isolement n'est pas défini.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TransactionTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : TimeSpan with get, set" Usage="System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie le délai d’attente par défaut pour les transactions créées par le répartiteur pour le compte du service.</summary>
        <value>Valeur <see cref="T:System.TimeSpan" /> qui représente le délai d'attente par défaut pour les transactions. La valeur par défaut est <see cref="F:System.TimeSpan.Zero" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut uniquement être définie lorsque l'instance du <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> est à l'état <xref:System.ServiceModel.CommunicationState.Created>, étant donné qu'il s'agit du seul état qui soit à la fois mutable et non disposé.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ChannelDispatcher#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_channeldispatcher/cs/snippets.cs#17)]
 [!code-vb[S_UE_ChannelDispatcher#17](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_ue_channeldispatcher/vb/snippets.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure à zéro ou trop élevée.</exception>
        <exception cref="T:System.InvalidOperationException">L'objet de communication est dans un état <see cref="F:System.ServiceModel.CommunicationState.Opening" /> ou <see cref="F:System.ServiceModel.CommunicationState.Opened" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Closing" /> ou <see cref="F:System.ServiceModel.CommunicationState.Closed" />.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">L'objet de communication est dans l'état <see cref="F:System.ServiceModel.CommunicationState.Faulted" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>