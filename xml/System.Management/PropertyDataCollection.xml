<Type Name="PropertyDataCollection" FullName="System.Management.PropertyDataCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8478cf87f93f89c2f5885dfedab722b6786c9f47" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36477760" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyDataCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyDataCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Management.PropertyDataCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyDataCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyDataCollection : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type PropertyDataCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Management</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente le jeu de propriétés d'un objet WMI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant répertorie des informations sur la **Win32_OperatingSystem** à l’aide de la classe la <xref:System.Management.PropertyData> classe. Pour plus d’informations sur **Win32_OperatingSystem**, consultez la documentation de Windows Management Instrumentation dans MSDN Library à http://msdn.microsoft.com/library.  
  
 [!code-csharp[wminet_PropertyDataCollection#1](~/samples/snippets/csharp/VS_Snippets_WindowsServer/wminet_PropertyDataCollection/cs/PropertyDataCollection.cs#1)]
 [!code-vb[wminet_PropertyDataCollection#1](~/samples/snippets/visualbasic/VS_Snippets_WindowsServer/wminet_PropertyDataCollection/vb/PropertyDataCollection.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un nouvel objet <see cref="T:System.Management.PropertyData" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (string propertyName, object propertyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string propertyName, object propertyValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.Add(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (propertyName As String, propertyValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ propertyName, System::Object ^ propertyValue);" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj -&gt; unit&#xA;override this.Add : string * obj -&gt; unit" Usage="propertyDataCollection.Add (propertyName, propertyValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="propertyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la nouvelle propriété.</param>
        <param name="propertyValue">Valeur de la propriété (ne peut pas être null).</param>
        <summary>Ajoute un nouveau <see cref="T:System.Management.PropertyData" /> avec la valeur spécifiée. La valeur ne peut pas être null et doit pouvoir être convertie en un type CIM (Common Information Model).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés ne peuvent être ajoutées qu’aux définitions de classe, pas aux instances. Cette méthode est uniquement valide lorsqu’elle est appelée sur une <xref:System.Management.PropertyDataCollection> dans un <xref:System.Management.ManagementClass>.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string propertyName, System.Management.CimType propertyType, bool isArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string propertyName, valuetype System.Management.CimType propertyType, bool isArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.Add(System.String,System.Management.CimType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (propertyName As String, propertyType As CimType, isArray As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ propertyName, System::Management::CimType propertyType, bool isArray);" />
      <MemberSignature Language="F#" Value="member this.Add : string * System.Management.CimType * bool -&gt; unit" Usage="propertyDataCollection.Add (propertyName, propertyType, isArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Management.CimType" />
        <Parameter Name="isArray" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété.</param>
        <param name="propertyType">Type CIM (Common Information Model) de la propriété.</param>
        <param name="isArray">
          <see langword="true" /> pour spécifier que la propriété est de type tableau ; sinon <see langword="false" />.</param>
        <summary>Ajoute un nouveau <see cref="T:System.Management.PropertyData" /> sans valeur assignée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés ne peuvent être ajoutées qu’aux définitions de classe, pas aux instances. Cette méthode est uniquement valide lorsqu’elle est appelée sur une <xref:System.Management.PropertyDataCollection> dans un <xref:System.Management.ManagementClass>.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string propertyName, object propertyValue, System.Management.CimType propertyType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string propertyName, object propertyValue, valuetype System.Management.CimType propertyType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.Add(System.String,System.Object,System.Management.CimType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (propertyName As String, propertyValue As Object, propertyType As CimType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ propertyName, System::Object ^ propertyValue, System::Management::CimType propertyType);" />
      <MemberSignature Language="F#" Value="member this.Add : string * obj * System.Management.CimType -&gt; unit" Usage="propertyDataCollection.Add (propertyName, propertyValue, propertyType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="propertyValue" Type="System.Object" />
        <Parameter Name="propertyType" Type="System.Management.CimType" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété.</param>
        <param name="propertyValue">Valeur de la propriété (peut être null).</param>
        <param name="propertyType">Type CIM de la propriété.</param>
        <summary>Ajoute un nouveau <see cref="T:System.Management.PropertyData" /> avec la valeur et le type CIM (Common Information Model) spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés ne peuvent être ajoutées qu’aux définitions de classe, pas aux instances. Cette méthode est uniquement valide lorsqu’elle est appelée sur une <xref:System.Management.PropertyDataCollection> dans un <xref:System.Management.ManagementClass>.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie l’objet <see cref="T:System.Management.PropertyDataCollection" /> dans un tableau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="propertyDataCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau vers lequel copier <see cref="T:System.Management.PropertyDataCollection" />.</param>
        <param name="index">Index à partir duquel commencer la copie.</param>
        <summary>Copie <see cref="T:System.Management.PropertyDataCollection" /> dans un tableau.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Management.PropertyData[] propertyArray, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Management.PropertyData[] propertyArray, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.CopyTo(System.Management.PropertyData[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (propertyArray As PropertyData(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Management::PropertyData ^&gt; ^ propertyArray, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Management.PropertyData[] * int -&gt; unit" Usage="propertyDataCollection.CopyTo (propertyArray, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyArray" Type="System.Management.PropertyData[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propertyArray">Tableau de destination devant contenir le <see cref="T:System.Management.PropertyDataCollection" /> copié.</param>
        <param name="index">Index dans le tableau de destination à partir duquel commencer la copie.</param>
        <summary>Copie <see cref="T:System.Management.PropertyDataCollection" /> dans un tableau d'objets <see cref="T:System.Management.PropertyData" /> spécialisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Management.PropertyDataCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Management.PropertyDataCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'objets dans <see cref="T:System.Management.PropertyDataCollection" />.</summary>
        <value>Retourne une valeur <see cref="T:System.Int32" /> représentant le nombre d'objets de la collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valeur de propriété  
 Nombre d'objets de la collection.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Management.PropertyDataCollection.PropertyDataEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Management.PropertyDataCollection/PropertyDataEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As PropertyDataCollection.PropertyDataEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Management::PropertyDataCollection::PropertyDataEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Management.PropertyDataCollection.PropertyDataEnumerator" Usage="propertyDataCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.PropertyDataCollection+PropertyDataEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l'énumérateur pour <see cref="T:System.Management.PropertyDataCollection" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez parcourir (comme dans Visual Basic .NET `For Each` instruction ou c# `For` instruction) un énumérateur avant qu’une seule fois. La mémoire qui contient les instances est libérée par WMI afin que l’énumérateur ne peut pas être réutilisé. Par conséquent, le <xref:System.Management.PropertyDataCollection.Count%2A> méthode ne peut pas être utilisée car elle requiert le rembobinage de l’énumérateur.  
  
 Les énumérateurs avant uniquement sont généralement beaucoup plus rapides et utilisent moins de mémoire que les énumérateurs classiques, mais ils ne permettent pas d’appels à <xref:System.Management.PropertyDataCollection.PropertyDataEnumerator.Reset%2A>.  
  
 Si un énumérateur est rembobinable, les objets dans la collection restent disponibles pour plusieurs énumérations.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Management.PropertyDataCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Management.PropertyDataCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'objet est synchronisé.</summary>
        <value>Retourne une valeur <see cref="T:System.Boolean" /> indiquant si l'objet est synchronisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valeur de propriété  
 `true` Si l’objet est synchronisé ; dans le cas contraire, `false`.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Management.PropertyData this[string propertyName] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.PropertyData Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Management.PropertyDataCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(propertyName As String) As PropertyData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Management::PropertyData ^ default[System::String ^] { System::Management::PropertyData ^ get(System::String ^ propertyName); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Management.PropertyData" Usage="System.Management.PropertyDataCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.PropertyData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété à récupérer.</param>
        <summary>Obtient la propriété spécifiée de <see cref="T:System.Management.PropertyDataCollection" /> en utilisant la syntaxe []. Cette propriété est l'indexeur de la classe <see cref="T:System.Management.PropertyDataCollection" />.</summary>
        <value>Retourne un <see cref="T:System.Management.PropertyData" /> qui contient les données d'une propriété spécifiée dans la collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valeur de propriété  
 A <xref:System.Management.PropertyData>, basé sur le nom spécifié.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
   
  
## Examples  
 L’exemple suivant obtient la **Freespace** propriété d’un <xref:System.Management.ManagementClass>.  
  
 [!code-csharp[wminet_PropertyDataCollection_Item#1](~/samples/snippets/csharp/VS_Snippets_WindowsServer/wminet_PropertyDataCollection_Item/cs/PropertyDataCollection_Item.cs#1)]
 [!code-vb[wminet_PropertyDataCollection_Item#1](~/samples/snippets/visualbasic/VS_Snippets_WindowsServer/wminet_PropertyDataCollection_Item/vb/PropertyDataCollection_Item.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (propertyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="abstract member Remove : string -&gt; unit&#xA;override this.Remove : string -&gt; unit" Usage="propertyDataCollection.Remove propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété à supprimer.</param>
        <summary>Supprime un <see cref="T:System.Management.PropertyData" /> de <see cref="T:System.Management.PropertyDataCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés ne peuvent pas être supprimées à partir des définitions de classe, pas à partir d’instances. Cette méthode est uniquement valide lorsqu’elle est appelée sur une collection de propriétés dans un <xref:System.Management.ManagementClass>.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Management.PropertyDataCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Management.PropertyDataCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente l'objet à utiliser pour la synchronisation.</summary>
        <value>Retourne une valeur <see cref="T:System.Object" /> qui contient l'objet à utiliser pour la synchronisation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valeur de propriété  
 Objet à utiliser pour la synchronisation.  
  
## <a name="net-framework-security"></a>Sécurité .NET Framework  
 Confiance totale accordée à l'appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel. Pour plus d’informations, consultez [à l’aide de bibliothèques à partir de Code d’un niveau de confiance partiel](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.PropertyDataCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Collections.IEnumerator" /> qui itère au sein de <see cref="T:System.Management.PropertyDataCollection" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> pour <see cref="T:System.Management.PropertyDataCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 (Visual Basic, c#)  
  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position. À cette position, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur est à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>. Si la collection est modifiée entre <xref:System.Collections.IEnumerator.MoveNext%2A> et <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> retourne l’élément auquel il est attribué, même si l’énumérateur est déjà invalidé.  
  
 L’énumérateur ne dispose pas d’un accès exclusif à la collection. Par conséquent, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>