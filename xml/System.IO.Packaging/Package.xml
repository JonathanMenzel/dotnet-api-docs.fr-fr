<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0786322f5a7b09fbe754ecb9b8253c5a5da85f58" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53227671" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente un conteneur qui peut stocker plusieurs objets de données.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> est une classe abstraite qui peut être utilisée pour organiser les objets en une seule entité d’un format physique défini pour la portabilité et des accès efficace.  
  
 Un fichier ZIP est le principal format physique pour le <xref:System.IO.Packaging.Package>.  Autres <xref:System.IO.Packaging.Package> implémentations peuvent utiliser d’autres formats physiques tels que d’un document XML, une base de données, ou un service Web.  
  
 Comme un système de fichiers, les éléments contenus dans un <xref:System.IO.Packaging.Package> sont référencées dans une organisation hiérarchique des fichiers et dossiers.  
  
 Bien que <xref:System.IO.Packaging.Package> lui-même est une classe abstraite, le <xref:System.IO.Packaging.ZipPackage> classe dérivée est utilisée comme valeur par défaut par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Un <xref:System.IO.Packaging.PackagePart> (« partie ») est la classe abstraite qui représente un objet qui est stocké dans un <xref:System.IO.Packaging.Package>.  
  
 Un <xref:System.IO.Packaging.PackageRelationship> (« relation ») définit une association entre une source de <xref:System.IO.Packaging.Package> ou <xref:System.IO.Packaging.PackagePart> et un objet cible.  Un <xref:System.IO.Packaging.PackageRelationship> peut prendre l’une des deux types, chacun d’eux peut prendre l’une des deux formes :  
  
-   Une relation au niveau du package (créée par le <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> méthode) se rapporte un <xref:System.IO.Packaging.Package> soit :  
  
    -   Une partie de la cible dans le package.  
  
    -   Une ressource cible en dehors du package.  
  
-   Une relation au niveau du composant (créée par le <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> (méthode)) est lié à une source de <xref:System.IO.Packaging.PackagePart> soit :  
  
    -   Une autre partie cible dans le package.  
  
    -   Une ressource cible en dehors du package.  
  
 Source de la relation <xref:System.IO.Packaging.Package> ou source <xref:System.IO.Packaging.PackagePart> est considéré comme le « propriétaire » de la relation.  Lorsque l’objet source est supprimé, toutes les relations appartienne à l’objet source sont également supprimées.  Le processus de création ou suppression d’une relation ne change pas physiquement les objets de la source ou la cible en aucune façon.  
  
 Un <xref:System.IO.Packaging.PackageDigitalSignature> (« signature numérique ») est une composition de parties et relations représentant une signature numérique incluse avec un <xref:System.IO.Packaging.Package>.  La signature numérique identifie l’expéditeur et valide le fait que les composants et relations signés contient dans le <xref:System.IO.Packaging.Package> n’ont pas été modifiées.  
  
 Packages prennent également en charge les droits de gestion numériques (DRM) qui autorise des éléments de contenu dans un <xref:System.IO.Packaging.Package> devant être chiffrées avec des droits d’accès spécifiques accordés aux utilisateurs autorisés.  
  
 Selon le <xref:System.IO.Packaging.Package> architecture, un <xref:System.Windows.Xps.Packaging.XpsDocument> est un type de package conçu pour stocker des documents en fonction de l’ouverture [XML Paper Specification (XPS)](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 Le .NET Framework utilise des packages pour stocker du contenu, les ressources et les relations des pages et des documents à l’aide d’un fichier ZIP standard par défaut. Comme avec n’importe quel fichier ZIP, votre application peut utiliser le <xref:System.IO.Packaging> classes pour stocker et éventuellement protéger tout type ou le nombre de fichiers de données dans un seul conteneur à-un accès efficace.  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre les étapes de base pour la création d’un <xref:System.IO.Packaging.Package>.  Dans cet exemple, un package est créé pour contenir un document avec une image de graphique est affiché en tant que partie du document.  (Cela revient aux cas dans lequel un fichier HTML comporte un \<IMG > balise qui fait référence à un fichier image externe.)  Deux <xref:System.IO.Packaging.PackageRelationship> éléments sont également inclus dans le package.  La première, une relation « au niveau du package », définit la partie du document comme élément racine du package.  Une relation « au niveau du composant » seconde définit l’association entre la partie du document (la « source » de la relation au niveau du composant) et son utilisation de la partie de l’image (« cible » de la relation au niveau du composant).  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Spécification Open Packaging Conventions (OPC)</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Infrastructure de signature numérique des Open Packaging Conventions</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Packaging.Package" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Autorisations E/S de fichier pour le package.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Packaging.Package" /> qui utilise un <see cref="T:System.IO.FileAccess" /> donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> est un constructeur protégé de la <xref:System.IO.Packaging.Package> classe de base abstraite. Lorsqu’elle est appelée dans une classe dérivée, la <xref:System.IO.Packaging.Package.%23ctor%2A> constructeur initialise une nouvelle instance de la classe dérivée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="openFileAccess" /> n'est pas valide.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Autorisations E/S de fichier pour le package.</param>
        <param name="streaming"><see langword="true" /> pour ouvrir le package pour diffusion ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Packaging.Package" /> qui utilise un <see cref="T:System.IO.FileAccess" /> et une option de diffusion donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> est un constructeur protégé de la <xref:System.IO.Packaging.Package> abstraite la classe de base abstraite. Lorsqu’elle est appelée dans une classe dérivée, la <xref:System.IO.Packaging.Package.%23ctor%2A> constructeur initialise une nouvelle instance de la classe dérivée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="openFileAccess" /> n'est pas valide.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre et ferme le package ainsi que tout flux sous-jacent des composants.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour le <xref:System.IO.Packaging.Package> classe <xref:System.IO.Packaging.Package.Close%2A> et <xref:System.IO.Packaging.Package.Dispose%2A> effectuer la même opération : il n’est pas nécessaire d’appeler <xref:System.IO.Packaging.Package.Dispose%2A> si vous appelez <xref:System.IO.Packaging.Package.Close%2A>, ou vice versa.  
  
 <xref:System.IO.Packaging.Package.Close%2A> et <xref:System.IO.Packaging.Package.Dispose%2A> appeler en interne <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  Le `using` instruction (différent de la `using` directive d’espace de noms) est la méthode recommandée pour <xref:System.IO.Packaging.Package.Close%2A> et <xref:System.IO.Packaging.Package.Dispose%2A> un package.  [Écriture d’un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055) et [un exemple de Package de lecture](https://go.microsoft.com/fwlink/?LinkID=160034) indiquent comment fermer et supprimer un package à l’aide de la `using` instruction.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau composant de package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialise un vide <xref:System.IO.Stream> pour la nouvelle partie.  Le <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> méthode peut être utilisée pour obtenir une référence à l’instance de flux de données associée à la partie.  
  
 Pour plus d’informations sur les parties de package, consultez la section 1.1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.PackagePart> puis y stocker des données.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> appelle en interne la classe dérivée <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> méthode pour créer le composant selon le format physique implémenté dans la classe dérivée.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] du nouveau composant.</param>
        <param name="contentType">Type de contenu du flux de données.</param>
        <summary>Crée un nouveau composant non compressé avec un URI et un type de contenu donnés.</summary>
        <returns>Nouveau composant créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialise un vide <xref:System.IO.Stream> pour la nouvelle partie.  Le <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> méthode peut être utilisée pour obtenir une référence à l’instance de flux de données associée à la partie.  
  
 La partie <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> est <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Pour plus d’informations sur les parties de package, consultez la section 1.1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.PackagePart> puis y stocker des données.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ou <paramref name="contentType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> n'est pas un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] <see cref="T:System.IO.Packaging.PackagePart" /> valide.</exception>
        <exception cref="T:System.InvalidOperationException">Un composant  avec le <paramref name="partUri" /> spécifié est déjà présent dans le package.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule (un nouveau composant ne peut pas être ajouté).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> appelle en interne de la classe dérivée <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> méthode pour créer le composant selon le format physique implémenté dans la classe dérivée.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] du nouveau composant.</param>
        <param name="contentType">Type de contenu du flux de données.</param>
        <param name="compressionOption">Option de compression pour le flux de données, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> ou compression <see cref="F:System.IO.Packaging.CompressionOption.Normal" />.</param>
        <summary>Crée un nouveau composant avec un URI, un type de contenu et une option de compression donnés.</summary>
        <returns>Nouveau composant créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour la valeur par défaut <xref:System.IO.Packaging.ZipPackage> classe, dérivée du <xref:System.IO.Packaging.Package.CreatePart%2A> méthode prend uniquement en charge deux `compressionOption` valeurs, <xref:System.IO.Packaging.CompressionOption.NotCompressed> ou <xref:System.IO.Packaging.CompressionOption.Normal> la compression.  Autres <xref:System.IO.Packaging.CompressionOption> les valeurs de <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, ou <xref:System.IO.Packaging.CompressionOption.SuperFast> utiliser <xref:System.IO.Packaging.CompressionOption.Normal> la compression.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Crée un vide <xref:System.IO.Stream> pour la nouvelle partie.  Le <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> méthode peut être utilisée pour obtenir une référence à l’instance de flux de données associée à la partie.  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.PackagePart> puis y stocker des données.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ou <paramref name="contentType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> n'est pas un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] <see cref="T:System.IO.Packaging.PackagePart" /> valide.</exception>
        <exception cref="T:System.InvalidOperationException">Un composant  avec le <paramref name="partUri" /> spécifié est déjà présent dans le package.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <paramref name="compressionOption" /> n'est pas valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule (un nouveau composant ne peut pas être ajouté).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> appelle en interne de la classe dérivée <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> méthode pour créer le composant selon le format physique implémenté dans la classe dérivée.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] pour le composant en cours de création.</param>
        <param name="contentType">Type de contenu du flux de données.</param>
        <param name="compressionOption">Option de compression pour le flux de données.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau composant dans le package.</summary>
        <returns>Composant créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dérivée <xref:System.IO.Packaging.Package.CreatePartCore%2A> méthode est appelée par le <xref:System.IO.Packaging.Package.CreatePart%2A> méthode pour créer le composant selon le format physique implémenté dans la classe dérivée.  
  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> classe implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe est fournie et utilisée.  Dans l’opération par défaut, <xref:System.IO.Packaging.Package.CreatePart%2A> appelle en interne <xref:System.IO.Packaging.Package.CreatePartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> classe pour créer un nouveau composant dans un fichier ZIP.  
  
 Pour la valeur par défaut <xref:System.IO.Packaging.ZipPackage> classe, dérivée du <xref:System.IO.Packaging.Package.CreatePartCore%2A> méthode prend uniquement en charge deux `compressionOption` valeurs, <xref:System.IO.Packaging.CompressionOption.NotCompressed> ou <xref:System.IO.Packaging.CompressionOption.Normal> la compression.  Autres <xref:System.IO.Packaging.CompressionOption> les valeurs de <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, ou <xref:System.IO.Packaging.CompressionOption.SuperFast> utiliser <xref:System.IO.Packaging.CompressionOption.Normal> la compression.  
  
 Pour plus d’informations sur le modèle de package et les composants de package, consultez le chapitre 1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La dérivée <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> implémentation doit pas faire d’hypothèses sur l’ordre ou les opérations effectuées par le <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> méthode qui l’appelle.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une relation au niveau du package pour un composant donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une relation au niveau du package définit une association entre le package et un composant de cible associé ou la ressource.  Une relation au niveau du package peut être une des deux formes.  
  
-   Entre un <xref:System.IO.Packaging.Package> vers une cible <xref:System.IO.Packaging.PackagePart> à l’intérieur du package.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une ressource cible en dehors du package.  
  
 Dans une relation de package, le package est considéré comme le « propriétaire » de la relation.  Lorsque le package est supprimé, toutes les relations possédées par le package sont également supprimées.  Le processus de création ou la suppression de la relation ne modifie pas physiquement le composant cible ou la ressource en aucune façon.  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant illustre la création d’un <xref:System.IO.Packaging.PackageRelationship> entre un <xref:System.IO.Packaging.Package> et une partie du document racine.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] du composant cible.</param>
        <param name="targetMode">Indique si le composant cible est <see cref="F:System.IO.Packaging.TargetMode.Internal" /> ou <see cref="F:System.IO.Packaging.TargetMode.External" /> au package.</param>
        <param name="relationshipType">URI qui définit de façon unique le rôle de la relation.</param>
        <summary>Crée une relation au niveau du package avec un composant avec URI, mode cible et type de relation donnés.</summary>
        <returns>Relation au niveau du package avec le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une relation au niveau du package définit une association entre le package et un composant de cible associé ou la ressource.  Une relation au niveau du package peut être une des deux formes.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une partie cible dans le package.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une ressource cible en dehors du package.  
  
 Dans une relation de package, le package est considéré comme le « propriétaire » de la relation.  Lorsque le package est supprimé, toutes les relations possédées par le package sont également supprimées.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> ne modifie pas physiquement le composant cible ou la ressource en aucune façon.  
  
 La cible d’une relation ne peut pas être une autre relation.  
  
 Si `targetMode` est spécifié en tant que <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` doit être un URI relatif est formé conformément à la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource).  L’URI relatif interne peut être un chemin absolu qui commence par une barre oblique (« / ») caractère tel que « / page1.xaml » ou « / /images/picture4.jpg », ou un chemin relatif tel que «.. / imagespicture1.jpg » qui se résout par rapport à la racine du package (« / ») en tant que l’URI de base.  
  
 Si `targetMode` est spécifié en tant que <xref:System.IO.Packaging.TargetMode.External>, `targetUri` peut être soit absolu ou relatif URI formé en fonction de la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource). `http://www.microsoft.com/page2.xml` est un exemple d’un URI absolu qui fait référence à une ressource cible externe « page2.xm ».  « images/picture1.jpg » est un exemple d’un URI relatif qui fait également référence à une cible externe ressource « 1.jpg », mais qui est résolue par rapport à l’URI du package lui-même.  
  
 `relationshipType` doit être un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formé conformément à la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource).  Le tableau suivant présente le niveau de package `relationshipType` URI défini par la spécification Open Packaging Conventions (OPC).  
  
|Relation au niveau du package|URI de Type de relation|  
|---------------------------------|---------------------------|  
|Propriétés principales|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Certificat de Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Origine de la Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniature|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Pour plus d’informations sur l’empaquetage et les relations de package, consultez la section 1.3 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.IO.Packaging.Package.CreateRelationship%2A> pour créer un <xref:System.IO.Packaging.PackageRelationship> entre un <xref:System.IO.Packaging.Package> et une partie du document racine.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> ou <paramref name="relationshipType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le composant <paramref name="targetUri" /> est un <see cref="T:System.IO.Packaging.PackageRelationship" />, ou <paramref name="targetMode" /> est <see cref="F:System.IO.Packaging.TargetMode.Internal" /> et <paramref name="targetUri" /> est un URI absolu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="targetMode" /> n'est pas valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] du composant cible.</param>
        <param name="targetMode">Indique si le composant cible est <see cref="F:System.IO.Packaging.TargetMode.Internal" /> ou <see cref="F:System.IO.Packaging.TargetMode.External" /> au package.</param>
        <param name="relationshipType">URI qui définit de façon unique le rôle de la relation.</param>
        <param name="id">Identificateur XML unique.</param>
        <summary>Crée une relation au niveau du package avec un composant avec URI, mode cible, type de relation et [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)] donnés.</summary>
        <returns>Relation au niveau du package avec le composant spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une relation au niveau du package définit une association entre le package et un composant de cible associé ou la ressource.  Une relation au niveau du package peut être une des deux formes.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une partie cible dans le package.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une ressource cible en dehors du package.  
  
 Dans une relation de package, le package est considéré comme le « propriétaire » de la relation.  Lorsque le package est supprimé, toutes les relations possédées par le package sont également supprimées.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> ne modifie pas physiquement le composant cible ou la ressource en aucune façon.  
  
 La cible d’une relation ne peut pas être une autre relation.  
  
 `id` Doit être un identificateur XML valide.  Le `id` est xsd : ID de type et doit respecter les conventions d’affectation de noms recommandées dans le XML Schema Part 2 : Spécification de types de données (voir [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Si `id` est spécifié en tant que `null` un ID unique est généré automatiquement.  Un `id` spécifié par vide chaîne n’est pas valide.  
  
 Si `targetMode` est spécifié en tant que <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` doit être un URI relatif est formé conformément à la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource).  L’URI relatif interne peut être un chemin absolu qui commence par une barre oblique (« / ») caractère tel que « / page1.xaml » ou « / /images/picture4.jpg », ou un chemin relatif tel que «.. / imagespicture1.jpg » qui se résout par rapport à la racine du package (« / ») en tant que l’URI de base.  
  
 Si `targetMode` est spécifié en tant que <xref:System.IO.Packaging.TargetMode.External>, `targetUri` peut être soit absolu ou relatif URI formé en fonction de la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource). `http://www.microsoft.com/page2.xml` est un exemple d’un URI absolu qui fait référence à une ressource cible externe « page2.xm ».  « images/picture1.jpg » est un exemple d’un URI relatif qui fait également référence à une cible externe ressource « 1.jpg », mais qui est résolue par rapport à l’URI du package lui-même.  
  
 `relationshipType` doit être un URI qui est formé conformément à la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource).  Le tableau suivant présente le niveau de package `relationshipType` URI défini par la spécification Open Packaging Conventions (OPC).  
  
|Relation au niveau du package|URI de Type de relation|  
|---------------------------------|---------------------------|  
|Propriétés principales|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Certificat de Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Origine de la Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniature|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Pour plus d’informations sur l’empaquetage et les relations de package, consultez la section 1.3 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.IO.Packaging.Package.CreateRelationship%2A> pour créer un <xref:System.IO.Packaging.PackageRelationship> entre un <xref:System.IO.Packaging.Package> et une partie du document racine.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> ou <paramref name="relationshipType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le composant <paramref name="targetUri" /> est un <see cref="T:System.IO.Packaging.PackageRelationship" />, ou <paramref name="targetMode" /> est <see cref="F:System.IO.Packaging.TargetMode.Internal" /> et <paramref name="targetUri" /> est un URI absolu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="targetMode" /> n'est pas valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> n'est pas un identificateur XML valide; ou bien un composant avec l'<paramref name="id" /> spécifié est déjà présent dans le package.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] du composant à supprimer.</param>
        <summary>Supprime du package un composant avec un URI donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` doit être un URI relatif qui se compose d’un chemin d’accès absolu qui commence par une barre oblique (« / ») caractères.  Le chemin d’accès absolu, relatif à la racine du package et est formée conformément à la [RFC 3986](https://tools.ietf.org/html/rfc3986) spécification de syntaxe générique identificateur URI (Uniform Resource).  « / page1.xaml » et « / /images/picture4.jpg » sont des exemples d’URI de composant valide.  
  
 Aucune exception n’est levée si un composant avec la valeur `partUri` n’est pas dans le package.  (Vous pouvez utiliser la <xref:System.IO.Packaging.Package.PartExists%2A> méthode pour déterminer si une partie avec une certaine `partUri` se trouve dans le package.)  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> n'est pas un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] <see cref="T:System.IO.Packaging.PackagePart" /> valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> appelle en interne de la classe dérivée <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> méthode pour supprimer le composant selon le format physique implémenté dans la classe dérivée.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri"><see cref="P:System.IO.Packaging.PackagePart.Uri" /> du <see cref="T:System.IO.Packaging.PackagePart" /> à supprimer.</param>
        <summary>En cas de substitution dans une classe dérivée, supprime un composant avec un URI donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> classe implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe est fournie et utilisée.  Dans l’opération par défaut, <xref:System.IO.Packaging.Package.DeletePart%2A> appelle en interne <xref:System.IO.Packaging.Package.DeletePartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> selon le format physique implémenté dans la classe dérivée de l’opération de suppression de classe pour effectuer la réelle.  
  
 Pour plus d’informations sur le modèle de package et les composants de package, consultez le chapitre 1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La classe dérivée <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implémentation est appelée par le <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> méthode avec le composant spécifié selon le format physique implémenté dans la classe dérivée.  
  
La dérivée <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implémentation doit pas faire d’hypothèses sur l’ordre ou les opérations effectuées par le <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> méthode qui l’appelle.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> du <see cref="T:System.IO.Packaging.PackageRelationship" /> à supprimer.</param>
        <summary>Supprime une relation au niveau du package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une relation au niveau du package définit une association entre le package et un composant de cible associé ou la ressource.  Une relation au niveau du package peut être une des deux formes.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une partie cible dans le package.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une ressource cible en dehors du package.  
  
 Dans une relation de package, le package est considéré comme le « propriétaire » de la relation.  Lorsque le package est supprimé, toutes les relations possédées par le package sont également supprimées.  
  
 Aucune exception n’est levée si une relation avec la valeur `id` n’est pas dans le package.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> ne modifie pas physiquement le composant cible en aucune façon.  
  
 Pour plus d’informations sur les relations de package, consultez la section 1.3 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> n'est pas un identificateur XML valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Vide et enregistre le contenu de tous les composants et relations, ferme le package et libère toutes les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour vous assurer que toutes les modifications sont correctement enregistrées, <xref:System.IO.Packaging.Package.Dispose%2A> également finalise, vide et ferme toutes les parties et relations qui sont contenues dans le package.  
  
 Pour le <xref:System.IO.Packaging.Package> (classe), <xref:System.IO.Packaging.Package.Dispose%2A> et <xref:System.IO.Packaging.Package.Close%2A> effectuer la même opération : il n’est pas nécessaire d’appeler <xref:System.IO.Packaging.Package.Dispose%2A> si vous appelez <xref:System.IO.Packaging.Package.Close%2A>, ou vice versa.  
  
 <xref:System.IO.Packaging.Package.Close%2A> et <xref:System.IO.Packaging.Package.Dispose%2A> appeler en interne <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Les classes dérivées qui allouent et gèrent des ressources non-mémoire doivent substituer cette méthode pour libérer des ressources lorsque <xref:System.IO.Packaging.Package.Dispose%2A> est appelée. Remplacements de classe dérivée doivent également appeler <xref:System.IO.Packaging.Package.Flush%2A> et la classe de base <xref:System.IO.Packaging.Package.Dispose%2A> méthode pour vous assurer que le nettoyage des classe de base est toujours effectué.  
  
> [!NOTE]
>  Le `using` instruction (différent de la `using` directive d’espace de noms) est la méthode recommandée pour <xref:System.IO.Packaging.Package.Close%2A> et <xref:System.IO.Packaging.Package.Dispose%2A> un package. [Écriture d’un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055) montre comment fermer et supprimer un package à l’aide de la `using` instruction.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le paramètre d'accès au fichier pour le package.</summary>
        <value>Une des valeurs <see cref="T:System.IO.FileAccess" /> : <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> ou <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.IO.Packaging.Package.FileOpenAccess%2A> n’a pas de valeur par défaut.  Le paramètre des accès au fichier est spécifié dans le <xref:System.IO.Packaging.Package.%23ctor%2A> appeler de constructeur lorsque vous créez un nouveau package, ou dans le <xref:System.IO.Packaging.Package.Open%2A> appeler lorsque vous ouvrez un package existant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre le contenu de tous les composants et relations contenus dans le package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> appelle en interne de la classe dérivée <xref:System.IO.Packaging.Package.FlushCore%2A> implémentation pour effectuer l’opération de vidage spécifique au format.  La classe dérivée <xref:System.IO.Packaging.Package.FlushCore%2A> méthode est chargée d’enregistrer le contenu des parties et relations à l’implémentation de classe dérivée physique spécifique.  
  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe de base est fournie et utilisée. Dans l’opération par défaut, <xref:System.IO.Packaging.Package.Flush%2A> appelle en interne <xref:System.IO.Packaging.Package.FlushCore%2A> pour enregistrer les composants et relations dans un package de fichiers ZIP.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> est appelée automatiquement par le <xref:System.IO.Packaging.Package.Close%2A> et <xref:System.IO.Packaging.Package.Dispose%2A> méthodes.  Lorsque <xref:System.IO.Packaging.Package.Close%2A> ou <xref:System.IO.Packaging.Package.Dispose%2A> est appelée vous n’avez pas à appeler <xref:System.IO.Packaging.Package.Flush%2A> séparément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en lecture seule et ne peut pas être modifié.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> appelle en interne de la classe dérivée <see cref="M:System.IO.Packaging.Package.FlushCore" /> méthode pour vider le composant selon le format physique implémenté dans la classe dérivée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, enregistre le contenu de tous les composants et relations dans le magasin de classes dérivées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> est appelée par le <xref:System.IO.Packaging.Package.Flush%2A> méthode pour effectuer l’opération de vidage en fonction du format physique implémenté dans la classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La dérivée <see cref="M:System.IO.Packaging.Package.FlushCore" /> implémentation ne doit pas faire d’hypothèses concernant l’ordre ou les opérations effectuées par le <see cref="M:System.IO.Packaging.Package.Flush" /> méthode qui l’appelle.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] du composant à retourner.</param>
        <summary>Retourne le composant avec un URI donné.</summary>
        <returns>Composant avec le <paramref name="partUri" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.InvalidOperationException> est levée si une partie avec la valeur `partUri` n’existe pas.  
  
 Le <xref:System.IO.Packaging.Package.PartExists%2A> méthode peut être utilisée pour déterminer si `partUri` fait référence à un composant existant.  
  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe de base est fournie et utilisée.  Dans l’opération par défaut, <xref:System.IO.Packaging.Package.GetPart%2A> appelle en interne <xref:System.IO.Packaging.Package.GetPartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> classe pour retourner un composant demandé à partir d’un fichier ZIP.  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment rechercher, extraire et lire les parties qui sont contenus dans un package.  Pour obtenir un exemple complet, consultez [un exemple de Package de lecture](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> n'est pas un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] <see cref="T:System.IO.Packaging.PackagePart" /> valide.</exception>
        <exception cref="T:System.InvalidOperationException">Un composant avec le <paramref name="partUri" /> spécifié n'est pas dans le package.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> appelle en interne la classe dérivée <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> méthode pour vider le composant selon le format physique implémenté dans la classe dérivée.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] du composant à récupérer.</param>
        <summary>En cas de substitution dans une classe dérivée, retourne le composant adressé par un URI donné.</summary>
        <returns>Le composant demandé; ou <see langword="null" />, si un composant avec le <paramref name="partUri" /> spécifié n'est pas dans le package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe est fournie et utilisée.  Dans l’opération par défaut, <xref:System.IO.Packaging.Package.GetPart%2A> appelle en interne <xref:System.IO.Packaging.Package.GetPartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> classe à récupérer une partie d’un fichier ZIP.  
  
 Pour plus d’informations sur le modèle de package et les composants de package, consultez le chapitre 1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La classe dérivée <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implémentation est appelée par le <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> accès et retourner le composant spécifié selon le format physique implémenté dans la classe dérivée.  
  
La dérivée <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implémentation doit pas faire d’hypothèses sur l’ordre ou les opérations effectuées par le <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> méthode qui l’appelle.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection de tous les composants dans le package.</summary>
        <returns>Collection de tous les éléments <see cref="T:System.IO.Packaging.PackagePart" /> contenus dans le package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Retourne une collection de toutes les parties qui sont contenus dans le package, y compris <xref:System.IO.Packaging.PackageRelationship> parties.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> ne retourne jamais `null`; Toutefois, la collection retournée contient zéro élément si le package ne contient pas de pièces.  
  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe de base est fournie et utilisée.  Dans l’opération par défaut, <xref:System.IO.Packaging.Package.GetParts%2A> appelle le <xref:System.IO.Packaging.Package.GetPartsCore%2A> méthode de la <xref:System.IO.Packaging.ZipPackage> classe pour retourner les parties d’un fichier ZIP.  
  
 Pour plus d’informations sur les packages et les composants de package, consultez la section 1.1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.IO.Packaging.Package.GetParts%2A> méthode pour obtenir une collection des parties qui sont contenus dans un <xref:System.IO.Packaging.Package>.  Pour le code source complet du programme, consultez [création d’un Package avec une Signature numérique, exemple](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> appelle en interne la classe dérivée <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> méthode pour vider le composant selon le format physique implémenté dans la classe dérivée.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lors d'une substitution dans une classe dérivée, retourne un tableau contenant tous les composants dans le package.</summary>
        <returns>Tableau de tous les composants contenus dans le package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe dérivée <xref:System.IO.Packaging.Package.GetPartsCore%2A> implémentation est appelée par le <xref:System.IO.Packaging.Package.GetParts%2A> méthode pour accéder et retourner le tableau de composants selon le format physique implémenté dans la classe dérivée.  
  
 Par défaut, un <xref:System.IO.Packaging.ZipPackage> implémentation dérivée de l’abstraite <xref:System.IO.Packaging.Package> classe est fournie et utilisée.  Dans l’opération par défaut, <xref:System.IO.Packaging.Package.GetParts%2A> appelle en interne <xref:System.IO.Packaging.Package.GetPartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> classe à récupérer les parties d’un fichier ZIP.  
  
 Pour plus d’informations sur le modèle de package et les composants de package, consultez le chapitre 1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La dérivée <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> implémentation doit pas faire d’hypothèses sur l’ordre ou les opérations effectuées par le <see cref="M:System.IO.Packaging.Package.GetParts" /> méthode qui l’appelle.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relation à retourner.</param>
        <summary>Retourne la relation au niveau du package avec un identificateur donné.</summary>
        <returns>Relation au niveau du package avec l'<paramref name="id" />spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Doit être un identificateur XML valide. Le `id` type est xsd : ID et doit respecter les conventions d’affectation de noms recommandées dans les [section 3.3.8 de XML Schema Part 2 : Spécification de types de données](https://www.w3.org/TR/xmlschema-2/#ID).  
  
 Pour plus d’informations sur l’empaquetage et les relations de package, consultez la section 1.3 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> n'est pas un identificateur XML valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une relation avec l'<paramref name="id" /> spécifié n'est pas dans le package.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection de toutes les relations au niveau du package.</summary>
        <returns>Collection de toutes les relations au niveau du package contenues dans le package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> ne retourne jamais `null`; Toutefois, la collection retournée peut contenir zéro élément si le package ne contient pas de relations au niveau du package.  
  
 Une relation au niveau du package définit une association entre le package et un composant de cible associé ou la ressource.  Une relation au niveau du package peut être une des deux formes.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une partie cible dans le package.  
  
-   Entre un <xref:System.IO.Packaging.Package> à une ressource cible en dehors du package.  
  
 Dans une relation de package, le package est considéré comme le « propriétaire » de la relation.  Lorsque le package est supprimé, toutes les relations possédées par le package sont également supprimées.  Le processus de création ou la suppression de la relation ne modifie pas physiquement le composant cible ou la ressource en aucune façon.  
  
 Pour plus d’informations sur l’empaquetage et les relations de package, consultez la section 1.3 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType"><see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> à faire correspondre et à retourner dans la collection.</param>
        <summary>Retourne une collection de toutes les relations au niveau du package correspondant à un <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> donné.</summary>
        <returns>Collection de relations au niveau du package correspondant au <paramref name="relationshipType" />spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> ne retourne jamais `null`; Toutefois, la collection retournée peut contenir zéro élément si aucune relation au niveau du package qui correspondent à la chaîne `relationshipType`.  
  
 Le tableau suivant présente le niveau de package `relationshipType` URI défini par la spécification Open Packaging Conventions (OPC).  
  
|Relation au niveau du package|URI de Type de relation|  
|---------------------------------|---------------------------|  
|Propriétés principales|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Certificat de Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Origine de la Signature numérique|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniature|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer les relations qui ont été définies pour le package.  Pour obtenir un exemple complet, consultez [un exemple de Package de lecture](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> est une chaîne vide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.Package> qui incorpore <xref:System.IO.Packaging.PackageRelationship> et <xref:System.IO.Packaging.PackagePart> éléments ainsi que les données stockées.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux E/S sur lequel le package doit être ouvert.</param>
        <summary>Ouvre un package sur un flux de données E/S donné.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Le package à ouvrir requiert une autorisation de lecture ou de lecture/écriture et le <paramref name="stream" /> spécifié est en écriture seule ; ou bien le package à ouvrir requiert une autorisation d'écriture ou de lecture/écriture et le <paramref name="stream" /> spécifié est en lecture seule.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nom et chemin d'accès du package.</param>
        <summary>Ouvre un package à un chemin d'accès et nom de fichier donnés.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Cela <xref:System.IO.Packaging.Package.Open%2A> méthode ouvre le package avec les attributs par défaut <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, et <xref:System.IO.FileShare.None> (pour spécifier des attributs différents, utilisez une des autres surcharges de méthode Open).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.Package> qui incorpore <xref:System.IO.Packaging.PackageRelationship> et <xref:System.IO.Packaging.PackagePart> éléments ainsi que les données stockées.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Flux E/S sur lequel le package doit être ouvert.</param>
        <param name="packageMode">Mode de fichier dans lequel le package doit être ouvert.</param>
        <summary>Ouvre un package avec un flux de données E/S et un mode de fichier donnés.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <paramref name="packageMode" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">Le package à ouvrir requiert une autorisation de lecture ou de lecture/écriture et le <paramref name="stream" /> spécifié est en écriture seule ; ou bien le package à ouvrir requiert une autorisation d'écriture ou de lecture/écriture et le <paramref name="stream" /> spécifié est en lecture seule.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Nom et chemin d'accès du package.</param>
        <param name="packageMode">Mode de fichier dans lequel le package doit être ouvert.</param>
        <summary>Ouvre un package à un chemin d'accès donné au moyen d'un mode de fichier donné.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Cela <xref:System.IO.Packaging.Package.Open%2A> méthode ouvre le package avec les attributs par défaut <xref:System.IO.FileAccess.ReadWrite> et <xref:System.IO.FileShare.None> (pour spécifier des attributs différents, utilisez une des autres surcharges de méthode Open).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.Package> qui incorpore <xref:System.IO.Packaging.PackageRelationship> et <xref:System.IO.Packaging.PackagePart> éléments ainsi que les données stockées.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur pour <paramref name="packageMode" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Flux E/S sur lequel le package doit être ouvert.</param>
        <param name="packageMode">Mode de fichier dans lequel le package doit être ouvert.</param>
        <param name="packageAccess">Chemin d'accès dans lequel le package doit être ouvert.</param>
        <summary>Ouvre un package avec un flux de données E/S, un mode de fichier et un paramètre d'accès au fichier donnés.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="packageMode" /> ou <paramref name="packageAccess" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">Le package à ouvrir requiert une autorisation de lecture ou de lecture/écriture et le <paramref name="stream" /> spécifié est en écriture seule ; ou bien, le package à ouvrir requiert une autorisation d'écriture ou de lecture/écriture et le <paramref name="stream" /> spécifié est en lecture seule.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Nom et chemin d'accès du package.</param>
        <param name="packageMode">Mode de fichier dans lequel le package doit être ouvert.</param>
        <param name="packageAccess">Chemin d'accès dans lequel le package doit être ouvert.</param>
        <summary>Ouvre un package à un chemin d'accès donné à l'aide d'un mode de fichier et d'un paramètre d'accès au fichier donnés.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Cela <xref:System.IO.Packaging.Package.Open%2A> méthode ouvre le package avec une valeur par défaut <xref:System.IO.FileShare.None> attribut (pour spécifier un attribut différent, utilisez la <xref:System.IO.Packaging.Package.Open%2A> surcharge de méthode).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir et lire un <xref:System.IO.Packaging.Package> contenant <xref:System.IO.Packaging.PackageRelationship> et <xref:System.IO.Packaging.PackagePart> éléments ainsi que les données stockées.  Pour obtenir un exemple complet, consultez [un exemple de Package de lecture](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="packageMode" /> ou <paramref name="packageAccess" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Nom et chemin d'accès du package.</param>
        <param name="packageMode">Mode de fichier dans lequel le package doit être ouvert.</param>
        <param name="packageAccess">Chemin d'accès dans lequel le package doit être ouvert.</param>
        <param name="packageShare">Mode de partage de fichier dans lequel le package doit être ouvert.</param>
        <summary>Ouvre un package à un chemin d'accès donné à l'aide d'un mode de fichier, d'un chemin d'accès et d'un paramètre de partage de fichier donnés.</summary>
        <returns>Package ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> est le type de package par défaut qui est utilisé par le <xref:System.IO.Packaging.Package.Open%2A> (méthode).  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.IO.Packaging.Package> qui incorpore <xref:System.IO.Packaging.PackageRelationship> et <xref:System.IO.Packaging.PackagePart> éléments ainsi que les données stockées.  Pour obtenir un exemple complet, consultez [écriture dans un exemple de Package](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="packageMode" />, <paramref name="packageAccess" /> ou <paramref name="packageShare" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les propriétés principales du package.</summary>
        <value>Propriétés principales du package.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les propriétés principales de package, consultez la section 3.1 de la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Objet <see cref="T:System.Uri" /> du composant à vérifier.</param>
        <summary>Indique si un composant avec un URI donné est dans le package.</summary>
        <returns><see langword="true" /> si un composant avec le <paramref name="partUri" /> spécifié se trouve dans le package ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `partUri` doit commencer par un caractère barre oblique « / » et être absolu depuis la racine du package.  
  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> n'est pas un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] <see cref="T:System.IO.Packaging.PackagePart" /> valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule (impossible de lire les informations).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relation à vérifier.</param>
        <summary>Indique si une relation au niveau du package avec un ID donné est contenue dans le package.</summary>
        <returns><see langword="true" /> si une relation au niveau du package avec l'<paramref name="id" /> spécifié se trouve dans le package ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez la spécification Open Packaging Conventions (OPC) disponible pour téléchargement à l’adresse <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> n'est pas un identificateur XML valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le package n'est pas ouvert (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> a été appelée).</exception>
        <exception cref="T:System.IO.IOException">Le package est en écriture seule.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ce membre prend en charge l'infrastructure [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] et n'est pas conçu pour l'utilisation de l'application.  Utilisez plutôt la méthode de type sécurisé <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>