<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5d6a178da4ca5a70d9c3b8a15f0604cf360da09c" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48594419" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une instance de workflow.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 La classe <xref:System.Workflow.Runtime.WorkflowInstance> expose les méthodes et propriétés qui peuvent être utilisées pour contrôler l'exécution d'une instance de workflow ; il s'agit essentiellement d'un proxy de l'instance de workflow réelle utilisée par le moteur d'exécution de workflow. Un hôte ou un service peut envoyer une instruction au moteur d'exécution de workflow afin qu'il exécute des actions sur une instance de workflow en appelant les méthodes correspondantes contenues dans la classe <xref:System.Workflow.Runtime.WorkflowInstance>.  Si l'action demandée n'est pas valide, par exemple, si l'hôte appelle <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> dans une instance de workflow déjà exécutée, le moteur d'exécution de workflow déclenchera une exception appropriée.  
  
> [!NOTE]
>  Si une instance de workflow ne répond pas du fait qu'un appel sur l'application hôte ne renvoie rien, la seule méthode pour récupérer l'instance est de redémarrer l'exécution. Toutefois, si l'instance a été déchargée de force, interrompue ou suspendue, elle peut être poursuivie en appelant la méthode <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'exemple de code suivant présente la création et le démarrage d'une <xref:System.Workflow.Runtime.WorkflowInstance> dans un hôte du workflow. Le code crée une instance du <xref:System.Workflow.Runtime.WorkflowRuntime>, ajoute des services à l'exécution, puis présente la méthode recommandée pour créer un objet <xref:System.Workflow.Runtime.WorkflowInstance>. Le code initialise <xref:System.Workflow.Runtime.WorkflowInstance> en appelant la méthode <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> et lui passant le type créé précédemment. La <xref:System.Workflow.Runtime.WorkflowInstance> est démarrée avec l'appel de la méthode <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>.  
  
 Cet exemple de code fait partie de l'exemple du Kit de développement logiciel Canceling a Workflow (SDK) et provient du fichier Program.cs. Pour plus d’informations, consultez [annulation d’un Workflow](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Annulation d’un flux de travail</related>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abandonne l'instance de workflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’instance de workflow est abandonnée de façon synchrone ; autrement dit, la méthode est renvoyée après que l’instance de workflow ait été abandonnée. Le moteur d'exécution de workflow invalide l'instance de workflow en mémoire et efface le <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Si un service de persistance a été utilisé par votre instance de workflow, tout le travail exécuté depuis le dernier point de persistance est supprimé. Après avoir abandonné l'instance de workflow, le moteur d'exécution de workflow déclenche l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted>. Vous pouvez appeler <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> pour recharger l'instance de workflow et démarrer à partir de son dernier point de persistance.  
  
 `Abort` est différent de <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> dans le sens que `Abort` efface simplement l'instance de workflow en mémoire et peut être redémarré à partir du dernier point de persistance. Terminate efface l'instance de workflow en mémoire et informe le service de persistance que celle-ci a été effacée de la mémoire. Pour <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, cela signifie que toutes les informations sur l'état de cette instance de workflow sont supprimées de la base de données à la fin. Vous ne serez pas en mesure de recharger l'instance de workflow à partir d'un point de persistance précédemment stocké.  
  
   
  
## Examples  
 L'exemple suivant montre l'appel à Abort d'une instance de workflow de type Workflow1.  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">
          <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> spécifiant les mises à jour dynamiques de l'instance de workflow.</param>
        <summary>Applique des modifications à l'instance de workflow spécifiée par l'objet <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'instance de workflow n'est pas déjà suspendue, le moteur d'exécution de workflow interrompt temporairement l'instance avant d'appliquer les modifications.  
  
   
  
## Examples  
 L'exemple suivant présente l'appel ApplyWorkflowChanges à un objet <xref:System.Workflow.Runtime.WorkflowInstance>.  Cet exemple est issu de l'exemple du Kit de développement logiciel Ordering State Machine (SDK) et provient du fichier Mainform.cs.  Pour plus d’informations, consultez le [Ordering State Machine, exemple](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nom du <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Objet à mettre en file d'attente.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" /> autorisant l’expéditeur à être notifié lorsque <c>item</c> est remis.</param>
        <param name="workItem">Objet à passer aux méthodes <see cref="T:System.Workflow.Runtime.IPendingWork" />.</param>
        <summary>Publie de façon synchrone un message dans la file d’attente de workflow spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Envoie l'`item` dans la <xref:System.Workflow.Runtime.WorkflowQueue> spécifiée. Si vous souhaitez être notifié lorsque le message est remis, vous pouvez implémenter <xref:System.Workflow.Runtime.IPendingWork> dans votre service et passer un `workItem` et un objet <xref:System.Workflow.Runtime.IPendingWork> à <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Si vous ne souhaitez pas telle notification, vous pouvez passer une référence Null (`Nothing` en Visual Basic) pour `pendingWork` et `workItem`.  
  
 Lorsque vous utilisez cette méthode avec un workflow de machine d’état, vous pouvez obtenir une exception avec le message « file d’attente '{0}' n’est pas activé. » Cela arrive lorsque l'état actuel de l'ordinateur d'état ne sait pas comment gérer un événement spécifique. Par exemple, lorsqu’un état autre que l’état actuel contient la <xref:System.Workflow.Activities.EventDrivenActivity> qui contient le <xref:System.Workflow.Activities.HandleExternalEventActivity> qui est représenté par la file d’attente '{0}'.  
  
> [!NOTE]
>  Il n'est pas garanti que les messages soient reçus par l'instance de workflow dans l'ordre de leur envoi. Par exemple, si la réception d'un message dans une file d'attente existante (file d'attente A) entraîne la création d'une autre file d'attente (file d'attente B) par un workflow écoutant ensuite un message envoyé après le premier, il est possible que le deuxième message arrive en premier et ne soit pas reçu du fait que sa file d'attente n'a pas encore été créée. Pour empêcher ce problème, le deuxième message ne doit pas être envoyé tant que la présence de la deuxième file d'attente n'a pas été vérifiée (à l'aide de <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>.)  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Lorsque l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> se produit, la méthode `OnWorkflowIdled` définie dans cet exemple est appelée. Il détermine quel workflow est désactivé à l'aide de la propriété <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> puis obtient une collection d'éléments en file d'attente pour l'instance de workflow en appelant la méthode <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>. Le code itère au sein de la collection pour déterminer quelle activité attend l'événement ayant désactivé le workflow. Il envoie alors une exception à la file d'attente de workflow à l'aide de la méthode <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> avec le nom de l'élément de la file d'attente de l'événement.  
  
 Cet exemple de code fait partie de l'exemple du Kit de développement logiciel Canceling a Workflow (SDK) et provient du fichier Program.cs. Pour plus d’informations, consultez [annulation d’un Workflow](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> est une référence Null (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.  
  
- ou - 
La <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> spécifiée par <paramref name="queueName" /> n'existe pas.  
  
- ou - 
La <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> spécifiée par <paramref name="queueName" /> n'est pas activée.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Annulation d’un flux de travail</related>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nom du <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Objet à mettre en file d'attente.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" /> autorisant l’expéditeur à être notifié lorsque <c>item</c> est remis.</param>
        <param name="workItem">Objet à passer aux méthodes <see cref="T:System.Workflow.Runtime.IPendingWork" />.</param>
        <summary>Publie un message dans la file d'attente de flux de travail spécifiée lorsque le flux de travail est inactif. <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> attend que le flux de travail atteigne un point d'inactivité et se met en file d'attente après avoir vérifié que le programmateur de flux de travail est inactif (autrement dit, aucune opération active n'est exécutée).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attend que l'instance de workflow devienne inactive puis envoie l'`item` dans la <xref:System.Workflow.Runtime.WorkflowQueue> spécifiée. Si vous appelez <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A> alors que l'instance de workflow est suspendue, le moteur d'exécution de workflow va lever une <xref:System.InvalidOperationException>. Si vous souhaitez être notifié lorsque le message est remis, vous pouvez implémenter <xref:System.Workflow.Runtime.IPendingWork> dans votre service et passer un `workItem` et un objet <xref:System.Workflow.Runtime.IPendingWork> à <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Si vous ne souhaitez pas telle notification, vous pouvez passer une référence Null (`Nothing` en Visual Basic) pour `pendingWork` et `workItem`.  
  
 Lorsque vous utilisez cette méthode avec un workflow de machine d’état, vous pouvez obtenir une exception qui contient le message « file d’attente '{0}' n’est pas activé. » Cela se produit lorsque l'état actuel de l'ordinateur d'état ne sait pas comment gérer un événement spécifique. Par exemple, lorsqu’un état autre que l’état actuel contient la <xref:System.Workflow.Activities.EventDrivenActivity> qui contient le <xref:System.Workflow.Activities.HandleExternalEventActivity> qui est représenté par la file d’attente '{0}'.  
  
   
  
## Examples  
 L'exemple suivant présente l'envoi d'informations à une instance de workflow à l'aide de la méthode `EnqueueItemOnIdle`. En premier lieu, un objet WorkflowInstance est créé et démarré ; ensuite, un objet qui implémente l'interface <xref:System.Workflow.Runtime.IPendingWork> est créé. `EnqueueItemOnIdle` est ensuite appelée, en passant les valeurs de chaîne pour le nom de la file d’attente, de l’élément en file d’attente et de l’élément de travail à passer aux méthodes de l’objet pendingWork.  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> est une référence Null (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.  
  
- ou - 
L'instance de workflow est interrompue.  
  
- ou - 
La <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> spécifiée par <paramref name="queueName" /> n'existe pas.  
  
- ou - 
La <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> spécifiée par <paramref name="queueName" /> n'est pas activée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer.</param>
        <summary>Renvoie une valeur indiquant si l'objet spécifié est égal à la <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>
          <see langword="true" /> si l'objet spécifié est égal à cette <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'objet doit être une instance de la classe <xref:System.Workflow.Runtime.WorkflowInstance> et avoir le même <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> que cette <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cette instance de workflow.</summary>
        <returns>Code de hachage pour cette <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> renvoie un code de hachage de basé sur la valeur de <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère l'activité racine pour cette instance de workflow.</summary>
        <returns>Objet <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser l'activité racine pour naviguer dans la hiérarchie d'activité du workflow.  
  
 Cette méthode n'est pas thread-safe, de ce fait, l'hôte doit synchroniser ses appels sur cette méthode.  
  
   
  
## Examples  
 L'exemple suivant présente la récupération de la définition du workflow d'une instance de workflow.  Cet exemple est issu de l'exemple du Kit de développement logiciel Ordering State Machine (SDK) et provient du fichier Mainform.cs.  Pour plus d’informations, consultez le [Ordering State Machine, exemple](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie le point suivant à l'heure planifiée pour la remise à cette <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> d'un message du minuteur.</summary>
        <returns>Une valeur DateTime représentant l'heure <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> suivante à laquelle cette <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> se verra remettre un message du minuteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant présente l'utilisation de la méthode <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> pour déterminer si plusieurs messages du minuteur du workflow sont mis en file d'attente. Cet exemple est issu de l'exemple du Kit de développement logiciel WorkflowThreading (SDK) et provient du fichier Program.cs. Pour plus d’informations, consultez [Workflow Threading, exemple](http://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9).  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une collection d'objets <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> contenant les éléments en attente et les activités abonnées pour les files d'attente de workflow associées à cette instance de workflow.</summary>
        <returns>
          <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> renvoie une collection d'objets <xref:System.Workflow.Runtime.WorkflowQueueInfo>, dont chacun contient des informations sur l'état de l'une des files d'attente de flux de travail associée à cette instance de flux de travail. <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> contient les éléments en attente pour <xref:System.Workflow.Runtime.WorkflowQueue> et <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> contient une liste des activités souscrites pour la remise d'élément dans <xref:System.Workflow.Runtime.WorkflowQueue>.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment vous pouvez utiliser la méthode <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> pour obtenir des informations sur l'état de toutes les files d'attentes de workflow associées à un objet <xref:System.Workflow.Runtime.WorkflowInstance>. Lorsque l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> se produit, la méthode `OnWorkflowIdled` définie dans cet exemple est appelée. Il détermine quel workflow est désactivé à l'aide de la propriété <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> puis obtient une collection d'éléments en file d'attente pour l'instance de workflow en appelant la méthode <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>. Le code itère au sein de la collection pour déterminer quelle activité attend l'événement ayant désactivé le workflow. Il envoie alors une exception à la file d'attente de workflow à l'aide de la méthode <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> avec le nom de l'élément de la file d'attente de l'événement.  
  
 Cet exemple de code fait partie de l'exemple du Kit de développement logiciel Canceling a Workflow (SDK) et provient du fichier Program.cs. Pour plus d’informations, consultez [annulation d’un Workflow](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Annulation d’un flux de travail</related>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur unique de l'instance de workflow.</summary>
        <value>
          <see cref="T:System.Guid" /> de l'instance de workflow.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> pour référencer l'instance de workflow.  
  
   
  
## Examples  
 L'exemple de code suivant présente comment utiliser la propriété <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> pour obtenir des informations sur un objet <xref:System.Workflow.Runtime.WorkflowInstance>. Le premier extrait de code crée une variable <xref:System.Workflow.Runtime.WorkflowInstance> nommée `instanceId`.  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 Le second extrait de code utilise la propriété <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> comme premier objet dans un appel de constructeur `OrderEventArgs` lorsque la méthode `CallBackForApproval` est appelée.  
  
 Cet exemple de code fait partie de l'exemple du Kit de développement logiciel Listen (SDK) et provient du fichier OrderServiceImple.cs. Pour plus d’informations, consultez [exemple écouter](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)).  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)">Listen, exemple</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Charge une instance de workflow précédemment déchargée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> est synchrone ; si l'instance de workflow peut être chargée, <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> sera renvoyé après le chargement de l'instance de workflow dans la mémoire et sa planification par le moteur d'exécution de workflow. L'exécution déclenche l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> après que le service de persistance ait restauré l'instance de workflow en mémoire, mais avant que le moteur d'exécution de workflow l'ait planifiée.  
  
   
  
## Examples  
 L'exemple suivant montre comment charger un objet <xref:System.Workflow.Runtime.WorkflowInstance> précédemment déchargé.  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rechargez les profils de suivi de cette instance de workflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'exécution effectuant le suivi de l'infrastructure rechargera chaque <xref:System.Workflow.Runtime.Tracking.TrackingProfile> pour cette instance de workflow associée à ses canaux de suivi. S'il ne se trouve pas déjà dans un état suspendu, le workflow est suspendu temporairement par l'exécution effectuant le suivi de l'infrastructure pendant le rechargement des profils de suivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reprend l'exécution d'une instance de workflow précédemment suspendue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'hôte peut appeler <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> pour reprendre l'exécution d'une instance de workflow suspendue précédemment. Si l'instance de workflow n'est pas à l'état suspendu, aucune mesure n'est prise. L'exécution déclenche l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> juste avant la reprise de l'exécution de l'instance de workflow.  
  
   
  
## Examples  
 L'exemple suivant montre l'appel à Resume sur une instance de workflow précédemment suspendue.  Cet exemple provient de l'exemple du Kit de développement logiciel Suspend and Terminate (SDK).  Pour plus d’informations, consultez [suspendre et arrêter un exemple](http://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517).  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre l'exécution de l'instance de workflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> appelle <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A> à l'activité racine de cette instance de workflow. Si <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> rencontre une exception, il arrête l'instance de workflow en appelant <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> avec la propriété <xref:System.Exception.Message%2A> de l'exception passée comme raison pour l'arrêt.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment vous pouvez utiliser la méthode <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> pour démarrer une <xref:System.Workflow.Runtime.WorkflowInstance> dans un hôte de workflow. Le code crée une instance du <xref:System.Workflow.Runtime.WorkflowRuntime>, ajoute des services à l'exécution, puis présente la méthode recommandée pour créer un objet <xref:System.Workflow.Runtime.WorkflowInstance>. Il crée un objet <xref:System.Type> et le caste vers l'un des objets de workflow auxquels l'hôte est associé. Le code initialise ensuite <xref:System.Workflow.Runtime.WorkflowInstance> en appelant la méthode <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> et lui passant le type créé précédemment. La <xref:System.Workflow.Runtime.WorkflowInstance> est démarrée avec l'appel de la méthode <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>.  
  
 Cet exemple de code fait partie de l'exemple du Kit de développement logiciel Canceling a Workflow (SDK) et provient du fichier Program.cs. Pour plus d’informations, consultez [annulation d’un Workflow](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.  
  
- ou - 
L'instance de workflow a déjà été démarrée.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Annulation d’un flux de travail</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Description de la raison de la suspension de l'instance de workflow.</param>
        <summary>Interrompt l'instance de workflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’instance de workflow est suspendue de façon synchrone. Si l'instance de workflow est déjà suspendue, aucune mesure est prise ; sinon, le moteur d'exécution de workflow interrompt l'instance, déclenche l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> et passe `reason` dans une <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>.  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> ne décharge pas l'instance de workflow.  
  
   
  
## Examples  
 L'exemple de code suivant montre l'appel à Suspend sur un objet <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Description de la raison de l'arrêt de l'instance de workflow.</param>
        <summary>Met fin à l’instance de workflow de façon synchrone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’instance de workflow est arrêtée de façon synchrone. L'hôte appelle <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> pour arrêter l'instance de workflow. Le moteur d'exécution de workflow efface l'instance de workflow en mémoire et en informe le service de persistance. Pour <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, cela signifie que toutes les informations sur l'état de cette instance de workflow sont supprimées de la base de données à la fin. Vous ne serez pas en mesure de recharger l'instance de workflow à partir d'un point de persistance précédemment stocké.  
  
 Après que l'instance de workflow en mémoire ait été effacée et que le service de persistance ait été informé de l'arrêt, la méthode `Terminate` déclenche l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> et passe `reason` dans la propriété <xref:System.Exception.Message%2A> d'une <xref:System.Workflow.ComponentModel.WorkflowTerminatedException> contenue dans le <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs>.  
  
 `Terminate` est différent de <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> dans ce sens que Terminate efface l'instance de workflow en mémoire et informe le service de persistance de l'arrêt, alors que `Abort` efface simplement l'instance de workflow en mémoire, qui peut être redémarrée à partir du dernier point de persistance.  
  
   
  
## Examples  
 L'exemple de code suivant présente l'appel à Terminate sur un objet <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le moteur d'exécution de workflow ne s'exécute pas.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décharge l'instance de workflow de la mémoire dans le magasin de persistances lorsque l'instance est interrompue ou inactive.</summary>
        <returns>
          <see langword="true" /> si l'instance de workflow a été déchargée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'instance de workflow est inactive ou suspendue, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> utilise le service de persistance pour supprimer l'instance de workflow de la mémoire et la rendre persistante dans un magasin de données. Si aucun service de persistance n'est enregistré avec le <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> lève une <xref:System.InvalidOperationException>. Si l’instance de workflow est rendue persistante avec succès, le runtime déclenche le <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> événements et retourne `true`. <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> Retourne `false` si l’instance de workflow a déjà été déchargée, a été arrêté, a été abandonnée ou est déjà terminée.  
  
 L'hôte peut utiliser <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> pour libérer les ressources système d'un workflow inactif.  
  
   
  
## Examples  
 L'exemple suivant présente l'utilisation de la méthode TryUnload pour décharger un workflow lorsque l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> se déclenche. Cet exemple est issu de l'exemple du Kit de développement logiciel Using Persistence Services (SDK) et provient du fichier Program.cs. Pour plus d’informations, consultez [exemple des Services de persistance à l’aide de](http://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6).  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun service de persistance n'est enregistré auprès du moteur d'exécution de workflow.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décharge l'instance de workflow de la mémoire dans le magasin de persistances. Cet appel se bloque jusqu’à la fin du travail planifié en cours ou à la fin de la portée d’une transaction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> est synchrone ; autrement dit, il est renvoyé après avoir effectué toute action qu'il exécute. Si l'instance de workflow n'est pas inactive, l'exécution attend que l'instance puisse être interrompue. Une instance peut être interrompue uniquement une fois que l'élément de travail planifié en cours a été exécuté ; c'est en général ce qui se produit lorsque l'activité en cours d'exécution est renvoyée par sa méthode <xref:System.Workflow.ComponentModel.Activity.Execute%2A>. Toutefois, si l'instance exécute une <xref:System.Workflow.ComponentModel.TransactionScopeActivity>, la portée de transaction doit effectuer l'exécution avant que l'instance puisse être interrompue. Unload utilise ensuite le service de persistances pour supprimer l'instance de workflow de la mémoire et la rendre persistante dans un magasin de données. Si aucun service de persistance n'est enregistré avec le <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> lève une <xref:System.InvalidOperationException>. Si l'instance de workflow a pu être rendue persistante, l'exécution déclenche l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded>.  
  
 L'hôte peut utiliser <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> pour libérer les ressources système d'un workflow inactif.  
  
   
  
## Examples  
 L'exemple suivant montre comment appeler <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> sur un objet <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun service de persistance n'est enregistré auprès du moteur d'exécution de workflow.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> pour cette instance de workflow.</summary>
        <value>
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> représentant l'environnement d'exécution dans lequel cette instance de workflow s'exécute.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant illustre l'accès à l'exécution <xref:System.Workflow.Runtime.WorkflowRuntime> d'un objet <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>