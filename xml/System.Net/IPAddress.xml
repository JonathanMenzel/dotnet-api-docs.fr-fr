<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b382b2e424f3335e396090615b29820d1cd62c1d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30470713" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="37d12-101">Fournit une adresse IP (Internet Protocol).</span>
      <span class="sxs-lookup">
        <span data-stu-id="37d12-101">Provides an Internet Protocol (IP) address.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-102">La <xref:System.Net.IPAddress> classe contient l’adresse d’un ordinateur sur un réseau IP.</span><span class="sxs-lookup"><span data-stu-id="37d12-102">The <xref:System.Net.IPAddress> class contains the address of a computer on an IP network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-103">L’exemple de code suivant montre comment interroger un serveur pour obtenir les adresses de famille et les adresses IP qu’il prend en charge.</span><span class="sxs-lookup"><span data-stu-id="37d12-103">The following code example shows how to query a server to obtain the family addresses and the IP addresses it supports.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-104">Initialise une nouvelle instance de la classe <see cref="T:System.Net.IPAddress" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-104">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="37d12-105">Valeur du tableau d'octets de l'adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-105">The byte array value of the IP address.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-106">Initialise une nouvelle instance de la classe <see cref="T:System.Net.IPAddress" /> avec l'adresse spécifiée sous forme de tableau de <see cref="T:System.Byte" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-106">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-107">Le <xref:System.Net.IPAddress> est créé avec le <xref:System.Net.IPAddress.Address%2A> propriété `address`.</span><span class="sxs-lookup"><span data-stu-id="37d12-107">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address%2A> property set to `address`.</span></span>  
  
 <span data-ttu-id="37d12-108">Si la longueur de `address` est 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> construit une adresse IPv4 ; sinon, une adresse IPv6 avec une portée de 0 est construite.</span><span class="sxs-lookup"><span data-stu-id="37d12-108">If the length of `address` is 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 <span data-ttu-id="37d12-109">Le <xref:System.Byte> tableau est supposé pour être dans l’ordre d’octets réseau avec l’octet le plus significatif tout d’abord dans la position d’index 0.</span><span class="sxs-lookup"><span data-stu-id="37d12-109">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d12-110">
            <paramref name="address" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-110">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d12-111">
            <paramref name="address" /> contient une mauvaise adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-111">
              <paramref name="address" /> contains a bad IP address.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress">
          <span data-ttu-id="37d12-112">Valeur de type Long de l'adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-112">The long value of the IP address.</span>
          </span>
          <span data-ttu-id="37d12-113">Par exemple, la valeur 0x2414188f au format big-endian correspond à l'adresse IP 143.24.20.36.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-113">For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-114">Initialise une nouvelle instance de la classe <see cref="T:System.Net.IPAddress" /> avec l'adresse spécifiée sous forme de <see cref="T:System.Int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-114">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-115">Le <xref:System.Net.IPAddress> instance est créée avec le <xref:System.Net.IPAddress.Address%2A> propriété `newAddress`.</span><span class="sxs-lookup"><span data-stu-id="37d12-115">The <xref:System.Net.IPAddress> instance is created with the <xref:System.Net.IPAddress.Address%2A> property set to `newAddress`.</span></span>  
  
 <span data-ttu-id="37d12-116">Le <xref:System.Int64> valeur est supposée pour être dans l’ordre d’octet du réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-116">The <xref:System.Int64> value is assumed to be in network byte order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d12-117">
            <paramref name="newAddress" /> &lt; 0 ou</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-117">
              <paramref name="newAddress" /> &lt; 0 or</span>
          </span>
          <span data-ttu-id="37d12-118">
            <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-118">
              <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="37d12-119">Valeur du tableau d'octets de l'adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-119">The byte array value of the IP address.</span>
          </span>
        </param>
        <param name="scopeid">
          <span data-ttu-id="37d12-120">Valeur de type Long de l'identificateur de portée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-120">The long value of the scope identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-121">Initialise une nouvelle instance de la classe <see cref="T:System.Net.IPAddress" /> avec l'adresse spécifiée sous forme de tableau de <see cref="T:System.Byte" /> et l'identificateur de portée spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-121">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-122">Ce constructeur instancie une adresse IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-122">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="37d12-123">Le `scopeid` identifie une interface réseau dans le cas d’une adresse de lien local.</span><span class="sxs-lookup"><span data-stu-id="37d12-123">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="37d12-124">La portée est valide uniquement pour les adresses de lien local et de site local.</span><span class="sxs-lookup"><span data-stu-id="37d12-124">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="37d12-125">Le <xref:System.Byte> tableau est supposé pour être dans l’ordre d’octets réseau avec l’octet le plus significatif tout d’abord dans la position d’index 0.</span><span class="sxs-lookup"><span data-stu-id="37d12-125">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d12-126">
            <paramref name="address" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-126">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d12-127">
            <paramref name="address" /> contient une mauvaise adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-127">
              <paramref name="address" /> contains a bad IP address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d12-128">
            <paramref name="scopeid" /> &lt; 0 ou</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-128">
              <paramref name="scopeid" /> &lt; 0 or</span>
          </span>
          <span data-ttu-id="37d12-129">
            <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-129">
              <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-130">Adresse IP (Internet Protocol).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-130">An Internet Protocol (IP) address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-131">Valeur de type Long de l'adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-131">The long value of the IP address.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-132">Cette propriété est obsolète.</span><span class="sxs-lookup"><span data-stu-id="37d12-132">This property is obsolete.</span></span> <span data-ttu-id="37d12-133">Utilisez <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d12-133">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span></span>  
  
 <span data-ttu-id="37d12-134">Pour convertir <xref:System.Net.IPAddress.Address%2A> pour la notation ponctuée, utilisez le <xref:System.Net.IPAddress.ToString%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d12-134">To convert <xref:System.Net.IPAddress.Address%2A> to dotted-quad notation, use the <xref:System.Net.IPAddress.ToString%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-135">L’exemple suivant utilise le <xref:System.Net.IPAddress.Address%2A> paramètre à récupérer l’adresse IP de la <xref:System.Net.IPAddress> instance.</span><span class="sxs-lookup"><span data-stu-id="37d12-135">The following example uses the <xref:System.Net.IPAddress.Address%2A> parameter to retrieve the IP address of the <xref:System.Net.IPAddress> instance.</span></span>  
  
 [!code-cpp[IPAddress_Address_AddressFamily#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/CPP/ipaddress_address_addressfamily.cpp#2)]
 [!code-csharp[IPAddress_Address_AddressFamily#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/CS/ipaddress_address_addressfamily.cs#2)]
 [!code-vb[IPAddress_Address_AddressFamily#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Address_AddressFamily/VB/ipaddress_address_addressfamily.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="37d12-136">La famille d'adresses est <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-136">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-137">Obtient la famille d'adresses de l'adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-137">Gets the address family of the IP address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-138">Retourne <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> pour IPv4 ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> pour IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-138">Returns <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> for IPv4 or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> for IPv6.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37d12-139">Reportez-vous à l’exemple dans le <xref:System.Net.IPAddress> rubrique de la classe.</span><span class="sxs-lookup"><span data-stu-id="37d12-139">Refer to the example in the <xref:System.Net.IPAddress> class topic.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-140">Fournit une adresse IP qui indique que le serveur doit écouter les activités des clients sur toutes les interfaces réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-140">Provides an IP address that indicates that the server must listen for client activity on all network interfaces.</span>
          </span>
          <span data-ttu-id="37d12-141">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-141">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-142">Le <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> utilise le <xref:System.Net.IPAddress.Any> champ pour indiquer qu’un <xref:System.Net.Sockets.Socket> instance doit écouter les activités des clients sur toutes les interfaces réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-142">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.Any> field to indicate that a <xref:System.Net.Sockets.Socket> instance must listen for client activity on all network interfaces.</span></span>  
  
 <span data-ttu-id="37d12-143">Le <xref:System.Net.IPAddress.Any> champ équivaut à 0.0.0.0 en notation ponctuée.</span><span class="sxs-lookup"><span data-stu-id="37d12-143">The <xref:System.Net.IPAddress.Any> field is equivalent to 0.0.0.0 in dotted-quad notation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-144">Fournit une adresse de diffusion IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-144">Provides the IP broadcast address.</span>
          </span>
          <span data-ttu-id="37d12-145">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-145">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-146">Le <xref:System.Net.IPAddress.Broadcast> champ équivaut à 255.255.255.255 en notation ponctuée.</span><span class="sxs-lookup"><span data-stu-id="37d12-146">The <xref:System.Net.IPAddress.Broadcast> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-147">L’exemple suivant imprime le <xref:System.Net.IPAddress.Broadcast> adresse à la console.</span><span class="sxs-lookup"><span data-stu-id="37d12-147">The following example prints the <xref:System.Net.IPAddress.Broadcast> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">
          <span data-ttu-id="37d12-148">Instance de <see cref="T:System.Net.IPAddress" /> à comparer à l'instance actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-148">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-149">Compare deux adresses IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-149">Compares two IP addresses.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-150">
            <see langword="true" /> si les deux adresses sont identiques ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-150">
              <see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-151">Le <xref:System.Net.IPAddress.Equals%2A> méthode compare actuel <xref:System.Net.IPAddress> de l’instance avec la `comparand` paramètre et retourne `true` si les deux instances contiennent la même adresse IP.</span><span class="sxs-lookup"><span data-stu-id="37d12-151">The <xref:System.Net.IPAddress.Equals%2A> method compares the current <xref:System.Net.IPAddress> instance with the `comparand` parameter and returns `true` if the two instances contain the same IP address.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d12-152">Fournit une copie de <see cref="T:System.Net.IPAddress" /> sous forme de tableau d'octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-152">Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-153">Tableau <see cref="T:System.Byte" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-153">A <see cref="T:System.Byte" /> array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37d12-154">L’exemple de code suivant montre comment obtenir un serveur d’adresse IP au format d’octet.</span><span class="sxs-lookup"><span data-stu-id="37d12-154">The following code example shows how to get a server IP address in byte format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d12-155">Retourne une valeur de hachage pour une adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-155">Returns a hash value for an IP address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-156">Valeur de hachage entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-156">An integer hash value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-157">Le <xref:System.Net.IPAddress.GetHashCode%2A> méthode retourne un code de hachage de l’adresse IP.</span><span class="sxs-lookup"><span data-stu-id="37d12-157">The <xref:System.Net.IPAddress.GetHashCode%2A> method returns a hash code of the IP address.</span></span> <span data-ttu-id="37d12-158">Cette valeur peut être utilisée comme clé dans les tables de hachage.</span><span class="sxs-lookup"><span data-stu-id="37d12-158">This value can be used as a key in hash tables.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-159">Convertit une valeur pour qu'elle utilise l'ordre d'octet du réseau, et non celui de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-159">Converts a value from host byte order to network byte order.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="37d12-160">Nombre à convertir utilisant l'ordre d'octet de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-160">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-161">Convertit une valeur courte pour qu'elle utilise l'ordre d'octet du réseau, et non celui de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-161">Converts a short value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-162">Valeur courte utilisant l'ordre d'octet du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-162">A short value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-163">Des ordinateurs différents utilisent des conventions différentes pour le classement des octets dans les valeurs entières multioctets.</span><span class="sxs-lookup"><span data-stu-id="37d12-163">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="37d12-164">Certains ordinateurs placer tout d’abord de l’octet le plus significatif (appelé ordre big-endian) et d’autres placent l’octet le moins significatif tout d’abord (appelé ordre little-endian).</span><span class="sxs-lookup"><span data-stu-id="37d12-164">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="37d12-165">Pour travailler avec des ordinateurs qui utilisent le classement des octets différent, toutes les valeurs entières qui sont envoyés sur le réseau sont envoyés dans l’ordre d’octets réseau ayant tout d’abord l’octet le plus significatif.</span><span class="sxs-lookup"><span data-stu-id="37d12-165">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="37d12-166">Le <xref:System.Net.IPAddress.HostToNetworkOrder%2A> méthode convertit des valeurs entières multioctets qui sont stockés sur le système hôte à partir de l’ordre d’octet utilisé par l’hôte pour l’ordre d’octet utilisé par le réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-166">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="37d12-167">Nombre à convertir utilisant l'ordre d'octet de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-167">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-168">Convertit une valeur entière pour qu'elle utilise l'ordre d'octet du réseau, et non celui de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-168">Converts an integer value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-169">Valeur entière utilisant l'ordre d'octet du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-169">An integer value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-170">Des ordinateurs différents utilisent des conventions différentes pour le classement des octets dans les valeurs entières multioctets.</span><span class="sxs-lookup"><span data-stu-id="37d12-170">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="37d12-171">Certains ordinateurs placer tout d’abord de l’octet le plus significatif (appelé ordre big-endian) et d’autres placent l’octet le moins significatif tout d’abord (appelé ordre little-endian).</span><span class="sxs-lookup"><span data-stu-id="37d12-171">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="37d12-172">Pour travailler avec des ordinateurs qui utilisent le classement des octets différent, toutes les valeurs entières qui sont envoyés sur le réseau sont envoyés dans l’ordre d’octets réseau ayant tout d’abord l’octet le plus significatif.</span><span class="sxs-lookup"><span data-stu-id="37d12-172">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="37d12-173">Le <xref:System.Net.IPAddress.HostToNetworkOrder%2A> méthode convertit des valeurs entières multioctets qui sont stockés sur le système hôte à partir de l’ordre d’octet utilisé par l’hôte pour l’ordre d’octet utilisé par le réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-173">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="37d12-174">Nombre à convertir utilisant l'ordre d'octet de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-174">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-175">Convertit une valeur de type Long pour qu'elle utilise l'ordre d'octet du réseau, et non celui de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-175">Converts a long value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-176">Valeur de type Long utilisant l'ordre d'octet du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-176">A long value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-177">Des ordinateurs différents utilisent des conventions différentes pour le classement des octets dans les valeurs entières multioctets.</span><span class="sxs-lookup"><span data-stu-id="37d12-177">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="37d12-178">Certains ordinateurs placer tout d’abord de l’octet le plus significatif (appelé ordre big-endian) et d’autres placent l’octet le moins significatif tout d’abord (appelé ordre little-endian).</span><span class="sxs-lookup"><span data-stu-id="37d12-178">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="37d12-179">Pour travailler avec des ordinateurs qui utilisent le classement des octets différent, toutes les valeurs entières qui sont envoyés sur le réseau sont envoyés dans l’ordre d’octets réseau ayant tout d’abord l’octet le plus significatif.</span><span class="sxs-lookup"><span data-stu-id="37d12-179">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="37d12-180">Le <xref:System.Net.IPAddress.HostToNetworkOrder%2A> méthode convertit des valeurs entières multioctets qui sont stockés sur le système hôte à partir de l’ordre d’octet utilisé par l’hôte pour l’ordre d’octet utilisé par le réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-180">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-181">La méthode <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> utilise le champ <see cref="F:System.Net.IPAddress.IPv6Any" /> pour indiquer que <see cref="T:System.Net.Sockets.Socket" /> doit écouter les activités des clients sur toutes les interfaces réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-181">The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-182">Le <xref:System.Net.IPAddress.IPv6Any> champ équivaut à 0:0:0:0:0:0:0:0 en notation hexadécimale à deux-points, ou à :: en notation compacte.</span><span class="sxs-lookup"><span data-stu-id="37d12-182">The <xref:System.Net.IPAddress.IPv6Any> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-183">L’exemple de code suivant affiche la valeur d’en cours n’importe quelle adresse de l’hôte au format compressé standard.</span><span class="sxs-lookup"><span data-stu-id="37d12-183">The following code example displays the value of the current host's Any address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-184">Fournit l'adresse de bouclage IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-184">Provides the IP loopback address.</span>
          </span>
          <span data-ttu-id="37d12-185">Cette propriété est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-185">This property is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-186">Le <xref:System.Net.IPAddress.IPv6Loopback> champ équivaut à 0:0:0:0:0:0:0:1 en notation hexadécimale à deux-points, ou à :: 1 en notation compacte.</span><span class="sxs-lookup"><span data-stu-id="37d12-186">The <xref:System.Net.IPAddress.IPv6Loopback> field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-187">L’exemple de code suivant affiche la valeur de l’adresse de bouclage de l’hôte actuel au format compressé standard.</span><span class="sxs-lookup"><span data-stu-id="37d12-187">The following code example displays the value of the current host's loopback address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-188">Fournit une adresse IP qui indique qu'aucune interface réseau ne doit être utilisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-188">Provides an IP address that indicates that no network interface should be used.</span>
          </span>
          <span data-ttu-id="37d12-189">Cette propriété est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-189">This property is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-190">Le <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> utilise le <xref:System.Net.IPAddress.IPv6None> champ pour indiquer qu’un <xref:System.Net.Sockets.Socket> ne doit pas écouter pour l’activité du client.</span><span class="sxs-lookup"><span data-stu-id="37d12-190">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.IPv6None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="37d12-191">Le <xref:System.Net.IPAddress.IPv6None> champ équivaut à 0:0:0:0:0:0:0:0 en notation hexadécimale à deux-points, ou à :: 0 en notation compacte.</span><span class="sxs-lookup"><span data-stu-id="37d12-191">The <xref:System.Net.IPAddress.IPv6None> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-192">L’exemple de code suivant affiche la valeur de l’hôte actuel Qu'aucune adresse au format compressé standard.</span><span class="sxs-lookup"><span data-stu-id="37d12-192">The following code example displays the value of the current host's None address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-193">Indique si l'adresse IP est une adresse IPv6 mappée IPv4.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-193">Gets whether the IP address is an IPv4-mapped IPv6 address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-194">Retourne <see cref="T:System.Boolean" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-194">Returns <see cref="T:System.Boolean" />.</span>
          </span>
          <span data-ttu-id="37d12-195">
            <see langword="true" /> si l'adresse IP est une adresse IPv6 mappée IPv4 ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-195">
              <see langword="true" /> if the IP address is an IPv4-mapped IPv6 address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-196">Double pile sockets nécessitent toujours des adresses IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-196">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="37d12-197">La possibilité d’interagir avec une adresse IPv4 requiert l’utilisation du format adresse IPv6 mappées IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-197">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="37d12-198">Toutes les adresses IPv4 doivent être représentées dans le format d’adresse IPv6 mappées IPv4 qui permet à une application uniquement IPv6 communiquer avec un nœud IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-198">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="37d12-199">Le format d’adresse IPv6 mappées IPv4 permet à l’adresse IPv4 d’un nœud d’IPv4 pour être représentée comme une adresse IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-199">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="37d12-200">L’adresse IPv4 est encodée dans les 32 bits de poids faible de l’adresse IPv6, et les bits de poids fort 96 contenir le préfixe 0:0:0:0:0:FFFF.</span><span class="sxs-lookup"><span data-stu-id="37d12-200">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="37d12-201">Le format d’adresse IPv6 IPv4 mappées est spécifié dans RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="37d12-201">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="37d12-202">Pour plus d’informations, consultez [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="37d12-202">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-203">Indique si l'adresse est une adresse de lien local IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-203">Gets whether the address is an IPv6 link local address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-204">
            <see langword="true" /> si l'adresse IP est une adresse de lien local IPv6 ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-204">
              <see langword="true" /> if the IP address is an IPv6 link local address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-205">Indique si l'adresse est une adresse globale multicast IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-205">Gets whether the address is an IPv6 multicast global address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-206">
            <see langword="true" /> si l'adresse IP est une adresse globale multicast IPv6 ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-206">
              <see langword="true" /> if the IP address is an IPv6 multicast global address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-207">Indique si l'adresse est une adresse de site local IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-207">Gets whether the address is an IPv6 site local address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-208">
            <see langword="true" /> si l'adresse IP est une adresse de site local IPv6 ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-208">
              <see langword="true" /> if the IP address is an IPv6 site local address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-209">Indique si l'adresse est une adresse Teredo IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-209">Gets whether the address is an IPv6 Teredo address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-210">
            <see langword="true" /> si l'adresse IP est une adresse Teredo IPv6 ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-210">
              <see langword="true" /> if the IP address is an IPv6 Teredo address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-211">Une adresse Teredo est une adresse IPv6 avec le préfixe de 2001 :: / 32.</span><span class="sxs-lookup"><span data-stu-id="37d12-211">A Teredo address is an IPv6 address with the prefix of 2001::/32.</span></span> <span data-ttu-id="37d12-212">Adresses Teredo peuvent être retournées par la résolution de nom DNS normale ou énumérées comme une adresse IPv6 affectée à une interface locale.</span><span class="sxs-lookup"><span data-stu-id="37d12-212">Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="37d12-213">Adresse IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-213">An IP address.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-214">Indique si l'adresse IP spécifiée est une adresse de bouclage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-214">Indicates whether the specified IP address is the loopback address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-215">
            <see langword="true" /> si <paramref name="address" /> est l'adresse de bouclage, sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-215">
              <see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-216">Le <xref:System.Net.IPAddress.IsLoopback%2A> méthode compare `address` à <xref:System.Net.IPAddress.Loopback> et retourne `true` si les deux adresses IP sont identiques.</span><span class="sxs-lookup"><span data-stu-id="37d12-216">The <xref:System.Net.IPAddress.IsLoopback%2A> method compares `address` to <xref:System.Net.IPAddress.Loopback> and returns `true` if the two IP addresses are the same.</span></span>  
  
 <span data-ttu-id="37d12-217">Dans le cas d’IPv4, qui le <xref:System.Net.IPAddress.IsLoopback%2A> méthode retourne `true` pour n’importe quelle adresse IP de l’écran (X, Y et Z 127.x.y.z où sont situés dans la plage 0-255), pas seulement <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span><span class="sxs-lookup"><span data-stu-id="37d12-217">In the case of IPv4, that the <xref:System.Net.IPAddress.IsLoopback%2A> method returns `true` for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-218">Le code suivant exemple utilise le <xref:System.Net.IPAddress.IsLoopback%2A> méthode pour déterminer si l’adresse spécifiée est une adresse de bouclage.</span><span class="sxs-lookup"><span data-stu-id="37d12-218">The following code example uses the <xref:System.Net.IPAddress.IsLoopback%2A> method to determine whether the specified address is a loopback address.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-219">Fournit l'adresse de bouclage IP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-219">Provides the IP loopback address.</span>
          </span>
          <span data-ttu-id="37d12-220">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-220">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-221">Le <xref:System.Net.IPAddress.Loopback> champ équivaut à 127.0.0.1 dans la notation ponctuée.</span><span class="sxs-lookup"><span data-stu-id="37d12-221">The <xref:System.Net.IPAddress.Loopback> field is equivalent to 127.0.0.1 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-222">L’exemple suivant imprime le <xref:System.Net.IPAddress.Loopback> adresse à la console.</span><span class="sxs-lookup"><span data-stu-id="37d12-222">The following example prints the <xref:System.Net.IPAddress.Loopback> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d12-223">Mappe l'objet <see cref="T:System.Net.IPAddress" /> à une adresse IPv4.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-223">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-224">Retourne <see cref="T:System.Net.IPAddress" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-224">Returns <see cref="T:System.Net.IPAddress" />.</span>
          </span>
          <span data-ttu-id="37d12-225">Adresse IPv4.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-225">An IPv4 address.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-226">Double pile sockets nécessitent toujours des adresses IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-226">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="37d12-227">La possibilité d’interagir avec une adresse IPv4 requiert l’utilisation du format adresse IPv6 mappées IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-227">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="37d12-228">Toutes les adresses IPv4 doivent être représentées dans le format d’adresse IPv6 mappées IPv4 qui permet à une application uniquement IPv6 communiquer avec un nœud IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-228">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="37d12-229">Le format d’adresse IPv6 mappées IPv4 permet à l’adresse IPv4 d’un nœud d’IPv4 pour être représentée comme une adresse IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-229">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="37d12-230">L’adresse IPv4 est encodée dans les 32 bits de poids faible de l’adresse IPv6, et les bits de poids fort 96 contenir le préfixe 0:0:0:0:0:FFFF.</span><span class="sxs-lookup"><span data-stu-id="37d12-230">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="37d12-231">Le format d’adresse IPv6 IPv4 mappées est spécifié dans RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="37d12-231">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="37d12-232">Pour plus d’informations, consultez [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="37d12-232">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 <span data-ttu-id="37d12-233">Si vous souhaitez utiliser <xref:System.Net.IPAddress.MapToIPv4%2A> pour convertir une adresse IPv4 de format IPv6 au format IPv4, vous devez tout d’abord vous assurer que vous avez sélectionné une adresse IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-233">If you want to use <xref:System.Net.IPAddress.MapToIPv4%2A> to convert an IPv4 address from IPv6 format to IPv4 format, you must first ensure that you've got an IPv4 address.</span></span> <span data-ttu-id="37d12-234">Appelez <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, qui retournera `true` si l’adresse IP est initialement IPv4 écrite sous la forme d’IPv6, ou `false` dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="37d12-234">Call <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, which will return `true` if the IP address is originally IPv4 written as IPv6, or `false` otherwise.</span></span> <span data-ttu-id="37d12-235">Si <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> retourne `true`, utilisez <xref:System.Net.IPAddress.MapToIPv4%2A> pour la conversion.</span><span class="sxs-lookup"><span data-stu-id="37d12-235">If <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> returns `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> to make the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d12-236">Mappe l'objet <see cref="T:System.Net.IPAddress" /> à une adresse IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-236">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-237">Retourne <see cref="T:System.Net.IPAddress" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-237">Returns <see cref="T:System.Net.IPAddress" />.</span>
          </span>
          <span data-ttu-id="37d12-238">Adresse IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-238">An IPv6 address.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-239">Double pile sockets nécessitent toujours des adresses IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-239">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="37d12-240">La possibilité d’interagir avec une adresse IPv4 requiert l’utilisation du format adresse IPv6 mappées IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-240">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="37d12-241">Toutes les adresses IPv4 doivent être représentées dans le format d’adresse IPv6 mappées IPv4 qui permet à une application uniquement IPv6 communiquer avec un nœud IPv4.</span><span class="sxs-lookup"><span data-stu-id="37d12-241">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="37d12-242">Le format d’adresse IPv6 mappées IPv4 permet à l’adresse IPv4 d’un nœud d’IPv4 pour être représentée comme une adresse IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-242">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="37d12-243">L’adresse IPv4 est encodée dans les 32 bits de poids faible de l’adresse IPv6, et les bits de poids fort 96 contenir le préfixe 0:0:0:0:0:FFFF.</span><span class="sxs-lookup"><span data-stu-id="37d12-243">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="37d12-244">Le format d’adresse IPv6 IPv4 mappées est spécifié dans RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="37d12-244">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="37d12-245">Pour plus d’informations, consultez [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="37d12-245">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-246">Convertit un nombre pour qu'il utilise l'ordre d'octet de l'hôte, et non celui du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-246">Converts a number from network byte order to host byte order.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="37d12-247">Nombre à convertir utilisant l'ordre d'octet du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-247">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-248">Convertit une valeur courte pour qu'elle utilise l'ordre d'octet de l'hôte, et non celui du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-248">Converts a short value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-249">Valeur courte utilisant l'ordre d'octet de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-249">A short value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-250">Des ordinateurs différents utilisent des conventions différentes pour le classement des octets dans les valeurs entières multioctets.</span><span class="sxs-lookup"><span data-stu-id="37d12-250">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="37d12-251">Certains ordinateurs placer tout d’abord de l’octet le plus significatif (appelé ordre big-endian) et d’autres placent l’octet le moins significatif tout d’abord (appelé ordre little-endian).</span><span class="sxs-lookup"><span data-stu-id="37d12-251">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="37d12-252">Pour travailler avec des ordinateurs qui utilisent le classement des octets différent, toutes les valeurs entières qui sont envoyés sur le réseau sont envoyés dans l’ordre d’octets réseau ayant tout d’abord l’octet le plus significatif.</span><span class="sxs-lookup"><span data-stu-id="37d12-252">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="37d12-253">Le <xref:System.Net.IPAddress.NetworkToHostOrder%2A> méthode convertit des valeurs entières multioctets qui sont stockés sur le système hôte à partir de l’ordre d’octet utilisé par le réseau à l’ordre d’octet utilisé par l’hôte.</span><span class="sxs-lookup"><span data-stu-id="37d12-253">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-254">L’exemple suivant utilise la <xref:System.Net.IPAddress.NetworkToHostOrder%2A> méthode pour convertir une valeur de type short à partir de l’ordre d’octet du réseau hôte.</span><span class="sxs-lookup"><span data-stu-id="37d12-254">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a short value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="37d12-255">Nombre à convertir utilisant l'ordre d'octet du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-255">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-256">Convertit une valeur entière pour qu'elle utilise l'ordre d'octet de l'hôte, et non celui du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-256">Converts an integer value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-257">Valeur entière utilisant l'ordre d'octet de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-257">An integer value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-258">Des ordinateurs différents utilisent des conventions différentes pour le classement des octets dans les valeurs entières multioctets.</span><span class="sxs-lookup"><span data-stu-id="37d12-258">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="37d12-259">Certains ordinateurs placer tout d’abord de l’octet le plus significatif (appelé ordre big-endian) et d’autres placent l’octet le moins significatif tout d’abord (appelé ordre little-endian).</span><span class="sxs-lookup"><span data-stu-id="37d12-259">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="37d12-260">Pour travailler avec des ordinateurs qui utilisent le classement des octets différent, toutes les valeurs entières qui sont envoyés sur le réseau sont envoyés dans l’ordre d’octets réseau ayant tout d’abord l’octet le plus significatif.</span><span class="sxs-lookup"><span data-stu-id="37d12-260">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="37d12-261">Le <xref:System.Net.IPAddress.NetworkToHostOrder%2A> méthode convertit des valeurs entières multioctets qui sont stockés sur le système hôte à partir de l’ordre d’octet utilisé par le réseau à l’ordre d’octet utilisé par l’hôte.</span><span class="sxs-lookup"><span data-stu-id="37d12-261">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-262">L’exemple suivant utilise la <xref:System.Net.IPAddress.NetworkToHostOrder%2A> méthode pour convertir une valeur entière à partir de l’ordre d’octet du réseau hôte.</span><span class="sxs-lookup"><span data-stu-id="37d12-262">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert an integer value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="37d12-263">Nombre à convertir utilisant l'ordre d'octet du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-263">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-264">Convertit une valeur de type Long pour qu'elle utilise l'ordre d'octet de l'hôte, et non celui du réseau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-264">Converts a long value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-265">Valeur de type Long utilisant l'ordre d'octet de l'hôte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-265">A long value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-266">Des ordinateurs différents utilisent des conventions différentes pour le classement des octets dans les valeurs entières multioctets.</span><span class="sxs-lookup"><span data-stu-id="37d12-266">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="37d12-267">Certains ordinateurs placer tout d’abord de l’octet le plus significatif (appelé ordre big-endian) et d’autres placent l’octet le moins significatif tout d’abord (appelé ordre little-endian).</span><span class="sxs-lookup"><span data-stu-id="37d12-267">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="37d12-268">Pour travailler avec des ordinateurs qui utilisent le classement des octets différent, toutes les valeurs entières qui sont envoyés sur le réseau sont envoyés dans l’ordre d’octets réseau ayant tout d’abord l’octet le plus significatif.</span><span class="sxs-lookup"><span data-stu-id="37d12-268">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="37d12-269">Le <xref:System.Net.IPAddress.NetworkToHostOrder%2A> méthode convertit des valeurs entières multioctets qui sont stockés sur le système hôte à partir de l’ordre d’octet utilisé par le réseau à l’ordre d’octet utilisé par l’hôte.</span><span class="sxs-lookup"><span data-stu-id="37d12-269">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-270">L’exemple suivant utilise la <xref:System.Net.IPAddress.NetworkToHostOrder%2A> méthode pour convertir une valeur de type long à partir de l’ordre d’octet du réseau hôte.</span><span class="sxs-lookup"><span data-stu-id="37d12-270">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a long value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-271">Fournit une adresse IP qui indique qu'aucune interface réseau ne doit être utilisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-271">Provides an IP address that indicates that no network interface should be used.</span>
          </span>
          <span data-ttu-id="37d12-272">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-272">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-273">Le <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> utilise le <xref:System.Net.IPAddress.None> champ pour indiquer qu’un <xref:System.Net.Sockets.Socket> ne doit pas écouter pour l’activité du client.</span><span class="sxs-lookup"><span data-stu-id="37d12-273">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="37d12-274">Le <xref:System.Net.IPAddress.None> champ équivaut à 255.255.255.255 en notation ponctuée.</span><span class="sxs-lookup"><span data-stu-id="37d12-274">The <xref:System.Net.IPAddress.None> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d12-275">L’exemple suivant utilise le <xref:System.Net.IPAddress.None> propriété pour indiquer qu’aucune interface réseau ne doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="37d12-275">The following example uses the <xref:System.Net.IPAddress.None> property to indicate that no network interface should be used.</span></span>  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString">
          <span data-ttu-id="37d12-276">Chaîne qui contient une adresse IP en notation ponctuée à quatre nombres pour IPv4 et en notation hexadécimale utilisant le signe deux-points comme séparateur pour IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-276">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-277">Convertit une chaîne d'adresse IP en instance de <see cref="T:System.Net.IPAddress" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-277">Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-278">Instance de <see cref="T:System.Net.IPAddress" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-278">An <see cref="T:System.Net.IPAddress" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-279">La méthode statique <xref:System.Net.IPAddress.Parse%2A> méthode crée un <xref:System.Net.IPAddress> instance à partir d’une adresse IP en notation ponctuée pour IPv4 et en notation hexadécimale à deux-points pour IPv6.</span><span class="sxs-lookup"><span data-stu-id="37d12-279">The static <xref:System.Net.IPAddress.Parse%2A> method creates an <xref:System.Net.IPAddress> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span>  
  
 <span data-ttu-id="37d12-280">Le nombre de parties (chaque partie est séparée par un point) dans `ipString` détermine comment l’adresse IP est construite.</span><span class="sxs-lookup"><span data-stu-id="37d12-280">The number of parts (each part is separated by a period) in `ipString` determines how the IP address is constructed.</span></span> <span data-ttu-id="37d12-281">Une adresse d’une partie est stockée directement dans l’adresse réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-281">A one part address is stored directly in the network address.</span></span> <span data-ttu-id="37d12-282">Une adresse en deux parties, pratique pour spécifier une adresse de classe A, place la partie de tête dans le premier octet et la partie de fin dans les trois octets de la plus à droite de l’adresse réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-282">A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address.</span></span> <span data-ttu-id="37d12-283">Une adresse en trois parties, pratique pour spécifier une adresse de classe B, place la première partie dans le premier octet, la deuxième partie dans le deuxième octet et la dernière partie dans les deux octets de la plus à droite de l’adresse réseau.</span><span class="sxs-lookup"><span data-stu-id="37d12-283">A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address.</span></span> <span data-ttu-id="37d12-284">Exemple :</span><span class="sxs-lookup"><span data-stu-id="37d12-284">For example:</span></span>  
  
|<span data-ttu-id="37d12-285">Nombre de parties et exemple `ipString`</span><span class="sxs-lookup"><span data-stu-id="37d12-285">Number of parts and example `ipString`</span></span>|<span data-ttu-id="37d12-286">Adresse IPv4 pour IPAddress</span><span class="sxs-lookup"><span data-stu-id="37d12-286">IPv4 address for IPAddress</span></span>|  
|--------------------------------------------|--------------------------------|  
|<span data-ttu-id="37d12-287">1 -- "65535"</span><span class="sxs-lookup"><span data-stu-id="37d12-287">1 -- "65535"</span></span>|<span data-ttu-id="37d12-288">0.0.255.255</span><span class="sxs-lookup"><span data-stu-id="37d12-288">0.0.255.255</span></span>|  
|<span data-ttu-id="37d12-289">2 -- "20.2"</span><span class="sxs-lookup"><span data-stu-id="37d12-289">2 -- "20.2"</span></span>|<span data-ttu-id="37d12-290">20.0.0.2</span><span class="sxs-lookup"><span data-stu-id="37d12-290">20.0.0.2</span></span>|  
|<span data-ttu-id="37d12-291">2 -- "20.65535"</span><span class="sxs-lookup"><span data-stu-id="37d12-291">2 -- "20.65535"</span></span>|<span data-ttu-id="37d12-292">20.0.255.255</span><span class="sxs-lookup"><span data-stu-id="37d12-292">20.0.255.255</span></span>|  
|<span data-ttu-id="37d12-293">3 -- "128.1.2"</span><span class="sxs-lookup"><span data-stu-id="37d12-293">3 -- "128.1.2"</span></span>|<span data-ttu-id="37d12-294">128.1.0.2</span><span class="sxs-lookup"><span data-stu-id="37d12-294">128.1.0.2</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="37d12-295">Le code suivant convertit une chaîne qui contient une adresse IP, en notation ponctuée pour IPv4 ou en notation hexadécimale à deux-points pour IPv6, en une instance de la <xref:System.Net.IPAddress> classe.</span><span class="sxs-lookup"><span data-stu-id="37d12-295">The following code converts a string that contains an IP address, in dotted-quad notation for IPv4 or in colon-hexadecimal notation for IPv6, into an instance of the <xref:System.Net.IPAddress> class.</span></span> <span data-ttu-id="37d12-296">Ensuite, il utilise surchargées <xref:System.Net.IPAddress.ToString%2A> méthode pour afficher l’adresse en notation standard.</span><span class="sxs-lookup"><span data-stu-id="37d12-296">Then it uses the overloaded <xref:System.Net.IPAddress.ToString%2A> method to display the address in standard notation.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d12-297">
            <paramref name="ipString" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-297">
              <paramref name="ipString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="37d12-298">
            <paramref name="ipString" /> n’est pas une adresse IP valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-298">
              <paramref name="ipString" /> is not a valid IP address.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d12-299">Obtient ou définit l'identificateur de portée d'adresse IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-299">Gets or sets the IPv6 address scope identifier.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="37d12-300">Entier long qui spécifie la portée de l'adresse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-300">A long integer that specifies the scope of the address.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-301">La signification de <xref:System.Net.IPAddress.ScopeId%2A> change en fonction du contexte dans lequel il est utilisé.</span><span class="sxs-lookup"><span data-stu-id="37d12-301">The meaning of <xref:System.Net.IPAddress.ScopeId%2A> changes depending on the context in which it is used.</span></span>  
  
-   <span data-ttu-id="37d12-302">Adresse de lien local.</span><span class="sxs-lookup"><span data-stu-id="37d12-302">Link-local address.</span></span> <span data-ttu-id="37d12-303">Sur un ordinateur hôte avec plusieurs interfaces connectées à différentes liaisons, la même adresse de lien local peut avoir plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="37d12-303">On a host with multiple interfaces connected to separate links, the same link-local address can be assigned to multiple interfaces.</span></span> <span data-ttu-id="37d12-304">Pour lever l’ambiguïté, un identificateur de portée est utilisé pour spécifier l’interface via laquelle les messages sont échangés.</span><span class="sxs-lookup"><span data-stu-id="37d12-304">To eliminate this ambiguity, a scope identifier is used to specify the interface over which messages are exchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d12-305">Les adresses locales au lien, identifiés par le préfixe de Format (FP) FE80, sont utilisés par les nœuds lors de la communication avec des nœuds voisins sur la même liaison.</span><span class="sxs-lookup"><span data-stu-id="37d12-305">Link-local addresses, identified by the Format Prefix (FP) FE80, are used by nodes when communicating with neighboring nodes on the same link.</span></span>  
  
-   <span data-ttu-id="37d12-306">Adresses de site local.</span><span class="sxs-lookup"><span data-stu-id="37d12-306">Site-local addresses.</span></span> <span data-ttu-id="37d12-307">Un hôte peut être connecté à plusieurs sites.</span><span class="sxs-lookup"><span data-stu-id="37d12-307">A host can be connected to multiple sites.</span></span> <span data-ttu-id="37d12-308">Dans ce cas, un identificateur de portée est utilisé pour indiquer un site spécifique pour communiquer avec.</span><span class="sxs-lookup"><span data-stu-id="37d12-308">In this case, a scope identifier is used to indicate a specific site to communicate with.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d12-309">Adresses de site local, identifiés par le préfixe de Format (FP) FEC0, sont utilisées par les nœuds lors de la communication sur des intranets privés.</span><span class="sxs-lookup"><span data-stu-id="37d12-309">Site-local addresses, identified by the Format Prefix (FP) FEC0, are used by nodes when communicating on private intranets.</span></span>  
  
 <span data-ttu-id="37d12-310">La notation est utilisée pour spécifier le `ScopeId` avec une adresse est `Address%ScopeId`.</span><span class="sxs-lookup"><span data-stu-id="37d12-310">The notation that is used to specify the `ScopeId` with an address is `Address%ScopeId`.</span></span> <span data-ttu-id="37d12-311">Par exemple, `FE80::5EFE:192.168.41.30%2.`.</span><span class="sxs-lookup"><span data-stu-id="37d12-311">For example, `FE80::5EFE:192.168.41.30%2.`</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="37d12-312">
            <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-312">
              <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d12-313">
            <paramref name="scopeId" /> &lt; 0</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-313">
              <paramref name="scopeId" /> &lt; 0</span>
          </span>
          <span data-ttu-id="37d12-314">\- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-314">\- or -</span>
          </span>  
  
-   <span data-ttu-id="37d12-315"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="37d12-315"><paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d12-316">Convertit une adresse Internet en notation standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-316">Converts an Internet address to its standard notation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-317">Chaîne qui contient l'adresse IP en notation ponctuée à quatre nombres IPv4 ou en notation hexadécimale utilisant le signe deux-points comme séparateur en IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-317">A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-318">Le <xref:System.Net.IPAddress.ToString%2A> méthode convertit l’adresse IP qui est stocké dans le <xref:System.Net.IPAddress.Address%2A> propriété ponctuée IPv4 ou IPv6 la notation hexadécimale à deux-points.</span><span class="sxs-lookup"><span data-stu-id="37d12-318">The <xref:System.Net.IPAddress.ToString%2A> method converts the IP address that is stored in the <xref:System.Net.IPAddress.Address%2A> property to either IPv4 dotted-quad or IPv6 colon-hexadecimal notation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="37d12-319">La famille d'adresses est <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> et l'adresse est mauvaise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-319">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">
          <span data-ttu-id="37d12-320">Chaîne à valider.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-320">The string to validate.</span>
          </span>
        </param>
        <param name="address">
          <span data-ttu-id="37d12-321">La version <see cref="T:System.Net.IPAddress" /> de la chaîne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-321">The <see cref="T:System.Net.IPAddress" /> version of the string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d12-322">Détermine si une chaîne est une adresse IP valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-322">Determines whether a string is a valid IP address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d12-323">
            <see langword="true" /> si <paramref name="ipString" /> a pu être analysée comme une adresse IP ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d12-323">
              <see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d12-324">Notez que cette méthode accepte comme valide une valeur ipString qui peut être analysée comme un <xref:System.Int64>et puis traite ce Int64 comme la valeur de type long d’une adresse IP dans l’ordre des octets réseau, similaire à celle qui le <xref:System.Net.IPAddress.%23ctor%2A> constructeur ne.</span><span class="sxs-lookup"><span data-stu-id="37d12-324">Note that this method accepts as valid an ipString value that can be parsed as an <xref:System.Int64>, and then treats that Int64 as the long value of an IP address in network byte order, similar to the way that the <xref:System.Net.IPAddress.%23ctor%2A> constructor does.</span></span> <span data-ttu-id="37d12-325">Cela signifie que cette méthode retourne la valeur true si le Int64 est analysée avec succès, même si elle représente une adresse qui n’est pas une adresse IP valide.</span><span class="sxs-lookup"><span data-stu-id="37d12-325">This means that this method returns true if the Int64 is parsed successfully, even if it represents an address that's not a valid IP address.</span></span> <span data-ttu-id="37d12-326">Par exemple, si ipString est « 1 », cette méthode retourne true même si « 1 » (ou 0.0.0.1) n’est pas une adresse IP valide et vous pouvez vous attendre à cette méthode retourne la valeur false.</span><span class="sxs-lookup"><span data-stu-id="37d12-326">For example, if ipString is "1", this method returns true even though "1" (or 0.0.0.1) is not a valid IP address and you might expect this method to return false.</span></span> <span data-ttu-id="37d12-327">Résolution de ce bogue compromettrait les applications existantes, donc le comportement actuel n’est pas modifié.</span><span class="sxs-lookup"><span data-stu-id="37d12-327">Fixing this bug would break existing apps, so the current behavior will not be changed.</span></span> <span data-ttu-id="37d12-328">Votre code peut éviter ce comportement en vous assurant qu’il utilise cette méthode uniquement pour analyser les adresses IP dans la notation décimale.</span><span class="sxs-lookup"><span data-stu-id="37d12-328">Your code can avoid this behavior by ensuring that it only uses this method to parse IP addresses in dotted-decimal format.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>