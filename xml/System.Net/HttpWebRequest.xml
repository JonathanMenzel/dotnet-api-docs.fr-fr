<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e375cff6d3f3621aa35b61963b8d8aa09e4f97b6" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691818" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an HTTP-specific implementation of the <see cref="T:System.Net.WebRequest" /> class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest> classe prend en charge les propriétés et méthodes définies dans <xref:System.Net.WebRequest> et d’autres propriétés et méthodes qui permettent aux utilisateurs d’interagir directement avec les serveurs à l’aide de HTTP.  
  
 N’utilisez pas le <xref:System.Net.HttpWebRequest.%23ctor%2A> constructeur. Utilisez le <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> méthode pour initialiser de nouveaux <xref:System.Net.HttpWebRequest> objets. Si le schéma pour l’identificateur de ressource uniforme (URI) est `http://` ou `https://`, <xref:System.Net.WebRequest.Create%2A> retourne un <xref:System.Net.HttpWebRequest> objet.  
  
 Le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode effectue une demande synchrone à la ressource spécifiée dans le <xref:System.Net.HttpWebRequest.RequestUri%2A> propriété et retourne un <xref:System.Net.HttpWebResponse> qui contient l’objet de réponse. Les données de réponse peuvent être reçues à l’aide du flux retourné par <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Si l’objet de réponse ou le flux de réponse est fermé, données restantes seront perdus. Les données restantes seront être purgées et le socket qui sera utilisé pour les demandes suivantes à nouveau lors de la fermeture de l’objet de réponse ou le flux de données si les conditions suivantes sont respectées : il s’agit d’une demande keep-alive ou canalisée en rafale, uniquement une petite quantité de données doit être reçu, ou données restantes est reçu dans un petit intervalle de temps. Si aucune des conditions mentionnées maintenez ou le drainage de temps est dépassé, le socket va être fermé. Pour les connexions keep-alive ou en pipeline, nous recommandons que l’application lit le flux de données jusqu'à ce que EOF. Cela garantit que le socket seront réutilisé pour les demandes suivantes, ce qui entraîne de meilleures performances et moins de ressources utilisées.  
  
 Lorsque vous souhaitez envoyer des données à la ressource, le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode retourne un <xref:System.IO.Stream> objet à utiliser pour envoyer des données. Le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> et <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthodes fournissent un accès asynchrone dans le flux de données d’envoi.  
  
 Pour l’authentification du client avec <xref:System.Net.HttpWebRequest>, le certificat client doit être installé dans le magasin de certificats personnel de l’utilisateur actuel.  
  
 Le <xref:System.Net.HttpWebRequest> classe lève un <xref:System.Net.WebException> lorsque des erreurs se produisent lors de l’accès à une ressource. Le <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> propriété contient un <xref:System.Net.WebExceptionStatus> valeur qui indique la source de l’erreur. Lorsque <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> est <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, le <xref:System.Net.WebException.Response%2A> propriété contient le <xref:System.Net.HttpWebResponse> reçu de la ressource.  
  
 <xref:System.Net.HttpWebRequest> expose des valeurs d’en-tête HTTP courantes envoyées à la ressource Internet en tant que propriétés, définies par les méthodes ou par le système. le tableau suivant contient une liste complète. Vous pouvez définir d’autres en-têtes le <xref:System.Net.HttpWebRequest.Headers%2A> propriété en tant que paires nom/valeur. Notez que les serveurs et les caches peuvent modifier ou ajouter des en-têtes pendant la requête.  
  
 Le tableau suivant répertorie les en-têtes HTTP qui sont définies par les méthodes ou propriétés ou le système.  
  
|Header|Définie par|  
|------------|------------|  
|Accepter|Définie par le <xref:System.Net.HttpWebRequest.Accept%2A> propriété.|  
|Connexion|Définie par le <xref:System.Net.HttpWebRequest.Connection%2A> propriété, <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété.|  
|Content-Length|Définie par le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété.|  
|Type de contenu|Définie par le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété.|  
|Attendre|Définie par le <xref:System.Net.HttpWebRequest.Expect%2A> propriété.|  
|Date|Défini par le système à la date actuelle.|  
|Hôte|Défini par le système pour des informations sur l’hôte actuel.|  
|If-Modified-Since|Définie par le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété.|  
|Plage|Définie par le <xref:System.Net.HttpWebRequest.AddRange%2A> (méthode).|  
|Références|Définie par le <xref:System.Net.HttpWebRequest.Referer%2A> propriété.|  
|Codage de transfert|Définie par le <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété (le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété doit être `true`).|  
|Agent utilisateur|Définie par le <xref:System.Net.HttpWebRequest.UserAgent%2A> propriété.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> est automatiquement enregistrée. Vous n’avez pas besoin d’appeler le <xref:System.Net.WebRequest.RegisterPrefix%2A> méthode pour inscrire <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> avant d’utiliser des URI commençant par `http://` ou `https://`.  
  
 L’ordinateur local ou un fichier de configuration d’application peut spécifier qu’un proxy par défaut est utilisé. Si le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété est spécifiée, les paramètres de proxy à partir de la <xref:System.Net.HttpWebRequest.Proxy%2A> l’ordinateur local ou un fichier de configuration d’application de remplacement de la propriété et la <xref:System.Net.HttpWebRequest> instance utilisera les paramètres de proxy spécifiés. Si aucun proxy n’est spécifié dans un fichier de configuration et la <xref:System.Net.HttpWebRequest.Proxy%2A> propriété n’est pas spécifiée, la <xref:System.Net.HttpWebRequest> classe utilise les paramètres proxy hérités à partir d’Internet Explorer sur l’ordinateur local. S’il n’y a aucun paramètre de proxy dans Internet Explorer, la demande est envoyée directement au serveur.  
  
 La <xref:System.Net.HttpWebRequest> classe analyse une liste de contournement proxy avec des caractères génériques hérités d’Internet Explorer de manière différente que la liste de contournement est analysée directement par Internet Explorer. Par exemple, la <xref:System.Net.HttpWebRequest> classe analyse une liste de « nt * » à partir d’Internet Explorer comme une expression régulière de « nt. $». Cela diffère du comportement de natif d’Internet Explorer. Par conséquent, une URL de «`http://intxxxxx`» le proxy à l’aide de la <xref:System.Net.HttpWebRequest> classe, mais pas le proxy à l’aide d’Internet Explorer.  
  
> [!NOTE]
>  Le Framework met en cache les sessions SSL comme elles sont créées et essaie de réutiliser une session mise en cache pour une nouvelle demande, si possible. Lorsque vous tentez de réutiliser une session SSL, le Framework utilise le premier élément de <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (s’il en existe un), ou essaie de réutiliser une session anonyme si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> est vide.  
  
> [!NOTE]
>  Pour des raisons de sécurité, les cookies sont désactivés par défaut. Si vous souhaitez utiliser des cookies, utiliser le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété pour activer les cookies.  
  
 Le .NET Framework 4.6 inclut une nouvelle fonctionnalité de sécurité qui bloque le chiffrement non sécurisé et pour les connexions, les algorithmes de hachage. Les applications à l’aide de TLS/SSL via des API telles que HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. et le ciblage de .NET Framework 4.6 obtenir le comportement plus sécurisés par défaut.  
  
 Les développeurs peuvent faire désactiver ce comportement afin de maintenir l’interopérabilité avec leurs services existants SSL3 TLS ou avec les services de RC4. [Cet article](https://support.microsoft.com/kb/3069494) explique comment modifier votre code afin que le nouveau comportement est désactivé.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.HttpWebRequest> pour l’URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Pour accéder à l’URI demandé ou n’importe quel URI vers lequel la demande est redirigée. Énumération associée : <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. These constructors are obsolete; see the Remarks section for details.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Les deux <xref:System.Net.HttpWebRequest> constructeurs sont obsolètes et ne doit pas être utilisés. Appelez le <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> méthode pour initialiser de nouveaux <xref:System.Net.HttpWebRequest> objets.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. This constructor is obsolete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes. This constructor is obsolete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez la sérialisation, une application doit s’exécuter en mode confiance totale.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">pour un accès illimité aux ressources réseau. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels a request to an Internet resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Abort%2A> méthode annule une demande à une ressource. Après une demande est annulée, l’appel le <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, ou <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode entraîne un <xref:System.Net.WebException> avec la <xref:System.Net.WebException.Status%2A> propriété la valeur <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Le <xref:System.Net.HttpWebRequest.Abort%2A> méthode exécutera de façon synchrone le rappel spécifié pour le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthodes si le <xref:System.Net.HttpWebRequest.Abort%2A> méthode est appelée alors qu’une de ces opérations sont en attente. Cela peut entraîner des problèmes de blocage potentiel.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Dans le cas de requêtes asynchrones, il est responsable de l’application cliente pour implémenter son propre mécanisme de délai d’attente. L’exemple de code suivant montre comment effectuer cette opération.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Accept" /> HTTP header.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Accept" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour effacer le `Accept` l’en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.Accept%2A> propriété `null`.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Accept%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a range header to the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Si `range` est un nombre positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande au serveur d’envoyer les 100 premiers octets (à partir du début à la position d’octet 99) est le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
   
  
## Examples  
 L’exemple de code suivant ajoute un en-tête de plage à la demande.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Si `range` est un nombre positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande au serveur d’envoyer les 100 premiers octets (à partir du début à la position d’octet 99) est le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande les 100 premiers octets aurait à être serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `from` paramètre serait spécifié comme 0 et le `to` paramètre serait spécifié comme 99. Le spécificateur de plage est automatiquement défini en tant que « octets » par cette méthode.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
   
  
## Examples  
 L’exemple de code suivant ajoute un en-tête de plage à la demande.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande les 100 premiers octets aurait à être serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `from` paramètre serait spécifié comme 0 et le `to` paramètre serait spécifié comme 99. Le spécificateur de plage est automatiquement défini en tant que « octets » par cette méthode.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Si `range` est un nombre positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », car il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plage personnalisé autre que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande les 100 premiers octets aurait à être serait le suivant :  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié comme « octets » et le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Si `range` est un nombre positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », car il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plage personnalisé autre que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande les 100 premiers octets aurait à être serait le suivant :  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié comme « octets » et le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », car il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plage personnalisé autre que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande les 100 premiers octets aurait à être serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié comme « octets », le `from` paramètre serait 0 et le `to` paramètre serait 99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La chaîne spécifiée dans l’en-tête Accept-Ranges est le spécificateur de plages qui serait spécifié dans le `rangeSpecifier` paramètre pour cette méthode.  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une demande permet à un client demander qu’elles souhaitent recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », car il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plage personnalisé autre que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’en-tête Range dans une requête de protocole HTTP qui demande les 100 premiers octets aurait à être serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié comme « octets », le `from` paramètre serait 0 et le `to` paramètre serait 99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets devrait se présenter comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La chaîne spécifiée dans l’en-tête Accept-Ranges est le spécificateur de plages qui serait spécifié dans le `rangeSpecifier` paramètre pour cette méthode.  
  
 Si un en-tête Accept-Ranges n’est reçu dans l’en-tête de la réponse du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, devrait se présenter comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse d’une requête de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) of the Internet resource that actually responds to the request.</summary>
        <value>
          <see cref="T:System.Uri" /> identifiant la ressource Internet qui répond réellement à la requête. La valeur par défaut est l’URI utilisé par la méthode <see cref="M:System.Net.WebRequest.Create(System.String)" /> pour initialiser la requête.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Address%2A> propriété est définie sur l’URI lorsque toutes les redirections qui se produisent pendant la requête sont terminées.  
  
 L’URI de la demande d’origine est conservé le <xref:System.Net.HttpWebRequest.RequestUri%2A> propriété.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.HttpWebRequest> objet `req` a été redirigé vers un autre emplacement pour répondre à la demande et définit la valeur de la `hasChanged` variable `true` si la demande a été redirigée ; sinon `hasChanged`a la valeur `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the request should follow redirection responses.</summary>
        <value>
          <see langword="true" /> si la requête doit suivre automatiquement les réponses de redirection provenant de la ressource Internet ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> à `true` si vous souhaitez que la demande pour suivre automatiquement les en-têtes de redirection HTTP vers le nouvel emplacement de la ressource. Le nombre maximal de redirections à suivre est défini par le <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriété.  
  
 Si <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> a la valeur `false`, toutes les réponses avec un code d’état HTTP entre 300 et 399 sont retournées à l’application.  
  
 L’en-tête d’autorisation est désactivée lors de redirections automatiques et <xref:System.Net.HttpWebRequest> essaie automatiquement de vous authentifier de nouveau à l’emplacement redirigé. Dans la pratique, cela signifie qu’une application ne peut pas placer les informations d’authentification personnalisée dans l’en-tête d’autorisation s’il est possible de rencontrer la redirection. Au lieu de cela, l’application doit implémenter et inscrire un module d’authentification personnalisé. Le <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> et la classe connexe sont utilisées pour implémenter un module d’authentification personnalisé. Le <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> méthode inscrit un module d’authentification personnalisé.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriété pour permettre à la requête de suivre les réponses de redirection.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the received from the Internet resource.</summary>
        <value>
          <see langword="true" /> pour activer la mise en mémoire tampon des données reçues de la ressource Internet ; <see langword="false" /> pour désactiver la mise en mémoire tampon. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the data sent to the Internet resource.</summary>
        <value>
          <see langword="true" /> pour activer la mise en mémoire tampon des données envoyées à la ressource Internet ; <see langword="false" /> pour désactiver la mise en mémoire tampon. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> est `true`, les données sont mis en mémoire tampon, prêt à être renvoyées en cas de redirections ou l’authentification des demandes.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> propriété pour désactiver la mise en mémoire tampon des données.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Paramètre <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> à <see langword="true" /> peut entraîner des problèmes de performances lors du téléchargement des jeux de données volumineux, car le tampon de données peut utiliser toute la mémoire disponible.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression that is used.</summary>
        <value>A <see cref="T:System.Net.DecompressionMethods" /> objet qui indique le type de décompression utilisé.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The object's current state does not allow this property to be set.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> méthode démarre une demande asynchrone pour un flux utilisé pour envoyer des données pour le <xref:System.Net.HttpWebRequest>. La méthode de rappel asynchrone utilise la <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode pour retourner le flux réel.  
  
 Le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> méthode requiert certaines tâches de configuration synchrone pour terminer (résolution de DNS, la détection de proxy et connexion de socket TCP, par exemple) avant que cette méthode est asynchrone. Par conséquent, cette méthode doit jamais être appelée sur un thread d’interface utilisateur utilisateur, car elle peut prendre beaucoup de temps (jusqu'à plusieurs minutes en fonction des paramètres de réseau) pour effectuer les tâches de configuration synchrone initiale avant une exception pour une erreur est générée ou la méthode a réussi.  
  
 Pour en savoir plus sur le pool de threads, consultez [le Pool de threads gérés](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une demande particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> méthode pour effectuer une demande asynchrone pour une instance de flux de données.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The stream is being used by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request to an Internet resource.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request for a response.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode démarre une demande asynchrone pour une réponse de la ressource Internet. La méthode de rappel asynchrone utilise le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthode pour retourner le réel <xref:System.Net.WebResponse>.  
  
 A <xref:System.Net.ProtocolViolationException> est levée dans plusieurs cas lorsque les propriétés définies sur la <xref:System.Net.HttpWebRequest> classe sont en conflit. Cette exception se produit si une application définit la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété et la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true`, puis envoie une requête HTTP GET. Cette exception se produit si une application tente d’envoyer mémorisé en bloc vers un serveur qui prend uniquement en charge le protocole HTTP 1.0, où cela n'est pas pris en charge. Cette exception se produit si une application tente d’envoyer des données sans définir la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété ou le <xref:System.Net.HttpWebRequest.SendChunked%2A> est `false` lors de la mise en mémoire tampon est désactivée et sur une connexion keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`)`.`  
  
 Si un <xref:System.Net.WebException> est levée, utilisez la <xref:System.Net.WebException.Response%2A> et <xref:System.Net.WebException.Status%2A> propriétés de l’exception pour déterminer la réponse du serveur.  
  
 Le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode requiert certaines tâches de configuration synchrone pour terminer (résolution de DNS, la détection de proxy et connexion de socket TCP, par exemple) avant que cette méthode est asynchrone. Par conséquent, cette méthode doit jamais être appelée sur un thread d’interface utilisateur utilisateur, car elle peut prendre beaucoup de temps (jusqu'à plusieurs minutes en fonction des paramètres de réseau) pour effectuer les tâches de configuration synchrone initiale avant une exception pour une erreur est générée ou la méthode a réussi.  
  
 Pour en savoir plus sur le pool de threads, consultez [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une demande particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode pour effectuer une demande asynchrone pour une ressource Internet.  
  
> [!NOTE]
>  Dans le cas de requêtes asynchrones, il est responsable de l’application cliente pour implémenter son propre mécanisme de délai d’attente. L’exemple de code suivant montre comment procéder.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" /> and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the collection of security certificates that are associated with this request.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats de sécurité associés à cette requête.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application peut ajouter un certificat à une collection, mais peut-être pas des droits d’accès. Pour utiliser un certificat contenu dans la collection, l’application doit avoir les droits d’accès de l’entité qui a émis le certificat.  
  
> [!NOTE]
>  Le Framework met en cache les sessions SSL comme elles sont créées et essaie de réutiliser une session mise en cache pour une nouvelle demande, si possible. Lorsque vous tentez de réutiliser une session SSL, le Framework utilise le premier élément de <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (s’il en existe un), ou essaie de réutiliser une session anonyme si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> est vide.  
  
> [!NOTE]
>  Pour des raisons de performances, vous ne devez pas ajouter un certificat client pour un <xref:System.Net.HttpWebRequest> sauf si vous savez que le serveur demandera.  
>   
>  Pour obtenir un exemple de code illustrant comment énumérer les certificats dans le magasin de certificats client, consultez la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value specified for a set operation is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Connection" /> HTTP header.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Connection" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La requête envoie le <xref:System.Net.HttpWebRequest.Connection%2A> à la ressource Internet en tant que propriété du `Connection` en-tête HTTP. Si la valeur de la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété `true`, la valeur « Keep-alive » est ajoutée à la fin de la `Connection` en-tête.  
  
 Pour effacer le `Connection` l’en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.Connection%2A> propriété `null`.  
  
 Modification de la <xref:System.Net.HttpWebRequest.Connection%2A> propriété une fois que la requête a été lancée en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.Connection%2A> propriété à définir la valeur de l’en-tête HTTP de connexion.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of <see cref="P:System.Net.HttpWebRequest.Connection" /> is set to Keep-alive or Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the connection group for the request.</summary>
        <value>Nom du groupe de connexions pour cette requête. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriété permet d’associer une requête à un groupe de connexions. Cela est utile lorsque votre application effectue des demandes à un seul serveur pour des utilisateurs différents, par exemple un site Web qui Récupère des informations client à partir d’un serveur de base de données.  
  
   
  
## Examples  
 L’exemple de code suivants montrent comment utiliser les informations utilisateur pour former un groupe de connexions, en supposant que les variables `username`, `password`, et `domain` sont définies par l’application avant l’appel de ce code.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chaque groupe de connexions crée des connexions supplémentaires pour un serveur. Cela peut entraîner de dépassement du nombre de connexions définies par le <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> propriété pour ce serveur.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Content-length" /> HTTP header.</summary>
        <value>Nombre d'octets de données à envoyer à la ressource Internet. La valeur par défaut est -1, ce qui indique que la propriété n'a pas été définie et qu'aucune donnée de la requête ne doit être envoyée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété contient la valeur à envoyer en tant que le `Content-length` en-tête HTTP à la demande.  
  
 Toute valeur autre que -1 dans le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété indique que la demande transfère des données et que seules les méthodes qui transfèrent des données sont autorisés à définir dans le <xref:System.Net.HttpWebRequest.Method%2A> propriété.  
  
 Après le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété est définie sur une valeur, ce nombre d’octets doit être écrit dans le flux de demande qui est retourné en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode ou les deux le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> et <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthodes.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété à la longueur de la chaîne en cours de publication.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The new <see cref="P:System.Net.HttpWebRequest.ContentLength" /> value is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Content-type" /> HTTP header.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Content-type" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété contient le type de média de la demande. Valeurs assignées à la <xref:System.Net.HttpWebRequest.ContentType%2A> propriété remplacent le contenu existant lorsque la requête envoie le `Content-type` en-tête HTTP.  
  
 Pour effacer le `Content-type` l’en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.ContentType%2A> propriété `null`.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection> . Si <xref:System.Net.WebHeaderCollection> est défini, la valeur de propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate method called when an HTTP 100-continue response is received from the Internet resource.</summary>
        <value>Un délégué implémentant la méthode de rappel qui s'exécute lorsqu'une réponse HTTP Continue est retournée par la ressource Internet. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propriété spécifie la méthode de rappel à appeler lorsque le client reçoit un 100-continuer la réponse.  
  
 Lorsque le <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propriété est définie, le client appelle le délégué chaque fois que les réponses du type de protocole <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) sont reçus. Cela est utile si vous souhaitez que le client pour afficher l’état des données reçues à partir de la ressource Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a timeout, in milliseconds, to wait until the 100-Continue is received from the server.</summary>
        <value>Délai d’attente, en millisecondes, jusqu’à réception de la réponse 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les 100-continuer la réponse est reçue avant l’expiration du délai, le corps d’entité peut être envoyé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cookies associated with the request.</summary>
        <value>
          <see cref="T:System.Net.CookieContainer" /> contenant les cookies associés à cette requête.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété fournit une instance de la <xref:System.Net.CookieContainer> classe qui contient les cookies associés à cette demande.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> est `null` par défaut. Vous devez affecter un <xref:System.Net.CookieContainer> objet à la propriété pour que les cookies retournés dans le <xref:System.Net.HttpWebResponse.Cookies%2A> propriété de la <xref:System.Net.HttpWebResponse> retournée par le <xref:System.Net.HttpWebRequest.GetResponse%2A> (méthode).  
  
> [!NOTE]
>  Pour des raisons de sécurité, les cookies sont désactivés par défaut. Si vous souhaitez utiliser des cookies, utiliser le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété pour activer les cookies.  
  
   
  
## Examples  
 L’exemple de code suivant envoie une demande à une URL et affiche les cookies retournés dans la réponse.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information for the request.</summary>
        <value>
          <see cref="T:System.Net.ICredentials" /> qui contient les informations d’authentification associées à la requête. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Credentials%2A> propriété contient des informations d’authentification pour identifier le créateur de la demande. Le <xref:System.Net.HttpWebRequest.Credentials%2A> propriété peut être un <xref:System.Net.NetworkCredential>, auquel cas l’utilisateur, mot de passe, et les informations de domaine contenues dans le <xref:System.Net.NetworkCredential> objet est utilisé pour authentifier la demande, ou il peut être un <xref:System.Net.CredentialCache>, auquel cas l’Uniform Resource Identifier Identificateur (URI) de la demande est utilisé pour déterminer l’utilisateur, mot de passe et les informations de domaine à utiliser pour authentifier la demande.  
  
 Dans la plupart des scénarios de client, vous devez utiliser le <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriété, qui contient les informations d’identification de l’utilisateur actuellement connecté. Pour ce faire, définissez la <xref:System.Net.WebClient.UseDefaultCredentials%2A> propriété `true` au lieu de définir cette propriété.  
  
 Si le <xref:System.Net.HttpWebRequest> classe est utilisé dans une application de couche intermédiaire, comme une application ASP.NET, les informations d’identification dans le <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriété appartenir au compte d’exécution de la page ASP (informations d’identification côté serveur). En règle générale, vous définirez cette propriété pour les informations d’identification du client au nom duquel la demande est effectuée.  
  
> [!NOTE]
>  Le schéma d’authentification NTLM ne peut pas être utilisé pour emprunter l’identité d’un autre utilisateur. Kerberos doit être configuré spécialement pour prendre en charge l’emprunt d’identité.  
  
 Pour limiter HttpWebRequest à une ou plusieurs méthodes d’authentification, utilisez la <xref:System.Net.CredentialCache> classe et lier vos informations d’identification à un ou plusieurs schémas d’authentification  
  
 Schémas d’authentification pris en charge incluent Digest, Negotiate, Kerberos, NTLM et Basic.  
  
 Pour des raisons de sécurité, lorsque le suivi automatiquement les redirections, stocker les informations d’identification que vous souhaitez inclure dans la redirection dans un <xref:System.Net.CredentialCache> et l’affecter à cette propriété. Cette propriété sera automatiquement la valeur `null` lors de la redirection s’il contient n’est pas un <xref:System.Net.CredentialCache>. Ayant la valeur de cette propriété est automatiquement définie sur `null` dans ces conditions empêche les informations d’identification soient envoyées à n’importe quelle destination involontaire.
  
## Examples  
 L’exemple de code suivant définit les informations d’identification pour une demande.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the <see langword="Date" /> HTTP header value to use in an HTTP request.</summary>
        <value>Valeur d'en-tête Date dans la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’en-tête de Date est `null`, puis la valeur de retour est fixée à <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Le <xref:System.Net.HttpWebRequest.Date%2A> propriété est une norme <xref:System.DateTime?displayProperty=nameWithType> de l’objet et ne peut contenir un <xref:System.DateTimeKind?displayProperty=nameWithType> champ <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Tout type d’heure peut être définie lors de l’utilisation du <xref:System.Net.HttpWebRequest.Date%2A> propriété. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> est définie ou récupérée, les <xref:System.Net.HttpWebRequest.Date%2A> propriété est censée pour être <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (heure locale).  
  
 Les classes dans le <xref:System.Net> espace de noms écrivent toujours le <xref:System.Net.HttpWebRequest.Date%2A> propriété sur le câble pendant la transmission au format standard à l’aide du format GMT (Utc).  
  
 Si le <xref:System.Net.HttpWebRequest.Date%2A> est définie sur <xref:System.DateTime.MinValue?displayProperty=nameWithType>, puis le `Date` en-tête HTTP est supprimé de la <xref:System.Net.HttpWebRequest.Headers%2A> propriété et la <xref:System.Net.WebHeaderCollection>.  
  
 Si le <xref:System.Net.HttpWebRequest.Date%2A> propriété est <xref:System.DateTime.MinValue?displayProperty=nameWithType>, cela indique que le `Date` en-tête HTTP n’est pas inclus dans le <xref:System.Net.HttpWebRequest.Headers%2A> propriété et la <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
 Si le <xref:System.Net.HttpWebRequest.Date%2A> est définie et une tentative est faite pour envoyer un <xref:System.Net.HttpWebRequest> sans corps, avec un <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> seront levées par le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, et <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthodes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cache policy for this request.</summary>
        <value>Élément <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> spécifiant la stratégie de cache en vigueur pour cette demande quand aucune autre stratégie n'est applicable.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de cette propriété enregistre la stratégie spécifiée pour les schémas HTTP et HTTPS. Cette stratégie est utilisée pour cette demande si :  
  
 Il existe aucune <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> propriété spécifiée pour cette demande.  
  
 \- ou -  
  
 La configuration de l’ordinateur et application fichiers ne spécifient pas une stratégie de cache qui s’applique à l’identificateur de ressource uniforme (URI) utilisé pour créer cette demande.  
  
 La stratégie de cache détermine si la ressource demandée peut être extraite d’un cache plutôt que d’envoyer la demande à l’ordinateur hôte de ressource.  
  
 Une copie d’une ressource est ajoutée uniquement au cache si le flux de réponse pour la ressource est extrait et lu à la fin du flux de données. Une autre demande pour la même ressource pourrait utiliser une copie mise en cache, en fonction du niveau de stratégie de cache pour cette demande.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">pour un accès illimité aux ressources réseau. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default maximum length of an HTTP error response.</summary>
        <value>Longueur maximale par défaut d'une réponse d'erreur HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default for the <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> property.</summary>
        <value>Longueur, en kilo-octets (1 024 octets), de la valeur maximum par défaut pour les en-têtes de réponse reçus. Le fichier de configuration par défaut fixe cette valeur à 64 kilo-octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur de l’en-tête de réponse reçu la ligne d’état de réponse et des caractères de contrôle supplémentaire reçu dans le cadre du protocole HTTP. Une valeur-1 signifie qu'aucune limite n’est imposée sur les en-têtes de réponse reçus. une valeur de 0 signifie que toutes les requêtes échouent.  
  
 Cette valeur peut également être modifiée dans le fichier de configuration. L’impact de cette propriété peut être remplacée en définissant le <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriété sur une instance de la <xref:System.Net.HttpWebRequest> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not equal to -1 and is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode effectue une demande asynchrone pour un flux de données a été démarrée par le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode). Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  Vous devez définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété avant d’écrire des données dans le flux.  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion en vue de leur réutilisation. Échec pour fermer le flux de données indique à votre application de manquer de connexions.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode pour mettre fin à une demande asynchrone pour une instance de flux.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode effectue une demande asynchrone pour un flux de données a été démarrée par le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode) et les sorties du <xref:System.Net.TransportContext> associé au flux. Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
 Certains les applications qui utilisent l’authentification Windows intégrée avec protection étendue devront peut-être être en mesure d’interroger la couche de transport utilisée par <xref:System.Net.HttpWebRequest> afin de récupérer le jeton de liaison de canal (FAO) du canal de TLS sous-jacent. Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode permet d’accéder à ces informations pour les méthodes HTTP qui ont un corps de demande (`POST` et `PUT` demandes). Cela est nécessaire uniquement si l’application implémente sa propre authentification et a besoin d’accéder au CBT.  
  
> [!NOTE]
>  Si une application doit définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété, puis il doit être effectuée avant d’extraire le flux de données et écrire des données.  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion en vue de leur réutilisation. Échec pour fermer le flux de données indique à votre application de manquer de connexions.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a response.</param>
        <summary>Ends an asynchronous request to an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthode effectue une demande asynchrone pour une ressource Internet qui a été démarrée en appelant le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> (méthode).  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.Net.HttpWebResponse.Close%2A> méthode pour fermer le flux et libérer la connexion. Cela peut provoquer l’application de manquer de connexions.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthode pour mettre fin à une demande asynchrone pour une ressource Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult." />  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> property is greater than 0 but the data has not been written to the request stream.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Expect" /> HTTP header.</summary>
        <value>Le contenu de la <see langword="Expect" /> en-tête HTTP. La valeur par défaut est <see langword="null" />.  
  
 <block subset="none" type="note"><para> La valeur de cette propriété est stockée dans <see cref="T:System.Net.WebHeaderCollection" />. Si WebHeaderCollection est définie, la valeur de propriété est perdue.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> is set to a string that contains "100-continue" as a substring.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data required to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les objets inclus dans le <xref:System.Runtime.Serialization.SerializationInfo> sont automatiquement suivies et sérialisé par le formateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode retourne un flux à utiliser pour envoyer des données pour le <xref:System.Net.HttpWebRequest>. Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
 Si une application doit définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété, puis il doit être effectuée avant d’extraire le flux de données.  
  
 Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion en vue de leur réutilisation. Échec pour fermer le flux de données indique à votre application de manquer de connexions.  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une demande particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode pour retourner une instance de flux de données.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">The <see cref="T:System.Net.TransportContext" /> for the <see cref="T:System.IO.Stream" />.</param>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode retourne un flux à utiliser pour envoyer des données pour le <xref:System.Net.HttpWebRequest> et fournit en sortie le <xref:System.Net.TransportContext> associé au flux. Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
 Certains les applications qui utilisent l’authentification Windows intégrée avec protection étendue devront peut-être être en mesure d’interroger la couche de transport utilisée par <xref:System.Net.HttpWebRequest> afin de récupérer le jeton de liaison de canal (FAO) du canal de TLS sous-jacent. Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode permet d’accéder à ces informations pour les méthodes HTTP qui ont un corps de demande (`POST` et `PUT` demandes). Cela est nécessaire uniquement si l’application implémente sa propre authentification et a besoin d’accéder au CBT.  
  
 Si une application doit définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété, puis il doit être effectuée avant d’extraire le flux de données.  
  
 Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion en vue de leur réutilisation. Échec pour fermer le flux de données indique à votre application de manquer de connexions.  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une demande particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method was unable to obtain the <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a response from an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode retourne un <xref:System.Net.WebResponse> objet qui contient la réponse de la ressource Internet. L’instance réelle retournée est un <xref:System.Net.HttpWebResponse>et le type peut être converti à cette classe pour les propriétés d’accès spécifiques au protocole HTTP.  
  
 A <xref:System.Net.ProtocolViolationException> est levée dans plusieurs cas lorsque les propriétés définies sur la <xref:System.Net.HttpWebRequest> classe sont en conflit. Cette exception se produit si une application définit la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété et la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true`, puis envoie une requête HTTP GET. Cette exception se produit si une application tente d’envoyer mémorisé en bloc vers un serveur qui prend uniquement en charge le protocole HTTP 1.0, où cela n'est pas pris en charge. Cette exception se produit si une application tente d’envoyer des données sans définir la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété ou le <xref:System.Net.HttpWebRequest.SendChunked%2A> est `false` lors de la mise en mémoire tampon est désactivée et sur une connexion keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`)`.`  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.Net.HttpWebResponse.Close%2A> méthode pour fermer le flux et libérer la connexion. Cela peut provoquer l’application de manquer de connexions.  
  
 Lorsque vous utilisez la méthode POST, vous devez obtenir le flux de demande, écrire les données à valider et fermer le flux. Cette méthode est bloquée en attente de contenu à publier ; s’il n’existe aucun jeu de délai d’attente et vous ne fournissez pas de contenu, le thread appelant se bloque indéfiniment.  
  
> [!NOTE]
>  Appels multiples à <xref:System.Net.HttpWebRequest.GetResponse%2A> retournent le même objet de réponse ; la demande n’est pas relancée.  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une demande particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Si un <xref:System.Net.WebException> est levée, utilisez la <xref:System.Net.WebException.Response%2A> et <xref:System.Net.WebException.Status%2A> propriétés de l’exception pour déterminer la réponse du serveur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Pour des raisons de sécurité, les cookies sont désactivés par défaut. Si vous souhaitez utiliser des cookies, utiliser le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété pour activer les cookies.  
  
   
  
## Examples  
 L’exemple de code suivant obtient la réponse pour une demande.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater or equal to zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, this request includes data to be sent to the server. Requests that send data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a response has been received from an Internet resource.</summary>
        <value>
          <see langword="true" /> si une réponse a été reçue ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple vérifie le <xref:System.Net.HttpWebRequest.HaveResponse%2A> propriété pour déterminer si une réponse a été reçue d’une ressource Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a collection of the name/value pairs that make up the HTTP headers.</summary>
        <value>
          <see cref="T:System.Net.WebHeaderCollection" /> contenant les paires nom-valeur qui composent les en-têtes de la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Headers%2A> collection contient les en-têtes de protocole associés à la demande. Le tableau suivant répertorie les en-têtes HTTP qui ne sont pas stockées dans le <xref:System.Net.HttpWebRequest.Headers%2A> collection mais qui ne sont définies par le système ou définie par les propriétés ou méthodes.  
  
|Header|Définie par|  
|------------|------------|  
|Accepter|Définie par le <xref:System.Net.HttpWebRequest.Accept%2A> propriété.|  
|Connexion|Définie par le <xref:System.Net.HttpWebRequest.Connection%2A> propriété et <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété.|  
|Content-Length|Définie par le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété.|  
|Type de contenu|Définie par le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété.|  
|Attendre|Définie par le <xref:System.Net.HttpWebRequest.Expect%2A> propriété.|  
|Date|Définie par le <xref:System.Net.HttpWebRequest.Date%2A> propriété.|  
|Hôte|Définie par le <xref:System.Net.HttpWebRequest.Host%2A> propriété.|  
|If-Modified-Since|Définie par le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété.|  
|Plage|Définie par le <xref:System.Net.HttpWebRequest.AddRange%2A> (méthode).|  
|Références|Définie par le <xref:System.Net.HttpWebRequest.Referer%2A> propriété.|  
|Codage de transfert|Définie par le <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété (le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété doit être true).|  
|Agent utilisateur|Définie par le <xref:System.Net.HttpWebRequest.UserAgent%2A> propriété.|  
  
 Le <xref:System.Net.WebHeaderCollection.Add%2A> méthode lève une exception une <xref:System.ArgumentException> si vous essayez de définir un de ces en-têtes protégés.  
  
 Modification de la <xref:System.Net.HttpWebRequest.Headers%2A> propriété une fois que la requête a été lancée en appelant <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>.  
  
 Vous ne devez pas supposer que les valeurs d’en-tête reste inchangées, car les serveurs Web et les caches peuvent modifier ou ajouter des en-têtes à une requête Web.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.Headers%2A> propriété pour imprimer les paires de nom/valeur d’en-tête HTTP à la console.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the Host header value to use in an HTTP request independent from the request URI.</summary>
        <value>Valeur d'en-tête Hôte dans la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Host%2A> propriété peut être utilisée pour définir l’hôte de valeur d’en-tête à utiliser dans une requête HTTP indépendante de l’URI de requête. Le <xref:System.Net.HttpWebRequest.Host%2A> propriété peut se composer d’un nom d’hôte et un numéro de port facultatif. Un en-tête d’hôte sans informations sur le port implique le port par défaut pour le service demandé (port 80 pour une URL HTTP, par exemple).  
  
 Le format pour spécifier un hôte et le port doit respecter les règles dans la section 14.23 de la norme RFC2616 publiée par l’IETF. Un exemple répondant à ces exigences qui spécifie le port 8080 serait la valeur suivante pour le <xref:System.Net.HttpWebRequest.Host%2A> propriété :  
  
 `www.contoso.com:8080`  
  
 À l’aide de la <xref:System.Net.HttpWebRequest.Host%2A> propriété pour spécifier explicitement une valeur d’en-tête Host personnalisée affecte également la mise en cache des zones, les cookies et l’authentification. Lorsqu’une application fournit des informations d’identification pour un préfixe d’URI spécifique, les applications doivent s’assurer d’utiliser l’URI qui contient la valeur de l’en-tête d’hôte, pas le serveur cible dans l’URI. La clé utilisée lors de la mise en cache de ressources, utilise la valeur d’en-tête hôte plutôt que l’URI de requête. Les cookies sont stockés dans un <xref:System.Net.CookieContainer> et logiquement groupées par le nom de domaine du serveur. Si l’application spécifie un en-tête d’hôte, puis cette valeur sera utilisée en tant que domaine.  
  
 Si le <xref:System.Net.HttpWebRequest.Host%2A> propriété n’est pas définie, puis la valeur d’en-tête hôte à utiliser dans une requête HTTP est basée sur l’URI de requête.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The Host header cannot be set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The Host header cannot be set to an invalid value.</exception>
        <exception cref="T:System.InvalidOperationException">The Host header cannot be set after the <see cref="T:System.Net.HttpWebRequest" /> has already started to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="If-Modified-Since" /> HTTP header.</summary>
        <value>A <see cref="T:System.DateTime" /> qui contient le contenu de la <see langword="If-Modified-Since" /> en-tête HTTP. La valeur par défaut est l'horodatage actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est une norme <xref:System.DateTime?displayProperty=nameWithType> de l’objet et ne peut contenir un <xref:System.DateTimeKind?displayProperty=nameWithType> champ <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Tout type d’heure peut être définie lors de l’utilisation du <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> est définie ou récupérée, les <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est censée pour être <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (heure locale).  
  
 Les classes dans le <xref:System.Net> espace de noms écrivent toujours le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété sur le câble pendant la transmission au format standard à l’aide du format GMT (Utc).  
  
 Si le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> est définie sur <xref:System.DateTime.MinValue?displayProperty=nameWithType>, puis le `If-Modified-Since` en-tête HTTP est supprimé de la <xref:System.Net.HttpWebRequest.Headers%2A> propriété et la <xref:System.Net.WebHeaderCollection>.  
  
 Si le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est <xref:System.DateTime.MinValue?displayProperty=nameWithType>, cela indique que le `If-Modified-Since` en-tête HTTP n’est pas inclus dans le <xref:System.Net.HttpWebRequest.Headers%2A> propriété et la <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple vérifie le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make a persistent connection to the Internet resource.</summary>
        <value>
          <see langword="true" /> Si la demande à la ressource Internet doit contenir un <see langword="Connection" /> en-tête HTTP ayant la valeur Keep-alive ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `true` pour envoyer un `Connection` en-tête HTTP ayant la valeur Keep-alive. Une application utilise <xref:System.Net.HttpWebRequest.KeepAlive%2A> pour indiquer une préférence pour les connexions persistantes. Lorsque le <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`, l’application établit des connexions persistantes aux serveurs qui les prennent en charge.  
  
> [!NOTE]
>  Lorsque vous utilisez HTTP/1.1, Keep-Alive est activé par défaut. Paramètre <xref:System.Net.HttpWebRequest.KeepAlive%2A> à `false` peut entraîner l’envoi d’un `Connection: Close` en-tête vers le serveur.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété `false` pour éviter d’établir une connexion persistante avec la ressource Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of redirects that the request follows.</summary>
        <value>Nombre maximal de réponses de redirection suivies par la requête. La valeur par défaut est 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriété définit le nombre maximal de redirections que la requête doit suivre si les <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriété est `true`.  
  
   
  
## Examples  
 L’exemple de code suivant définit la valeur de cette propriété.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is set to 0 or less.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowed length of the response headers.</summary>
        <value>Longueur en kilo-octets (1 024 octets) des en-têtes de réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur de l’en-tête de réponse comprend la ligne d’état de réponse et des caractères de contrôle supplémentaire reçu dans le cadre du protocole HTTP. Une valeur-1 signifie qu'aucune limite n’est imposée sur les en-têtes de réponse ; une valeur de 0 signifie que toutes les requêtes échouent.  
  
 Si le <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriété n’est pas définie explicitement, la valeur par défaut la valeur de la <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> propriété.  
  
 Si la longueur de l’en-tête de réponse reçu dépasse la valeur de la <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriété, le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> méthodes lèvent une <xref:System.Net.WebException> avec la <xref:System.Net.WebException.Status%2A> propriété <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 L’exemple de code suivant définit la valeur de cette propriété.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after the request has already been submitted.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the media type of the request.</summary>
        <value>Type de média de la requête. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Net.HttpWebRequest.MediaType%2A> propriété affecte le <xref:System.Net.HttpWebResponse.CharacterSet%2A> propriété. Lorsque vous définissez la <xref:System.Net.HttpWebRequest.MediaType%2A> dans la demande, le type de média correspondant est choisi dans la liste des jeux de caractères retournés dans la réponse `Content-type` en-tête HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the method for the request.</summary>
        <value>Méthode de requête à utiliser pour contacter la ressource Internet. La valeur par défaut est GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Method%2A> propriété peut être définie à un des verbes de protocole HTTP 1.1 : GET, HEAD, POST, PUT, barre DELETE, TRACE ou OPTIONS.  
  
 Si le <xref:System.Net.HttpWebRequest.ContentLength%2A> est définie sur toute valeur autre que -1, le <xref:System.Net.HttpWebRequest.Method%2A> propriété doit être définie sur une propriété de protocole qui transfère des données.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Method%2A> propriété à valider.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No method is supplied.  -or-  The method string contains invalid characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</summary>
        <value>
          <see langword="true" /> si la requête doit être canalisée en rafale ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application utilise le <xref:System.Net.HttpWebRequest.Pipelined%2A> propriété pour indiquer une préférence pour les connexions canalisées en rafale. Lorsque <xref:System.Net.HttpWebRequest.Pipelined%2A> est `true`, une application établit des connexions canalisées en rafale aux serveurs qui les prennent en charge.  
  
 Les connexions canalisées en rafale sont effectuées uniquement lorsque le <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est également `true`.  
  
   
  
## Examples  
 L’exemple de code suivant imprime la valeur de la <xref:System.Net.HttpWebRequest.Pipelined%2A> propriété dans la console.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send an Authorization header with the request.</summary>
        <value>
          <see langword="true" /> Pour envoyer un en-tête d’autorisation HTTP avec les requêtes une fois l’authentification effectuée ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après une demande du client à un spécifique <xref:System.Uri> est correctement authentifié, si <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> est `true` et les informations d’identification sont fournies, l’en-tête Authorization est envoyé avec chaque demande à tout <xref:System.Uri> qui correspond à la spécifique <xref:System.Uri>jusqu'à la dernière barre oblique. Par conséquent, si la demande du client authentifié avec succès à un spécifique <xref:System.Uri> qui contient les éléments suivants :  
  
 `http://www.contoso.com/firstpath/`  
  
 L’en-tête d’autorisation pour la pré-authentification est envoyé avec chaque demande à une des opérations suivantes <xref:System.Uri> instances :  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Toutefois, l’en-tête d’autorisation n’est pas envoyé avec les demandes, à une des opérations suivantes <xref:System.Uri> instances :  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Si la demande du client à un spécifique <xref:System.Uri> est authentifiée, la demande utilise des procédures d’authentification standard.  
  
 À l’exception de la première demande, la <xref:System.Net.WebRequest.PreAuthenticate%2A> propriété indique s’il faut envoyer des informations d’authentification avec les demandes ultérieures à un <xref:System.Uri> qui correspond à la spécifique <xref:System.Uri> jusqu'à la dernière barre oblique sans attendre d’être un défi par le serveur.  
  
 La boîte de dialogue suivante entre client et serveur illustre l’effet de cette propriété. La boîte de dialogue part du principe que l’authentification de base est en cours d’utilisation.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> est `false`:  
  
 Client : Une URL GET  
  
 Serveur : Basic 401 WWW-Authenticate  
  
 Client : GET avec en-têtes d’autorisation  
  
 Serveur : 200 OK  
  
 Client : Une URL GET  
  
 Serveur : Basic 401 WWW-Authenticate  
  
 Client : GET avec en-têtes d’autorisation  
  
 Serveur : 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> est `true`:  
  
 Client : Une URL GET  
  
 Serveur : Basic 401 WWW-Authenticate  
  
 Client : GET avec en-têtes d’autorisation  
  
 Serveur : 200 OK  
  
 Client : GET une URL avec en-têtes d’autorisation  
  
 Si le schéma d’authentification ne prend pas en charge la pré-authentification, la valeur de cette propriété est ignorée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version of HTTP to use for the request.</summary>
        <value>Version HTTP à utiliser pour la requête. La valeur par défaut est <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.HttpWebRequest> classe prend en charge uniquement les versions 1.0 et 1.1 du protocole HTTP. Paramètre <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> vers une autre version lève une exception.  
  
> [!NOTE]
>  Pour définir la version HTTP de la requête actuelle, utilisez la <xref:System.Net.HttpVersion.Version10> et <xref:System.Net.HttpVersion.Version11> champs de la <xref:System.Net.HttpVersion> classe.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The HTTP version is set to a value other than 1.0 or 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets proxy information for the request.</summary>
        <value>Le <see cref="T:System.Net.IWebProxy" /> objet à utiliser pour traiter la demande. La valeur par défaut est définie en appelant le <see cref="P:System.Net.GlobalProxySelection.Select" /> propriété.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété identifie le <xref:System.Net.WebProxy> objet à utiliser pour traiter les demandes aux ressources Internet. Pour spécifier qu’aucun proxy doit être utilisé, définissez la <xref:System.Net.HttpWebRequest.Proxy%2A> propriété pour l’instance de proxy retournée par la <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> (méthode).  
  
 L’ordinateur local ou un fichier de configuration d’application peut spécifier qu’un proxy par défaut est utilisé. Si le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété est spécifiée, les paramètres de proxy à partir de la <xref:System.Net.HttpWebRequest.Proxy%2A> l’ordinateur local ou un fichier de configuration d’application de remplacement de la propriété et la <xref:System.Net.HttpWebRequest> instance utilisera les paramètres de proxy spécifiés. Si aucun proxy n’est spécifié dans un fichier de configuration et la <xref:System.Net.HttpWebRequest.Proxy%2A> propriété n’est pas spécifiée, la <xref:System.Net.HttpWebRequest> classe utilise les paramètres proxy hérités à partir d’Internet Explorer sur l’ordinateur local. S’il n’y a aucun paramètre de proxy dans Internet Explorer, la demande est envoyée directement au serveur.  
  
 La <xref:System.Net.HttpWebRequest> classe analyse une liste de contournement proxy avec des caractères génériques hérités d’Internet Explorer le même que la liste de contournement est analysée directement par Internet Explorer. Par exemple, le <xref:System.Net.HttpWebRequest> classe analyse une liste de « nt * » à partir d’Internet Explorer comme une expression régulière de « nt.\*». Par conséquent, une URL de «`http://nt.com`» le proxy à l’aide de la <xref:System.Net.HttpWebRequest> classe et à l’aide d’Internet Explorer.  
  
 La <xref:System.Net.HttpWebRequest> classe prend en charge le contournement de proxy local. La classe considère qu’une destination est locale si une des conditions suivantes est remplie :  
  
-   La destination contient un nom plat (aucun point dans l’URL).  
  
-   La destination contient une adresse de bouclage (<xref:System.Net.IPAddress.Loopback> ou <xref:System.Net.IPAddress.IPv6Loopback>) ou la destination contient un <xref:System.Net.IPAddress> affecté à l’ordinateur local.  
  
-   Le suffixe de domaine de la destination correspond au suffixe de domaine de l’ordinateur local (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Modification de la <xref:System.Net.HttpWebRequest.Proxy%2A> propriété une fois que la requête a été lancée en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>. Pour plus d’informations sur l’élément proxy, consultez [ \&lt ; defaultProxy\&gt ; Élément (paramètres réseau)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.Proxy%2A> méthode pour obtenir des informations de proxy pour la demande.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> is set to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.WebPermission">Pour obtenir ou définir le <see cref="P:System.Net.HttpWebRequest.Proxy" /> propriété. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a time-out in milliseconds when writing to or reading from a stream.</summary>
        <value>Nombre de millisecondes avant l'expiration de l'écriture ou de la lecture. La valeur par défaut est 300 000 millisecondes (5 minutes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriété est utilisée lors de l’écriture dans le flux retourné par la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode ou la lecture du flux retourné par la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> (méthode).  
  
 Plus précisément, le <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriété contrôle le délai d’attente pour le <xref:System.IO.Stream.Read%2A> (méthode), qui est utilisé pour lire le flux retourné par la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> (méthode) et pour le <xref:System.IO.Stream.Write%2A> (méthode), qui est utilisé pour écrire dans le flux retourné par la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>(méthode).  
  
 Pour spécifier la quantité de temps à attendre avant la fin de demande, utilisez le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment définir la propriété <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has already been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than or equal to zero and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Referer" /> HTTP header.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Referer" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriété `true`, le <xref:System.Net.HttpWebRequest.Referer%2A> propriété est définie automatiquement lors de la requête est redirigée vers un autre site.  
  
 Pour effacer le `Referer` l’en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.Referer%2A> propriété `null`.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Referer%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the original Uniform Resource Identifier (URI) of the request.</summary>
        <value>A <see cref="T:System.Uri" /> qui contient l’URI de la ressource Internet passée à la <see cref="M:System.Net.WebRequest.Create(System.String)" /> (méthode).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri> objet passé à <xref:System.Net.HttpWebRequest> par l’appel à <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Après une redirection en-tête ne modifie pas le <xref:System.Net.HttpWebRequest.RequestUri%2A> propriété. Pour obtenir l’URI qui a répondu à la demande, examinez le <xref:System.Net.HttpWebRequest.Address%2A> propriété.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.HttpWebRequest> objet `req` a été redirigé vers un autre emplacement pour répondre à la demande et définit la valeur de la `hasChanged` variable `true` si la demande a été redirigée ; sinon, `hasChanged` est défini sur `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send data in segments to the Internet resource.</summary>
        <value>
          <see langword="true" /> Pour envoyer des données à la ressource Internet par segments ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Net.HttpWebRequest.SendChunked%2A> est `true`, la demande envoie des données à la ressource Internet par segments. La ressource Internet doit prendre en charge la réception de données mémorisé en bloc.  
  
 Modification de la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété une fois que la requête a été lancée en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true` afin que les données peuvent être envoyées par segments à la ressource Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback function to validate the server certificate.</summary>
        <value>Une fonction de rappel pour valider le certificat de serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut est qu’aucune fonction de rappel n’a la valeur et le <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> propriété est `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service point to use for the request.</summary>
        <value>Un <see cref="T:System.Net.ServicePoint" /> qui représente la connexion réseau à la ressource Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> propriété peut être différente de <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> si la demande est redirigée.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request provides support for a <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> Si la demande prend en charge un <see cref="T:System.Net.CookieContainer" />; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les objets inclus dans le <xref:System.Runtime.Serialization.SerializationInfo> sont automatiquement suivies et sérialisé par le formateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value in milliseconds for the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> and <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> methods.</summary>
        <value>Nombre de millisecondes à attendre avant l'expiration de la demande. La valeur par défaut est 100 000 millisecondes (100 secondes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> est le nombre de millisecondes pendant lequel une demande synchrone suivante lancée avec le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode attend une réponse et le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode attend un flux de données. Le <xref:System.Net.HttpWebRequest.Timeout%2A> s’applique à la totalité de la demande et la réponse, pas individuellement à la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> et <xref:System.Net.HttpWebRequest.GetResponse%2A> les appels de méthode. Si la ressource n’est pas retournée dans le délai d’attente, la demande lève une <xref:System.Net.WebException> avec la <xref:System.Net.WebException.Status%2A> propriété <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété doit être définie avant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode est appelée. Modification de la <xref:System.Net.HttpWebRequest.Timeout%2A> propriété après avoir appelé la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode n’a aucun effet  
  
 Le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété n’a aucun effet sur les requêtes asynchrones avec la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> ou <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode).  
  
> [!CAUTION]
>  Dans le cas de requêtes asynchrones, l’application cliente implémente son propre mécanisme de délai d’attente. Reportez-vous à l’exemple dans le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> (méthode).  
  
 Pour spécifier la quantité de temps à attendre avant une lecture ou écriture opération arrive à expiration, utilisez le <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriété.  
  
 Une requête de nom de domaine (DNS) peut prendre jusqu'à 15 secondes à retourner ou délai d’attente. Si votre requête contient un nom d’hôte exigeant une résolution et que vous définissez <xref:System.Net.FileWebRequest.Timeout%2A> à une valeur inférieure à 15 secondes, il peut prendre 15 secondes ou plus avant un <xref:System.Net.WebException> est renvoyée pour indiquer un délai d’attente de votre demande.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété de la <xref:System.Net.HttpWebRequest> objet.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Transfer-encoding" /> HTTP header.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Transfer-encoding" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant de pouvoir définir le <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété, vous devez d’abord définir le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true`. Effacement <xref:System.Net.HttpWebRequest.TransferEncoding%2A> en lui affectant `null` n’a aucun effet sur la valeur de <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Valeurs assignées à la <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété remplacent le contenu existant.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set when <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to the value "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</summary>
        <value>
          <see langword="true" /> Pour maintenir la connexion pré-authentifiée ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut de cette propriété est `false`, ce qui entraîne la connexion actuelle à fermer après une demande est terminée. Votre application doit passer par la séquence d’authentification chaque fois qu’elle émet une nouvelle demande.  
  
 Si cette propriété est définie sur `true`, la connexion utilisée pour récupérer la réponse reste ouverte après l’exécution de l’authentification. Dans ce cas, les autres requêtes qui ont cette propriété la valeur `true` peuvent utiliser la connexion sans répéter l’authentification. En d’autres termes, si une connexion a été authentifiée pour l’utilisateur A, l’utilisateur B peut utiliser la même connexion ; demande de l’utilisateur B est remplie selon les informations d’identification de l’utilisateur A.  
  
> [!CAUTION]
>  Car il est possible pour une application d’utiliser la connexion sans être authentifiée, vous devez être sûr qu’il n’existe aucune faille administrative dans votre système lors de la définition de cette propriété `true`. Si votre application envoie des demandes de plusieurs utilisateurs (emprunte l’identité de plusieurs comptes d’utilisateur) et s’appuie sur l’authentification de protection des ressources, ne définissez pas cette propriété sur `true` sauf si vous utilisez des groupes de connexion comme décrit ci-dessous.  
  
 Vous souhaiterez peut-être activer ce mécanisme si votre problème de performances et de votre application s’exécute sur un serveur Web avec l’authentification Windows intégrée.  
  
 En activant ce paramètre, le système aux risques de sécurité s’ouvre. Si vous définissez la <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> propriété `true` veillez à prendre les précautions suivantes :  
  
-   Utilisez le <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriété pour gérer les connexions d’utilisateurs différents. Cela évite les possibilités d’utilisation de la connexion par des applications non authentifiées. Par exemple, l’utilisateur A doit avoir un nom de groupe de connexion unique qui est différent de l’utilisateur B. Cela fournit une couche d’isolation pour chaque compte d’utilisateur.  
  
-   Exécutez votre application dans un environnement protégé afin d’éviter les attaques de connexion possibles.  
  
 Si vous contrôlez le serveur principal, en guise d’alternative vous pouvez envisager la désactivation de la persistance de l’authentification. Pour augmenter les performances à un degré moindre, mais il est plus sûr. Pour plus d’informations, recherchez AuthPersistence dans MSDN library à [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Si les deux <xref:System.Net.WebRequest.PreAuthenticate%2A> et <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> ont la valeur `true`, chaque requête est envoyée à l’aide d’une connexion à partir du pool non sécurisé, mais avec un en-tête d’autorisation.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">L’autorisation Web illimitée est requis pour définir cette propriété.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether default credentials are sent with requests.</summary>
        <value>
          <see langword="true" /> si les informations d'identification par défaut sont utilisées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `true` si les demandes effectuées par ce <xref:System.Net.HttpWebRequest> objet doit, si requis par le serveur, être authentifié à l’aide les informations d’identification de l’utilisateur actuellement connecté. Pour les applications clientes, il s’agit du comportement souhaité dans la plupart des scénarios. Pour les applications de couche intermédiaire, telles que les applications ASP.NET, au lieu d’utiliser cette propriété, vous devez généralement définir la <xref:System.Net.HttpWebRequest.Credentials%2A> propriété les informations d’identification du client au nom duquel la demande est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You attempted to set this property after the request was sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="User-agent" /> HTTP header.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="User-agent" />. La valeur par défaut est <see langword="null" />.  
  
 <block subset="none" type="note"><para> La valeur de cette propriété est stockée dans <see cref="T:System.Net.WebHeaderCollection" />. Si WebHeaderCollection est définie, la valeur de propriété est perdue.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.UserAgent%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>