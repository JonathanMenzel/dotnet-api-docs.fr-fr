<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cd879c3587fb39650e94f53cf0d09e12fa723b98" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52741219" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une implémentation propre à HTTP de la classe <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Nous ne vous recommandons d’utiliser `HttpWebRequest` pour tout nouveau développement. Au lieu de cela, utilisez la <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> classe.

 Le <xref:System.Net.HttpWebRequest> classe prend en charge les propriétés et méthodes définies dans <xref:System.Net.WebRequest> et des propriétés supplémentaires et des méthodes qui permettent aux utilisateurs d’interagir directement avec les serveurs à l’aide de HTTP.  
  
 N’utilisez pas le <xref:System.Net.HttpWebRequest.%23ctor%2A> constructeur. Utilisez le <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> méthode pour initialiser de nouveaux <xref:System.Net.HttpWebRequest> objets. Si le schéma pour l’identificateur URI (Uniform Resource) est `http://` ou `https://`, <xref:System.Net.WebRequest.Create%2A> retourne un <xref:System.Net.HttpWebRequest> objet.  
  
 Le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode effectue une demande synchrone auprès de la ressource spécifiée dans le <xref:System.Net.HttpWebRequest.RequestUri%2A> propriété et retourne un <xref:System.Net.HttpWebResponse> qui contient l’objet de réponse. Les données de réponse peuvent être reçues en utilisant le flux retourné par <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Si l’objet de réponse ou le flux de réponse est fermé, données restantes seront perdus. Les données restantes seront s’épuiser et le socket sera utilisé à nouveau pour les demandes suivantes lors de la fermeture de l’objet de réponse ou d’un flux de données si les conditions suivantes sont respectées : il s’agit d’une demande keep-alive ou canalisée en rafale, uniquement une petite quantité de données doit être reçu, ou données restantes est reçu dans un petit intervalle de temps. Si aucune des conditions mentionnées maintenez ou la durée de drainage est dépassée, le socket est fermé. Pour les connexions keep-alive ou canalisée en rafale, nous recommandons que l’application lit les flux de données jusqu'à ce que EOF. Cela garantit que le socket sera utilisé à nouveau pour les demandes suivantes, ce qui entraîne de meilleures performances et moins de ressources utilisées.  
  
 Lorsque vous souhaitez envoyer des données à la ressource, le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode retourne un <xref:System.IO.Stream> objet à utiliser pour envoyer des données. Le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> et <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthodes fournissent un accès asynchrone au flux de données d’envoi.  
  
 Pour l’authentification du client avec <xref:System.Net.HttpWebRequest>, le certificat client doit être installé dans le répertoire Mon magasin de certificats de l’utilisateur actuel.  
  
 Le <xref:System.Net.HttpWebRequest> classe lève un <xref:System.Net.WebException> lorsque des erreurs se produisent pendant l’accès à une ressource. Le <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> propriété contient un <xref:System.Net.WebExceptionStatus> valeur qui indique la source de l’erreur. Lorsque <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> est <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, le <xref:System.Net.WebException.Response%2A> propriété contient le <xref:System.Net.HttpWebResponse> reçues de la ressource.  
  
 <xref:System.Net.HttpWebRequest> expose des valeurs d’en-tête HTTP courantes envoyées à la ressource Internet en tant que propriétés, définies par des méthodes ou par le système. le tableau suivant contient une liste complète. Vous pouvez définir d’autres en-têtes le <xref:System.Net.HttpWebRequest.Headers%2A> propriété en tant que paires nom/valeur. Notez que les serveurs et les caches peuvent modifier ou ajouter des en-têtes pendant la requête.  
  
 Le tableau suivant répertorie les en-têtes HTTP qui sont définies par les méthodes ou propriétés ou le système.  
  
|Header|Défini par|  
|------------|------------|  
|Accepter|Défini par le <xref:System.Net.HttpWebRequest.Accept%2A> propriété.|  
|Connexion|Défini par le <xref:System.Net.HttpWebRequest.Connection%2A> propriété, <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété.|  
|Content-Length|Défini par le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété.|  
|Content-Type|Défini par le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété.|  
|Attendre|Défini par le <xref:System.Net.HttpWebRequest.Expect%2A> propriété.|  
|Date|Défini par le système à la date actuelle.|  
|Hôte|Défini par le système pour des informations sur l’hôte actuel.|  
|If-Modified-Since|Défini par le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété.|  
|Plage|Défini par le <xref:System.Net.HttpWebRequest.AddRange%2A> (méthode).|  
|Référant|Défini par le <xref:System.Net.HttpWebRequest.Referer%2A> propriété.|  
|Codage de transfert|Défini par le <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété (la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété doit être `true`).|  
|User-Agent|Défini par le <xref:System.Net.HttpWebRequest.UserAgent%2A> propriété.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> est inscrit automatiquement. Vous n’avez pas besoin d’appeler le <xref:System.Net.WebRequest.RegisterPrefix%2A> méthode enregistriez <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> avant d’utiliser des URI commençant par `http://` ou `https://`.  
  
 L’ordinateur local ou un fichier de configuration d’application peut spécifier qu’un proxy par défaut est utilisé. Si le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété est spécifiée, les paramètres de proxy à partir de la <xref:System.Net.HttpWebRequest.Proxy%2A> l’ordinateur local ou un fichier de configuration d’application de remplacement de la propriété et la <xref:System.Net.HttpWebRequest> instance utilisera les paramètres de proxy spécifiés. Si aucun proxy n’est spécifié dans un fichier de configuration et le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété n’est pas spécifiée, la <xref:System.Net.HttpWebRequest> classe utilise les paramètres proxy hérités à partir d’Internet Explorer sur l’ordinateur local. S’il n’y a aucun paramètre de proxy dans Internet Explorer, la demande est envoyée directement au serveur.  
  
 Le <xref:System.Net.HttpWebRequest> classe analyse une liste de contournement proxy avec des caractères génériques hérités à partir d’Internet Explorer de manière différente que la liste de contournement est analysée directement par Internet Explorer. Par exemple, le <xref:System.Net.HttpWebRequest> classe analyse une liste de contournement de « nt * » à partir d’Internet Explorer comme une expression régulière de « nt. $». Cela diffère du comportement natif d’Internet Explorer. Par conséquent, une URL de «`http://intxxxxx`» le proxy à l’aide de la <xref:System.Net.HttpWebRequest> classe, mais pas le proxy à l’aide d’Internet Explorer.  
  
> [!NOTE]
>  Le Framework met en cache les sessions SSL lors de leur création et tente de réutiliser une session de mise en cache pour une nouvelle demande, si possible. Lorsque vous tentez de réutiliser une session SSL, le Framework utilise le premier élément du <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (s’il en existe un), ou tente de réutiliser une session anonyme si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> est vide.  
  
> [!NOTE]
>  Pour des raisons de sécurité, les cookies sont désactivés par défaut. Si vous souhaitez utiliser des cookies, utilisez le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété pour activer les cookies.  
  
 Le .NET Framework 4.6 inclut une nouvelle fonctionnalité de sécurité qui bloque les algorithmes pour les connexions de hachage et de chiffrement non sécurisé. Applications à l’aide de TLS/SSL via des API telles que HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. et ciblant .NET Framework 4.6 Obtient le comportement plus sécurisés par défaut.  
  
 Les développeurs veulent peuvent désactiver ce comportement afin de maintenir l’interopérabilité avec leurs services SSL3 existants ou TLS avec les services de RC4. [Cet article](https://support.microsoft.com/kb/3069494) explique comment modifier votre code afin que le nouveau comportement est désactivé.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.HttpWebRequest> pour l’URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Pour accéder à l’URI demandé ou n’importe quel URI de la requête est redirigée vers. Énumération associée : <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Modifications apportées à l’authentification NTLM pour HTTPWebRequest dans la Version 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.HttpWebRequest" />. Ces constructeurs sont obsolètes. Pour plus d’informations, consultez la section Remarques.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Les deux <xref:System.Net.HttpWebRequest> constructeurs sont obsolètes et ne doit pas être utilisés. Appelez le <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> méthode pour initialiser de nouveaux <xref:System.Net.HttpWebRequest> objets.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.HttpWebRequest" />. Ce constructeur est obsolète.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les informations requises pour sérialiser le nouvel objet <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient la source et la destination du flux sérialisé associé au nouvel objet <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.HttpWebRequest" /> à partir des instances spécifiées des classes <see cref="T:System.Runtime.Serialization.SerializationInfo" /> et <see cref="T:System.Runtime.Serialization.StreamingContext" />. Ce constructeur est obsolète.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application doit s’exécuter en mode confiance totale lors de l’utilisation de sérialisation.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">pour un accès illimité aux ressources réseau. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Sérialisation XML et SOAP</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule une requête adressée à une ressource Internet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Abort%2A> méthode annule une demande à une ressource. Après une demande est annulée, l’appel la <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, ou <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode entraîne un <xref:System.Net.WebException> avec la <xref:System.Net.WebException.Status%2A> propriété définie sur <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Le <xref:System.Net.HttpWebRequest.Abort%2A> méthode exécutera de façon synchrone le rappel spécifié pour le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthodes si le <xref:System.Net.HttpWebRequest.Abort%2A> méthode est appelée alors qu’une de ces opérations sont en attente. Cela peut entraîner des problèmes de blocage potentielle.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Dans le cas des requêtes asynchrones, il est la responsabilité de l’application cliente pour implémenter son propre mécanisme de délai d’attente. L’exemple de code suivant montre comment effectuer cette opération.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="Accept" />.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Accept" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour effacer le `Accept` en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.Accept%2A> propriété `null`.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Accept%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un en-tête de plage à la requête.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Point de départ ou de fin de la plage.</param>
        <summary>Ajoute un en-tête de plage d'octets à une requête d'une plage spécifique à partir du début ou de la fin des données demandées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Si `range` est positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui demande au serveur d’envoyer les 100 premiers octets (à partir du début à la position d’octet 99) est la suivante :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
   
  
## Examples  
 L’exemple de code suivant ajoute un en-tête de plage à la demande.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Point de départ ou de fin de la plage.</param>
        <summary>Ajoute un en-tête de plage d'octets à une requête d'une plage spécifique à partir du début ou de la fin des données demandées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Si `range` est positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui demande au serveur d’envoyer les 100 premiers octets (à partir du début à la position d’octet 99) est la suivante :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Position à laquelle démarrer l'envoi de données.</param>
        <param name="to">Position à laquelle arrêter l'envoi de données.</param>
        <summary>Ajoute un en-tête de plage d'octets à la requête d'une plage spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui seraient des demandes, les 100 premiers octets serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `from` paramètre serait spécifié en tant que 0 et le `to` paramètre serait spécifié comme 99. Le spécificateur de plage est automatiquement défini comme « octets » par cette méthode.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
   
  
## Examples  
 L’exemple de code suivant ajoute un en-tête de plage à la demande.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> est supérieur à <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> est inférieur à 0.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Position à laquelle démarrer l'envoi de données.</param>
        <param name="to">Position à laquelle arrêter l'envoi de données.</param>
        <summary>Ajoute un en-tête de plage d'octets à la requête d'une plage spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage d’octets à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui seraient des demandes, les 100 premiers octets serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `from` paramètre serait spécifié en tant que 0 et le `to` paramètre serait spécifié comme 99. Le spécificateur de plage est automatiquement défini comme « octets » par cette méthode.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> est supérieur à <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> est inférieur à 0.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Description de la plage.</param>
        <param name="range">Point de départ ou de fin de la plage.</param>
        <summary>Ajoute un en-tête de plage à une requête pour une plage spécifique à partir du début ou de la fin des données demandées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Si `range` est positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », puisqu’il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plages personnalisées autres que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui seraient des demandes, les 100 premiers octets serait le suivant :  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié en tant que « octets » et le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Description de la plage.</param>
        <param name="range">Point de départ ou de fin de la plage.</param>
        <summary>Ajoute un en-tête de plage à une requête pour une plage spécifique à partir du début ou de la fin des données demandées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Si `range` est positif, le `range` paramètre spécifie le point de départ de la plage. Le serveur doit commencer à envoyer des données à partir de la `range` paramètre spécifié à la fin des données dans l’entité HTTP.  
  
 Si `range` est négatif, le `range` paramètre spécifie le point de fin de la plage. Le serveur doit commencer à envoyer des données à partir du début des données dans l’entité HTTP à le `range` paramètre spécifié.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », puisqu’il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plages personnalisées autres que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui seraient des demandes, les 100 premiers octets serait le suivant :  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié en tant que « octets » et le `range` paramètre serait -99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Description de la plage.</param>
        <param name="from">Position à laquelle démarrer l'envoi de données.</param>
        <param name="to">Position à laquelle arrêter l'envoi de données.</param>
        <summary>Ajoute un en-tête de plage à une requête d'une plage spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », puisqu’il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plages personnalisées autres que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui seraient des demandes, les 100 premiers octets serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié en tant que « octets », le `from` paramètre serait 0 et le `to` paramètre serait 99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La chaîne spécifiée dans l’en-tête Accept-Ranges est le spécificateur de plages qui serait spécifié dans le `rangeSpecifier` paramètre pour cette méthode.  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> est supérieur à <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Description de la plage.</param>
        <param name="from">Position à laquelle démarrer l'envoi de données.</param>
        <param name="to">Position à laquelle arrêter l'envoi de données.</param>
        <summary>Ajoute un en-tête de plage à une requête d'une plage spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> méthode ajoute un en-tête de plage à la demande.  
  
 Étant donné que toutes les entités HTTP sont représentées dans les messages HTTP en tant que séquence d’octets, le concept d’une plage d’octets est significatif pour une entité HTTP. Toutefois, pas tous les clients et serveurs doivent prendre en charge les opérations de plage d’octets.  
  
 L’en-tête de plage sur une requête permet à un client demander qu’il ne souhaite recevoir une partie de la plage d’octets spécifiée dans une entité HTTP. Serveurs ne sont pas requis pour prendre en charge les demandes d’en-tête Range.  
  
 Le `rangeSpecifier` paramètre est normalement spécifié en tant que « octets », puisqu’il s’agit du seul spécificateur de plage reconnu par la plupart des serveurs HTTP. Définition de la `rangeSpecifier` paramètre d’une autre chaîne permet la prise en charge de spécificateurs de plages personnalisées autres que les octets (le spécificateur de plage d’octets défini dans RFC 2616 par l’IETF).  
  
 Un exemple d’un en-tête de plage dans une requête de protocole HTTP qui seraient des demandes, les 100 premiers octets serait le suivant :  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Pour cet exemple, le `rangeSpecifier` paramètre serait spécifié en tant que « octets », le `from` paramètre serait 0 et le `to` paramètre serait 99.  
  
 Un serveur HTTP indique la prise en charge des en-têtes Range avec l’en-tête Accept-Ranges dans la réponse. Un exemple d’en-tête Accept-Ranges d’un serveur qui prend en charge les plages d’octets se présente comme suit :  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La chaîne spécifiée dans l’en-tête Accept-Ranges est le spécificateur de plages qui serait spécifié dans le `rangeSpecifier` paramètre pour cette méthode.  
  
 Si un en-tête Accept-Ranges n’est pas reçu dans l’en-tête de la réponse à partir du serveur, le serveur ne prend pas en charge les en-têtes de la plage. Un exemple d’en-tête Accept-Ranges d’un serveur qui ne prend pas en charge les plages, mais reconnaît l’en-tête Accept-Ranges, se présente comme suit :  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Lors de la réception de la réponse à partir d’une demande de plage, seuls les en-têtes HTTP associés à l’ensemble de la demande sont analysés et rendus disponibles via des propriétés sur la <xref:System.Net.HttpWebResponse> classe. En-têtes associés à chaque plage sont retournés dans la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> est supérieur à <paramref name="to" />  
  
- ou - 
 <paramref name="from" /> ou <paramref name="to" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible d’ajouter l’en-tête de plage.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URI (Uniform Resource Identifier) de la ressource Internet qui répond réellement à la requête.</summary>
        <value>
          <see cref="T:System.Uri" /> identifiant la ressource Internet qui répond réellement à la requête. La valeur par défaut est l’URI utilisé par la méthode <see cref="M:System.Net.WebRequest.Create(System.String)" /> pour initialiser la requête.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Address%2A> propriété est définie sur l’URI une fois que toutes les redirections qui se produisent pendant la demande sont terminées.  
  
 L’URI de la demande d’origine est conservé le <xref:System.Net.HttpWebRequest.RequestUri%2A> propriété.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.HttpWebRequest> objet `req` a été redirigé vers un autre emplacement pour répondre à la demande et définit la valeur de la `hasChanged` à la variable `true` si la demande a été redirigée ; sinon `hasChanged`est défini sur `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la requête doit suivre les réponses de redirection.</summary>
        <value>
          <see langword="true" /> si la requête doit suivre automatiquement les réponses de redirection provenant de la ressource Internet ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> à `true` si vous souhaitez que la demande de suivre automatiquement les en-têtes de redirection HTTP vers le nouvel emplacement de la ressource. Le nombre maximal de redirections à suivre est défini le <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriété.  
  
 Si <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> a la valeur `false`, toutes les réponses avec un code d’état HTTP 300 et 399 est retourné à l’application.  
  
 L’en-tête d’autorisation est désactivée lors de redirections automatiques et <xref:System.Net.HttpWebRequest> tente automatiquement de s’authentifier de nouveau à l’emplacement redirigé. Dans la pratique, cela signifie qu’une application ne peut pas placer les informations de l’authentification personnalisée dans l’en-tête d’autorisation s’il est possible de rencontrer la redirection. Au lieu de cela, l’application doit implémenter et inscrire un module d’authentification personnalisé. Le <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> et de la classe connexe sont utilisées pour implémenter un module d’authentification personnalisé. Le <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> méthode inscrit un module d’authentification personnalisé.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriété pour autoriser la demande de suivre les réponses de redirection.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les données reçues à partir de la ressource Internet doivent être mises en mémoire tampon.</summary>
        <value>
          <see langword="true" /> pour activer la mise en mémoire tampon des données reçues de la ressource Internet ; <see langword="false" /> pour désactiver la mise en mémoire tampon. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les données envoyées à la ressource Internet doivent être mises en mémoire tampon.</summary>
        <value>
          <see langword="true" /> pour activer la mise en mémoire tampon des données envoyées à la ressource Internet ; <see langword="false" /> pour désactiver la mise en mémoire tampon. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> est `true`, les données sont mis en mémoire tampon, prêt à être renvoyées en cas de redirections ou l’authentification des demandes.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> propriété permettant de désactiver la mise en mémoire tampon de données.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Paramètre <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> à <see langword="true" /> peut entraîner des problèmes de performances lors du chargement de jeux de données volumineux, car la mémoire tampon de données peut utiliser toute la mémoire disponible.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de décompression utilisé.</summary>
        <value>Un <see cref="T:System.Net.DecompressionMethods" /> objet qui indique le type de décompression utilisé.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L’état actuel de l’objet ne permet pas de définir cette propriété.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objet d'état de cette requête.</param>
        <summary>Démarre une requête asynchrone pour un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire des données.</summary>
        <returns>Élément <see cref="T:System.IAsyncResult" /> qui référence la demande asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> méthode démarre une demande asynchrone d’un flux utilisé pour envoyer des données pour le <xref:System.Net.HttpWebRequest>. La méthode de rappel asynchrone utilise les <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode pour retourner le flux réel.  
  
 Le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> méthode requiert certaines tâches de synchrone d’installation pour terminer (résolution DNS, la détection de proxy et connexion de socket TCP, par exemple) avant que cette méthode ne soit asynchrone. Par conséquent, cette méthode doit jamais être appelée sur un thread d’interface (UI) utilisateur, car il peut prendre beaucoup de temps (jusqu'à plusieurs minutes en fonction des paramètres de réseau) pour effectuer les tâches de configuration synchrone initiale avant une exception pour une erreur est générée ou la méthode réussit.  
  
 Pour en savoir plus sur le pool de threads, consultez [le pool de threads managés](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une requête particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> méthode pour effectuer une demande asynchrone d’une instance de flux.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">La propriété <see cref="P:System.Net.HttpWebRequest.Method" /> est GET ou HEAD.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> est <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> est <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> a la valeur -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> est <see langword="false" />, et <see cref="P:System.Net.HttpWebRequest.Method" /> est POST ou PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par un appel précédent à <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> est défini sur une valeur, et <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a pour valeur <see langword="false" />.  
  
- ou - 
Le nombre de threads du pool de threads est insuffisant.</exception>
        <exception cref="T:System.NotSupportedException">Le validateur du cache de demande a indiqué que la réponse à cette demande peut être obtenue à partir du cache. Toutefois, les demandes qui écrivent des données ne doivent pas utiliser le cache. Cette exception peut se produire si vous utilisez un validateur de cache personnalisé qui est implémenté de manière incorrecte.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.</exception>
        <exception cref="T:System.ObjectDisposedException">Dans une application .NET Compact Framework, un flux de requête avec une longueur de contenu nulle n’a pas été obtenu et s’est fermé correctement. Pour plus d’informations sur la gestion des requêtes avec une longueur de contenu nulle, consultez [Programmation réseau dans le .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /></param>
        <param name="state">Objet d'état de cette requête.</param>
        <summary>Démarre une requête asynchrone adressée à une ressource Internet.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à la requête asynchrone d’une réponse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode démarre une demande asynchrone d’une réponse de la ressource Internet. La méthode de rappel asynchrone utilise les <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthode pour retourner le texte réel <xref:System.Net.WebResponse>.  
  
 Un <xref:System.Net.ProtocolViolationException> est levée dans plusieurs cas lorsque les propriétés définies sur la <xref:System.Net.HttpWebRequest> classe sont en conflit. Cette exception se produit si une application définit le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété et la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true`, puis envoie une requête HTTP GET. Cette exception se produit si une application tente d’envoyer mémorisé en bloc à un serveur qui prend uniquement en charge le protocole HTTP 1.0, où ce n’est pas possible. Cette exception se produit si une application tente d’envoyer des données sans paramètre la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété ou le <xref:System.Net.HttpWebRequest.SendChunked%2A> est `false` lors de la mise en mémoire tampon est désactivée et sur une connexion keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`)`.`  
  
 Si un <xref:System.Net.WebException> est levée, utilisez la <xref:System.Net.WebException.Response%2A> et <xref:System.Net.WebException.Status%2A> propriétés de l’exception pour déterminer la réponse à partir du serveur.  
  
 Le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode requiert certaines tâches de synchrone d’installation pour terminer (résolution DNS, la détection de proxy et connexion de socket TCP, par exemple) avant que cette méthode ne soit asynchrone. Par conséquent, cette méthode doit jamais être appelée sur un thread d’interface (UI) utilisateur, car il peut prendre beaucoup de temps (jusqu'à plusieurs minutes en fonction des paramètres de réseau) pour effectuer les tâches de configuration synchrone initiale avant une exception pour une erreur est générée ou la méthode réussit.  
  
 Pour en savoir plus sur le pool de threads, consultez [le pool de threads managés](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une requête particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [ &#91; \<topic://conUsingNetworkTracing >&#93;](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode pour effectuer une demande asynchrone d’une ressource Internet.  
  
> [!NOTE]
>  Dans le cas des requêtes asynchrones, il est la responsabilité de l’application cliente pour implémenter son propre mécanisme de délai d’attente. L’exemple de code suivant montre comment procéder.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux est déjà utilisé par un appel précédent à <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> est défini sur une valeur, et <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a pour valeur <see langword="false" />.  
  
- ou - 
Le nombre de threads du pool de threads est insuffisant.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> a pour valeur GET ou HEAD, et <see cref="P:System.Net.HttpWebRequest.ContentLength" /> est supérieur à zéro ou <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a pour valeur <see langword="true" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> a la valeur <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a la valeur <see langword="false" />, et <see cref="P:System.Net.HttpWebRequest.ContentLength" /> a la valeur -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a la valeur <see langword="false" /> et <see cref="P:System.Net.HttpWebRequest.Method" /> a la valeur POST ou PUT.  
  
- ou - 
La <see cref="T:System.Net.HttpWebRequest" /> a un corps d’entité, mais la méthode <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> est appelée sans que soit appelée la méthode <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
- ou - 
La <see cref="P:System.Net.HttpWebRequest.ContentLength" /> est supérieure à zéro, mais l’application n’écrit pas toutes les données promises.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la collection de certificats de sécurité qui sont associés à cette requête.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats de sécurité associés à cette requête.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application peut ajouter un certificat à une collection, mais peut-être pas des droits d’accès. Pour utiliser un certificat contenu dans la collection, l’application doit avoir les mêmes droits d’accès que l’entité qui a émis le certificat.  
  
> [!NOTE]
>  Le Framework met en cache les sessions SSL lors de leur création et tente de réutiliser une session de mise en cache pour une nouvelle demande, si possible. Lorsque vous tentez de réutiliser une session SSL, le Framework utilise le premier élément du <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (s’il en existe un), ou tente de réutiliser une session anonyme si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> est vide.  
  
> [!NOTE]
>  Pour des raisons de performances, vous ne devez pas ajouter un certificat client pour un <xref:System.Net.HttpWebRequest> sauf si vous savez que le serveur vous demandera.  
>   
>  Pour obtenir un exemple de code illustrant comment énumérer les certificats dans le magasin de certificats client, consultez la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur spécifiée pour une opération set est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="Connection" />.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Connection" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La requête envoie le <xref:System.Net.HttpWebRequest.Connection%2A> à la ressource Internet en tant que propriété le `Connection` en-tête HTTP. Si la valeur de la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`, la valeur « Keep-alive » est ajoutée à la fin de la `Connection` en-tête.  
  
 Pour effacer le `Connection` en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.Connection%2A> propriété `null`.  
  
 Modification de la <xref:System.Net.HttpWebRequest.Connection%2A> propriété une fois que la demande a été lancée en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.Connection%2A> propriété pour définir la valeur de l’en-tête HTTP de connexion.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de <see cref="P:System.Net.HttpWebRequest.Connection" /> est Keep-alive ou Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du groupe de connexions pour la requête.</summary>
        <value>Nom du groupe de connexions pour cette requête. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriété vous permet d’associer une requête avec un groupe de connexions. Cela est utile lorsque votre application effectue des demandes à un seul serveur pour différents utilisateurs, tel qu’un site Web qui Récupère des informations client à partir d’un serveur de base de données.  
  
   
  
## Examples  
 L’exemple de code suivants montrent comment utiliser les informations utilisateur pour former un groupe de connexions, en supposant que les variables `username`, `password`, et `domain` sont définies par l’application avant l’appel de ce code.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chaque groupe de connexions crée des connexions supplémentaires pour un serveur. Cela peut entraîner de dépassement du nombre de connexions défini par le <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> propriété pour ce serveur.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Regroupement de connexions</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’en-tête HTTP <see langword="Content-length" />.</summary>
        <value>Nombre d'octets de données à envoyer à la ressource Internet. La valeur par défaut est -1, ce qui indique que la propriété n'a pas été définie et qu'aucune donnée de la requête ne doit être envoyée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété contient la valeur à envoyer en tant que le `Content-length` en-tête HTTP avec la demande.  
  
 Toute valeur autre que -1 dans le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété indique que la demande transfère des données et que seules les méthodes qui transfèrent des données sont autorisés à être définies dans le <xref:System.Net.HttpWebRequest.Method%2A> propriété.  
  
 Après le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété est définie sur une valeur, ce nombre d’octets doit être écrit dans le flux de demande qui est retourné en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode ou les deux le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> et <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthodes.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété à la longueur de la chaîne en cours de publication.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La requête a été lancée en appelant la méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La nouvelle valeur de <see cref="P:System.Net.HttpWebRequest.ContentLength" /> est inférieure à 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="Content-type" />.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Content-type" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété contient le type de média de la demande. Valeurs affectées à la <xref:System.Net.HttpWebRequest.ContentType%2A> propriété remplacent le contenu existant lorsque la requête envoie le `Content-type` en-tête HTTP.  
  
 Pour effacer le `Content-type` en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.ContentType%2A> propriété `null`.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection> . Si <xref:System.Net.WebHeaderCollection> est défini, la valeur de propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la méthode du délégué qui est appelée lors de la réception d'une réponse HTTP 100-Continue de la ressource Internet.</summary>
        <value>Un délégué implémentant la méthode de rappel qui s'exécute lorsqu'une réponse HTTP Continue est retournée par la ressource Internet. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propriété spécifie la méthode de rappel à appeler lorsque le client reçoit un 100-Continue de réponse.  
  
 Lorsque le <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> est définie, le client appelle le délégué chaque fois que les réponses de type de protocole <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) sont reçus. Cela est utile si vous souhaitez que le client pour afficher l’état des données reçues à partir de la ressource Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un délai d’attente, en millisecondes, jusqu’à réception de la réponse 100-Continue depuis le serveur.</summary>
        <value>Délai d’attente, en millisecondes, jusqu’à réception de la réponse 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les 100-Continue la réponse est reçue avant l’expiration du délai, le corps d’entité peuvent être envoyé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les cookies associés à la requête.</summary>
        <value>
          <see cref="T:System.Net.CookieContainer" /> contenant les cookies associés à cette requête.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété fournit une instance de la <xref:System.Net.CookieContainer> classe qui contient les cookies associés à cette demande.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> est `null` par défaut. Vous devez affecter un <xref:System.Net.CookieContainer> objet à la propriété pour que les cookies retournés dans le <xref:System.Net.HttpWebResponse.Cookies%2A> propriété de la <xref:System.Net.HttpWebResponse> retourné par le <xref:System.Net.HttpWebRequest.GetResponse%2A> (méthode).  
  
> [!NOTE]
>  Pour des raisons de sécurité, les cookies sont désactivés par défaut. Si vous souhaitez utiliser des cookies, utilisez le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété pour activer les cookies.  
  
   
  
## Examples  
 L’exemple de code suivant envoie une demande à une URL et affiche les cookies retournés dans la réponse.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations d'authentification pour la requête.</summary>
        <value>
          <see cref="T:System.Net.ICredentials" /> qui contient les informations d’authentification associées à la requête. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Credentials%2A> propriété contient des informations d’authentification pour identifier le créateur de la demande. Le <xref:System.Net.HttpWebRequest.Credentials%2A> propriété peut être un <xref:System.Net.NetworkCredential>, auquel cas l’utilisateur, mot de passe, et les informations de domaine contenues dans le <xref:System.Net.NetworkCredential> objet est utilisé pour authentifier la demande, ou il peut être un <xref:System.Net.CredentialCache>, auquel cas l’Uniform Resource Identificateur (URI) de la demande est utilisé pour déterminer l’utilisateur, mot de passe et les informations de domaine à utiliser pour authentifier la demande.  
  
 Dans la plupart des scénarios clients, vous devez utiliser le <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriété, qui contient les informations d’identification de l’utilisateur actuellement connecté. Pour ce faire, définissez la <xref:System.Net.WebClient.UseDefaultCredentials%2A> propriété `true` au lieu de définir cette propriété.  
  
 Si le <xref:System.Net.HttpWebRequest> classe est utilisée dans une application de couche intermédiaire, comme une application ASP.NET, les informations d’identification dans le <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriété appartenir au compte d’exécution de la page ASP (les informations d’identification côté serveur). En règle générale, vous devez définir cette propriété pour les informations d’identification du client au nom duquel la demande est effectuée.  
  
> [!NOTE]
>  Le schéma d’authentification NTLM ne peut pas être utilisé pour emprunter l’identité d’un autre utilisateur. Kerberos doit être configuré spécialement pour prendre en charge l’emprunt d’identité.  
  
 Pour limiter HttpWebRequest à une ou plusieurs méthodes d’authentification, utilisez la <xref:System.Net.CredentialCache> classe et de lier vos informations d’identification à un ou plusieurs schémas d’authentification  
  
 Schémas d’authentification pris en charge incluent Digest, Negotiate, Kerberos, NTLM et Basic.  
  
 Pour des raisons de sécurité, si l'on suit automatiquement les redirections, stocker les informations d’identification que vous souhaitez inclure dans la redirection dans un <xref:System.Net.CredentialCache> et l’affecter à cette propriété. Cette propriété définira automatiquement `null` lors de la redirection si elle contient une valeur autre qu’un <xref:System.Net.CredentialCache>. Avoir cette valeur de propriété automatiquement la valeur `null` dans ces conditions empêche les informations d’identification d’être envoyé à n’importe quelle destination involontaire.
  
## Examples  
 L’exemple de code suivant définit les informations d’identification pour une demande.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur d’en-tête HTTP <see langword="Date" /> à utiliser dans une requête HTTP.</summary>
        <value>Valeur d'en-tête Date dans la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’en-tête de Date est `null`, puis la valeur de retour est fixée <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Le <xref:System.Net.HttpWebRequest.Date%2A> propriété est une norme <xref:System.DateTime?displayProperty=nameWithType> de l’objet et peut contenir un <xref:System.DateTimeKind?displayProperty=nameWithType> champ <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Tout type d’heure peut être définie lors de l’utilisation du <xref:System.Net.HttpWebRequest.Date%2A> propriété. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> est définie ou récupérée, la <xref:System.Net.HttpWebRequest.Date%2A> propriété est censée pour être <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (heure locale).  
  
 Les classes dans le <xref:System.Net> espace de noms écrivent toujours le <xref:System.Net.HttpWebRequest.Date%2A> propriété sur le câble pendant la transmission au format standard à l’aide du format GMT (Utc).  
  
 Si le <xref:System.Net.HttpWebRequest.Date%2A> propriété est définie sur <xref:System.DateTime.MinValue?displayProperty=nameWithType>, puis le `Date` en-tête HTTP est supprimé de la <xref:System.Net.HttpWebRequest.Headers%2A> propriété et le <xref:System.Net.WebHeaderCollection>.  
  
 Si le <xref:System.Net.HttpWebRequest.Date%2A> propriété est <xref:System.DateTime.MinValue?displayProperty=nameWithType>, cela indique que le `Date` en-tête HTTP n’est pas inclus dans le <xref:System.Net.HttpWebRequest.Headers%2A> propriété et le <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
 Si le <xref:System.Net.HttpWebRequest.Date%2A> est définie et une tentative est effectuée pour envoyer un <xref:System.Net.HttpWebRequest> sans corps, puis un <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> seront levées par le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, et <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthodes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la stratégie de cache par défaut de cette requête.</summary>
        <value>Élément <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> spécifiant la stratégie de cache en vigueur pour cette demande quand aucune autre stratégie n'est applicable.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de cette propriété enregistre la stratégie spécifiée pour les schémas HTTP et HTTPS. Cette stratégie est utilisée pour cette demande si :  
  
 Il existe aucune <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> propriété spécifiée pour cette demande.  
  
 \- ou -  
  
 La configuration de l’ordinateur et application fichiers ne spécifient pas une stratégie de cache qui n’est applicable à l’identificateur URI (Uniform Resource) utilisé pour créer cette demande.  
  
 La stratégie de cache détermine si la ressource demandée peut être extraite d’un cache au lieu d’envoyer la demande à l’ordinateur hôte de ressources.  
  
 Une copie d’une ressource est ajoutée uniquement au cache si le flux de réponse pour la ressource est récupéré et que vous lire jusqu'à la fin du flux. Une autre demande pour la même ressource pourrait utiliser une copie mise en cache, en fonction du niveau de stratégie de cache pour cette demande.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">pour un accès illimité aux ressources réseau. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la longueur maximale par défaut d'une réponse d'erreur HTTP.</summary>
        <value>Longueur maximale par défaut d'une réponse d'erreur HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est inférieure à 0 et n’est pas égale à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur par défaut de la propriété <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />.</summary>
        <value>Longueur, en kilo-octets (1 024 octets), de la valeur maximum par défaut pour les en-têtes de réponse reçus. Le fichier de configuration par défaut fixe cette valeur à 64 kilo-octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur de l’en-tête de réponse reçu la ligne d’état de réponse et tous les caractères de contrôle supplémentaires qui sont reçus dans le cadre du protocole HTTP. Une valeur-1 signifie qu'aucune limite sur les en-têtes de réponse reçus ; une valeur de 0 signifie que toutes les demandes échouent.  
  
 Cette valeur peut également être modifiée dans le fichier de configuration. L’impact de cette propriété peut être substituée en définissant le <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriété sur une instance de la <xref:System.Net.HttpWebRequest> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur n’est pas égale à -1 et est inférieure à zéro.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termine une requête asynchrone d’un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire des données.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Requête d'un flux en attente.</param>
        <summary>Termine une requête asynchrone d’un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire des données.</summary>
        <returns>
          <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode effectue une demande asynchrone d’un flux qui a été démarrée par le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode). Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  Vous devez définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété avant d’écrire des données dans le flux.  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion pour une réutilisation. Si échoue pour fermer le flux, votre application s’exécute en dehors de connexions.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode à la fin d’une demande asynchrone d’une instance de flux.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">La requête ne s’est pas terminée et aucun flux n’est disponible.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> n’a pas été retourné par l’instance actuelle à partir d’un appel à <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette méthode a déjà été appelée avec <paramref name="asyncResult" /></exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.  
  
- ou - 
Une erreur s’est produite pendant le traitement de la demande.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Requête d'un flux en attente.</param>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> pour <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">
          <see cref="T:System.Net.TransportContext" /> pour <see cref="T:System.IO.Stream" />.</param>
        <summary>Termine une requête asynchrone pour un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données et crée une sortie du <see cref="T:System.Net.TransportContext" /> associé au flux.</summary>
        <returns>
          <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> méthode effectue une demande asynchrone d’un flux qui a été démarrée par le <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode) et les sorties du <xref:System.Net.TransportContext> associé au flux. Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
 Certaines applications qui utilisent l’authentification Windows intégrée avec protection étendue peuvent nécessiter être en mesure d’interroger la couche de transport utilisée par <xref:System.Net.HttpWebRequest> afin de récupérer le jeton de liaison de canal (FAO) du canal de TLS sous-jacent. Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode permet d’accéder à ces informations pour les méthodes HTTP qui ont un corps de demande (`POST` et `PUT` demandes). Cela est uniquement nécessaire si l’application implémente sa propre authentification et a besoin d’accéder au canal.  
  
> [!NOTE]
>  Si une application doit définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété, puis il doit être effectuée avant d’extraire le flux de données et écrire des données.  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion pour une réutilisation. Si échoue pour fermer le flux, votre application s’exécute en dehors de connexions.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> n’a pas été retourné par l’instance actuelle à partir d’un appel à <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette méthode a déjà été appelée avec <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">La requête ne s’est pas terminée et aucun flux n’est disponible.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.  
  
- ou - 
Une erreur s’est produite pendant le traitement de la demande.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Requête d'une réponse en attente.</param>
        <summary>Termine une requête asynchrone adressée à une ressource Internet.</summary>
        <returns>
          <see cref="T:System.Net.WebResponse" /> contenant la réponse de la ressource Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthode effectue une demande asynchrone d’une ressource Internet qui a été démarrée en appelant le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> (méthode).  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.Net.HttpWebResponse.Close%2A> méthode pour fermer le flux et libérer la connexion. Pour ce faire, peut entraîner votre application s’exécute en dehors de connexions.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> méthode à la fin d’une demande asynchrone d’une ressource Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette méthode a déjà été appelée avec <paramref name="asyncResult." />  
  
- ou - 
La propriété <see cref="P:System.Net.HttpWebRequest.ContentLength" /> est supérieure à 0, mais les données n’ont pas été écrites dans le flux de demande.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.  
  
- ou - 
Une erreur s’est produite pendant le traitement de la demande.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> n’a pas été retourné par l’instance actuelle à partir d’un appel à <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="Expect" />.</summary>
        <value>Contenu de l’en-tête HTTP <see langword="Expect" />. La valeur par défaut est <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 La valeur de cette propriété est stockée dans <see cref="T:System.Net.WebHeaderCollection" />. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> est définie sur une chaîne qui contient « 100-continue » en tant que sous-chaîne.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur de hachage pour une instance de <see cref="T:System.Net.WebRequest" />.</summary>
        <returns>Valeur de hachage entier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
La méthode GetHashCode retourne un code de hachage de la demande web. Cette valeur peut être utilisée en tant que clé dans les tables de hachage.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> à remplir de données.</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui spécifie la destination de cette sérialisation.</param>
        <summary>Remplit un <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec les données nécessaires pour sérialiser l'objet cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les objets inclus dans le <xref:System.Runtime.Serialization.SerializationInfo> sont automatiquement suivies et sérialisé par le formateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête.</summary>
        <returns>
          <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode retourne un flux à utiliser pour envoyer des données pour le <xref:System.Net.HttpWebRequest>. Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
 Si une application doit définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété, puis il doit être effectuée avant d’extraire le flux.  
  
 Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion pour une réutilisation. Si échoue pour fermer le flux, votre application s’exécute en dehors de connexions.  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une requête particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode pour retourner une instance de flux.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">La propriété <see cref="P:System.Net.HttpWebRequest.Method" /> est GET ou HEAD.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> est <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> est <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> a la valeur -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> est <see langword="false" />, et <see cref="P:System.Net.HttpWebRequest.Method" /> est POST ou PUT.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> est appelée plusieurs fois.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> est défini sur une valeur et <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a la valeur <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Le validateur du cache de requête a indiqué que la réponse à cette requête peut être obtenue à partir du cache. Toutefois, les requêtes qui écrivent des données ne doivent pas utiliser le cache. Cette exception peut se produire si vous utilisez un validateur de cache personnalisé qui est implémenté de manière incorrecte.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.  
  
- ou - 
Le délai d’attente de la requête a expiré.  
  
- ou - 
Une erreur s’est produite pendant le traitement de la demande.</exception>
        <exception cref="T:System.ObjectDisposedException">Dans une application .NET Compact Framework, un flux de requête avec une longueur de contenu nulle n’a pas été obtenu et s’est fermé correctement. Pour plus d’informations sur la gestion des requêtes avec une longueur de contenu nulle, consultez [Programmation réseau dans le .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> pour <see cref="T:System.IO.Stream" />.</param>
        <summary>Obtient un objet <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête et exporte le <see cref="T:System.Net.TransportContext" /> associé au flux.</summary>
        <returns>
          <see cref="T:System.IO.Stream" /> à utiliser pour écrire les données de la requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode retourne un flux à utiliser pour envoyer des données pour le <xref:System.Net.HttpWebRequest> et fournit en sortie le <xref:System.Net.TransportContext> associé au flux. Après le <xref:System.IO.Stream> objet a été renvoyé, vous pouvez envoyer des données avec le <xref:System.Net.HttpWebRequest> à l’aide de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> (méthode).  
  
 Certaines applications qui utilisent l’authentification Windows intégrée avec protection étendue peuvent nécessiter être en mesure d’interroger la couche de transport utilisée par <xref:System.Net.HttpWebRequest> afin de récupérer le jeton de liaison de canal (FAO) du canal de TLS sous-jacent. Le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode permet d’accéder à ces informations pour les méthodes HTTP qui ont un corps de demande (`POST` et `PUT` demandes). Cela est uniquement nécessaire si l’application implémente sa propre authentification et a besoin d’accéder au canal.  
  
 Si une application doit définir la valeur de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété, puis il doit être effectuée avant d’extraire le flux.  
  
 Vous devez appeler la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> méthode pour fermer le flux et libérer la connexion pour une réutilisation. Si échoue pour fermer le flux, votre application s’exécute en dehors de connexions.  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une requête particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">La méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> n’a pas pu obtenir le <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> est appelée plusieurs fois.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> est défini sur une valeur et <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a la valeur <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Le validateur du cache de requête a indiqué que la réponse à cette requête peut être obtenue à partir du cache. Toutefois, les requêtes qui écrivent des données ne doivent pas utiliser le cache. Cette exception peut se produire si vous utilisez un validateur de cache personnalisé qui n’est pas implémenté correctement.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">La propriété <see cref="P:System.Net.HttpWebRequest.Method" /> est GET ou HEAD.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> a la valeur <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a la valeur <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> a la valeur -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a la valeur <see langword="false" />, et <see cref="P:System.Net.HttpWebRequest.Method" /> a la valeur POST ou PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.  
  
- ou - 
Le délai d’attente de la requête a expiré.  
  
- ou - 
Une erreur s’est produite pendant le traitement de la demande.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une réponse d'une ressource Internet.</summary>
        <returns>
          <see cref="T:System.Net.WebResponse" /> contenant la réponse de la ressource Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode retourne un <xref:System.Net.WebResponse> objet qui contient la réponse de la ressource Internet. L’instance réelle retournée est un <xref:System.Net.HttpWebResponse>et peut être converti à cette classe pour accéder aux propriétés propres à HTTP.  
  
 Un <xref:System.Net.ProtocolViolationException> est levée dans plusieurs cas lorsque les propriétés définies sur la <xref:System.Net.HttpWebRequest> classe sont en conflit. Cette exception se produit si une application définit le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété et la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true`, puis envoie une requête HTTP GET. Cette exception se produit si une application tente d’envoyer mémorisé en bloc à un serveur qui prend uniquement en charge le protocole HTTP 1.0, où ce n’est pas possible. Cette exception se produit si une application tente d’envoyer des données sans paramètre la <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété ou le <xref:System.Net.HttpWebRequest.SendChunked%2A> est `false` lors de la mise en mémoire tampon est désactivée et sur une connexion keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`)`.`  
  
> [!CAUTION]
>  Vous devez appeler la <xref:System.Net.HttpWebResponse.Close%2A> méthode pour fermer le flux et libérer la connexion. Pour ce faire, peut entraîner votre application s’exécute en dehors de connexions.  
  
 Lorsque vous utilisez la méthode POST, vous devez obtenir le flux de demande, écrire les données de publication et fermer le flux. Cette méthode reste bloquée en attendant contenu à publier ; s’il n’existe aucun jeu de délai d’attente et vous ne fournissez pas de contenu, le thread appelant se bloque indéfiniment.  
  
> [!NOTE]
>  Appels multiples à <xref:System.Net.HttpWebRequest.GetResponse%2A> retournent le même objet de réponse ; la demande n’est pas relancée.  
  
> [!NOTE]
>  Votre application ne peut pas combiner des méthodes synchrones et asynchrones pour une requête particulière. Si vous appelez le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> (méthode), vous devez utiliser le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode pour récupérer la réponse.  
  
> [!NOTE]
>  Si un <xref:System.Net.WebException> est levée, utilisez la <xref:System.Net.WebException.Response%2A> et <xref:System.Net.WebException.Status%2A> propriétés de l’exception pour déterminer la réponse à partir du serveur.  
  
> [!NOTE]
>  Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Pour des raisons de sécurité, les cookies sont désactivés par défaut. Si vous souhaitez utiliser des cookies, utilisez le <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriété pour activer les cookies.  
  
   
  
## Examples  
 L’exemple de code suivant obtient la réponse pour une demande.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux est déjà utilisé par un appel précédent à <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> est défini sur une valeur et <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a pour valeur <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> a pour valeur GET ou HEAD, et soit <see cref="P:System.Net.HttpWebRequest.ContentLength" /> est supérieur ou égal à zéro, soit <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a pour valeur <see langword="true" />.  
  
- ou - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> a pour valeur <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a pour valeur <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> a pour valeur -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a pour valeur <see langword="false" />, tandis que <see cref="P:System.Net.HttpWebRequest.Method" /> a pour valeur POST ou PUT.  
  
- ou - 
La <see cref="T:System.Net.HttpWebRequest" /> a un corps d’entité, mais la méthode <see cref="M:System.Net.HttpWebRequest.GetResponse" /> est appelée sans que soit appelée la méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
- ou - 
Le <see cref="P:System.Net.HttpWebRequest.ContentLength" /> est supérieur à zéro, mais l’application n’écrit pas toutes les données promises.</exception>
        <exception cref="T:System.NotSupportedException">Le validateur du cache de demande a indiqué que la réponse à cette demande peut être fournie à partir du cache ; toutefois, cette demande comprend des données à envoyer au serveur. Les demandes qui envoient des données ne doivent pas utiliser le cache. Cette exception peut se produire si vous utilisez un validateur de cache personnalisé qui est implémenté de manière incorrecte.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> a déjà été appelé.  
  
- ou - 
Le délai d’attente de la requête a expiré.  
  
- ou - 
Une erreur s’est produite pendant le traitement de la demande.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si une réponse a été reçue d'une ressource Internet.</summary>
        <value>
          <see langword="true" /> si une réponse a été reçue ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple vérifie la <xref:System.Net.HttpWebRequest.HaveResponse%2A> propriété afin de déterminer si une réponse a été reçue à partir d’une ressource Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie une collection de paires nom-valeur qui composent les en-têtes HTTP.</summary>
        <value>
          <see cref="T:System.Net.WebHeaderCollection" /> contenant les paires nom-valeur qui composent les en-têtes de la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Headers%2A> collection contient les en-têtes de protocole associés à la demande. Le tableau suivant répertorie les en-têtes HTTP qui ne sont pas stockées dans le <xref:System.Net.HttpWebRequest.Headers%2A> collection mais qui sont définis par le système ou par propriétés ou méthodes.  
  
|Header|Défini par|  
|------------|------------|  
|Accepter|Défini par le <xref:System.Net.HttpWebRequest.Accept%2A> propriété.|  
|Connexion|Défini par le <xref:System.Net.HttpWebRequest.Connection%2A> propriété et <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété.|  
|Content-Length|Défini par le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété.|  
|Content-Type|Défini par le <xref:System.Net.HttpWebRequest.ContentType%2A> propriété.|  
|Attendre|Défini par le <xref:System.Net.HttpWebRequest.Expect%2A> propriété.|  
|Date|Défini par le <xref:System.Net.HttpWebRequest.Date%2A> propriété.|  
|Hôte|Défini par le <xref:System.Net.HttpWebRequest.Host%2A> propriété.|  
|If-Modified-Since|Défini par le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété.|  
|Plage|Défini par le <xref:System.Net.HttpWebRequest.AddRange%2A> (méthode).|  
|Référant|Défini par le <xref:System.Net.HttpWebRequest.Referer%2A> propriété.|  
|Codage de transfert|Défini par le <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété (la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété doit être true).|  
|User-Agent|Défini par le <xref:System.Net.HttpWebRequest.UserAgent%2A> propriété.|  
  
 Le <xref:System.Net.WebHeaderCollection.Add%2A> méthode lève un <xref:System.ArgumentException> si vous essayez de définir un de ces en-têtes protégés.  
  
 Modification de la <xref:System.Net.HttpWebRequest.Headers%2A> propriété une fois que la demande a été lancée en appelant <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève un <xref:System.InvalidOperationException>.  
  
 Vous ne devez pas supposer que les valeurs d’en-tête resteront inchangées, car les serveurs Web et les caches peuvent modifier ou ajouter des en-têtes à une requête Web.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.Headers%2A> propriété pour imprimer les paires de nom/valeur d’en-tête HTTP à la console.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La requête a été lancée en appelant la méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur d'en-tête Hôte à utiliser dans une requête HTTP indépendante de l'URI de la requête.</summary>
        <value>Valeur d'en-tête Hôte dans la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Host%2A> propriété peut être utilisée pour définir la valeur d’en-tête à utiliser dans une requête HTTP indépendante de la demande URI hôte. Le <xref:System.Net.HttpWebRequest.Host%2A> propriété peut se composer d’un nom d’hôte et un numéro de port facultatif. Un en-tête d’hôte sans informations de port implique le port par défaut pour le service demandé (port 80 pour une URL HTTP, par exemple).  
  
 Le format pour spécifier un hôte et un port doit respecter les règles dans la section 14.23 de RFC2616 publiée par l’IETF. Un exemple répondant à ces exigences qui spécifie le port 8080 serait la valeur suivante pour le <xref:System.Net.HttpWebRequest.Host%2A> propriété :  
  
 `www.contoso.com:8080`  
  
 À l’aide de la <xref:System.Net.HttpWebRequest.Host%2A> propriété pour spécifier explicitement une valeur d’en-tête hôte personnalisée affecte également la mise en cache des zones, les cookies et l’authentification. Lorsqu’une application fournit des informations d’identification d’un préfixe URI spécifique, les applications doit veiller à utiliser l’URI qui contient la valeur de l’en-tête d’hôte, pas le serveur cible dans l’URI. La clé utilisée lors de la mise en cache de ressources, utilise la valeur d’en-tête hôte plutôt que l’URI de demande. Les cookies sont stockés dans un <xref:System.Net.CookieContainer> et regroupés logiquement par le nom de domaine du serveur. Si l’application spécifie un en-tête d’hôte, puis cette valeur sera utilisée en tant que domaine.  
  
 Si le <xref:System.Net.HttpWebRequest.Host%2A> propriété n’est pas définie, puis la valeur d’en-tête hôte à utiliser dans une requête HTTP est basée sur l’URI de demande.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Impossible de définir l’en-tête de l’hôte sur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Impossible de définir l’en-tête de l’hôte sur une valeur non valide.</exception>
        <exception cref="T:System.InvalidOperationException">L’en-tête de l’hôte ne peut pas être défini une fois que l’envoi de la <see cref="T:System.Net.HttpWebRequest" /> a commencé.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="If-Modified-Since" />.</summary>
        <value>
          <see cref="T:System.DateTime" /> qui contient l’en-tête HTTP <see langword="If-Modified-Since" />. La valeur par défaut est l'horodatage actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est une norme <xref:System.DateTime?displayProperty=nameWithType> de l’objet et peut contenir un <xref:System.DateTimeKind?displayProperty=nameWithType> champ <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Tout type d’heure peut être définie lors de l’utilisation du <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> est définie ou récupérée, la <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est censée pour être <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (heure locale).  
  
 Les classes dans le <xref:System.Net> espace de noms écrivent toujours le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété sur le câble pendant la transmission au format standard à l’aide du format GMT (Utc).  
  
 Si le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est définie sur <xref:System.DateTime.MinValue?displayProperty=nameWithType>, puis le `If-Modified-Since` en-tête HTTP est supprimé de la <xref:System.Net.HttpWebRequest.Headers%2A> propriété et le <xref:System.Net.WebHeaderCollection>.  
  
 Si le <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété est <xref:System.DateTime.MinValue?displayProperty=nameWithType>, cela indique que le `If-Modified-Since` en-tête HTTP n’est pas inclus dans le <xref:System.Net.HttpWebRequest.Headers%2A> propriété et le <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple vérifie la <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si une connexion persistante doit être établie avec la ressource Internet.</summary>
        <value>
          <see langword="true" /> si la requête adressée à la ressource Internet doit contenir un en-tête HTTP <see langword="Connection" /> ayant la valeur Keep-alive ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `true` pour envoyer un `Connection` en-tête HTTP ayant la valeur Keep-alive. Une application utilise <xref:System.Net.HttpWebRequest.KeepAlive%2A> pour indiquer une préférence pour les connexions persistantes. Lorsque le <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est `true`, l’application établit des connexions persistantes aux serveurs qui les prennent en charge.  
  
> [!NOTE]
>  Lorsque vous utilisez HTTP/1.1, Keep-Alive est activé par défaut. Paramètre <xref:System.Net.HttpWebRequest.KeepAlive%2A> à `false` peut entraîner l’envoi d’un `Connection: Close` en-tête au serveur.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété `false` pour éviter d’établir une connexion persistante avec la ressource Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal de redirections suivies par la requête.</summary>
        <value>Nombre maximal de réponses de redirection suivies par la requête. La valeur par défaut est 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriété définit le nombre maximal de redirections de la requête à suivre si le <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriété est `true`.  
  
   
  
## Examples  
 L’exemple de code suivant définit la valeur de cette propriété.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur est inférieure ou égale à 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la longueur maximale autorisée des en-têtes de réponse.</summary>
        <value>Longueur en kilo-octets (1 024 octets) des en-têtes de réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur de l’en-tête de réponse comprend la ligne d’état de réponse et tous les caractères de contrôle supplémentaires qui sont reçus dans le cadre du protocole HTTP. Une valeur-1 signifie qu'aucune limite sur les en-têtes de réponse ; une valeur de 0 signifie que toutes les demandes échouent.  
  
 Si le <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriété n’est pas définie explicitement, sa valeur par défaut à la valeur de la <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> propriété.  
  
 Si la longueur de l’en-tête de réponse reçu dépasse la valeur de la <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriété, le <xref:System.Net.HttpWebRequest.EndGetResponse%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> méthodes lèvent une <xref:System.Net.WebException> avec la <xref:System.Net.WebException.Status%2A> propriété définie sur <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 L’exemple de code suivant définit la valeur de cette propriété.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété est définie après l’envoi de la requête.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est inférieure à 0 et n’est pas égale à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de média de la requête.</summary>
        <value>Type de média de la requête. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Net.HttpWebRequest.MediaType%2A> propriété affecte le <xref:System.Net.HttpWebResponse.CharacterSet%2A> propriété. Lorsque vous définissez la <xref:System.Net.HttpWebRequest.MediaType%2A> dans la demande, le type de média correspondant est choisi dans la liste de jeux de caractères retournés dans la réponse `Content-type` en-tête HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la méthode pour la requête.</summary>
        <value>Méthode de requête à utiliser pour contacter la ressource Internet. La valeur par défaut est GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Method%2A> propriété peut être définie à l’un des verbes de protocole HTTP 1.1 : GET, HEAD, POST, PUT, DELETE, TRACE ou OPTIONS.  
  
 Si le <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété est définie sur n’importe quelle valeur autre que -1, le <xref:System.Net.HttpWebRequest.Method%2A> propriété doit être définie sur une propriété de protocole qui transfère des données.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Method%2A> propriété à valider.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aucune méthode n’est fournie.  
  
- ou - 
La chaîne de la méthode contient des caractères non valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la requête doit être canalisée en rafale vers la ressource Internet.</summary>
        <value>
          <see langword="true" /> si la requête doit être canalisée en rafale ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application utilise le <xref:System.Net.HttpWebRequest.Pipelined%2A> propriété pour indiquer une préférence pour les connexions canalisées en rafale. Lorsque <xref:System.Net.HttpWebRequest.Pipelined%2A> est `true`, une application établit des connexions canalisées en rafale aux serveurs qui les prennent en charge.  
  
 Les connexions canalisées en rafale sont effectuées uniquement lorsque le <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriété est également `true`.  
  
   
  
## Examples  
 L’exemple de code suivant imprime la valeur de la <xref:System.Net.HttpWebRequest.Pipelined%2A> propriété sur la console.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si un en-tête d'autorisation doit être envoyé avec la requête.</summary>
        <value>
          <see langword="true" /> pour envoyer un en-tête d’autorisation HTTP avec les requêtes une fois l’authentification effectuée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après une demande du client à un spécifique <xref:System.Uri> est correctement authentifié, si <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> est `true` et informations d’identification sont fournies, l’en-tête d’autorisation est envoyé avec chaque demande à tout <xref:System.Uri> qui correspond à la spécifique <xref:System.Uri>jusqu'à la dernière barre oblique. Par conséquent, si la demande du client est correctement authentifié auprès d’un spécifique <xref:System.Uri> qui contient les éléments suivants :  
  
 `http://www.contoso.com/firstpath/`  
  
 L’en-tête d’autorisation pour la pré-authentification est envoyé avec chaque demande à une des opérations suivantes <xref:System.Uri> instances :  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Toutefois, l’en-tête d’autorisation n’est pas envoyé avec les demandes, à une des opérations suivantes <xref:System.Uri> instances :  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Si le client demande à un spécifique <xref:System.Uri> est authentifié, la demande utilise des procédures d’authentification standard.  
  
 À l’exception de la première demande, le <xref:System.Net.WebRequest.PreAuthenticate%2A> propriété indique s’il faut envoyer des informations d’authentification avec les demandes ultérieures à un <xref:System.Uri> qui correspond à la spécifique <xref:System.Uri> jusqu'à la dernière barre oblique sans attendre d’être mise en concurrence par le serveur.  
  
 La boîte de dialogue suivante entre client et serveur illustre l’effet de cette propriété. La boîte de dialogue part du principe que l’authentification de base est en cours d’utilisation.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> est `false`:  
  
 Client : Une URL GET  
  
 Serveur : 401 WWW-Authenticate Basic  
  
 Client : GET avec en-têtes d’autorisation  
  
 Serveur : 200 OK  
  
 Client : Une URL GET  
  
 Serveur : 401 WWW-Authenticate Basic  
  
 Client : GET avec en-têtes d’autorisation  
  
 Serveur : 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> est `true`:  
  
 Client : Une URL GET  
  
 Serveur : 401 WWW-Authenticate Basic  
  
 Client : GET avec en-têtes d’autorisation  
  
 Serveur : 200 OK  
  
 Client : GET une URL avec en-têtes d’autorisation  
  
 Si le schéma d’authentification ne prend pas en charge la pré-authentification, la valeur de cette propriété est ignorée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du serveur proxy à utiliser pour les requêtes.</summary>
        <value>Version HTTP à utiliser pour la requête. La valeur par défaut est <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest> classe prend en charge uniquement les versions 1.0 et 1.1 du protocole HTTP. Paramètre <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> vers une autre version lève une exception.  
  
> [!NOTE]
>  Pour définir la version HTTP de la requête actuelle, utilisez la <xref:System.Net.HttpVersion.Version10> et <xref:System.Net.HttpVersion.Version11> champs de la <xref:System.Net.HttpVersion> classe.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La version HTTP a une valeur autre que 1.0 ou 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations de proxy pour la requête.</summary>
        <value>Objet <see cref="T:System.Net.IWebProxy" /> à utiliser pour rediriger la requête via un proxy. La valeur par défaut est définie en appelant la propriété <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété identifie le <xref:System.Net.WebProxy> objet à utiliser pour traiter les demandes de ressources Internet. Pour spécifier qu’aucun proxy doit être utilisé, définissez la <xref:System.Net.HttpWebRequest.Proxy%2A> propriété à l’instance de proxy retournée par la <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> (méthode).  
  
 L’ordinateur local ou un fichier de configuration d’application peut spécifier qu’un proxy par défaut est utilisé. Si le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété est spécifiée, les paramètres de proxy à partir de la <xref:System.Net.HttpWebRequest.Proxy%2A> l’ordinateur local ou un fichier de configuration d’application de remplacement de la propriété et la <xref:System.Net.HttpWebRequest> instance utilisera les paramètres de proxy spécifiés. Si aucun proxy n’est spécifié dans un fichier de configuration et le <xref:System.Net.HttpWebRequest.Proxy%2A> propriété n’est pas spécifiée, la <xref:System.Net.HttpWebRequest> classe utilise les paramètres proxy hérités à partir d’Internet Explorer sur l’ordinateur local. S’il n’y a aucun paramètre de proxy dans Internet Explorer, la demande est envoyée directement au serveur.  
  
 Le <xref:System.Net.HttpWebRequest> classe analyse une liste de contournement proxy avec des caractères génériques hérités d’Internet Explorer le même que la liste de contournement est analysée directement par Internet Explorer. Par exemple, le <xref:System.Net.HttpWebRequest> classe analyse une liste de contournement de « nt * » à partir d’Internet Explorer comme une expression régulière de « nt.\*». Par conséquent, une URL de «`http://nt.com`» le proxy à l’aide de la <xref:System.Net.HttpWebRequest> classe et à l’aide d’Internet Explorer.  
  
 Le <xref:System.Net.HttpWebRequest> classe prend en charge le contournement de proxy local. La classe considère qu’une destination locale si une des conditions suivantes est remplie :  
  
-   La destination contient un nom plat (aucun point dans l’URL).  
  
-   La destination contient une adresse de bouclage (<xref:System.Net.IPAddress.Loopback> ou <xref:System.Net.IPAddress.IPv6Loopback>) ou la destination contient un <xref:System.Net.IPAddress> attribué à l’ordinateur local.  
  
-   Le suffixe de domaine de la destination correspond au suffixe de domaine de l’ordinateur local (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Modification de la <xref:System.Net.HttpWebRequest.Proxy%2A> propriété une fois que la demande a été lancée en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>. Pour plus d’informations sur l’élément proxy, consultez [ \&lt ; defaultProxy\&gt ; Élément (paramètres réseau)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Net.HttpWebRequest.Proxy%2A> méthode pour obtenir des informations de proxy pour la demande.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La requête a été lancée en appelant <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations requises pour effectuer l’opération demandée.</exception>
        <permission cref="T:System.Net.WebPermission">Pour obtenir ou définir le <see cref="P:System.Net.HttpWebRequest.Proxy" /> propriété. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy, élément (paramètres réseau)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Configuration des applications Internet</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Configuration du proxy</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Détection automatique de proxy</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un délai d'expiration exprimé en millisecondes lors de la lecture ou de l'écriture d'un flux.</summary>
        <value>Nombre de millisecondes avant l'expiration de l'écriture ou de la lecture. La valeur par défaut est 300 000 millisecondes (5 minutes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriété est utilisée lors de l’écriture dans le flux retourné par la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode ou lecture du flux retourné par la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> (méthode).  
  
 Plus précisément, le <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriété détermine le délai d’attente pour le <xref:System.IO.Stream.Read%2A> (méthode), qui est utilisé pour lire le flux retourné par la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> (méthode) et pour le <xref:System.IO.Stream.Write%2A> (méthode), qui est utilisé pour écrire dans le flux retourné par la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>(méthode).  
  
 Pour spécifier la quantité de temps à attendre la fin de demande, utilisez le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment définir la propriété <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La requête a déjà été envoyée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour une opération ensembliste est inférieure ou égale à zéro et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="Referer" />.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Referer" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriété est `true`, le <xref:System.Net.HttpWebRequest.Referer%2A> propriété est définie automatiquement lors de la demande est redirigée vers un autre site.  
  
 Pour effacer le `Referer` en-tête HTTP, définissez la <xref:System.Net.HttpWebRequest.Referer%2A> propriété `null`.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Referer%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URI (Uniform Resource Identifier) d'origine de la requête.</summary>
        <value>
          <see cref="T:System.Uri" /> contenant l’URI de la ressource Internet passée à la méthode <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Uri> objet passé à <xref:System.Net.HttpWebRequest> par l’appel à <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Après une redirection en-tête ne modifie pas le <xref:System.Net.HttpWebRequest.RequestUri%2A> propriété. Pour obtenir l’URI qui a répondu à la demande, examinez le <xref:System.Net.HttpWebRequest.Address%2A> propriété.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si le <xref:System.Net.HttpWebRequest> objet `req` a été redirigé vers un autre emplacement pour répondre à la demande et définit la valeur de la `hasChanged` à la variable `true` si la demande a été redirigée, sinon `hasChanged` est défini sur `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les données doivent être envoyées par segments à la ressource Internet.</summary>
        <value>
          <see langword="true" /> pour envoyer les données à la ressource Internet par segments ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Net.HttpWebRequest.SendChunked%2A> est `true`, la demande envoie des données à la ressource Internet par segments. La ressource Internet doit prendre en charge la réception des données mémorisé en bloc.  
  
 Modification de la <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété une fois que la demande a été lancée en appelant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> méthode lève une exception une <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true` afin que les données peuvent être envoyées par segments à la ressource Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La requête a été lancée en appelant la méthode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une fonction de rappel pour valider le certificat de serveur.</summary>
        <value>Une fonction de rappel pour valider le certificat de serveur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut est qu’aucune fonction de rappel n’a la valeur et le <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> propriété est `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le point de service à utiliser pour la requête.</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" /> représentant la connexion réseau à la ressource Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> propriété peut être différente de <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> si la demande est redirigée.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la requête fournit une prise en charge pour un <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> si le fournisseur fournit la prise en charge pour un <see cref="T:System.Net.CookieContainer" /> ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> à remplir de données.</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui spécifie la destination de cette sérialisation.</param>
        <summary>Remplit <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec les données nécessaires pour sérialiser l'objet cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les objets inclus dans le <xref:System.Runtime.Serialization.SerializationInfo> sont automatiquement suivies et sérialisé par le formateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur du délai d’attente exprimée en millisecondes pour les méthodes <see cref="M:System.Net.HttpWebRequest.GetResponse" /> et <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>Nombre de millisecondes à attendre avant l'expiration de la demande. La valeur par défaut est 100 000 millisecondes (100 secondes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> est le nombre de millisecondes pendant lequel une requête synchrone suivante lancée avec le <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode attend une réponse et le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> méthode attend un flux de données. Le <xref:System.Net.HttpWebRequest.Timeout%2A> s’applique à la totalité de la demande et la réponse, pas individuellement à la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> et <xref:System.Net.HttpWebRequest.GetResponse%2A> les appels de méthode. Si la ressource n’est pas retournée dans le délai d’attente, la demande lève un <xref:System.Net.WebException> avec la <xref:System.Net.WebException.Status%2A> propriété définie sur <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété doit être définie avant le <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode est appelée. Modification de la <xref:System.Net.HttpWebRequest.Timeout%2A> propriété après avoir appelé la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> méthode n’a aucun effet  
  
 Le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété n’a aucun effet sur les requêtes asynchrones lancées avec le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> ou <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> (méthode).  
  
> [!CAUTION]
>  Dans le cas de requêtes asynchrones, l’application cliente implémente son propre mécanisme de délai d’attente. Consultez l’exemple dans le <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> (méthode).  
  
 Pour spécifier la quantité de temps à attendre avant une lecture ou écriture opération arrive à expiration, utilisez le <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriété.  
  
 Une requête de nom de domaine (DNS) peut prendre jusqu'à 15 secondes à retourner ou délai d’attente. Si votre requête contient un nom d’hôte qui requiert une résolution et que vous définissez <xref:System.Net.FileWebRequest.Timeout%2A> sur une valeur inférieure à 15 secondes, il peut prendre 15 secondes ou plus avant une <xref:System.Net.WebException> est levée pour indiquer un délai d’expiration de votre demande.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.Timeout%2A> propriété de la <xref:System.Net.HttpWebRequest> objet.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée est inférieure à zéro et n’est pas <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="Transfer-encoding" />.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="Transfer-encoding" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant de pouvoir définir le <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété, vous devez d’abord définir le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété `true`. Effacement <xref:System.Net.HttpWebRequest.TransferEncoding%2A> en lui affectant `null` n’a aucun effet sur la valeur de <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Valeurs affectées à la <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriété remplacent le contenu existant.  
  
> [!NOTE]
>  La valeur de cette propriété est stockée dans <xref:System.Net.WebHeaderCollection>. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> est défini quand <see cref="P:System.Net.HttpWebRequest.SendChunked" /> a la valeur <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> a la valeur « Chunked ».</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le partage de connexion authentifié NTLM à haut débit est autorisé.</summary>
        <value>
          <see langword="true" /> pour maintenir ouverte la connexion pré-authentifiée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut de cette propriété est `false`, ce qui entraîne la connexion actuelle à être fermée après une demande est terminée. Votre application doit passer par la séquence d’authentification chaque fois qu’il émet une nouvelle demande.  
  
 Si cette propriété est définie sur `true`, la connexion utilisée pour récupérer la réponse reste ouverte après que l’authentification a été effectuée. Dans ce cas, les autres requêtes qui ont cette propriété la valeur `true` peuvent utiliser la connexion sans ré-authentifier. En d’autres termes, si une connexion a été authentifiée pour l’utilisateur A, l’utilisateur B peut utiliser la même connexion ; demande de l’utilisateur B est traitée selon les informations d’identification de l’utilisateur A.  
  
> [!CAUTION]
>  Comme il est possible qu’une application pour utiliser la connexion sans être authentifiée, vous avez besoin pour vous assurer qu’il n’existe aucune faille administrative dans votre système lors de la définition de cette propriété `true`. Si votre application envoie des demandes pour plusieurs utilisateurs (emprunte l’identité de plusieurs comptes d’utilisateur) et s’appuie sur l’authentification pour protéger les ressources, ne définissez pas cette propriété `true` , sauf si vous utilisez des groupes de connexion comme décrit ci-dessous.  
  
 Voulez-vous activer ce mécanisme si votre problème de performances et de votre application s’exécute sur un serveur Web avec l’authentification Windows intégrée.  
  
 L’activation de ce paramètre, le système aux risques de sécurité s’ouvre. Si vous définissez la <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> propriété `true` veillez à prendre les précautions suivantes :  
  
-   Utilisez le <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriété pour gérer les connexions pour différents utilisateurs. Cela évite les possibilités d’utilisation de la connexion par des applications non authentifiées. Par exemple, l’utilisateur A doit avoir un nom de groupe de connexion unique qui est différent de l’utilisateur B. Cela fournit une couche d’isolation pour chaque compte d’utilisateur.  
  
-   Exécutez votre application dans un environnement protégé afin d’éviter les attaques de connexion possibles.  
  
 Si vous contrôlez le serveur principal, en guise d’alternative vous pouvez envisager la désactivation de la persistance de l’authentification. Cela améliore les performances à un moindre degré, mais il est plus sûr. Pour plus d’informations, recherchez AuthPersistence dans MSDN library à le [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Si les deux <xref:System.Net.WebRequest.PreAuthenticate%2A> et <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> sont définies sur `true`, chaque requête est envoyée à l’aide d’une connexion à partir du pool non sécurisé, mais avec un en-tête d’autorisation.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">L’autorisation Web illimitée est requis pour définir cette propriété.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui contrôle si les informations d’identification par défaut sont envoyées avec les requêtes.</summary>
        <value>
          <see langword="true" /> si les informations d'identification par défaut sont utilisées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `true` lorsque des requêtes effectuées par ce <xref:System.Net.HttpWebRequest> objet doit, si requis par le serveur, être authentifié à l’aide les informations d’identification de l’utilisateur actuellement connecté. Pour les applications clientes, il s’agit du comportement souhaité dans la plupart des scénarios. Pour les applications de couche intermédiaire, telles que les applications ASP.NET, au lieu d’utiliser cette propriété, vous définissez généralement la <xref:System.Net.HttpWebRequest.Credentials%2A> propriété pour les informations d’identification du client au nom duquel la demande est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous avez tenté de définir cette propriété après l’envoi de la requête.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l’en-tête HTTP <see langword="User-agent" />.</summary>
        <value>Valeur de l’en-tête HTTP <see langword="User-agent" />. La valeur par défaut est <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 La valeur de cette propriété est stockée dans <see cref="T:System.Net.WebHeaderCollection" />. Si WebHeaderCollection est défini, la valeur de la propriété est perdue.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.HttpWebRequest.UserAgent%2A> propriété.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>