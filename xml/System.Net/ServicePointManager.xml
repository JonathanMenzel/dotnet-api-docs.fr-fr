<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e30df950ceffdac0908c042e1da064fa81092e1c" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52195282" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gère la collection d'objets <see cref="T:System.Net.ServicePoint" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> est une classe statique utilisée pour créer, gérer et supprimer des instances de la <xref:System.Net.ServicePoint> classe.  
  
 Lorsqu’une application demande une connexion à une ressource Internet identificateur URI (Uniform Resource) via le <xref:System.Net.ServicePointManager> objet, le <xref:System.Net.ServicePointManager> retourne un <xref:System.Net.ServicePoint> objet qui contient les informations de connexion pour l’hôte et le schéma identifiés par l’URI. S’il existe un <xref:System.Net.ServicePoint> objet pour cet hôte et le schéma, le <xref:System.Net.ServicePointManager> objet retourne existant <xref:System.Net.ServicePoint> objet ; sinon, le <xref:System.Net.ServicePointManager> objet crée une nouvelle <xref:System.Net.ServicePoint> objet.  
  
 Le .NET Framework 4.6 inclut une nouvelle fonctionnalité de sécurité qui bloque les algorithmes pour les connexions de hachage et de chiffrement non sécurisé. Applications à l’aide de TLS/SSL via des API telles que <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>, etc. et ciblant .NET Framework 4.6 obtenir le comportement plus sécurisés par défaut.  
  
 Les développeurs veulent peuvent désactiver ce comportement afin de maintenir l’interopérabilité avec leurs services SSL3 existants ou le TLS avec les services de RC4. [Cet article](https://support.microsoft.com/kb/3069494) explique comment modifier votre code afin que le nouveau comportement est désactivé.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.ServicePoint> objet pour les connexions à l’URI www.contoso.com.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
    <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager, élément (paramètres réseau)</related>
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la stratégie pour les certificats serveur.</summary>
        <value>Objet qui implémente l'interface <see cref="T:System.Net.ICertificatePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Net.ServicePointManager.CertificatePolicy%2A> propriété est définie sur une <xref:System.Net.ICertificatePolicy> objet d’interface, le <xref:System.Net.ServicePointManager> objet utilise la stratégie de certificat définie dans cette instance au lieu de la stratégie de certificat par défaut.  
  
 La stratégie de certificat par défaut autorise les certificats valides et les certificats valides qui ont expiré.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment intercepter une exception de stratégie de certificat pour une stratégie de certificat personnalisé. Il part du principe que l’objet de stratégie de certificat a été défini, que l’identificateur URI (Uniform Resource) pour la ressource Web est contenu dans la variable `myUri`et qu’il existe une méthode nommée `ProcessResponse` qui effectue le travail de l’application.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour définir le <see cref="P:System.Net.ServicePointManager.CertificatePolicy" /> propriété. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui indique si le certificat est vérifié par rapport à la liste de révocation de l'autorité de certification.</summary>
        <value>
          <see langword="true" /> si la liste de révocation de certificats est vérifiée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> est `true`, le certificat est vérifié par rapport à la liste de révocation autorité de certification, dans le cadre du processus de validation de certificat. Sa valeur par défaut est `false`.  
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour définir cette propriété. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal de connexions simultanées autorisées par un objet <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>Nombre maximal de connexions simultanées autorisées par un objet <see cref="T:System.Net.ServicePoint" />. La limite de connexion par défaut est 10 pour les applications ASP.NET hébergées et 2 pour tous les autres. Quand une application s’exécute en tant qu’hôte ASP.NET, il est impossible de modifier la valeur de cette propriété par le biais du fichier de configuration si la propriété autoConfig est définie sur <see langword="true" />. Toutefois, vous pouvez modifier la valeur par programmation quand la propriété autoConfig est définie sur <see langword="true" />. Définissez la valeur de votre choix une seule fois, au moment du chargement d'AppDomain.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriété définit le nombre maximal par défaut de connexions simultanées que le <xref:System.Net.ServicePointManager> objet assigne à la <xref:System.Net.ServicePoint.ConnectionLimit%2A> propriété lors de la création <xref:System.Net.ServicePoint> objets.  
  
 Modification de la <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriété n’a aucun effet sur existant <xref:System.Net.ServicePoint> objets ; elle affecte seulement <xref:System.Net.ServicePoint> objets sont initialisés après la modification. Si la valeur de cette propriété n’a pas été définie directement ou via la configuration, la valeur par défaut à la constante <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>.  
  
> [!NOTE]
>  Toute modification apportée à la <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriété affecte les connexions HTTP 1.0 et 1.1 de HTTP. Il n’est pas possible de modifier séparément la limite de connexion pour les protocoles HTTP 1.0 et HTTP 1.1.
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> est inférieur ou égal à 0.</exception>
        <permission cref="T:System.Net.WebPermission">pour les autorisations Web illimitées. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Nombre de connexions non persistantes (4) autorisées par défaut sur un objet <see cref="T:System.Net.ServicePoint" /> connecté à un serveur HTTP/1.0 ou ultérieur. Ce champ est constant, mais n'est plus utilisé dans le .NET Framework 2.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Nombre de connexions persistantes (2) autorisées par défaut sur un objet <see cref="T:System.Net.ServicePoint" /> connecté à un serveur HTTP/1.1 ou ultérieur. Ce champ est constant et est utilisé pour initialiser la propriété <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> si la valeur de la propriété <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> n'a pas été définie soit directement, soit par configuration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple définit le <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> propriété à l’aide de ce champ.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique la durée pendant laquelle une résolution DNS (Domain Name Service) est considérée comme valide.</summary>
        <value>Valeur du délai d'expiration exprimée en millisecondes. Une valeur de -1 indique un délai d'attente infini. La valeur par défaut est 120 000 millisecondes (deux minutes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une résolution DNS (Domain Name Service) effectue une rotation entre les adresses IP (Internet Protocol) applicables.</summary>
        <value>
          <see langword="false" /> si une résolution DNS retourne toujours la première adresse IP pour un hôte particulier ; sinon, <see langword="true" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque plusieurs adresses IP est associée à un nom d’hôte, une résolution DNS retourne normalement la première adresse IP. Si vous définissez cette propriété sur `true`, puis les résolutions DNS suivantes passera en revue toutes les adresses IP disponibles pour un hôte particulier. Cette option est utile lorsqu’un service utilise DNS comme une mécanisme entre des serveurs ou clusters de serveurs d’équilibrage de charge.  
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Net.Security.EncryptionPolicy" /> pour cette instance de <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Stratégie de chiffrement à utiliser pour cette instance de <see cref="T:System.Net.ServicePointManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une valeur n’est pas spécifiée dans le fichier de configuration, le <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> propriété par défaut <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>. Cet affichage est appliqué à une session SSL/TLS sur ce <xref:System.Net.ServicePointManager> instance.  
  
 L’utilisation du chiffrement Null est nécessaire lorsque la stratégie de chiffrement est définie sur <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager, élément (paramètres réseau)</related>
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui détermine si le comportement 100-Continue doit être utilisé.</summary>
        <value>
          <see langword="true" /> pour activer le comportement 100-Continue. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette propriété a la valeur `true`, 100-Continue comportement est utilisé. Les demandes de client qui utilisent le `PUT` et `POST` méthodes ajoutent un en-tête Expect à la demande, si le <xref:System.Net.ServicePointManager.Expect100Continue%2A> propriété est `true` et <xref:System.Net.HttpWebRequest.ContentLength%2A> propriété est supérieure à zéro ou le <xref:System.Net.HttpWebRequest.SendChunked%2A> propriété a la valeur true. Le client s’attend à recevoir un 100-Continue de réponse du serveur pour indiquer que le client doit envoyer les données à valider. Ce mécanisme permet aux clients d’éviter l’envoi de grandes quantités de données sur le réseau lorsque le serveur, selon les en-têtes de demande, point de rejeter la demande.  
  
 Par exemple, supposons que le <xref:System.Net.ServicePointManager.Expect100Continue%2A> propriété est `false`. Lorsque la demande est envoyée au serveur, elle inclut les données. Si, après avoir lu les en-têtes de demande, le serveur nécessite une authentification et doit envoyer une réponse 401, le client doit renvoyer les données avec les en-têtes d’authentification appropriés.  
  
 Si cette propriété est `true`, les en-têtes de demande sont envoyés au serveur. Si le serveur n’a pas a rejeté la requête, il envoie un 100-Continue réponse signalant que les données peuvent être transmises. Si, comme dans l’exemple précédent, le serveur nécessite une authentification, il envoie la réponse 401 et le client n’a pas transmis inutilement les données.  
  
 Modification de la valeur de cette propriété n’affecte pas existant <xref:System.Net.ServicePoint> objets. Nouvelles <xref:System.Net.ServicePoint> objets créés après la modification sont affectés.  
  
 Les 100-Continue le comportement n’est pas utilisé pour les requêtes HTTP 1.0 même si cette propriété est définie sur `true`.  
  
 Le Expect 100-Continue le comportement est décrite en détail dans la norme IETF RFC 2616, Section 10.1.1.  
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un objet <see cref="T:System.Net.ServicePoint" /> existant ou crée un objet <see cref="T:System.Net.ServicePoint" /> pour gérer les communications liées à cette demande.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">Objet <see cref="T:System.Uri" /> de la ressource Internet à contacter.</param>
        <summary>Recherche un objet <see cref="T:System.Net.ServicePoint" /> existant ou crée un objet <see cref="T:System.Net.ServicePoint" /> pour gérer les communications avec l'objet <see cref="T:System.Uri" /> spécifié.</summary>
        <returns>Objet <see cref="T:System.Net.ServicePoint" /> qui gère les communications liées à la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePointManager.FindServicePoint%2A> méthode retourne le <xref:System.Net.ServicePoint> objet associé au nom d’hôte Internet spécifié. Si aucun <xref:System.Net.ServicePoint> objet existe pour cet hôte, le <xref:System.Net.ServicePointManager> en crée un objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le nombre maximal d'objets <see cref="T:System.Net.ServicePoint" /> défini dans <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> est atteint.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">URI de la ressource Internet à contacter.</param>
        <param name="proxy">Données du proxy relatives à cette demande.</param>
        <summary>Recherche un objet <see cref="T:System.Net.ServicePoint" /> existant ou crée un objet <see cref="T:System.Net.ServicePoint" /> pour gérer les communications avec l'URI (Uniform Resource Identifier) spécifié.</summary>
        <returns>Objet <see cref="T:System.Net.ServicePoint" /> qui gère les communications liées à la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePointManager.FindServicePoint%2A> méthode retourne le <xref:System.Net.ServicePoint> objet associé au nom d’hôte Internet spécifié. Si aucun <xref:System.Net.ServicePoint> objet existe pour cet hôte, le <xref:System.Net.ServicePointManager> en crée un objet.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’appel de cette méthode pour accéder à un <xref:System.Net.ServicePoint> objet.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">L'URI spécifié dans <paramref name="uriString" /> n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Le nombre maximal d'objets <see cref="T:System.Net.ServicePoint" /> défini dans <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> est atteint.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">Objet <see cref="T:System.Uri" /> contenant l'adresse de la ressource Internet à contacter.</param>
        <param name="proxy">Données du proxy relatives à cette demande.</param>
        <summary>Recherche un objet <see cref="T:System.Net.ServicePoint" /> existant ou crée un objet <see cref="T:System.Net.ServicePoint" /> pour gérer les communications avec l'objet <see cref="T:System.Uri" /> spécifié.</summary>
        <returns>Objet <see cref="T:System.Net.ServicePoint" /> qui gère les communications liées à la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePointManager.FindServicePoint%2A> méthode retourne le <xref:System.Net.ServicePoint> objet associé au nom d’hôte Internet spécifié. Si aucun <xref:System.Net.ServicePoint> objet existe pour cet hôte, le <xref:System.Net.ServicePointManager> en crée un objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le nombre maximal d'objets <see cref="T:System.Net.ServicePoint" /> défini dans <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> est atteint.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le temps d'inactivité maximal d'un objet <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>Temps d'inactivité maximal, en millisecondes, d'un objet <see cref="T:System.Net.ServicePoint" />. La valeur par défaut est 100 000 millisecondes (100 secondes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> propriété définit la durée d’inactivité maximale que le <xref:System.Net.ServicePointManager> objet assigne à la <xref:System.Net.ServicePoint.MaxIdleTime%2A> propriété lors de la création <xref:System.Net.ServicePoint> objets. Modifications apportées à cette valeur affectent uniquement <xref:System.Net.ServicePoint> les objets qui sont initialisées une fois la valeur est modifiée.  
  
 Après un <xref:System.Net.ServicePoint> objet a été inactif pendant la durée spécifiée dans <xref:System.Net.ServicePoint.MaxIdleTime%2A>, il est éligible pour le garbage collection. Un <xref:System.Net.ServicePoint> objet est inactif lorsque la liste des connexions est associée la <xref:System.Net.ServicePoint> objet est vide.  
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> est inférieur à <see cref="F:System.Threading.Timeout.Infinite" /> ou supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">pour les autorisations Web illimitées. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal d'objets <see cref="T:System.Net.ServicePoint" /> à conserver à tout moment.</summary>
        <value>Nombre maximal d'objets <see cref="T:System.Net.ServicePoint" /> à conserver. La valeur par défaut est 0, ce qui signifie que le nombre d'objets <see cref="T:System.Net.ServicePoint" /> est illimité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous diminuez la <xref:System.Net.ServicePointManager.MaxServicePoints%2A> propriété dessous du nombre de <xref:System.Net.ServicePoint> objets en cours d’existence, la <xref:System.Net.ServicePointManager> supprime le <xref:System.Net.ServicePoint> objets avec les temps d’inactivité plus longue. Si le nombre de <xref:System.Net.ServicePoint> objets avec des connexions actives est supérieur à la valeur de <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, la <xref:System.Net.ServicePointManager> objet supprime le <xref:System.Net.ServicePoint> objets qu’ils deviennent inactifs.  
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> est inférieur à 0 ou supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">pour les autorisations Web illimitées. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si cette propriété est définie sur <see langword="true" />, toutes les connexions TCP sortantes depuis HttpWebRequest utilisent l'option de socket native SO_REUSE_UNICASTPORT sur le socket. Les ports sortants sous-jacents sont alors partagés. Cela est utile quand un nombre élevé de connexions sortantes est effectué dans une courte période et que l'application risque de manquer de ports.</summary>
        <value>Retourne <see cref="T:System.Boolean" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut est `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le protocole de sécurité utilisé par les objets <see cref="T:System.Net.ServicePoint" /> gérés par cet objet <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Une des valeurs définies dans l'énumération <see cref="T:System.Net.SecurityProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Cette propriété sélectionne la version du protocole Secure Sockets Layer (SSL) ou de sécurité TLS (Transport Layer) à utiliser pour les nouvelles connexions ; les connexions existantes ne sont pas modifiées.  
  
À compter de .NET Framework 4.7, la valeur de par défaut de cette propriété est <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Cela permet la mise en réseau en fonction des API de .NET Framework <xref:System.Net.Security.SslStream> (par exemple, FTP, HTTP et SMTP) d’hériter les protocoles de sécurité par défaut du système d’exploitation ou à partir de toutes les configurations personnalisées effectuées par un administrateur système. Pour plus d’informations sur les SSL/TLS protocoles sont activés par défaut sur chaque version du système d’exploitation Windows, consultez [protocoles dans TLS/SSL (Schannel SSP)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Pour les versions du .NET Framework via le Kit de développement .NET Framework 4.6.2, sans valeur par défaut est répertorié pour cette propriété. Le paysage de la sécurité en perpétuelle évolution et par défaut de protocoles et les niveaux de protection sont modifiés au fil du temps afin d’éviter les faiblesses connues. Valeurs par défaut varient selon la configuration de l’ordinateur individuel, les logiciels installés et les correctifs appliqués.  
  
 Votre code ne doit jamais implicitement dépendent à l’aide d’un niveau de protection particulier, ou sur l’hypothèse qu’un niveau de sécurité donné est utilisé par défaut. Si votre application dépend de l’utilisation d’un niveau de sécurité particulier, vous devez spécifier explicitement ce niveau, puis vérifiez pour être sûr qu’il est réellement en cours d’utilisation sur la connexion établie. En outre, votre code doit être conçu pour être robustes face aux modifications dans lequel les protocoles sont pris en charge, par conséquent sont souvent apporter des changements peu préavis afin d’atténuer les menaces émergentes.  
  
 Le .NET Framework 4.6 inclut une nouvelle fonctionnalité de sécurité qui bloque les algorithmes pour les connexions de hachage et de chiffrement non sécurisé. Applications à l’aide de TLS/SSL via des API telles que HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. et ciblant .NET Framework 4.6 Obtient le comportement plus sécurisés par défaut.  
  
 Les développeurs veulent peuvent désactiver ce comportement afin de maintenir l’interopérabilité avec leurs services SSL3 existants ou TLS avec les services de RC4. [Cet article](https://support.microsoft.com/kb/3069494) explique comment modifier votre code afin que le nouveau comportement est désactivé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La valeur spécifiée pour définir la propriété n’est pas une valeur d’énumération <see cref="T:System.Net.SecurityProtocolType" /> valide.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le rappel de valider un certificat de serveur.</summary>
        <value>
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Une application peut définir le <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> propriété à une méthode à utiliser pour la validation personnalisée par le client du certificat du serveur. Lors de la validation personnalisée, le `sender` paramètre passé à la <xref:System.Net.Security.RemoteCertificateValidationCallback> peut être un nom de chaîne hôte ou un objet dérivé <xref:System.Net.WebRequest> (<xref:System.Net.HttpWebRequest>, par exemple) en fonction de la <xref:System.Net.ServicePointManager.CertificatePolicy%2A> propriété.  
  
Lors de la validation personnalisée n’est pas utilisée, le nom du certificat est comparé avec le nom d’hôte utilisé pour créer la demande. Par exemple, si <xref:System.Net.WebRequest.Create%28System.String%29> a été passé à un paramètre de «https://www.contoso.com/default.html», le comportement par défaut est pour le client vérifie le certificat à www.contoso.com.  

Bien qu’étant un délégué multicast, uniquement la valeur retournée par le Gestionnaire d’événements exécutée en dernier est considéré comme faisant autoritée. En d’autres termes, vous pouvez attacher plusieurs délégués, et obtenir un rappel à partir de <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>. Chaque rappel retourne une valeur qui indique si le certificat est accepté ou non ; Toutefois, seule la valeur à partir du dernier délégué est respectée.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour définir le <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" /> propriété. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="keepAliveTime" Type="System.Int32" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enabled">Si la valeur est true, l’option de persistance (KeepAlive) du TCP sur une connexion TCP sera activée à l’aide des valeurs <paramref name="keepAliveTime" /> et <paramref name="keepAliveInterval" /> spécifiées.  
  
Si la valeur est false, l'option de persistance du TCP est désactivée et les paramètres restants sont ignorés.  
  
La valeur par défaut est false.</param>
        <param name="keepAliveTime">Spécifie le délai d'attente, en millisecondes, sans activité jusqu'à l'envoi du premier paquet persistant.  
  
La valeur doit être supérieure à 0.  Si une valeur inférieure ou égale à zéro est passée, une exception <see cref="T:System.ArgumentOutOfRangeException" /> est levée.</param>
        <param name="keepAliveInterval">Spécifie l'intervalle, en millisecondes, entre les envois des paquets persistants si aucun accusé de réception n'est reçu.  
  
La valeur doit être supérieure à 0.  Si une valeur inférieure ou égale à zéro est passée, une exception <see cref="T:System.ArgumentOutOfRangeException" /> est levée.</param>
        <summary>Active ou désactive l'option permettant de maintenir une connexion TCP active.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application peut demander qu’un fournisseur TCP/IP permettent d’utiliser des paquets keep-alive sur une connexion TCP. La valeur par défaut est que l’utilisation de paquets keep-alive sur une connexion TCP est désactivée.  
  
 Les paramètres par défaut lorsqu’un socket TCP est initialisé le délai d’expiration des jeux le keep-alive à 2 heures et l’intervalle KeepAlive à 1 seconde. Le `keepAliveTime` paramètre spécifie le délai d’attente, en millisecondes, sans activité jusqu'à ce que le premier paquet persistant est envoyé. Le `keepAliveInterval` paramètre spécifie l’intervalle, en millisecondes, entre envoi de paquets keep-alive successives si aucun accusé de réception. Le nombre de sondes keep-alive ne peut pas être modifié et est défini sur 10.  
  
 Si une connexion TCP est supprimée en tant que le résultat de connexions persistantes, un <xref:System.Net.Sockets.SocketError> de <xref:System.Net.Sockets.SocketError.NetworkReset> est retournée pour tous les appels en cours d’exécution sur le socket, et tous les appels suivants échoueront avec un <xref:System.Net.Sockets.SocketError> de <xref:System.Net.Sockets.SocketError.NotConnected>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée pour le paramètre <paramref name="keepAliveTime" /> ou <paramref name="keepAliveInterval" /> est inférieure ou égale à 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si l'algorithme Nagle est utilisé par les points de service gérés par cet objet <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>
          <see langword="true" /> pour utiliser l'algorithme Nagle ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’algorithme Nagle est utilisé pour réduire le trafic réseau par la mise en mémoire tampon de petits paquets de données et les transmettre en tant qu’un seul paquet. Ce processus est également appelé « nagling » ; Il est largement utilisé, car il réduit le nombre de paquets transmis et réduit la surcharge par paquet.  
  
 Modification de la valeur de cette propriété n’affecte pas existant <xref:System.Net.ServicePoint> objets. Seuls points de service créées après la modification sont affectés.  
  
 L’algorithme Nagle est décrite en détail dans IETF RFC 896.  
  
   
  
## Examples  
 L’exemple de code suivant définit cette propriété.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>