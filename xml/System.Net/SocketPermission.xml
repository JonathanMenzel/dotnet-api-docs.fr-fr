<Type Name="SocketPermission" FullName="System.Net.SocketPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac4c73bd39efe04be4531cc25c9b520ac59aa9bf" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30469893" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SocketPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit SocketPermission extends System.Security.CodeAccessPermission implements class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.Net.SocketPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SocketPermission&#xA;Inherits CodeAccessPermission&#xA;Implements IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class SocketPermission sealed : System::Security::CodeAccessPermission, System::Security::Permissions::IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Contrôle les droits d'établissement ou d'acceptation de connexions à une adresse de transport.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.SocketPermission> instances contrôlent l’autorisation d’accepter les connexions ou lancer <xref:System.Net.Sockets.Socket> connexions. A <xref:System.Net.Sockets.Socket> autorisation peut être établie pour un nom d’hôte ou adresse IP, un numéro de port et un protocole de transport.  
  
> [!NOTE]
>  Évitez de créer des autorisations de socket à l’aide de noms d’hôtes, car ces noms doivent être résolus en adresses IP, et cela pourrait bloquer la pile.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la <xref:System.Net.SocketPermission> classe pour définir, modifier et appliquer diverses restrictions d’accès de Sockets.  
  
 [!code-cpp[SocketPermissionExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPermissionExample/CPP/source.cpp#1)]
 [!code-csharp[SocketPermissionExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPermissionExample/CS/source.cs#1)]
 [!code-vb[SocketPermissionExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SocketPermissionExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.SocketPermission" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketPermission(System::Security::Permissions::PermissionState state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Une des valeurs de <see cref="T:System.Security.Permissions.PermissionState" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.SocketPermission" /> qui autorise un accès illimité à <see cref="T:System.Net.Sockets.Socket" /> ou interdit tout accès à <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Net.SocketPermission> instance est créée avec le `Unrestricted` valeur <xref:System.Security.Permissions.PermissionState> le <xref:System.Net.SocketPermission> instance passe toutes les demandes. Toute autre valeur pour `state` entraîne une <xref:System.Net.SocketPermission> instance échoue toutes les demandes, sauf si une autorisation d’adresse de transport est ajoutée avec <xref:System.Net.SocketPermission.AddPermission%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Net.SocketPermission> à l’aide un <xref:System.Security.Permissions.PermissionState> valeur énumérée.  
  
 [!code-cpp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CPP/dateclient_socketpermission_constructor.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CS/dateclient_socketpermission_constructor.cs#1)]
 [!code-vb[dateClient_SocketPermission_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/VB/dateclient_socketpermission_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketPermission (System.Net.NetworkAccess access, System.Net.TransportType transport, string hostName, int portNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.NetworkAccess access, valuetype System.Net.TransportType transport, string hostName, int32 portNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.#ctor(System.Net.NetworkAccess,System.Net.TransportType,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (access As NetworkAccess, transport As TransportType, hostName As String, portNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketPermission(System::Net::NetworkAccess access, System::Net::TransportType transport, System::String ^ hostName, int portNumber);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="access" Type="System.Net.NetworkAccess" />
        <Parameter Name="transport" Type="System.Net.TransportType" />
        <Parameter Name="hostName" Type="System.String" />
        <Parameter Name="portNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="access">Une des valeurs de <see cref="T:System.Net.NetworkAccess" />.</param>
        <param name="transport">Une des valeurs de <see cref="T:System.Net.TransportType" />.</param>
        <param name="hostName">Nom d'hôte de l'adresse de transport.</param>
        <param name="portNumber">Numéro de port de l'adresse de transport.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.SocketPermission" /> pour l'adresse de transport donnée avec l'autorisation spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Net.SocketPermission> qui contrôle l’accès à l’objet `hostName` et `portNumber` à l’aide du `transport`.  
  
 Le `hostName` peut être un nom DNS, une adresse IP ou un sous-réseau IP spécifié, tel que 192.168.1.  
  
 Le `portNumber` peut être n’importe quel numéro de port valide défini par le transport, ou <xref:System.Net.SocketPermission.AllPorts?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Net.SocketPermission> à l’aide un <xref:System.Net.NetworkAccess> valeur, énumérée une <xref:System.Net.TransportType> énumérée valeur, le nom d’hôte et le numéro de port.  
  
 [!code-cpp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CPP/dateclient_socketpermission_constructor.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CS/dateclient_socketpermission_constructor.cs#1)]
 [!code-vb[dateClient_SocketPermission_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/VB/dateclient_socketpermission_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostName" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptList">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator AcceptList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator AcceptList" />
      <MemberSignature Language="DocId" Value="P:System.Net.SocketPermission.AcceptList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptList As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerator ^ AcceptList { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'instances de <see cref="T:System.Net.EndpointPermission" /> identifiant les points de terminaison qui peuvent être acceptés selon cette instance d'autorisation.</summary>
        <value>Instance implémentant l'interface <see cref="T:System.Collections.IEnumerator" /> contenant des instances de <see cref="T:System.Net.EndpointPermission" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.AcceptList%2A> propriété pour retourner une liste de points de terminaison auxquels sont accordés des privilèges d’acceptation.  
  
 [!code-cpp[SocketPermissionExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPermissionExample/CPP/source.cpp#2)]
 [!code-csharp[SocketPermissionExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPermissionExample/CS/source.cs#2)]
 [!code-vb[SocketPermissionExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SocketPermissionExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPermission">
      <MemberSignature Language="C#" Value="public void AddPermission (System.Net.NetworkAccess access, System.Net.TransportType transport, string hostName, int portNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPermission(valuetype System.Net.NetworkAccess access, valuetype System.Net.TransportType transport, string hostName, int32 portNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.AddPermission(System.Net.NetworkAccess,System.Net.TransportType,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPermission (access As NetworkAccess, transport As TransportType, hostName As String, portNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPermission(System::Net::NetworkAccess access, System::Net::TransportType transport, System::String ^ hostName, int portNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="access" Type="System.Net.NetworkAccess" />
        <Parameter Name="transport" Type="System.Net.TransportType" />
        <Parameter Name="hostName" Type="System.String" />
        <Parameter Name="portNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="access">Une des valeurs de <see cref="T:System.Net.NetworkAccess" />.</param>
        <param name="transport">Une des valeurs de <see cref="T:System.Net.TransportType" />.</param>
        <param name="hostName">Nom d'hôte de l'adresse de transport.</param>
        <param name="portNumber">Numéro de port de l'adresse de transport.</param>
        <summary>Ajoute une autorisation au jeu d'autorisations pour une adresse de transport.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `hostName` peut être un nom DNS, une adresse IP ou un sous-réseau IP spécifié, tel que 192.168.1.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.AddPermission%2A> pour ajouter des autorisations de connexion à l’hôte spécifié.  
  
 [!code-cpp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CPP/dateclient_socketpermission_constructor.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CS/dateclient_socketpermission_constructor.cs#1)]
 [!code-vb[dateClient_SocketPermission_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/VB/dateclient_socketpermission_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostName" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllPorts">
      <MemberSignature Language="C#" Value="public const int AllPorts = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 AllPorts = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.Net.SocketPermission.AllPorts" />
      <MemberSignature Language="VB.NET" Value="Public Const AllPorts As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int AllPorts = -1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Définit une constante représentant tous les ports.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ est en lecture seule. La valeur de ce champ est -1.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.AllPorts> propriété afin de fournir des autorisations de connexion à tous les ports de ressources.  
  
 [!code-cpp[DateClient_SocketPermission_Constructor#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CPP/dateclient_socketpermission_constructor.cpp#1)]
 [!code-csharp[DateClient_SocketPermission_Constructor#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CS/dateclient_socketpermission_constructor.cs#1)]
 [!code-vb[DateClient_SocketPermission_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/VB/dateclient_socketpermission_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectList">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator ConnectList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator ConnectList" />
      <MemberSignature Language="DocId" Value="P:System.Net.SocketPermission.ConnectList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectList As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerator ^ ConnectList { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'instances de <see cref="T:System.Net.EndpointPermission" /> identifiant les points de terminaison auxquels vous pouvez vous connecter selon cette instance d'autorisation.</summary>
        <value>Instance implémentant l'interface <see cref="T:System.Collections.IEnumerator" /> contenant des instances de <see cref="T:System.Net.EndpointPermission" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.ConnectList%2A> propriété pour retourner une liste de points de terminaison pour les connexions sont accordés des privilèges.  
  
 [!code-cpp[dateClient_SocketPermission_ToXml#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/CPP/dateclient_socketpermission_toxml.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_ToXml#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/CS/dateclient_socketpermission_toxml.cs#1)]
 [!code-vb[dateClient_SocketPermission_ToXml#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/VB/dateclient_socketpermission_toxml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie d'une instance <see cref="T:System.Net.SocketPermission" />.</summary>
        <returns>Nouvelle instance de la classe <see cref="T:System.Net.SocketPermission" /> qui est une copie de l'instance en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet retourné par cette méthode représente le même niveau d’accès que l’instance actuelle. Cette méthode substitue <xref:System.Security.CodeAccessPermission.Copy%2A> et est implémentée pour prendre en charge la <xref:System.Security.IPermission> interface.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Net.SocketPermission> en effectuant une copie d’un objet <xref:System.Net.SocketPermission>.  
  
 [!code-cpp[SocketPermissionExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPermissionExample/CPP/source.cpp#4)]
 [!code-csharp[SocketPermissionExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPermissionExample/CS/source.cs#4)]
 [!code-vb[SocketPermissionExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SocketPermissionExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement securityElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement securityElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ securityElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityElement" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="securityElement">Encodage XML utilisé pour reconstruire l'instance de <see cref="T:System.Net.SocketPermission" />.</param>
        <summary>Reconstruit une instance de <see cref="T:System.Net.SocketPermission" /> pour un encodage XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.SocketPermission.FromXml%2A> méthode reconstruit un <xref:System.Net.SocketPermission> instance à partir d’un encodage XML défini par la <xref:System.Security.SecurityElement> classe.  
  
 Utilisez le <xref:System.Net.SocketPermission.ToXml%2A> méthode pour encoder le <xref:System.Net.SocketPermission> instance, y compris des informations d’état, au format XML.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.FromXml%2A> méthode pour convertir le XML codé des données à un <xref:System.Net.SocketPermission> instance.  
  
 [!code-cpp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CPP/dateclient_socketpermission_constructor.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_Constructor#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CS/dateclient_socketpermission_constructor.cs#1)]
 [!code-vb[dateClient_SocketPermission_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/VB/dateclient_socketpermission_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityElement" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="securityElement" /> n'est pas un élément d'autorisation pour ce type.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Instance de <see cref="T:System.Net.SocketPermission" /> avec laquelle l’instance actuelle doit entrer en intersection.</param>
        <summary>Retourne l'intersection logique entre deux instances de <see cref="T:System.Net.SocketPermission" />.</summary>
        <returns>Instance de <see cref="T:System.Net.SocketPermission" /> qui représente l'intersection de deux instances de <see cref="T:System.Net.SocketPermission" />. Si l'intersection est vide, la méthode retourne <see langword="null" />. Si le paramètre <paramref name="target" /> est une référence null, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’intersection de deux autorisations est une autorisation qui permet de protéger les ressources et opérations protégées par les deux autorisations. Plus précisément, elle représente les autorisations minimales telles que toute demande passant les deux autorisations passe également leur intersection. Cette méthode substitue <xref:System.Security.CodeAccessPermission.Intersect%2A> et est implémentée pour prendre en charge la <xref:System.Security.IPermission> interface.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.Intersect%2A> méthode pour obtenir une intersection logique entre deux <xref:System.Net.SocketPermission> instances.  
  
 [!code-cpp[DateClient_SocketPermission_Constructor#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CPP/dateclient_socketpermission_constructor.cpp#1)]
 [!code-csharp[DateClient_SocketPermission_Constructor#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/CS/dateclient_socketpermission_constructor.cs#1)]
 [!code-vb[DateClient_SocketPermission_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_Constructor/VB/dateclient_socketpermission_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="target" /> n'est pas un <see cref="T:System.Net.SocketPermission" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Net.DnsPermission" /> n'est pas accordé à l'appelant de la méthode.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Net.SocketPermission" /> qui doit être testé pour la relation de sous-ensemble.</param>
        <summary>Détermine si l'autorisation actuelle est un sous-ensemble de l'autorisation spécifiée.</summary>
        <returns>Si <paramref name="target" /> est <see langword="null" />, cette méthode retourne <see langword="true" /> si l'instance en cours ne définit aucune autorisation ; sinon, <see langword="false" />. Si <paramref name="target" /> n'est pas <see langword="null" />, cette méthode retourne <see langword="true" /> si l'instance en cours définit un sous-ensemble d'autorisations <paramref name="target" /> ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’autorisation actuelle est un sous-ensemble de l’autorisation spécifiée si l’autorisation actuelle spécifie un ensemble d’opérations qui est entièrement contenu par l’autorisation spécifiée.  
  
 Par exemple, une autorisation qui représente l’accès à 192.168.1.1 : 80 est un sous-ensemble d’une autorisation qui représente l’accès à 192.168.1.1:Any. Si cette méthode retourne `true`, l’autorisation en cours ne représente pas plus d’accès à la ressource protégée que l’autorisation spécifiée.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.IsSubsetOf%2A> pour déterminer si une méthode <xref:System.Net.SocketPermission> est le sous-ensemble d’un autre.  
  
 [!code-cpp[SocketPermissionExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPermissionExample/CPP/source.cpp#2)]
 [!code-csharp[SocketPermissionExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPermissionExample/CS/source.cs#2)]
 [!code-vb[SocketPermissionExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SocketPermissionExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> n'est pas un <see cref="T:System.Net.Sockets.SocketException" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Net.DnsPermission" /> n'est pas accordé à l'appelant de la méthode.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie l’état d’autorisation général de l’objet.</summary>
        <returns>
          <see langword="true" /> si l'instance de <see cref="T:System.Net.SocketPermission" /> est créée avec la valeur <see langword="Unrestricted" /> à partir de <see cref="T:System.Security.Permissions.PermissionState" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie le <xref:System.Net.SocketPermission.IsUnrestricted%2A> propriété pour déterminer si le texte spécifié <xref:System.Net.SocketPermission> possède des restrictions.  
  
 [!code-cpp[dateClient_SocketPermission_ToXml#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/CPP/dateclient_socketpermission_toxml.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_ToXml#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/CS/dateclient_socketpermission_toxml.cs#1)]
 [!code-vb[dateClient_SocketPermission_ToXml#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/VB/dateclient_socketpermission_toxml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un encodage XML d’une instance de <see cref="T:System.Net.SocketPermission" /> et de son état actuel.</summary>
        <returns>Instance de <see cref="T:System.Security.SecurityElement" /> contenant une représentation encodée XML de l'instance de <see cref="T:System.Net.SocketPermission" />, informations d'état comprises</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.SocketPermission.ToXml%2A> méthode crée un <xref:System.Security.SecurityElement> instance pour encoder une représentation de la <xref:System.Net.SocketPermission> instance, y compris des informations d’état, au format XML.  
  
 Utilisez le <xref:System.Net.SocketPermission.FromXml%2A> méthode pour restaurer les informations d’état d’un <xref:System.Security.SecurityElement> instance.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.ToXml%2A> méthode pour convertir un <xref:System.Net.SocketPermission> au format XML.  
  
 [!code-cpp[dateClient_SocketPermission_ToXml#1](~/samples/snippets/cpp/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/CPP/dateclient_socketpermission_toxml.cpp#1)]
 [!code-csharp[dateClient_SocketPermission_ToXml#1](~/samples/snippets/csharp/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/CS/dateclient_socketpermission_toxml.cs#1)]
 [!code-vb[dateClient_SocketPermission_ToXml#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/DateClient_SocketPermission_ToXml/VB/dateclient_socketpermission_toxml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.SocketPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Instance de <see cref="T:System.Net.SocketPermission" /> à combiner avec l’instance actuelle.</param>
        <summary>Retourne l'union logique entre deux instances de <see cref="T:System.Net.SocketPermission" />.</summary>
        <returns>Instance de <see cref="T:System.Net.SocketPermission" /> qui représente l'union de deux instances de <see cref="T:System.Net.SocketPermission" />. Si le paramètre <paramref name="target" /> est <see langword="null" />, il retourne une copie de l'instance en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat d’un appel à <xref:System.Net.SocketPermission.Union%2A> est une autorisation qui représente l’ensemble de l’accès à <xref:System.Net.Sockets.Socket> connexions représentées par l’instance actuelle, ainsi que l’accès représenté par `target`. Toute demande qui passe l’instance actuelle ou `target` passent leur union. Cette méthode substitue <xref:System.Security.CodeAccessPermission.Union%2A> et est implémentée pour prendre en charge la <xref:System.Security.IPermission> interface.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Net.SocketPermission.Union%2A> méthode pour retourner l’union logique existante deux <xref:System.Net.SocketPermission> instances.  
  
 [!code-cpp[SocketPermissionExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPermissionExample/CPP/source.cpp#2)]
 [!code-csharp[SocketPermissionExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPermissionExample/CS/source.cs#2)]
 [!code-vb[SocketPermissionExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SocketPermissionExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> n'est pas un <see cref="T:System.Net.SocketPermission" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>