<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BufferedGraphicsContext.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56cebe4384e5215400e3718cf0dc794274c63580a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6cebe4384e5215400e3718cf0dc794274c63580a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>Provides methods for creating graphics buffers that can be used for double buffering.</source>
          <target state="translated">Fournit des méthodes permettant de créer des mémoires tampons de graphiques qui peuvent être utilisées pour le mécanisme de double tampon.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>The <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> class allows you to implement custom double buffering for your graphics.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> classe vous permet d’implémenter le mécanisme de double tampon personnalisé pour vos graphiques.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>Graphics that use double buffering can reduce or eliminate flicker that is caused by redrawing a display surface.</source>
          <target state="translated">Les graphiques qui utilisent le mécanisme de double tampon réduire ou éliminer le scintillement provoqué par le rafraîchissement du dessin une surface d’affichage.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>The simplest way to use double buffering is to set the <ph id="ph1">&lt;xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer&gt;</ph> control style flag on a control using the <ph id="ph2">&lt;xref:System.Windows.Forms.Control.SetStyle%2A&gt;</ph> method.</source>
          <target state="translated">La façon la plus simple d’utiliser le mécanisme de double tampon consiste à définir le <ph id="ph1">&lt;xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer&gt;</ph> contrôler l’indicateur de style sur un contrôle à l’aide de la <ph id="ph2">&lt;xref:System.Windows.Forms.Control.SetStyle%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer&gt;</ph> control styles flag for a control redirects all painting for the control through a default graphics buffer, without requiring any additional code.</source>
          <target state="translated">Définition de la <ph id="ph1">&lt;xref:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer&gt;</ph> indicateur de styles de contrôle pour un contrôle redirige toute la peinture du contrôle via une mémoire tampon de graphiques par défaut, sans requérir de code supplémentaire.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>This flag is set to <ph id="ph1">`true`</ph> by default.</source>
          <target state="translated">Cet indicateur est défini <ph id="ph1">`true`</ph> par défaut.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>The <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> class provides methods for creating and configuring a graphics buffer.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> classe fournit des méthodes pour créer et configurer une mémoire tampon de graphiques.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>The <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method creates a <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph>, which is a wrapper for a graphics buffer that also provides methods you can use to write to the buffer and render its contents to an output device.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> méthode crée un <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph>, qui est un wrapper pour une mémoire tampon de graphiques qui fournit également des méthodes que vous pouvez utiliser pour écrire dans la mémoire tampon et restituer son contenu sur un périphérique de sortie.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>You can retrieve the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> for the current application domain from the static <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsManager.Current%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Vous pouvez récupérer le <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> pour le domaine d’application actuel à partir de la méthode statique <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsManager.Current%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>For graphically intensive applications such as animation, you can create a dedicated <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> using the constructor, but for most applications the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsManager.Current%2A?displayProperty=nameWithType&gt;</ph> property will be sufficient.</source>
          <target state="translated">Pour les applications gourmandes en ressources graphiques telles que l’animation, vous pouvez créer une dédiée <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> en utilisant le constructeur, mais la plupart des applications le <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsManager.Current%2A?displayProperty=nameWithType&gt;</ph> propriété seront suffisante.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>For more information on drawing buffered graphics and custom buffering implementations, see <bpt id="p1">[</bpt>Double Buffered Graphics<ept id="p1">](~/docs/framework/winforms/advanced/double-buffered-graphics.md)</ept> and <bpt id="p2">[</bpt>How to: Manually Manage Buffered Graphics<ept id="p2">](~/docs/framework/winforms/advanced/how-to-manually-manage-buffered-graphics.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur le dessin des graphiques mis en mémoire tampon et la mise en mémoire tampon des implémentations personnalisées, consultez <bpt id="p1">[</bpt>Double Buffered Graphics<ept id="p1">](~/docs/framework/winforms/advanced/double-buffered-graphics.md)</ept> et <bpt id="p2">[</bpt>Comment : gérer manuellement mis en mémoire tampon des graphiques<ept id="p2">](~/docs/framework/winforms/advanced/how-to-manually-manage-buffered-graphics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>The following code example demonstrates how to acquire the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> for the current application domain.</source>
          <target state="translated">L’exemple de code suivant montre comment acquérir la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> pour le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphicsContext" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphicsContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.#ctor">
          <source>For graphically intensive applications such as animation, you can sometimes improve performance by using a dedicated <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> instead of the default instance provided by the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsManager&gt;</ph>.</source>
          <target state="translated">Pour les applications gourmandes en ressources graphiques telles que l’animation, vous pouvez parfois améliorer les performances en utilisant une dédiée <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> au lieu de l’instance par défaut fournie par le <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsManager&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.#ctor">
          <source>This allows you to create and manage graphics buffers individually.</source>
          <target state="translated">Cela vous permet de créer et gérer les mémoires tampon de graphiques individuellement.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.#ctor">
          <source>You should always call <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> when you finish using a dedicated <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</source>
          <target state="translated">Vous devez toujours appeler <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> lorsque vous avez terminé à l’aide d’une dédiée <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.#ctor">
          <source>For more information about dedicated graphics buffers, see <bpt id="p1">[</bpt>How to: Manually Manage Buffered Graphics<ept id="p1">](~/docs/framework/winforms/advanced/how-to-manually-manage-buffered-graphics.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les mémoires tampons de graphiques dédiées, consultez <bpt id="p1">[</bpt>Comment : gérer manuellement mis en mémoire tampon des graphiques<ept id="p1">](~/docs/framework/winforms/advanced/how-to-manually-manage-buffered-graphics.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="T:System.Drawing.BufferedGraphicsContext">
          <source>Creates a graphics buffer.</source>
          <target state="translated">Crée une mémoire tampon de graphiques.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Drawing.Graphics" /&gt;</ph> to match the pixel format for the new buffer to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Drawing.Graphics" /&gt;</ph> pour correspondre au format pixel de la nouvelle mémoire tampon.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Drawing.Rectangle" /&gt;</ph> indicating the size of the buffer to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Drawing.Rectangle" /&gt;</ph> indiquant la taille de la mémoire tampon à créer.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>Creates a graphics buffer of the specified size using the pixel format of the specified <ph id="ph1">&lt;see cref="T:System.Drawing.Graphics" /&gt;</ph>.</source>
          <target state="translated">Crée une mémoire tampon de graphiques de la taille spécifiée à l'aide du format pixel du <ph id="ph1">&lt;see cref="T:System.Drawing.Graphics" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphics" /&gt;</ph> that can be used to draw to a buffer of the specified dimensions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphics" /&gt;</ph> qui peut être utilisé pour dessiner dans une mémoire tampon des dimensions spécifiées.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method with a rectangle whose size exceeds the value of the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext.MaximumBuffer%2A&gt;</ph> property, a temporary <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> is created to allocate the buffer and provide a temporary context for the buffer.</source>
          <target state="translated">Lorsque vous appelez le <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> méthode avec un rectangle dont la taille dépasse la valeur de la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext.MaximumBuffer%2A&gt;</ph> propriété, une valeur temporaire <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> est créé pour allouer la mémoire tampon et de fournir un contexte temporaire pour la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>The new <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> is distinct from the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> for the application domain and it is disposed automatically when the <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> returned by the <ph id="ph4">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method is disposed.</source>
          <target state="translated">La nouvelle <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> est différente de la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> pour l’application de domaine et il est supprimé automatiquement lorsque le <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> retourné par la <ph id="ph4">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> méthode est supprimée.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>The following code example demonstrates creating a graphics buffer using the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre la création d’une mémoire tampon de graphiques à l’aide de la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.Drawing.Graphics,System.Drawing.Rectangle)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> to a device context to match the pixel format of the new buffer to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> pour qu'un contexte de périphérique (Device Context) corresponde au format pixel de la nouvelle mémoire tampon.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Drawing.Rectangle" /&gt;</ph> indicating the size of the buffer to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Drawing.Rectangle" /&gt;</ph> indiquant la taille de la mémoire tampon à créer.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>Creates a graphics buffer of the specified size using the pixel format of the specified <ph id="ph1">&lt;see cref="T:System.Drawing.Graphics" /&gt;</ph>.</source>
          <target state="translated">Crée une mémoire tampon de graphiques de la taille spécifiée à l'aide du format pixel du <ph id="ph1">&lt;see cref="T:System.Drawing.Graphics" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphics" /&gt;</ph> that can be used to draw to a buffer of the specified dimensions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphics" /&gt;</ph> qui peut être utilisé pour dessiner dans une mémoire tampon des dimensions spécifiées.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method with a rectangle whose size exceeds the value of the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext.MaximumBuffer%2A&gt;</ph> property, a temporary <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> is created to allocate the buffer and provide a temporary context for the buffer.</source>
          <target state="translated">Lorsque vous appelez le <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> méthode avec un rectangle dont la taille dépasse la valeur de la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext.MaximumBuffer%2A&gt;</ph> propriété, une valeur temporaire <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> est créé pour allouer la mémoire tampon et de fournir un contexte temporaire pour la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>The new <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> is distinct from the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> for the application domain and it is disposed automatically when the <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> returned by the <ph id="ph4">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method is disposed.</source>
          <target state="translated">La nouvelle <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> est différente de la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> pour l’application de domaine et il est supprimé automatiquement lorsque le <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> retourné par la <ph id="ph4">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> méthode est supprimée.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>The following code example demonstrates creating a graphics buffer using the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre la création d’une mémoire tampon de graphiques à l’aide de la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Allocate%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>for access to unmanaged code.</source>
          <target state="translated">Pour accéder au code non managé.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Allocate(System.IntPtr,System.Drawing.Rectangle)">
          <source>Related enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphicsContext" /&gt;</ph>.</source>
          <target state="translated">Libère toutes les ressources utilisées par <ph id="ph1">&lt;see cref="T:System.Drawing.BufferedGraphicsContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</source>
          <target state="translated">Appelez la méthode <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> une fois que vous avez terminé d'utiliser <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> in an unusable state.</source>
          <target state="translated">La méthode <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> rend le <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> inutilisable.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> was occupying.</source>
          <target state="translated">Après avoir appelé <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph>, vous devez libérer toutes les références à la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> pour que le garbage collector puisse récupérer la mémoire qui le <ph id="ph3">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph> occupée.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> et <bpt id="p2">[</bpt>implémentant une méthode de suppression<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</source>
          <target state="translated">Appelez toujours <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.Dispose%2A&gt;</ph> avant de libérer votre dernière référence à <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</source>
          <target state="translated">Sinon, les ressources qu’il utilise ne seront pas libérées tant que le garbage collector du <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Finalize">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
          <target state="translated">Autorise un objet à tenter de libérer des ressources et à exécuter d'autres opérations de nettoyage avant qu'il ne soit récupéré par une opération garbage collection.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Drawing.BufferedGraphicsContext.Invalidate">
          <source>Disposes of the current graphics buffer, if a buffer has been allocated and has not yet been disposed.</source>
          <target state="translated">Supprime la mémoire tampon de graphiques active, si une mémoire tampon a été allouée et n'a pas encore été supprimée.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Drawing.BufferedGraphicsContext.Invalidate">
          <source>If the graphics buffer is in use, it will be marked for disposal as soon as it is free; otherwise, it will be disposed immediately.</source>
          <target state="translated">Si la mémoire tampon de graphiques est en cours d’utilisation, elle est marquée pour suppression dès qu’il est disponible ; Sinon, elle est immédiatement supprimée.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>Gets or sets the maximum size of the buffer to use.</source>
          <target state="translated">Obtient ou définit la taille maximale de la mémoire tampon à utiliser.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>A <ph id="ph1">&lt;see cref="T:System.Drawing.Size" /&gt;</ph> indicating the maximum size of the buffer dimensions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Drawing.Size" /&gt;</ph> indiquant la taille maximale des dimensions de la mémoire tampon.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>This property allows you to get or set the maximum dimensions for a buffer that should be retained in memory.</source>
          <target state="translated">Cette propriété permet d’obtenir ou définir les dimensions maximales pour une mémoire tampon qui doit être conservée en mémoire.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>You can allocate a buffer of any size, however any buffer with dimensions greater than the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.MaximumBuffer%2A&gt;</ph> size will be used temporarily and then discarded when the <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> object is released.</source>
          <target state="translated">Vous pouvez allouer une mémoire tampon de n’importe quelle taille, toutefois, les mettre en mémoire tampon des dimensions supérieure à la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext.MaximumBuffer%2A&gt;</ph> taille sera utilisée temporairement et puis ignorées lorsque la <ph id="ph2">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> objet est libéré.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>The following example demonstrates setting the maximum size for the buffer for a <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</source>
          <target state="translated">L’exemple suivant illustre la définition de la taille maximale de la mémoire tampon pour un <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphicsContext&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> class.</source>
          <target state="translated">Ce code fait partie d’un exemple plus complet fourni pour la <ph id="ph1">&lt;xref:System.Drawing.BufferedGraphics&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>The height or width of the size is less than or equal to zero.</source>
          <target state="translated">La hauteur ou la largeur de la taille est inférieure ou égale à zéro.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>for allowing user access to all windows.</source>
          <target state="translated">Pour autoriser l’accès utilisateur à toutes les fenêtres.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Drawing.BufferedGraphicsContext.MaximumBuffer">
          <source>Related enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>