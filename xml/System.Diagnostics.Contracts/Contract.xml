<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="83aa0-101">Contient des méthodes statiques pour représenter des contrats de programme tels que conditions préalables, post-conditions et invariants objet.</span><span class="sxs-lookup"><span data-stu-id="83aa0-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-102">Classes de contrat de code vous permettent de spécifier des conditions préalables, post-conditions et invariants d’objet dans votre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="83aa0-103">Les conditions préalables sont des exigences qui doivent être satisfaites à l'entrée d'une méthode ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="83aa0-104">Les post-conditions décrivent les attentes à la sortie de la méthode ou de la propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="83aa0-105">Les invariants d’objet décrivent l’état attendu pour une classe qui ne présente aucun problème de condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="83aa0-106">Pour plus d’informations sur les conditions préalables, post-conditions et invariants d’objet, consultez [les contrats de Code](~/docs/framework/debug-trace-profile/code-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="83aa0-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="83aa0-107">Pour télécharger les outils et obtenir des instructions détaillées sur l’utilisation des contrats de code, consultez [Contrats de code](http://go.microsoft.com/fwlink/?LinkId=152461) sur le site web MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="83aa0-107">For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="83aa0-108">Vous devez utiliser un module de réécriture binaire pour insérer la mise en œuvre de l’exécution de contrats.</span><span class="sxs-lookup"><span data-stu-id="83aa0-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="83aa0-109">Dans le cas contraire, les contrats tels que la <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> méthode peut uniquement être testé statiquement et ne lèvera pas d’exceptions pendant l’exécution si un contrat est violé.</span><span class="sxs-lookup"><span data-stu-id="83aa0-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="83aa0-110">Vous pouvez télécharger le module de réécriture binaire CCRewrite à partir de [les contrats de Code](http://go.microsoft.com/fwlink/?LinkId=152461) sur le site Web MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="83aa0-110">You can download the binary rewriter CCRewrite from [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="83aa0-111">CCRewrite est fourni avec un complément Visual Studio qui vous permet d’activer la mise en œuvre de contrat d’exécution à partir du projet **propriétés** page.</span><span class="sxs-lookup"><span data-stu-id="83aa0-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="83aa0-112">Le module de réécriture binaire et le complément Visual Studio ne sont pas fournis avec [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] ou le Kit de développement logiciel Windows.</span><span class="sxs-lookup"><span data-stu-id="83aa0-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="83aa0-113">Dans les versions Debug, exécute un test à l'exécution pour une condition spécifiée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-113">In debug builds, performs a run-time test for a specified condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-114">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-114">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="83aa0-115">Vérifie une condition ; si la condition est <see langword="false" />, suit la stratégie d'escalade définie pour l'analyseur.</span><span class="sxs-lookup"><span data-stu-id="83aa0-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-116">La stratégie d’escalade par défaut consiste à signaler au débogueur un échec de contrat ou à afficher une **Assert** boîte de dialogue si un débogueur n’est pas attaché.</span><span class="sxs-lookup"><span data-stu-id="83aa0-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="83aa0-117">Si vous le souhaitez, l’analyseur peut être paramétrée pour lever une exception.</span><span class="sxs-lookup"><span data-stu-id="83aa0-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-118">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-118">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-119">Message à afficher si la condition n'est pas remplie.</span><span class="sxs-lookup"><span data-stu-id="83aa0-119">A message to display if the condition is not met.</span></span></param>
        <summary><span data-ttu-id="83aa0-120">Vérifie une condition ; si la condition est <see langword="false" />, suit la stratégie d'escalade définie par l'analyseur et affiche le message spécifié.</span><span class="sxs-lookup"><span data-stu-id="83aa0-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-121">La stratégie d’escalade par défaut consiste à signaler au débogueur un échec de contrat ou à afficher une **Assert** boîte de dialogue si un débogueur n’est pas attaché.</span><span class="sxs-lookup"><span data-stu-id="83aa0-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="83aa0-122">Si vous le souhaitez, l’analyseur peut être paramétrée pour lever une exception.</span><span class="sxs-lookup"><span data-stu-id="83aa0-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="83aa0-123">Le `userMessage` paramètre est passé à la sortie du débogueur.</span><span class="sxs-lookup"><span data-stu-id="83aa0-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="83aa0-124">Si `userMessage` n’est pas une chaîne constante littérale, outils peut-être pas en mesure de le lire.</span><span class="sxs-lookup"><span data-stu-id="83aa0-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="83aa0-125">Fait en sorte que les outils d'analyse du code supposent qu'une condition est <see langword="true" />, même s'il ne peut pas être prouvé statiquement qu'elle est toujours <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-126">Expression conditionnelle à supposer comme <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-126">The conditional expression to assume <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="83aa0-127">Fait en sorte que les outils d'analyse du code supposent que la condition spécifiée est <see langword="true" />, même s'il ne peut pas être prouvé statiquement qu'elle est toujours <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-128">Au moment de l’exécution à l’aide de cette méthode équivaut à l’aide de la <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="83aa0-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-129">Expression conditionnelle à supposer comme <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-129">The conditional expression to assume <see langword="true" />.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-130">Message à envoyer si l'hypothèse échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-130">The message to post if the assumption fails.</span></span></param>
        <summary><span data-ttu-id="83aa0-131">Fait en sorte que les outils d'analyse du code supposent qu'une condition est <see langword="true" />, même s'il ne peut pas être prouvé statiquement qu'elle est toujours <see langword="true" />, et affiche un message si l'hypothèse échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-132">Si `userMessage` n’est pas une chaîne constante littérale, le contrat ne peut pas être compris par les outils.</span><span class="sxs-lookup"><span data-stu-id="83aa0-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="83aa0-133">Au moment de l’exécution à l’aide de cette méthode équivaut à l’aide de la <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="83aa0-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="83aa0-134">Se produit quand un contrat échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-134">Occurs when a contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-135">Les informations d’événement pour cet événement sont fournies par le <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> objet est passé au gestionnaire d’événements.</span><span class="sxs-lookup"><span data-stu-id="83aa0-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="83aa0-136">Cet événement signale un environnement d’application managé comme un interpréteur interactif ou un hôte de navigateur Web dont le contrat a échoué.</span><span class="sxs-lookup"><span data-stu-id="83aa0-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="83aa0-137">Avant cela, il déclenche un événement une application peut gérer qu’elle juge appropriée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="83aa0-138">Par exemple, si le code est en cours d’exécution dans une infrastructure de test, vous pouvez connecter un échec de test et puis terminer le test.</span><span class="sxs-lookup"><span data-stu-id="83aa0-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="83aa0-139">L’implémentation par défaut de la <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> méthode dans la bibliothèque de classes .NET Framework consiste à appeler chaque gestionnaire inscrit avec le <xref:System.Diagnostics.Contracts.Contract.ContractFailed> événement.</span><span class="sxs-lookup"><span data-stu-id="83aa0-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="83aa0-140">Les exceptions levées par les gestionnaires sont ignorées, mais chaque gestionnaire peut indiquer si l’échec est contrôlé en appelant le <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> méthode pour les arguments d’événement.</span><span class="sxs-lookup"><span data-stu-id="83aa0-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="83aa0-141">Si un gestionnaire définit l’échec comme géré, la méthode retourne `null` et aucune action supplémentaire n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="83aa0-142">Gestionnaires peuvent également appeler le <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> méthode pour indiquer au code de déroulement.</span><span class="sxs-lookup"><span data-stu-id="83aa0-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="83aa0-143">Dans ce cas, une exception est levée après que tous les gestionnaires ont été exécutés.</span><span class="sxs-lookup"><span data-stu-id="83aa0-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="83aa0-144">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="83aa0-144">requires full trust for the immediate caller.</span></span> <span data-ttu-id="83aa0-145">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="83aa0-145">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="83aa0-146">Marque la fin de la section de contrat quand les contrats d’une méthode contiennent uniquement des conditions préalables sous la forme <see langword="if" />-<see langword="then" />-<see langword="throw" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-147">La plupart du code contient déjà une validation des paramètres sous la forme de `if` - `then` - `throw` code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="83aa0-148">Les outils de contrat reconnaissent `if` - `then` - `throw` instructions sous les conditions préalables lorsque les instructions apparaissent en premier à l’intérieur d’une méthode, et l’ensemble de ces instructions est suivi par un explicite<xref:System.Diagnostics.Contracts.Contract> appel de méthode, comme un <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, ou <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="83aa0-149">Lorsque `if` - `then` - `throw` instructions apparaissent sous cette forme, les outils de contrat les reconnaissent en tant que hérité-nécessitent des instructions.</span><span class="sxs-lookup"><span data-stu-id="83aa0-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="83aa0-150">Le <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> forme est utilisée uniquement si aucun autre contrat ne suit la `if` - `then` - `throw` séquences, mais ils doivent toujours être référencées comme hérité-requiert.</span><span class="sxs-lookup"><span data-stu-id="83aa0-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="83aa0-151">Spécifie un contrat de post-condition pour la méthode englobante ou la propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-151">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-152">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-152">The conditional expression to test.</span></span> <span data-ttu-id="83aa0-153">L'expression peut inclure des valeurs <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> et <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <summary><span data-ttu-id="83aa0-154">Spécifie un contrat de post-condition pour la méthode englobante ou la propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-154">Specifies a postcondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-155">Le `condition` paramètre spécifie une post-condition est censée être `true` lorsque la méthode englobante ou la propriété est retournée normalement.</span><span class="sxs-lookup"><span data-stu-id="83aa0-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="83aa0-156">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-157">Vous devez utiliser le module de réécriture binaire (disponible à l’adresse [les contrats de Code](http://go.microsoft.com/fwlink/?LinkId=152461) sur le site Web MSDN DevLabs) pour la mise en œuvre de l’exécution de cette post-condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-157">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83aa0-158">L’exemple suivant montre comment utiliser le <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> pour s’assurer qu’une valeur attendue est retournée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="83aa0-159">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-160">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-160">The conditional expression to test.</span></span> <span data-ttu-id="83aa0-161">L'expression peut inclure des valeurs <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> et <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-162">Message à afficher si l'expression n'est pas <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-162">The message to display if the expression is not <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="83aa0-163">Spécifie un contrat de post-condition pour une condition de sortie fournie et un message à afficher si la condition est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-164">Le `condition` paramètre spécifie une post-condition est censée être `true` lorsque la méthode englobante ou la propriété est retournée normalement.</span><span class="sxs-lookup"><span data-stu-id="83aa0-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="83aa0-165">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-166">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-167">Vous devez utiliser le module de réécriture binaire (disponible à l’adresse [les contrats de Code](http://go.microsoft.com/fwlink/?LinkId=152461) sur le site Web MSDN DevLabs) pour la mise en œuvre de l’exécution de cette post-condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-167">You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="83aa0-168">Si `userMessage` n’est pas une chaîne constante littérale, le contrat ne peut pas être compris par les outils.</span><span class="sxs-lookup"><span data-stu-id="83aa0-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="83aa0-169">Spécifie un contrat de post-condition pour la méthode englobante ou la propriété en fonction de l'exception et de la condition fournies.</span><span class="sxs-lookup"><span data-stu-id="83aa0-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="83aa0-170">Type d'exception qui appelle la vérification de post-condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-170">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="83aa0-171">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-171">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="83aa0-172">Spécifie un contrat de post-condition pour la méthode englobante ou la propriété en fonction de l'exception et de la condition fournies.</span><span class="sxs-lookup"><span data-stu-id="83aa0-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-173">Le `condition` paramètre spécifie une post-condition est censée être `true` lorsque la méthode englobante ou la propriété se termine anormalement et qu’une exception de type `TException` est levée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="83aa0-174">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-175">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-176">Vous devez utiliser le module de réécriture binaire pour l’application d’exécution de cette post-condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="83aa0-177">Type d'exception qui appelle la vérification de post-condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-177">The type of exception that invokes the postcondition check.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="83aa0-178">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-178">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-179">Message à afficher si l'expression est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-179">The message to display if the expression is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="83aa0-180">Spécifie un contrat de post-condition et un message à afficher si la condition est <see langword="false" /> pour la méthode englobante ou la propriété, en fonction de l'exception et de la condition fournies.</span><span class="sxs-lookup"><span data-stu-id="83aa0-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-181">Le `condition` paramètre spécifie une post-condition est censée être `true` lorsque la méthode englobante ou la propriété se termine anormalement et qu’une exception de type `TException` est levée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="83aa0-182">Le `message` paramètre spécifie un message à afficher si la condition est `false`.</span><span class="sxs-lookup"><span data-stu-id="83aa0-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="83aa0-183">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-184">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-185">Vous devez utiliser le module de réécriture binaire pour l’application d’exécution de cette post-condition.</span><span class="sxs-lookup"><span data-stu-id="83aa0-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="83aa0-186">Si `userMessage` n’est pas une chaîne constante littérale, le contrat ne peut pas être compris par les outils.</span><span class="sxs-lookup"><span data-stu-id="83aa0-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="83aa0-187">Premier entier à passer à <c>predicate</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-187">The first integer to pass to <c>predicate</c>.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="83aa0-188">Dernier entier à passer à <c>predicate</c> plus un.</span><span class="sxs-lookup"><span data-stu-id="83aa0-188">One more than the last integer to pass to <c>predicate</c>.</span></span></param>
        <param name="predicate"><span data-ttu-id="83aa0-189">Fonction à évaluer pour une valeur de l'entier de la plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-189">The function to evaluate for any value of the integer in the specified range.</span></span></param>
        <summary><span data-ttu-id="83aa0-190">Détermine si un test spécifié a la valeur True pour un entier figurant dans une plage d'entiers.</span><span class="sxs-lookup"><span data-stu-id="83aa0-190">Determines whether a specified test is true for any integer within a range of integers.</span></span></summary>
        <returns>
          <span data-ttu-id="83aa0-191"><see langword="true" /> si <paramref name="predicate" /> retourne la valeur <see langword="true" /> pour tout entier à partir de <paramref name="fromInclusive" /> jusqu'à <paramref name="toExclusive" /> -1.</span><span class="sxs-lookup"><span data-stu-id="83aa0-191"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-192">Le `toExclusive` paramètre est un plus que le dernier entier pour faciliter l’utilisation de la longueur d’une plage d’entiers commençant à 0.</span><span class="sxs-lookup"><span data-stu-id="83aa0-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="83aa0-193">Par exemple, elle est définie à 5 pour les entiers de 0 à 4.</span><span class="sxs-lookup"><span data-stu-id="83aa0-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83aa0-194"><paramref name="predicate" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-194"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="83aa0-195"><paramref name="toExclusive" /> est inférieur à <paramref name="fromInclusive" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-195"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="83aa0-196">Le type qui est contenu dans <c>collection</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-196">The type that is contained in <c>collection</c>.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="83aa0-197">Collection à partir de laquelle des éléments de type <c>T</c> sont extraits pour être passés à <c>predicate</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-197">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span></span></param>
        <param name="predicate"><span data-ttu-id="83aa0-198">Fonction à évaluer pour un élément dans <c>collection</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-198">The function to evaluate for an element in <c>collection</c>.</span></span></param>
        <summary><span data-ttu-id="83aa0-199">Détermine si un élément dans une collection d’éléments existe dans une fonction.</span><span class="sxs-lookup"><span data-stu-id="83aa0-199">Determines whether an element within a collection of elements exists within a function.</span></span></summary>
        <returns>
          <span data-ttu-id="83aa0-200"><see langword="true" /> si et uniquement si <paramref name="predicate" /> retourne la valeur <see langword="true" /> pour tout élément de type <paramref name="T" /> dans <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-200"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83aa0-201"><paramref name="collection" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-201"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="83aa0-202">Premier entier à passer à <c>predicate</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-202">The first integer to pass to <c>predicate</c>.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="83aa0-203">Dernier entier à passer à <c>predicate</c> plus un.</span><span class="sxs-lookup"><span data-stu-id="83aa0-203">One more than the last integer to pass to <c>predicate</c>.</span></span></param>
        <param name="predicate"><span data-ttu-id="83aa0-204">Fonction à évaluer pour l'existence des entiers dans la plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-204">The function to evaluate for the existence of the integers in the specified range.</span></span></param>
        <summary><span data-ttu-id="83aa0-205">Détermine si une condition particulière est valide pour tous les entiers d'une étendue spécifiée.</span><span class="sxs-lookup"><span data-stu-id="83aa0-205">Determines whether a particular condition is valid for all integers in a specified range.</span></span></summary>
        <returns>
          <span data-ttu-id="83aa0-206"><see langword="true" /> si <paramref name="predicate" /> retourne la valeur <see langword="true" /> pour tous les entiers à partir de <paramref name="fromInclusive" /> jusqu'à <paramref name="toExclusive" /> -1.</span><span class="sxs-lookup"><span data-stu-id="83aa0-206"><see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-207">Le `toExclusive` paramètre est un plus que le dernier entier pour faciliter l’utilisation de la longueur d’une plage d’entiers commençant à 0.</span><span class="sxs-lookup"><span data-stu-id="83aa0-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="83aa0-208">Par exemple, elle est définie à 5 pour les entiers de 0 à 4.</span><span class="sxs-lookup"><span data-stu-id="83aa0-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83aa0-209">L’exemple suivant montre comment utiliser la <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> méthode pour déterminer si un tableau a un élément null.</span><span class="sxs-lookup"><span data-stu-id="83aa0-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83aa0-210"><paramref name="predicate" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-210"><paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="83aa0-211"><paramref name="toExclusive" /> est inférieur à <paramref name="fromInclusive" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-211"><paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="83aa0-212">Le type qui est contenu dans <c>collection</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-212">The type that is contained in <c>collection</c>.</span></span></typeparam>
        <param name="collection"><span data-ttu-id="83aa0-213">Collection à partir de laquelle des éléments de type <c>T</c> sont extraits pour être passés à <c>predicate</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-213">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span></span></param>
        <param name="predicate"><span data-ttu-id="83aa0-214">Fonction à évaluer pour l’existence de tous les éléments dans <c>collection</c>.</span><span class="sxs-lookup"><span data-stu-id="83aa0-214">The function to evaluate for the existence of all the elements in <c>collection</c>.</span></span></param>
        <summary><span data-ttu-id="83aa0-215">Détermine si tous les éléments dans une collection existent dans une fonction.</span><span class="sxs-lookup"><span data-stu-id="83aa0-215">Determines whether all the elements in a collection exist within a function.</span></span></summary>
        <returns>
          <span data-ttu-id="83aa0-216"><see langword="true" /> si et uniquement si <paramref name="predicate" /> retourne la valeur <see langword="true" /> pour tous les éléments de type <paramref name="T" /> dans <paramref name="collection" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-216"><see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="83aa0-217">L’exemple suivant montre comment utiliser la <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> méthode pour déterminer si une collection a un élément null.</span><span class="sxs-lookup"><span data-stu-id="83aa0-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="83aa0-218"><paramref name="collection" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-218"><paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="83aa0-219">Spécifie un contrat pour une méthode englobante ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-219">Specifies a contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-220">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-220">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="83aa0-221">Spécifie un contrat indifférent pour la méthode englobante ou la propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-221">Specifies an invariant contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> les contrats sont contenues dans une méthode qui est identifiée par le <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribut ; en général, la méthode est appelée `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="83aa0-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="83aa0-223">Ce contrat peut être spécifié uniquement dans une méthode invariante dédiée qui est déclarée sur une classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="83aa0-224">Si la méthode n’est pas sealed, elle doit faire référence uniquement aux membres protégés, et non aux membres privés, afin que les sous-classes peuvent veillez à maintenir les invariants.</span><span class="sxs-lookup"><span data-stu-id="83aa0-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="83aa0-225">Ce contrat n’est pas exposé aux clients ; Par conséquent, il peut référencer des membres qui sont moins visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-226">Vous devez utiliser le module de réécriture binaire pour l’application d’exécution de cet invariant.</span><span class="sxs-lookup"><span data-stu-id="83aa0-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="83aa0-227">Les invariants sont définis de façon conditionnelle selon la présence de la `CONTRACTS FULL` symbole.</span><span class="sxs-lookup"><span data-stu-id="83aa0-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="83aa0-228">Ils sont vérifiés au moment de l'exécution à la fin de chaque méthode publique.</span><span class="sxs-lookup"><span data-stu-id="83aa0-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="83aa0-229">Si un invariant mentionne une méthode publique dans la même classe, la vérification d’invariant normalement à la fin de cette méthode publique est désactivée et activée uniquement à la fin de l’appel de méthode externe à cette classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="83aa0-230">Cela se produit également si la classe est à nouveau entrée à cause d'un appel à une méthode sur une autre classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-231">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-231">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-232">Message à afficher si la condition est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-232">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="83aa0-233">Spécifie un contrat indifférent préalable pour la méthode englobante ou la propriété, et affiche un message si la condition pour le contrat échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> les contrats sont contenues dans une méthode qui est identifiée par le <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribut ; en général, la méthode est appelée `ObjectInvariant`.</span><span class="sxs-lookup"><span data-stu-id="83aa0-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="83aa0-235">Ce contrat peut être spécifié uniquement dans une méthode invariante dédiée qui est déclarée sur une classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="83aa0-236">Ce contrat n’est pas exposé aux clients ; Par conséquent, il peut référencer des membres qui sont moins visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-237">Vous devez utiliser le module de réécriture binaire pour l’application d’exécution de cet invariant.</span><span class="sxs-lookup"><span data-stu-id="83aa0-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="83aa0-238">Les invariants sont définis de manière conditionnelle sur la `CONTRACTS FULL` symbole.</span><span class="sxs-lookup"><span data-stu-id="83aa0-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="83aa0-239">Ils sont vérifiés au moment de l'exécution à la fin de chaque méthode publique.</span><span class="sxs-lookup"><span data-stu-id="83aa0-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="83aa0-240">Si un invariant mentionne une méthode publique dans la même classe, la vérification d’invariant normalement à la fin de cette méthode publique est désactivée et activée uniquement à la fin de l’appel de méthode externe à cette classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="83aa0-241">Cela se produit également si la classe est à nouveau entrée à cause d'un appel à une méthode sur une autre classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="83aa0-242">Type de valeur.</span><span class="sxs-lookup"><span data-stu-id="83aa0-242">The type of value.</span></span></typeparam>
        <param name="value"><span data-ttu-id="83aa0-243">Valeur à représenter (champ ou paramètre).</span><span class="sxs-lookup"><span data-stu-id="83aa0-243">The value to represent (field or parameter).</span></span></param>
        <summary><span data-ttu-id="83aa0-244">Représente les valeurs telles qu'elles étaient au démarrage d'une méthode ou d'une propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-244">Represents values as they were at the start of a method or property.</span></span></summary>
        <returns><span data-ttu-id="83aa0-245">Valeur du paramètre ou champ au démarrage d'une méthode ou propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-245">The value of the parameter or field at the start of a method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-246">Cette méthode peut être utilisée uniquement dans l’expression conditionnelle pour la <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contrat.</span><span class="sxs-lookup"><span data-stu-id="83aa0-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83aa0-247">L’exemple suivant illustre l’utilisation de la <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> pour s’assurer qu’un nombre a été mis à jour.</span><span class="sxs-lookup"><span data-stu-id="83aa0-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="83aa0-248">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="83aa0-249">Spécifie un contrat de condition préalable pour une méthode englobante ou une propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-249">Specifies a precondition contract for an enclosing method or property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-250">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-250">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="83aa0-251">Spécifie un contrat de condition préalable pour la méthode englobante ou la propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-251">Specifies a precondition contract for the enclosing method or property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="83aa0-252">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-253">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-254">Utilisez cette méthode à la place de la <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> méthode lors de la compatibilité descendante ne vous oblige pas à lever une exception particulière.</span><span class="sxs-lookup"><span data-stu-id="83aa0-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition"><span data-ttu-id="83aa0-255">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-255">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-256">Message à afficher si la condition est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-256">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="83aa0-257">Spécifie un contrat de condition préalable pour la méthode englobante ou la propriété, et affiche un message si la condition pour le contrat échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="83aa0-258">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-259">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-260">Utilisez cette méthode à la place de la <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> méthode lors de la compatibilité descendante ne vous oblige pas à lever une exception particulière.</span><span class="sxs-lookup"><span data-stu-id="83aa0-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="83aa0-261">Exception à lever si la condition est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-261">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="83aa0-262">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-262">The conditional expression to test.</span></span></param>
        <summary><span data-ttu-id="83aa0-263">Spécifie un contrat de condition préalable pour la méthode englobante ou la propriété, et lève une exception si la condition pour le contrat échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="83aa0-264">Vous devez activer la vérification pour utiliser l’exécution du <xref:System.Diagnostics.Contracts.Contract.Requires%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="83aa0-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="83aa0-265">Si la vérification de l’exécution est désactivée, le processus sera terminé.</span><span class="sxs-lookup"><span data-stu-id="83aa0-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="83aa0-266">Pour obtenir les outils de contrôle à l’exécution, consultez [les contrats de Code](http://go.microsoft.com/fwlink/?LinkId=152461) sur le site Web MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="83aa0-266">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="83aa0-267">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-268">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-269">Utilisez cette méthode à la place de la <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> méthode lorsque vous souhaitez lever une exception si la condition préalable échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException"><span data-ttu-id="83aa0-270">Exception à lever si la condition est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-270">The exception to throw if the condition is <see langword="false" />.</span></span></typeparam>
        <param name="condition"><span data-ttu-id="83aa0-271">Expression conditionnelle à tester.</span><span class="sxs-lookup"><span data-stu-id="83aa0-271">The conditional expression to test.</span></span></param>
        <param name="userMessage"><span data-ttu-id="83aa0-272">Message à afficher si la condition est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-272">The message to display if the condition is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="83aa0-273">Spécifie un contrat de condition préalable pour la méthode englobante ou la propriété, et lève une exception avec le message fourni si la condition pour le contrat échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="83aa0-274">Vous devez activer la vérification pour utiliser l’exécution du <xref:System.Diagnostics.Contracts.Contract.Requires%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="83aa0-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="83aa0-275">Si la vérification de l’exécution est désactivée, le processus sera terminé.</span><span class="sxs-lookup"><span data-stu-id="83aa0-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="83aa0-276">Pour obtenir les outils de contrôle à l’exécution, consultez [les contrats de Code](http://go.microsoft.com/fwlink/?LinkId=152461) sur le site Web MSDN DevLabs.</span><span class="sxs-lookup"><span data-stu-id="83aa0-276">To obtain the tools for runtime checking, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="83aa0-277">Cet appel de méthode doit être au début d’une méthode ou propriété, avant tout autre code.</span><span class="sxs-lookup"><span data-stu-id="83aa0-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="83aa0-278">Ce contrat est exposé aux clients ; Par conséquent, il doit référencer uniquement des membres qui sont au moins aussi visibles que la méthode englobante.</span><span class="sxs-lookup"><span data-stu-id="83aa0-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="83aa0-279">Utilisez cette méthode à la place de la <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> méthode lorsque vous souhaitez lever une exception si la condition préalable échoue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="83aa0-280">Type de valeur de retour de la méthode englobante ou propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-280">Type of return value of the enclosing method or property.</span></span></typeparam>
        <summary><span data-ttu-id="83aa0-281">Représente la valeur de retour d'une méthode ou propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-281">Represents the return value of a method or property.</span></span></summary>
        <returns><span data-ttu-id="83aa0-282">Valeur de retour de la méthode englobante ou propriété.</span><span class="sxs-lookup"><span data-stu-id="83aa0-282">Return value of the enclosing method or property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-283">Cette méthode peut être utilisée uniquement dans l’expression conditionnelle pour la <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contrat.</span><span class="sxs-lookup"><span data-stu-id="83aa0-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="83aa0-284">L’exemple suivant montre comment utiliser la <xref:System.Diagnostics.Contracts.Contract.Result%2A> méthode pour spécifier une valeur de retour attendue.</span><span class="sxs-lookup"><span data-stu-id="83aa0-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="83aa0-285">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Diagnostics.Contracts.ContractClassAttribute> classe.</span><span class="sxs-lookup"><span data-stu-id="83aa0-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="83aa0-286">Type du paramètre <see langword="out" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-286">The type of the <see langword="out" /> parameter.</span></span></typeparam>
        <param name="value"><span data-ttu-id="83aa0-287">Paramètre <see langword="out" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-287">The <see langword="out" /> parameter.</span></span></param>
        <summary><span data-ttu-id="83aa0-288">Représente la valeur finale (sortie) d'un paramètre <see langword="out" /> lors du retour d'une méthode.</span><span class="sxs-lookup"><span data-stu-id="83aa0-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span></span></summary>
        <returns><span data-ttu-id="83aa0-289">Valeur de sortie du paramètre <see langword="out" />.</span><span class="sxs-lookup"><span data-stu-id="83aa0-289">The output value of the <see langword="out" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="83aa0-290">Cette méthode peut être utilisée uniquement dans l’expression conditionnelle pour la <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contrat.</span><span class="sxs-lookup"><span data-stu-id="83aa0-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="83aa0-291">Comme avec la méthode <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, vous pouvez omettre le paramètre de type générique chaque fois que le compilateur est en mesure de déduire son type.</span><span class="sxs-lookup"><span data-stu-id="83aa0-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="83aa0-292">Le module de réécriture de contrat remplace l'appel de méthode par la valeur du paramètre `out`.</span><span class="sxs-lookup"><span data-stu-id="83aa0-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="83aa0-293">La méthode <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> peut apparaître uniquement dans des post-conditions.</span><span class="sxs-lookup"><span data-stu-id="83aa0-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="83aa0-294">L'argument de la méthode doit être un paramètre `out` ou un champ d'un paramètre `out` de structure.</span><span class="sxs-lookup"><span data-stu-id="83aa0-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="83aa0-295">Ce dernier est également utile pour faire référence aux champs dans la post-condition d'un constructeur de structure.</span><span class="sxs-lookup"><span data-stu-id="83aa0-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>