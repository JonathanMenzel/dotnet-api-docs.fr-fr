<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4ed869ade48c2d13d6c9ac52a586347c02426dbd" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59351833" /></Metadata><TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implémente les fonctionnalités de base destinées à un fournisseur de personnalisations.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit de la classe de base abstraite qui définit la fonctionnalité requise d’un fournisseur de personnalisations. Un fournisseur de personnalisations charge et enregistre les données de personnalisation de la part d’un <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instance.  
  
 La classe de base définit un comportement standard pour un nombre de méthodes. uniquement les méthodes qui traitent spécifiquement de magasin de données sous-jacent sont marqué comme abstract. Cela permet au développeur d’écrire un fournisseur personnalisé pour interagir avec un magasin de données spécifique, sans avoir besoin d’implémenter à nouveau les fonctionnalités standard utilisées par la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Vous pouvez dériver de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> et fournir des implémentations pour uniquement les méthodes abstraites définies dans cette classe. Les méthodes abstraites traitent spécifiquement de l’enregistrement et chargement des données dans un magasin de données physique et à l’administration du magasin de données. Un fournisseur personnalisé doit être capable de manipuler des informations de personnalisation d’une manière qui fait la distinction <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> données à partir de <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> données. En outre, un fournisseur doit segmenter les données de personnalisation par page ainsi que par application.  
  
Les implémentations de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> sont étroitement couplées aux implémentations de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> , car certaines méthodes de fournisseur de personnalisation retournent des instances de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-classes dérivées. Pour faciliter le développement de fournisseurs personnalisés, le <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> classe de base inclut une implémentation par défaut de la logique de personnalisation et de la logique de sérialisation/désérialisation utilisée directement par le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> classe. Par conséquent, la création d’un fournisseur personnalisé uniquement à des fins de travailler avec un magasin de données différent nécessite uniquement l’implémentation des méthodes abstraites suivantes : 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -Cette méthode doit pouvoir compter le nombre de lignes de données de personnalisation dans la base de données pour les paramètres de requête fournie.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -Étant donné le chemin d’accès et nom d’utilisateur, cette méthode charge deux objets volumineux binaires (BLOB) à partir de la base de données : un destiné aux données partagées et l’autre pour les données utilisateur. Si vous fournissez le nom d’utilisateur et le chemin d’accès, vous n’avez pas besoin du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle d’accéder aux informations de pages qui peuvent fournir les informations de chemin d’accès/nom d’utilisateur.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> -Étant donné le chemin d’accès et nom d’utilisateur, cette méthode supprime la ligne correspondante dans la base de données. Si vous fournissez le nom d’utilisateur et le chemin d’accès, vous n’avez pas besoin du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle d’accéder aux informations de pages qui peuvent fournir les informations de chemin d’accès/nom d’utilisateur.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -Étant donné le chemin d’accès et nom d’utilisateur, cette méthode enregistre l’objet BLOB fourni à la base de données. Si vous fournissez le nom d’utilisateur et le chemin d’accès, vous n’avez pas besoin du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle d’accéder aux informations de pages qui peuvent fournir les informations de chemin d’accès/nom d’utilisateur.  
  
Dans toutes ces méthodes, si seul un chemin d’accès est fourni, qui indique les données de personnalisation partagées pour la page sont manipulées. Si un chemin d’accès et un nom d’utilisateur sont passés à une méthode, puis les données de personnalisation utilisateur pour la page doivent être exploitées. Dans le cas de <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, les données partagées pour le chemin d’accès spécifié doivent toujours être chargées, et éventuellement les données de personnalisation utilisateur pour le chemin d’accès doivent également être chargées si le nom d’utilisateur n’est pas <see langword="null" />.  
  
Toutes les autres méthodes abstraites sont destinées uniquement dans les applications d’administration et ne sont pas utilisés par l’infrastructure Web Parts en cours d’exécution. Pour obtenir un exemple d’une implémentation d’un fournisseur de personnalisations, consultez la <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" /> classe.</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">Contrôles WebPart ASP.NET</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Vue d’ensemble de personnalisation de parties Web</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/784d8z92(v=vs.100)">Procédure pas à pas : Implémentation des WebParts avec un contrôle utilisateur</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178182(v=vs.100)">Personnalisation des WebParts</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme il s’agit d’un constructeur pour une classe abstraite, vous devez substituer cette méthode pour créer une instance d’une classe qui hérite de cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient ou définit le nom de l'application configurée pour le fournisseur.</summary>
        <value>L'application configurée pour le fournisseur de personnalisations.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un nom d’application n’est pas spécifié dans le fichier de configuration à l’aide de la [providers, élément de personalization pour webParts (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) , la valeur d’attribut le <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> propriété est utilisée.  
  
> [!CAUTION]
>  Car une seule instance de fournisseur de personnalisations par défaut est utilisée pour toutes les demandes prises en charge par un <xref:System.Web.HttpApplication> de l’objet, vous pouvez avoir plusieurs demandes peuvent s’exécuter simultanément, chaque tentative de définition du <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valeur de propriété. Le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriété n’est pas thread-safe pour les écritures multiples et en modifiant le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valeur de propriété peut entraîner un comportement inattendu pour plusieurs utilisateurs d’une application. Il est recommandé d’éviter que le code permettant aux utilisateurs de définir la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriété, sauf si requis. Définition de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriété peut être nécessaire, par exemple, dans une application administrative qui gère les données de personnalisation pour plusieurs applications.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste des objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> qui représentent le jeu des fonctionnalités connues utilisées par le jeu de contrôles WebPart.</summary>
        <returns>Un <see cref="T:System.Collections.IList" /> qui représente le jeu de fonctionnalités connues a utilisé par le jeu de contrôles WebPart.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuellement, cette méthode retourne une liste qui contient deux fonctionnalités : <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> et <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>. Voici les fonctionnalités par défaut qui peuvent être définies dans le [authorization, élément de personalization pour webParts (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) élément dans le [personalization, élément de webParts (ASP.NET Schéma des paramètres)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) élément de la [webParts, élément (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) section de configuration. Si vous choisissez d’implémenter une infrastructure de personnalisation personnalisées, vous pouvez substituer cette méthode et définir votre propre jeu de fonctionnalités utilisateur liées aux autorisations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les informations de personnalisation.</param>
        <param name="loadedState">Les informations d'état de personnalisation.</param>
        <summary>Détermine si la portée de personnalisation initiale doit être une portée <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> ou <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />.</summary>
        <returns>Un <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> qui indique si la portée de personnalisation actuelle est <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> ou <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si la portée actuelle doit être <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ou <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, selon une référence à un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et la personnalisation des informations qui a déjà été chargées à partir de plus haut dans le cycle de vie de personnalisation d’état. Ces informations sont utilisées par un <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instance pour les tâches suivantes liées à la personnalisation.  
  
 Les règles suivantes sont utilisées pour déterminer la portée de personnalisation :  
  
-   Étendue est censée initialement pour être <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Si le compte d’utilisateur en cours d’exécution n’est pas authentifié, l’étendue est définie <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Si le compte d’utilisateur en cours d’exécution est authentifié, un traitement supplémentaire se produit dans l’ordre de priorité :  
  
    -   Si la page est en mode de publication (postback), la demande de page contient les informations de portée à partir d’un affichage précédent de la page. Si ces informations de portée indiquent que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue a été utilisée, alors que la portée correspond à <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
    -   Si la page en cours d’exécution avait le contrôle transféré à partir d’une autre page (par exemple, si le transfert de contrôle s’est produite en raison d’appeler le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode ; Notez que cette vérification spécifique ne se produit pas pour la validation de plusieurs pages) et si le précédemment l’exécution de page avait un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance, l’étendue est définie à la valeur de la `Personalization.Scope` propriété du précédent <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance.  
  
    -   Si le critère précédent n’est pas remplie, la portée correspond à la valeur de la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> propriété actif <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Une fois les évaluations précédentes ont été apportées, et si la portée correspond à <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue, le traitement suivant se produit :  
  
-   Si le compte d’utilisateur en cours d’exécution a la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> fonctionnalité, l’étendue reste <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Si le compte d’utilisateur en cours d’exécution n’a pas la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> fonctionnalité, puis l’étendue est réinitialisé à <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Si le résultat de toutes les évaluations de portée précédentes est <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, ce résultat est stocké sous la forme d’un champ masqué sur la page en cours d’exécution. Ceci est le mécanisme par lequel une page de relire l’évaluation de la portée pendant les publications ultérieures.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La page associée à <paramref name="webPartManager" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les informations de personnalisation.</param>
        <summary>Retourne un dictionnaire qui contient des instances de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> représentant les fonctionnalités liées à la personnalisation dont dispose le compte d'utilisateur actif.</summary>
        <returns>Un <see cref="T:System.Collections.IDictionary" /> qui contient un nombre d'instances de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> supérieur ou égal à zéro si le compte d'utilisateur est authentifié, ou une valeur <see langword="null" /> si le compte d'utilisateur actif n'est pas authentifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode utilise les informations contenues dans le [authorization, élément de personalization pour webParts (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) élément dans le [personalization, élément pour webParts (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) élément de la [webParts, élément (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) section de configuration dans le fichier Machine.config ou Web.config pour déterminer un utilisateur habilité de fonctionnalités.  
  
 Les fonctionnalités dans le dictionnaire doivent être membres du <xref:System.Collections.IList> objet retourné par la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A> (méthode), qui contiennent le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> fonctionnalité et la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> fonctionnalité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La page associée à <paramref name="webPartManager" /> est <see langword="null" />.  
  
ou 
La demande associée à la page est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> doté des informations de personnalisation à rechercher. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="query"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> contenant une requête. Cette valeur peut être <see langword="null" />.</param>
        <param name="pageIndex">Emplacement où commence la requête.</param>
        <param name="pageSize">Nombre d'enregistrements à retourner.</param>
        <param name="totalRecords">Nombre total d'enregistrements disponibles.</param>
        <summary>En cas de substitution dans une classe dérivée, retourne une collection qui contient un nombre d'objets dérivés de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> supérieur ou égal à zéro, selon des paramètres de portée et des paramètres spécifiques à la requête.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> qui contient un nombre d'objets dérivés de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> supérieur ou égal à zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode d’administration pour l’interrogation des données de personnalisation. Les implémentations dérivées doivent suivre la logique décrite ci-dessous.  
  
 Le jeu d’éléments retournés est contraint par la `pageIndex` et `pageSize` paramètres, où `pageSize` définit le nombre d’enregistrements à retourner et `pageIndex` définit les enregistrements à retourner. Par exemple, un `pageIndex` de 0 et un `pageSize` 25 retournerait les 25 premières occurrences, tandis qu’un `pageIndex` 1 et un `pageSize` de 25 retournerait occurrences 26 à 50. Si vous souhaitez récupérer tous les enregistrements disponibles, définissez `pageIndex` à 0 et `pageSize` à <xref:System.Int32.MaxValue>.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-objets dérivés sont retournés par ordre alphabétique et triés par une combinaison de leurs <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> et <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> valeurs de propriété, à la fois dans l’ordre croissant.  
  
 Cette méthode passe les caractères génériques de requête dans le magasin de données sous-jacent. Prise en charge des caractères génériques dépend de la façon dont chaque fournisseur gère les caractères comme un astérisque (*), un symbole de pourcentage (%) ou un trait de soulignement (_).  
  
 Normalement, pour les magasins de données compatibles SQL, vous pouvez effectuer une recherche par caractères génériques sur un chemin d’accès partiel avec le caractère générique qui apparaît au début, la fin ou au milieu du texte de chaîne de recherche dans le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété. Par exemple, pour rechercher tous les chemins qui commencent par «\~/vdir », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété est définie «\~/vdir% ».  
  
 De même, une recherche générique sur un nom d’utilisateur partiel peut avoir le caractère générique en tout point dans la chaîne de texte de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété. Par exemple, pour rechercher tous les noms d’utilisateur qui commencent par « John », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> paramètre ressemble à « John % ».  
  
 Les contraintes de requête suivantes s’appliquent :  
  
-   Si seuls `scope` est fourni, et `query` est `null` ou toutes les propriétés sur `query` retourner `null` ou les valeurs par défaut, puis tous les enregistrements correspondant au `scope` paramètre sont retournés.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété n’est pas `null`, les enregistrements retournés sont également filtrés selon les chemins d’accès qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valeur.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété n’est pas `null`, les enregistrements retournés sont également filtrés selon les noms utilisateur qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valeur de propriété.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété n’est pas égale à <xref:System.DateTime.MaxValue>, les enregistrements retournés sont également filtrés pour retourner uniquement les enregistrements associés aux utilisateurs inactifs. La comparaison inclut des enregistrements où la <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> la propriété est inférieure ou égale à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété.  
  
 Notez que cette méthode ne valide pas les combinaisons de paramètres de requête. Par exemple, le code peut demander un jeu d’enregistrements d’état de personnalisation associé à un nom d’utilisateur spécifique dans la portée partagée. Étant donné que les noms d’utilisateur ne sont pas associés à des informations partagées, la collection retournée est vide.  
  
 Les combinaisons de paramètres susceptibles de retourner une collection non vide sont les suivantes :  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue en association avec le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue en combinaison avec les valeurs pour tout ou partie de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, et <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriétés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> des informations de personnalisation à rechercher. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="query"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> contenant une requête. Cette valeur peut être <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, retourne le nombre de lignes présentes dans le magasin de données sous-jacent également présentes dans la portée spécifiée.</summary>
        <returns>Nombre de lignes présentes dans le magasin de données sous-jacent qui existent pour le paramètre <paramref name="scope" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode d’administration pour extraire des décomptes des données de personnalisation. Les implémentations dérivées doivent suivre la logique décrite ci-dessous.  
  
 Cette méthode passe les caractères génériques de requête dans le magasin de données sous-jacent. Prise en charge des caractères génériques dépend de la façon dont chaque fournisseur gère les caractères comme un astérisque (*), un symbole de pourcentage (%) ou un trait de soulignement (_).  
  
 Normalement, pour les magasins de données compatibles SQL, vous pouvez effectuer une recherche par caractères génériques sur un chemin d’accès partiel avec le caractère générique qui apparaît au début, la fin ou au milieu du texte de chaîne de recherche dans le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété. Par exemple, pour rechercher tous les chemins qui commencent par «\~/vdir », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété est définie «\~/vdir% ».  
  
 De même, une recherche générique sur un nom d’utilisateur partiel peut avoir le caractère générique en tout point dans la chaîne de texte de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété. Par exemple, pour rechercher tous les noms d’utilisateur qui commencent par « John », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> paramètre ressemble à « John % ».  
  
 Les contraintes de requête suivantes s’appliquent :  
  
-   Si seuls `scope` est fourni, et `query` est `null` ou toutes les propriétés sur `query` retourner `null` ou les valeurs par défaut, puis tous les enregistrements correspondant au `scope` paramètre sont comptés.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété n’est pas `null`, les enregistrements comptés sont également filtrés selon les chemins d’accès qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valeur.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété n’est pas `null`, les enregistrements comptés sont également filtrés selon les noms utilisateur qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valeur de propriété.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété n’est pas égale à <xref:System.DateTime.MaxValue>, les enregistrements comptés sont également filtrés pour retourner uniquement les enregistrements associés aux utilisateurs inactifs. La comparaison inclut des enregistrements où la <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> la propriété est inférieure ou égale à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété.  
  
 Notez que cette méthode ne valide pas les combinaisons de paramètres de requête. Par exemple, le code peut demander un nombre d’enregistrements d’état de personnalisation associé à un nom d’utilisateur spécifique dans la portée partagée. Étant donné que les noms d’utilisateur ne sont pas associés à des informations partagées, le nombre retourné serait égal à zéro.  
  
 Les combinaisons de paramètres qui ont la possibilité de retourner un nombre différent de zéro sont les suivantes :  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue en association avec le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue en combinaison avec les valeurs pour tout ou partie de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, et <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriétés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les données de personnalisation.</param>
        <param name="path">Chemin d'accès pour les informations de personnalisation à utiliser comme clé de récupération.</param>
        <param name="userName">Nom d'utilisateur pour les informations de personnalisation à utiliser comme clé de récupération.</param>
        <param name="sharedDataBlob">Données retournées pour la portée <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />.</param>
        <param name="userDataBlob">Données retournées pour la portée <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />.</param>
        <summary>En cas de substitution dans une classe dérivée, charge des données de personnalisation brutes à partir du magasin de données sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> et implémentent cette méthode doit utiliser le `webPartManager`, `path`, et `username` paramètres en tant que clés de récupération. Indépendamment de la façon dont les données sont stockées dans le magasin de données (certains magasins de données peuvent effectuer un certain type de stockage intelligent), les données doivent être retournées de personnalisation comme un jeu d’octets dans deux tableaux compressé. Les données retournées doivent respecter les règles suivantes :  
  
-   Les données pour le <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue doit toujours être retournée dans le `sharedDataBlob` paramètre.  
  
-   Selon les valeurs de clé, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données sont retournées dans le `userDataBlob` paramètre. Non -`null` valeur pour le `userName` paramètre indique que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données doivent également être récupérées.  
  
 Un fournisseur de personnalisations qui dérive de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> et implémente cette méthode peut optimiser des interactions avec son magasin de données en récupérant toutes les données de personnalisation dans un seul aller-retour, par opposition à la récupération de <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> et <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données en deux Séparez les allers-retours.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les données de personnalisation.</param>
        <param name="ignoreCurrentUser"><see cref="T:System.Boolean" /> qui indique si le nom d'utilisateur doit être transmis au fournisseur de personnalisations.</param>
        <summary>Charge les données brutes du magasin de données sous-jacent et convertit ces données en un objet <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> qui contient les données de personnalisation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal utilisé par le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe pour charger des données de personnalisation. L’implémentation par défaut charge les données brutes à partir du magasin de données sous-jacent (la fonctionnalité est implémentée dans les fournisseurs dérivés), puis convertit les données brutes dans un <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> instance.  
  
 Si le `ignoreCurrentUser` paramètre est `true`, aucun nom d’utilisateur n’est passé à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A> (méthode). Un fournisseur de personnalisations peut choisir interpréter cela comme ce qui signifie que seul état de personnalisation avec un <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue doit être extrait du magasin de données sous-jacent.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> méthode s’exécute, il appelle le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A> (méthode), et il existe trois types d’erreur de désérialisation peut se produire lorsque l’état est en cours de chargement. Lorsque ces erreurs spécifiques se produisent, aucune exception n’est levée, et les événements d’erreur sont enregistrés par la fonctionnalité de contrôle d’intégrité (pour plus d’informations sur l’analyse des performances et en accédant aux journaux créés par elle, consultez [vue d’ensemble de la surveillance de l’intégrité ASP.NET ](https://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). À écrire dans le journal des événements d’erreur de désérialisation de la cause de trois scénarios suivants :  
  
-   Échec d’une tentative de désérialisation d’un type de propriété qui utilise une chaîne <xref:System.ComponentModel.TypeConverter>.  
  
-   Échec d’un tentative de désérialisation d’un type de propriété qui utilise la sérialisation binaire.  
  
-   Échec d’une tentative de désérialisation d’un type de propriété, car une instance du type ne peut pas être créée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La page associée à <paramref name="webPartManager" /> est <see langword="null" />.  
  
ou 
La demande associée à la page est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les données de personnalisation.</param>
        <param name="path">Chemin d'accès pour les informations de personnalisation à utiliser comme clé de stockage de données.</param>
        <param name="userName">Nom d'utilisateur pour les informations de personnalisation à utiliser comme clé de stockage de données.</param>
        <summary>En cas de substitution dans une classe dérivée, supprime des données de personnalisation brutes à partir du magasin de données sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> et implémentent cette méthode doit utiliser le `webPartManager`, `path`, et `userName` paramètres en tant que clés de stockage. Les implémentations dérivées doivent modifier le magasin de données afin que les données de personnalisation pour les clés de stockage fourni sont effectivement supprimées. Il incombe les implémentations dérivées quant à la façon dont ils physiquement parvenir.  
  
 Le fournisseur de personnalisations dérivé doit être en mesure de distinguer des données de personnalisation sur une base par page. En outre, pour l’état d’une page donnée, le fournisseur de personnalisations doit être en mesure de faire la distinction entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> et <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données de portée. Si un non -`null` nom d’utilisateur est fourni, puis l’opération de réinitialisation s’applique à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue ; sinon, l’opération de réinitialisation s’applique à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les données de personnalisation.</param>
        <summary>Réinitialise des données de personnalisation destinées au magasin de données sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal utilisé par le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe pour réinitialiser les données de personnalisation. L’implémentation par défaut utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour déterminer le chemin d’accès et nom d’utilisateur pour les données doivent être réinitialisées. L’implémentation par défaut puis appelle le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPartManager" /> n'est pas associé à une page.  
  
ou 
La page n'est associée à aucun <see cref="T:System.Web.HttpRequest" /> en cours de traitement.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> des informations de personnalisation à réinitialiser. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="paths">Chemins d'accès pour les informations de personnalisation à supprimer.</param>
        <param name="usernames">Noms d'utilisateur pour les informations de personnalisation à supprimer.</param>
        <summary>En cas de substitution dans une classe dérivée, supprime l'état de personnalisation issu du magasin de données sous-jacent selon les paramètres spécifiés.</summary>
        <returns>Nombre de lignes à supprimer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode administrative pour la suppression des données de personnalisation. Les implémentations dérivées doivent suivre la logique décrite ci-dessous.  
  
 Aucune recherche de caractères génériques n’est pris en charge par cette méthode. Si le fournisseur de personnalisations expose des données à partir d’un magasin de données prenant en charge les transactions, cette méthode doit exécuter ses opérations comme une transaction atomique unique.  
  
 Uniquement les combinaisons de paramètres suivantes sont autorisées :  
  
-   Le `scope` paramètre est défini, et tous les autres paramètres sont définis sur `null`. Cette combinaison supprime toutes les données de personnalisation WebPart associées à la portée de personnalisation indiquée par `scope`.  
  
-   Le `scope` paramètre est défini et le `paths` paramètre contient au moins une valeur. Cette combinaison supprime toutes les données de personnalisation WebPart pour le chemin d’accès spécifié ou les chemins d’accès dans la portée de personnalisation indiquée par `scope`.  
  
-   Le `scope` paramètre est défini sur <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, le `paths` paramètre est défini et contient une seule valeur et le `usernames` paramètre contient au moins une valeur. Cette combinaison supprime toutes les utilisateur données de personnalisation WebPart pour le chemin d’accès qui est associé à l’utilisateur ou les utilisateurs contenus dans `usernames`.  
  
-   Le `scope` paramètre est défini sur <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, le `paths` paramètre est défini sur `null`et le `usernames` paramètre contient au moins une valeur. Cette combinaison supprime toutes les données de composants WebPart, de personnalisation par utilisateur sur tous les chemins d’accès, associés à l’utilisateur ou les utilisateurs contenus dans `usernames`.  
  
 Toute autre combinaison de valeurs de paramètre n’est pas valide et lève un <xref:System.ArgumentException> exception. Plus précisément, les deux combinaisons suivantes ne sont pas autorisés :  
  
-   Le `usernames` paramètre ne peut pas être fourni lorsque `scope` est défini sur <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Le `paths` paramètre ne peut pas contenir plusieurs entrées lorsque le `usernames` paramètre n’est pas `null`.  
  
 N’importe quel `paths` et `usernames` contenus dans les tableaux respectifs des valeurs de paramètre doivent respecter les règles de validation suivantes. Si les règles de validation échouent pour n’importe quel membre des tableaux de paramètres, une <xref:System.ArgumentException> exception est levée. Les règles de validation sont :  
  
-   `null` les valeurs ne sont pas autorisées.  
  
-   Une chaîne vide (" ») n’est pas autorisée. Les paramètres doivent être supprimés avant d’effectuer une vérification de la chaîne vide.  
  
-   Le `usernames` paramètre ne peut pas contenir de virgules (,).  
  
-   La longueur de la `paths` paramètre ne peut pas être supérieur à 256 caractères pour une base de données SQL.  
  
-   La longueur de la `usernames` paramètre ne peut pas être supérieur à 256 caractères pour une base de données SQL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Nom des données de personnalisation à supprimer. Cette valeur peut être <see langword="null" />, mais ne peut pas constituer une chaîne vide ("").</param>
        <param name="userInactiveSinceDate">Date qui indique la dernière fois qu'un utilisateur du site Web a modifié des données de personnalisation.</param>
        <summary>En cas de substitution dans une classe dérivée, supprime des données de personnalisation WebPart issues du magasin de données sous-jacent selon les paramètres spécifiés.</summary>
        <returns>Nombre de lignes supprimées dans le magasin de données sous-jacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode administrative pour la suppression des données de personnalisation. Notez que cette méthode affecte uniquement les données de personnalisation utilisateur et non les données partagées.  
  
 Les implémentations dérivées doivent suivre la logique décrite ci-dessous :  
  
-   Le `path` paramètre ne peut pas contenir les caractères génériques.  
  
-   Si le fournisseur expose des données à partir d’un magasin de données prenant en charge les transactions, cette méthode doit exécuter ses opérations dans une transaction atomique unique.  
  
-   Si le `path` paramètre n’a pas`null`, ensuite associés à des enregistrements de personnalisation par utilisateur uniquement `path` seront supprimés.  
  
-   Uniquement les enregistrements de personnalisation par utilisateur associées aux utilisateurs qui sont considérés comme inactifs depuis la date indiquée dans le `userInactiveSinceDate` paramètre est supprimé. Plus précisément, les enregistrements dans lesquels <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> est inférieure ou égale à <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> sont supprimés.  
  
-   Si les deux paramètres sont fournis, les enregistrements qui correspondent à ces deux contraintes sont supprimés.  
  
-   Le `path` paramètre peut être `null`.  
  
-   Le `path` paramètre ne peut pas être une chaîne vide. Il doit être tronqué avant d’effectuer cette vérification.  
  
-   La propriété <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> ne peut pas être `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui gère les données de personnalisation.</param>
        <param name="path">Chemin d'accès pour les informations de personnalisation à utiliser comme clé de stockage de données.</param>
        <param name="userName">Nom d'utilisateur pour les informations de personnalisation à utiliser en tant que clé.</param>
        <param name="dataBlob">Tableau d'octets de données à enregistrer.</param>
        <summary>En cas de substitution dans une classe dérivée, enregistre des données de personnalisation brutes dans le magasin de données sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite de la méthode utilisée pour enregistrer les données de personnalisation brutes dans le magasin de données sous-jacent.  
  
 Les implémentations dérivées doivent utiliser le `webPartManager`, `path`, et `userName` paramètres en tant que clés de stockage. Le fournisseur de personnalisations dérivé doit être en mesure de distinguer des données de personnalisation sur une base par page. En outre, pour l’état d’une page donnée, le fournisseur doit être en mesure de faire la distinction entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> et <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue. Si un non -`null` nom d’utilisateur est fourni, le `dataBlob` paramètre figure dans <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue ; sinon, le `dataBlob` paramètre est censé pour être dans <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> qui contient des données de personnalisation à enregistrer.</param>
        <summary>Enregistre des données de personnalisation dans un magasin de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal utilisé par le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe pour enregistrer les données de personnalisation.  
  
 L’implémentation par défaut de cette méthode utilise les méthodes d’implémentation interne de <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> à regrouper les données de personnalisation dans un tableau d’octets. Si les résultats de cette compression génèrent un octet vide de tableau (étant donné que l’extraction de la propriété a entraîné aucune donnée de personnalisation), l’implémentation par défaut appelle la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> (méthode). Sinon, l’implémentation par défaut appelle la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="state" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'objet <paramref name="state" /> enregistré présente un type différent de l'objet <paramref name="state" /> retourné par la méthode <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>