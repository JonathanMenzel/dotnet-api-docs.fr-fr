<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6820a22ca9c6491458338c5f48a307db8cbc9dc9" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37538293" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implements the basic functionality for a personalization provider.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit de la classe de base abstraite qui définit la fonctionnalité requise d’un fournisseur de personnalisations. Un fournisseur de personnalisations charge et enregistre les données de personnalisation de la part d’un <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instance.  
  
 La classe de base définit un comportement standard pour un nombre de méthodes. uniquement les méthodes qui traitent spécifiquement de magasin de données sous-jacent sont marqué comme abstract. Cela permet au développeur d’écrire un fournisseur personnalisé pour interagir avec un magasin de données spécifique, sans avoir besoin d’implémenter à nouveau les fonctionnalités standard utilisées par la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Vous pouvez dériver de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> et fournir des implémentations pour uniquement les méthodes abstraites définies dans cette classe. Les méthodes abstraites traitent spécifiquement de l’enregistrement et chargement des données dans un magasin de données physique et à l’administration du magasin de données. Un fournisseur personnalisé doit être capable de manipuler des informations de personnalisation d’une manière qui fait la distinction <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> données à partir de <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> données. En outre, un fournisseur doit segmenter les données de personnalisation par page ainsi que par application.  Les implémentations de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> sont étroitement couplées aux implémentations de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> , car certaines méthodes de fournisseur de personnalisation retournent des instances de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-classes dérivées. Pour faciliter le développement de fournisseurs personnalisés, le <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> classe de base inclut une implémentation par défaut de la logique de personnalisation et de la logique de sérialisation/désérialisation utilisée directement par le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> classe. Par conséquent, la création d’un fournisseur personnalisé uniquement à des fins de travailler avec un magasin de données différent nécessite uniquement l’implémentation des méthodes abstraites suivantes :- <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -cette méthode doit pouvoir compter le nombre de lignes de données de personnalisation dans la base de données pour les paramètres de requête fournie.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -Étant donné le chemin d’accès et nom d’utilisateur, cette méthode charge deux objets volumineux binaires (BLOB) à partir de la base de données : un destiné aux données partagées et l’autre pour les données utilisateur. Si vous fournissez le nom d’utilisateur et le chemin d’accès, vous n’avez pas besoin du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle d’accéder aux informations de pages qui peuvent fournir les informations de chemin d’accès/nom d’utilisateur.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> : Étant donné le chemin d’accès et nom d’utilisateur, cela supprime de la méthode correspondant de la ligne dans la base de données. Si vous fournissez le nom d’utilisateur et le chemin d’accès, vous n’avez pas besoin du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle d’accéder aux informations de pages qui peuvent fournir les informations de chemin d’accès/nom d’utilisateur.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -Étant donné le chemin d’accès et nom d’utilisateur, cette méthode enregistre l’objet BLOB fourni dans la base de données. Si vous fournissez le nom d’utilisateur et le chemin d’accès, vous n’avez pas besoin du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle d’accéder aux informations de pages qui peuvent fournir les informations de chemin d’accès/nom d’utilisateur.  Dans toutes ces méthodes, si seul un chemin d’accès est fourni, qui indique les données de personnalisation partagées pour la page sont manipulées. Si un chemin d’accès et un nom d’utilisateur sont passés à une méthode, puis les données de personnalisation utilisateur pour la page doivent être exploitées. Dans le cas de <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, les données partagées pour le chemin d’accès spécifié doivent toujours être chargées, et éventuellement les données de personnalisation utilisateur pour le chemin d’accès doivent également être chargées si le nom d’utilisateur n’est pas <see langword="null" />.  Toutes les autres méthodes abstraites sont destinées uniquement dans les applications d’administration et ne sont pas utilisés par l’infrastructure Web Parts en cours d’exécution. Pour obtenir un exemple d’une implémentation d’un fournisseur de personnalisations, consultez la <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" /> classe.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme il s’agit d’un constructeur pour une classe abstraite, vous devez substituer cette méthode pour créer une instance d’une classe qui hérite de cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets or sets the name of the application configured for the provider.</summary>
        <value>L’application configurée pour le fournisseur de personnalisations.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un nom d’application n’est pas spécifié dans le fichier de configuration à l’aide de la [providers, élément de personalization pour webParts (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) , la valeur d’attribut le <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> propriété est utilisée.  
  
> [!CAUTION]
>  Car une seule instance de fournisseur de personnalisations par défaut est utilisée pour toutes les demandes prises en charge par un <xref:System.Web.HttpApplication> de l’objet, vous pouvez avoir plusieurs demandes peuvent s’exécuter simultanément, chaque tentative de définition du <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valeur de propriété. Le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriété n’est pas thread-safe pour les écritures multiples et en modifiant le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valeur de propriété peut entraîner un comportement inattendu pour plusieurs utilisateurs d’une application. Il est recommandé d’éviter que le code permettant aux utilisateurs de définir la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriété, sauf si requis. Définition de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriété peut être nécessaire, par exemple, dans une application administrative qui gère les données de personnalisation pour plusieurs applications.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a list of <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> objects that represent the set of known capabilities used by the Web Parts control set.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> that represents the set of known capabilities used by the Web Parts control set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuellement, cette méthode retourne une liste qui contient deux fonctionnalités : <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> et <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>. Voici les fonctionnalités par défaut qui peuvent être définies dans le [authorization, élément de personalization pour webParts (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) élément dans le [personalization, élément de webParts (ASP.NET Schéma des paramètres)](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) élément de la[webParts, élément (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) section de configuration. Si vous choisissez d’implémenter une infrastructure de personnalisation personnalisées, vous pouvez substituer cette méthode et définir votre propre jeu de fonctionnalités utilisateur liées aux autorisations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> that manages the personalization information.</param>
        <param name="loadedState">The personalization state information.</param>
        <summary>Determines whether the initial personalization scope should be <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> or <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> scope.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> indicating whether the current personalization scope is <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> or <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si la portée actuelle doit être <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ou <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, selon une référence à un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et la personnalisation des informations qui a déjà été chargées à partir de plus haut dans le cycle de vie de personnalisation d’état. Ces informations sont utilisées par un <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instance pour les tâches suivantes liées à la personnalisation.  
  
 Les règles suivantes sont utilisées pour déterminer la portée de personnalisation :  
  
-   Étendue est censée initialement pour être <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Si le compte d’utilisateur en cours d’exécution n’est pas authentifié, l’étendue est définie <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Si le compte d’utilisateur en cours d’exécution est authentifié, un traitement supplémentaire se produit dans l’ordre de priorité :  
  
    -   Si la page est en mode de publication (postback), la demande de page contient les informations de portée à partir d’un affichage précédent de la page. Si ces informations de portée indiquent que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue a été utilisée, alors que la portée correspond à <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
    -   Si la page en cours d’exécution avait le contrôle transféré à partir d’une autre page (par exemple, si le transfert de contrôle s’est produite en raison d’appeler le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode ; Notez que cette vérification spécifique ne se produit pas pour la validation de plusieurs pages) et si le précédemment l’exécution de page avait un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance, l’étendue est définie à la valeur de la `Personalization.Scope` propriété du précédent <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance.  
  
    -   Si le critère précédent n’est pas remplie, la portée correspond à la valeur de la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> propriété actif <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Une fois les évaluations précédentes ont été apportées, et si la portée correspond à <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue, le traitement suivant se produit :  
  
-   Si le compte d’utilisateur en cours d’exécution a la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> fonctionnalité, l’étendue reste <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Si le compte d’utilisateur en cours d’exécution n’a pas la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> fonctionnalité, puis l’étendue est réinitialisé à <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Si le résultat de toutes les évaluations de portée précédentes est <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, ce résultat est stocké sous la forme d’un champ masqué sur la page en cours d’exécution. Ceci est le mécanisme par lequel une page de relire l’évaluation de la portée pendant les publications ultérieures.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization information.</param>
        <summary>Returns a dictionary containing <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> instances that represent the personalization-related capabilities of the currently executing user account.</summary>
        <returns>An <see cref="T:System.Collections.IDictionary" /> containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> instances if the user account is authenticated, or <see langword="null" /> if the executing user account is not authenticated.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode utilise les informations contenues dans le [authorization, élément de personalization pour webParts (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) élément dans le [personalization, élément pour webParts (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) élément de la[webParts, élément (schéma des paramètres ASP.NET)](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) section de configuration dans le fichier Machine.config ou Web.config pour déterminer un utilisateur habilité de fonctionnalités.  
  
 Les fonctionnalités dans le dictionnaire doivent être membres du <xref:System.Collections.IList> objet retourné par la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A> (méthode), qui contiennent le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> fonctionnalité et la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> fonctionnalité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.  \- or -  The request associated with the page is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> with the personalization information to be queried. This value cannot be <see langword="null" />.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> containing a query. This value can be <see langword="null" />.</param>
        <param name="pageIndex">The location where the query starts.</param>
        <param name="pageSize">The number of records to return.</param>
        <param name="totalRecords">The total number of records available.</param>
        <summary>When overridden in a derived class, returns a collection containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-derived objects based on scope and specific query parameters.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-derived objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode d’administration pour l’interrogation des données de personnalisation. Les implémentations dérivées doivent suivre la logique décrite ci-dessous.  
  
 Le jeu d’éléments retournés est contraint par la `pageIndex` et `pageSize` paramètres, où `pageSize` définit le nombre d’enregistrements à retourner et `pageIndex` définit les enregistrements à retourner. Par exemple, un `pageIndex` de 0 et un `pageSize` 25 retournerait les 25 premières occurrences, tandis qu’un `pageIndex` 1 et un `pageSize` de 25 retournerait occurrences 26 à 50. Si vous souhaitez récupérer tous les enregistrements disponibles, définissez `pageIndex` à 0 et `pageSize` à <xref:System.Int32.MaxValue>.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-objets dérivés sont retournés par ordre alphabétique et triés par une combinaison de leurs <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> et <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> valeurs de propriété, à la fois dans l’ordre croissant.  
  
 Cette méthode passe les caractères génériques de requête dans le magasin de données sous-jacent. Prise en charge des caractères génériques dépend de la façon dont chaque fournisseur gère les caractères comme un astérisque (*), un symbole de pourcentage (%) ou un trait de soulignement (_).  
  
 Normalement, pour les magasins de données compatibles SQL, vous pouvez effectuer une recherche par caractères génériques sur un chemin d’accès partiel avec le caractère générique qui apparaît au début, la fin ou au milieu du texte de chaîne de recherche dans le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété. Par exemple, pour rechercher tous les chemins qui commencent par « ~/vdir », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété est définie à « ~/vdir% ».  
  
 De même, une recherche générique sur un nom d’utilisateur partiel peut avoir le caractère générique en tout point dans la chaîne de texte de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété. Par exemple, pour rechercher tous les noms d’utilisateur qui commencent par « John », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> paramètre ressemble à « John % ».  
  
 Les contraintes de requête suivantes s’appliquent :  
  
-   Si seuls `scope` est fourni, et `query` est `null` ou toutes les propriétés sur `query` retourner `null` ou les valeurs par défaut, puis tous les enregistrements correspondant au `scope` paramètre sont retournés.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété n’est pas `null`, les enregistrements retournés sont également filtrés selon les chemins d’accès qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valeur.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété n’est pas `null`, les enregistrements retournés sont également filtrés selon les noms utilisateur qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valeur de propriété.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété n’est pas égale à <xref:System.DateTime.MaxValue>, les enregistrements retournés sont également filtrés pour retourner uniquement les enregistrements associés aux utilisateurs inactifs. La comparaison inclut des enregistrements où la <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> la propriété est inférieure ou égale à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété.  
  
 Notez que cette méthode ne valide pas les combinaisons de paramètres de requête. Par exemple, le code peut demander un jeu d’enregistrements d’état de personnalisation associé à un nom d’utilisateur spécifique dans la portée partagée. Étant donné que les noms d’utilisateur ne sont pas associés à des informations partagées, la collection retournée est vide.  
  
 Les combinaisons de paramètres susceptibles de retourner une collection non vide sont les suivantes :  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue en association avec le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue en combinaison avec les valeurs pour tout ou partie de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, et <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriétés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> of the personalization information to be queried. This value cannot be <see langword="null" />.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> containing a query. This value can be <see langword="null" />.</param>
        <summary>When overridden in a derived class, returns the number of rows in the underlying data store that exist within the specified scope.</summary>
        <returns>The number of rows in the underlying data store that exist for the specified <paramref name="scope" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode d’administration pour extraire des décomptes des données de personnalisation. Les implémentations dérivées doivent suivre la logique décrite ci-dessous.  
  
 Cette méthode passe les caractères génériques de requête dans le magasin de données sous-jacent. Prise en charge des caractères génériques dépend de la façon dont chaque fournisseur gère les caractères comme un astérisque (*), un symbole de pourcentage (%) ou un trait de soulignement (_).  
  
 Normalement, pour les magasins de données compatibles SQL, vous pouvez effectuer une recherche par caractères génériques sur un chemin d’accès partiel avec le caractère générique qui apparaît au début, la fin ou au milieu du texte de chaîne de recherche dans le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété. Par exemple, pour rechercher tous les chemins qui commencent par « ~/vdir », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété est définie à « ~/vdir% ».  
  
 De même, une recherche générique sur un nom d’utilisateur partiel peut avoir le caractère générique en tout point dans la chaîne de texte de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété. Par exemple, pour rechercher tous les noms d’utilisateur qui commencent par « John », le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> paramètre ressemble à « John % ».  
  
 Les contraintes de requête suivantes s’appliquent :  
  
-   Si seuls `scope` est fourni, et `query` est `null` ou toutes les propriétés sur `query` retourner `null` ou les valeurs par défaut, puis tous les enregistrements correspondant au `scope` paramètre sont comptés.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété n’est pas `null`, les enregistrements comptés sont également filtrés selon les chemins d’accès qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valeur.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriété n’est pas `null`, les enregistrements comptés sont également filtrés selon les noms utilisateur qui correspondent à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valeur de propriété.  
  
-   Si le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété n’est pas égale à <xref:System.DateTime.MaxValue>, les enregistrements comptés sont également filtrés pour retourner uniquement les enregistrements associés aux utilisateurs inactifs. La comparaison inclut des enregistrements où la <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> la propriété est inférieure ou égale à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété.  
  
 Notez que cette méthode ne valide pas les combinaisons de paramètres de requête. Par exemple, le code peut demander un nombre d’enregistrements d’état de personnalisation associé à un nom d’utilisateur spécifique dans la portée partagée. Étant donné que les noms d’utilisateur ne sont pas associés à des informations partagées, le nombre retourné serait égal à zéro.  
  
 Les combinaisons de paramètres qui ont la possibilité de retourner un nombre différent de zéro sont les suivantes :  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue en association avec le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriété.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue en combinaison avec les valeurs pour tout ou partie de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, et <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriétés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the retrieval key.</param>
        <param name="userName">The user name for personalization information to be used as the retrieval key.</param>
        <param name="sharedDataBlob">The returned data for the <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> scope.</param>
        <param name="userDataBlob">The returned data for the <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> scope.</param>
        <summary>When overridden in a derived class, loads raw personalization data from the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> et implémentent cette méthode doit utiliser le `webPartManager`, `path`, et `username` paramètres en tant que clés de récupération. Indépendamment de la façon dont les données sont stockées dans le magasin de données (certains magasins de données peuvent effectuer un certain type de stockage intelligent), les données doivent être retournées de personnalisation comme un jeu d’octets dans deux tableaux compressé. Les données retournées doivent respecter les règles suivantes :  
  
-   Les données pour le <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue doit toujours être retournée dans le `sharedDataBlob` paramètre.  
  
-   Selon les valeurs de clé, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données sont retournées dans le `userDataBlob` paramètre. Non -`null` valeur pour le `userName` paramètre indique que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données doivent également être récupérées.  
  
 Un fournisseur de personnalisations qui dérive de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> et implémente cette méthode peut optimiser des interactions avec son magasin de données en récupérant toutes les données de personnalisation dans un seul aller-retour, par opposition à la récupération de <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> et <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données en deux Séparez les allers-retours.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="ignoreCurrentUser">A <see cref="T:System.Boolean" /> indicating whether the user name should be passed to the personalization provider.</param>
        <summary>Loads the raw data from the underlying data store and converts that data into a <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> object.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> containing personalization data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal utilisé par le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe pour charger des données de personnalisation. L’implémentation par défaut charge les données brutes à partir du magasin de données sous-jacent (la fonctionnalité est implémentée dans les fournisseurs dérivés), puis convertit les données brutes dans un <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> instance.  
  
 Si le `ignoreCurrentUser` paramètre est `true`, aucun nom d’utilisateur n’est passé à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A> (méthode). Un fournisseur de personnalisations peut choisir interpréter cela comme ce qui signifie que seul état de personnalisation avec un <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue doit être extrait du magasin de données sous-jacent.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> méthode s’exécute, il appelle le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A> (méthode), et il existe trois types d’erreur de désérialisation peut se produire lorsque l’état est en cours de chargement. Lorsque ces erreurs spécifiques se produisent, aucune exception n’est levée, et les événements d’erreur sont enregistrés par la fonctionnalité de contrôle d’intégrité (pour plus d’informations sur l’analyse des performances et en accédant aux journaux créés par elle, consultez [vue d’ensemble de la surveillance de l’intégrité ASP.NET ](http://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). À écrire dans le journal des événements d’erreur de désérialisation de la cause de trois scénarios suivants :  
  
-   Échec d’une tentative de désérialisation d’un type de propriété qui utilise une chaîne <xref:System.ComponentModel.TypeConverter>.  
  
-   Échec d’un tentative de désérialisation d’un type de propriété qui utilise la sérialisation binaire.  
  
-   Échec d’une tentative de désérialisation d’un type de propriété, car une instance du type ne peut pas être créée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.  \- or -  The request associated with the page is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the data store key.</param>
        <param name="userName">The user name for personalization information to be used as the data store key.</param>
        <summary>When overridden in a derived class, deletes raw personalization data from the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui dérivent de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> et implémentent cette méthode doit utiliser le `webPartManager`, `path`, et `userName` paramètres en tant que clés de stockage. Les implémentations dérivées doivent modifier le magasin de données afin que les données de personnalisation pour les clés de stockage fourni sont effectivement supprimées. Il incombe les implémentations dérivées quant à la façon dont ils physiquement parvenir.  
  
 Le fournisseur de personnalisations dérivé doit être en mesure de distinguer des données de personnalisation sur une base par page. En outre, pour l’état d’une page donnée, le fournisseur de personnalisations doit être en mesure de faire la distinction entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> et <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> données de portée. Si un non -`null` nom d’utilisateur est fourni, puis l’opération de réinitialisation s’applique à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue ; sinon, l’opération de réinitialisation s’applique à la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <summary>Resets personalization data to the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal utilisé par le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe pour réinitialiser les données de personnalisation. L’implémentation par défaut utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour déterminer le chemin d’accès et nom d’utilisateur pour les données doivent être réinitialisées. L’implémentation par défaut puis appelle le <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartManager" /> is not associated with a page.  \- or -  The page is not associated with an in-progress <see cref="T:System.Web.HttpRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> of the personalization information to be reset. This value cannot be <see langword="null" />.</param>
        <param name="paths">The paths for personalization information to be deleted.</param>
        <param name="usernames">The user names for personalization information to be deleted.</param>
        <summary>When overridden in a derived class, deletes personalization state from the underlying data store based on the specified parameters.</summary>
        <returns>The number of rows deleted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode administrative pour la suppression des données de personnalisation. Les implémentations dérivées doivent suivre la logique décrite ci-dessous.  
  
 Aucune recherche de caractères génériques n’est pris en charge par cette méthode. Si le fournisseur de personnalisations expose des données à partir d’un magasin de données prenant en charge les transactions, cette méthode doit exécuter ses opérations comme une transaction atomique unique.  
  
 Uniquement les combinaisons de paramètres suivantes sont autorisées :  
  
-   Le `scope` paramètre est défini, et tous les autres paramètres sont définis sur `null`. Cette combinaison supprime toutes les données de personnalisation WebPart associées à la portée de personnalisation indiquée par `scope`.  
  
-   Le `scope` paramètre est défini et le `paths` paramètre contient au moins une valeur. Cette combinaison supprime toutes les données de personnalisation WebPart pour le chemin d’accès spécifié ou les chemins d’accès dans la portée de personnalisation indiquée par `scope`.  
  
-   Le `scope` paramètre est défini sur <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, le `paths` paramètre est défini et contient une seule valeur et le `usernames` paramètre contient au moins une valeur. Cette combinaison supprime toutes les utilisateur données de personnalisation WebPart pour le chemin d’accès qui est associé à l’utilisateur ou les utilisateurs contenus dans `usernames`.  
  
-   Le `scope` paramètre est défini sur <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, le `paths` paramètre est défini sur `null`et le `usernames` paramètre contient au moins une valeur. Cette combinaison supprime toutes les données de composants WebPart, de personnalisation par utilisateur sur tous les chemins d’accès, associés à l’utilisateur ou les utilisateurs contenus dans `usernames`.  
  
 Toute autre combinaison de valeurs de paramètre n’est pas valide et lève un <xref:System.ArgumentException> exception. Plus précisément, les deux combinaisons suivantes ne sont pas autorisés :  
  
-   Le `usernames` paramètre ne peut pas être fourni lorsque `scope` est défini sur <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Le `paths` paramètre ne peut pas contenir plusieurs entrées lorsque le `usernames` paramètre n’est pas `null`.  
  
 N’importe quel `paths` et `usernames` contenus dans les tableaux respectifs des valeurs de paramètre doivent respecter les règles de validation suivantes. Si les règles de validation échouent pour n’importe quel membre des tableaux de paramètres, une <xref:System.ArgumentException> exception est levée. Les règles de validation sont :  
  
-   `null` les valeurs ne sont pas autorisées.  
  
-   Une chaîne vide (" ») n’est pas autorisée. Les paramètres doivent être supprimés avant d’effectuer une vérification de la chaîne vide.  
  
-   Le `usernames` paramètre ne peut pas contenir de virgules (,).  
  
-   La longueur de la `paths` paramètre ne peut pas être supérieur à 256 caractères pour une base de données SQL.  
  
-   La longueur de la `usernames` paramètre ne peut pas être supérieur à 256 caractères pour une base de données SQL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">The path of the personalization data to be deleted. This value can be <see langword="null" /> but cannot be an empty string ("").</param>
        <param name="userInactiveSinceDate">The date indicating the last time a Web site user changed personalization data.</param>
        <summary>When overridden in a derived class, deletes Web Parts personalization data from the underlying data store based on the specified parameters.</summary>
        <returns>The number of rows deleted from the underlying data store.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite d’une méthode administrative pour la suppression des données de personnalisation. Notez que cette méthode affecte uniquement les données de personnalisation utilisateur et non les données partagées.  
  
 Les implémentations dérivées doivent suivre la logique décrite ci-dessous :  
  
-   Le `path` paramètre ne peut pas contenir les caractères génériques.  
  
-   Si le fournisseur expose des données à partir d’un magasin de données prenant en charge les transactions, cette méthode doit exécuter ses opérations dans une transaction atomique unique.  
  
-   Si le `path` paramètre n’a pas`null`, ensuite associés à des enregistrements de personnalisation par utilisateur uniquement `path` seront supprimés.  
  
-   Uniquement les enregistrements de personnalisation par utilisateur associées aux utilisateurs qui sont considérés comme inactifs depuis la date indiquée dans le `userInactiveSinceDate` paramètre est supprimé. Plus précisément, les enregistrements dans lesquels <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> est inférieure ou égale à <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> sont supprimés.  
  
-   Si les deux paramètres sont fournis, les enregistrements qui correspondent à ces deux contraintes sont supprimés.  
  
-   Le `path` paramètre peut être `null`.  
  
-   Le `path` paramètre ne peut pas être une chaîne vide. Il doit être tronqué avant d’effectuer cette vérification.  
  
-   Le <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriété ne peut pas être `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the data store key.</param>
        <param name="userName">The user name for personalization information to be used as the key.</param>
        <param name="dataBlob">The byte array of data to be saved.</param>
        <summary>When overridden in a derived class, saves raw personalization data to the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est la définition abstraite de la méthode utilisée pour enregistrer les données de personnalisation brutes dans le magasin de données sous-jacent.  
  
 Les implémentations dérivées doivent utiliser le `webPartManager`, `path`, et `userName` paramètres en tant que clés de stockage. Le fournisseur de personnalisations dérivé doit être en mesure de distinguer des données de personnalisation sur une base par page. En outre, pour l’état d’une page donnée, le fournisseur doit être en mesure de faire la distinction entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> et <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue. Si un non -`null` nom d’utilisateur est fourni, le `dataBlob` paramètre figure dans <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> étendue ; sinon, le `dataBlob` paramètre est censé pour être dans <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> étendue.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> containing personalization data to be saved.</param>
        <summary>Saves personalization data to a data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est le point d’entrée principal utilisé par le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe pour enregistrer les données de personnalisation.  
  
 L’implémentation par défaut de cette méthode utilise les méthodes d’implémentation interne de <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> à regrouper les données de personnalisation dans un tableau d’octets. Si les résultats de cette compression génèrent un octet vide de tableau (étant donné que l’extraction de la propriété a entraîné aucune donnée de personnalisation), l’implémentation par défaut appelle la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> (méthode). Sinon, l’implémentation par défaut appelle la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="state" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="state" /> object being saved has a different type from the <paramref name="state" /> object that was returned by the <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> method.</exception>
      </Docs>
    </Member>
  </Members>
</Type>