<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601303" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Sert de classe centrale du jeu de composants webPart en gérant l’ensemble des contrôles, fonctionnalités et événements webPart qui se produisent sur une page web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle agit comme le centre de concentrateur ou de contrôle d’une application de composants WebPart. Il doit y avoir un seul--et unique--<xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance de contrôle sur chaque page qui utilise des contrôles WebPart. Comme avec la plupart des aspects des applications WebPart, les <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle fonctionne uniquement avec les utilisateurs authentifiés. En outre, ses fonctionnalités fonctionnent presque entièrement avec des contrôles serveur qui résident dans les zones WebPart qui héritent de la <xref:System.Web.UI.WebControls.WebParts.WebZone> classe. Contrôles serveur qui résident sur une page en dehors de ces zones peuvent avoir très peu de fonctionnalités WebPart ou d’interaction avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Comme concentrateur pour fonctionnalités WebPart sur une page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle exécute les types de tâches décrites dans le tableau suivant.  
  
|Catégorie de tâche|Ce que fait le contrôle|  
|-------------------|---------------------------|  
|Suivi des contrôles WebPart|Effectue le suivi de nombreux types de contrôles sur une page qui fournissent des fonctionnalités de composants WebPart, y compris <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, les connexions, les zones et autres.|  
|Ajout et suppression de contrôles WebPart|Fournit les méthodes pour l’ajout, la suppression et la fermeture de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sur une page.|  
|Administration des connexions|Crée des connexions entre les contrôles et surveille les connexions, ainsi que les processus d’ajout et de les supprimer.|  
|Personnalisation des pages et des contrôles|Permet aux utilisateurs de déplacer les contrôles vers différents emplacements sur une page et lance les vues dans lesquelles les utilisateurs peuvent modifier l’apparence, propriétés et le comportement de contrôles. Conserve les paramètres de personnalisation spécifiques à l’utilisateur sur chaque page.|  
|Basculement entre les différentes vues de page|Bascule une page entre les différentes vues spécialisées de la page, afin que les utilisateurs puissent exécuter certaines tâches telles que la modification de mise en page ou les contrôles d’édition.|  
|Le déclenchement d’événements de cycle de vie des composants WebPart|Définit, déclenche et permet aux développeurs de gérer les événements de cycle de vie de contrôles WebPart, tels que lorsque les contrôles sont ajoutés, déplacés, connectés ou supprimés.|  
|L’activation d’importation et exportation de contrôles|Exporte les flux XML qui contiennent l’état des propriétés de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, et permet aux utilisateurs d’importer les fichiers pour faciliter la personnalisation des contrôles complexes dans d’autres pages ou les sites.|  
  
 La <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe a un grand ensemble de propriétés. Cohérent avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> rôle de suivi d’autres contrôles, il a un nombre de propriétés qui référencent des collections de contrôles WebPart, ou d’autres objets WebPart spéciaux. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriétés sont toutes les collections sont utilisées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle son suivi et d’autres tâches de gestion.  
  
 Un autre groupe de propriétés contient des avertissements personnalisables qui s’appliquent dans certains scénarios qui se produisent dans une application WebPart. Celles-ci incluent la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriétés.  
  
 La <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe substitue certaines propriétés de base héritées, qui sont utilisées par nombreux contrôles serveur Web. Celles-ci incluent la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriétés.  
  
 Enfin, un groupe de propriétés est utile pour accéder à l’état actuel de l’application. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété indique le mode d’affichage actuel d’une page. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> propriété indique si un contrôle est autorisé à restituer un script côté client, qui est pertinent dans les situations dans lesquelles les utilisateurs peuvent avoir des navigateurs avec des fonctionnalités différentes ou avoir désactivé les scripts. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété est utile pour faire référence à une classe utilitaire qui contient les appels à un nombre de méthodes WebPart importantes utilisées pour les cas d’extensibilité. En masquant les appels à ces méthodes dans une classe distincte (le <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe), le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> API de la classe est simplifiée. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété fournit l’accès aux objets de personnalisation qui stockent des paramètres de personnalisation des utilisateurs et de conserver ces données dans un stockage permanent. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété indique quel <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle sur une page est actuellement sélectionné par l’utilisateur ou l’application. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété indique si les données de personnalisation personnalisées sur un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle a changé.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle contient cinq modes d’affichage intégrés ou des vues d’une page Web. Les développeurs peuvent étendre cette fonctionnalité, en créant des modes d’affichage personnalisé en étendant des types tels que les <xref:System.Web.UI.WebControls.WebParts.WebZone> classe ou la <xref:System.Web.UI.WebControls.WebParts.ToolZone> classe. Les utilisateurs peuvent basculer d’une page dans les différents modes d’affichage, sous réserve que le type approprié de contrôles qui correspondent à un mode d’affichage donné sont présentes dans une page.  
  
> [!NOTE]
>  Il est possible d’étendre cette fonctionnalité afin que les utilisateurs peuvent basculer en mode d’affichage personnalisé sans avoir de zone correspondante sur la page. Toutefois, le comportement par défaut est que les modes d’affichage correspondent à des zones.  
  
 Les modes d’affichage standard sont représentés par les champs publics dans la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. Le tableau suivant récapitule les champs et les modes d’affichage qu'ils font référence. Le mode d’affichage actuel d’une page, comme indiqué ci-dessus, est toujours référencé dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété et que le jeu de modes d’affichage possibles sur une page particulière, compte tenue du type de zones qui sont présents dans la page, est contenue dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
|Champ|En mode affichage des détails|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Le mode utilisateur normal d’une page Web ; mode d’affichage par défaut et la plus courante.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|La vue dans laquelle les utilisateurs peuvent réorganiser ou supprimer des contrôles pour modifier la mise en page.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|Affichage dans lequel une interface utilisateur (IU) de modification devient visible ; les utilisateurs peuvent modifier l’apparence, propriétés et le comportement des contrôles qui sont visibles dans le mode de navigation normal.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|Affichage dans lequel un interface utilisateur du catalogue devient visible ; les utilisateurs peuvent ajouter des contrôles à une page à partir des catalogues de contrôles disponibles.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|Affichage dans lequel une interface utilisateur de connexion devient visible ; les utilisateurs peuvent se connecter, gérer ou déconnecter les connexions entre les contrôles.|  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle contient également un nombre d’événements critiques dans le cycle de vie des pages de composants WebPart et des contrôles. Ces événements fournissent un contrôle par programmation précis sur le comportement de contrôles WebPart. La plupart des méthodes se rapportent directement aux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles (ou d’autres contrôles serveur ou utilisateur qui sont placés dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> afin qu’ils peuvent se comporter comme des zones <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles). Toutefois, quelques événements se rapportent à l’état de la page ou les connexions sur la page. Le tableau suivant répertorie les événements disponibles et résume leurs fonctions.  
  
> [!NOTE]
>  Dans tous les cas dans le tableau suivant, le mot « contrôle » fait référence à un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle ou n’importe quel serveur qui réside dans une zone et qui est encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet en cours d’exécution.  
  
|événement|Description |  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|Se produit juste avant l’ajout d’un contrôle à une page pour vérifier qu’il est autorisé.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|Se produit une fois que toutes les connexions sur une page ont été activées.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|Se produit juste avant le processus d’activation de toutes les connexions sur une page.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|Se produit après que le mode d’affichage actuel d’une page a changé.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|Se produit juste avant le processus de changement de mode d’affichage d’une page.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|Se produit après que la sélection d’un contrôle a été annulée.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|Se produit juste avant le processus d’annulation de la sélection d’un contrôle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|Se produit après l’ajout d’un contrôle à une zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|Se produit juste avant le processus d’ajout d’un contrôle à une zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|Se produit après qu’un contrôle a été fermé (supprimé d’une page).|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|Se produit juste avant le processus de fermeture d’un contrôle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|Se produit après qu’une instance d’un contrôle dynamique (qui a été créé par programme ou à partir d’un catalogue) a été définitivement supprimée.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|Se produit juste avant le processus de suppression d’un contrôle dynamique.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|Se produit après qu’un contrôle a été déplacé dans sa zone ou vers une autre zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|Se produit juste avant le processus de déplacement d’un contrôle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|Se produit après que deux contrôles sélectionnés pour participer à une connexion ont établi la connexion.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|Se produit juste avant le processus de connexion de deux contrôles.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|Se produit après la déconnexion de deux contrôles connectés.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|Se produit juste avant le processus de déconnexion de deux contrôles.|  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle dispose de nombreuses méthodes pour gérer les pages de composants WebPart. Un grand ensemble de méthodes, non répertoriées ici, les méthodes dont les noms prennent la forme on*EventName*. Ces méthodes généralement déclencher son événement associé et fournissent à l’événement avec un gestionnaire de type <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>. La plupart de ces méthodes peut être substituée par les développeurs qui héritent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. En outre, les développeurs de pages peuvent fournir des gestionnaires personnalisés pour les événements associés à ces méthodes. Par exemple, dans le cas de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement, un développeur de pages peut ajouter un `OnWebPartAdded` attribut le `<asp:webpartmanager>` élément dans le balisage d’une page Web, puis assignez le nom de méthode personnalisée à l’attribut pour fournir une gestion personnalisée pour l’événement. L’attribut correspond à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> (méthode) et ce modèle de base de fonctionnement pour la plupart des événements WebPart et leurs méthodes associées de la gestion des événements.  
  
 En outre, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle dispose de méthodes particulières à la tâche de gestion <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles (et les contrôles serveur ou utilisateur utilisés comme <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles). Ces méthodes incluent <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.  
  
 Un autre ensemble de méthodes est spécialisé pour les connexions. Cela inclut des méthodes telles que <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 Enfin, certaines <xref:System.Web.UI.WebControls.WebParts.WebPartManager> méthodes vous concentrer sur les fonctionnalités de personnalisation. Ceux-ci incluent <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.  
  
 Pour plus d’informations sur les autres <xref:System.Web.UI.WebControls.WebParts.WebPartManager> les méthodes qui sont accessibles via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété, consultez la documentation relative à la <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation déclarative et par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 Le contrôle utilisateur a un contrôle de liste déroulante qui affiche les modes d’affichage possibles sur une page, compte tenue des contrôles WebPart qui sont présents dans la page. Dans la page Web pour cet exemple de code, ce contrôle utilisateur est déclaré juste en dessous de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> élément dans le balisage de la page et qu’il existe un `Register` directive au début de la page Web pour inscrire le contrôle. Pour plus d’informations sur les modes d’affichage et une description du code source dans ce contrôle, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Le balisage déclaratif de la page Web contient `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. La page contient également du code incorporé qui gère les événements liés à la connexion pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler ; vous pouvez voir l’effet de ce code comme vous connectez et de Déconnectez les contrôles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Notez qu’il existe une interface nommée `IZipCode`, et cette interface est implémentée dans le `ZipCodeWebPart` classe. Cette classe a une méthode de rappel spéciale nommée `ProvideIZipCode` qui sert de fournisseur. L’autre type, nommé `WeatherWebPart`, est également implémenté avec une méthode spéciale nommée `GetIZipCode`, ce qui permet au contrôle d’agir comme un consommateur de l’autre contrôle.  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code suppose que vous avez compilé la code source dans un assembly et le `Register` le nom de l’assembly fait référence à la directive de la page Web. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois l’interface utilisateur de connexion s’affiche, cliquez sur le **créer une connexion à un consommateur** lien. Une cellule apparaît avec un contrôle de liste déroulante. Sélectionnez **contrôle météo** dans la liste déroulante, puis cliquez sur **connexion** pour établir la connexion des deux contrôles. Cliquez sur **fermer**, puis utilisez le **Mode d’affichage** liste déroulante, pour retourner la page en mode de navigation normal. Vous pouvez entrer un Code postal et le contrôle consommateur sera mise à jour avec la valeur d’entrée. Étant donné que la `ZipCode` a été marquée avec le `Personalizable` dans le code source, cette valeur de propriété sera conservé dans les sessions de navigateur, ce qui évite la valeur entrée par un utilisateur. Un contrôle plus sophistiqué de consommateur peut prendre les informations de code postal, rechercher des informations concernant la météo en fonction du code et présenter à un utilisateur.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle est conçu pour être étendu. Étant donné qu’il est central pour les applications WebPart, lorsque vous souhaitez étendre un type spécifique ou de contrôle dans le jeu de composants WebPart, dans de nombreux cas, vous devez également étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, car il est susceptible d’avoir une propriété ou une méthode qui est requis pour rendre  votre type personnalisé fonctionne dans le contexte d’une application de composants WebPart. Documentation de référence WebPart (voir <see cref="N:System.Web.UI.WebControls.WebParts" />), lorsque vous expliquant comment étendre un WebPart type mentionne ce qui doit être fait pour étendre la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe également ou montre comment l’étendre dans un exemple de code.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> constructeur initialise plusieurs variables importantes utilisées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Une assignation directement a un impact sur toutes les pages de composants WebPart est le fait que le mode d’affichage page par défaut est défini pour le mode de navigation (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend actives toutes les connexions d'une page Web actuellement inactives.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée sur chaque demande d’une page pour activer des connexions existantes entre <xref:System.Web.UI.WebControls.WebParts.WebPart> et d’autres contrôles serveur résidant dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones. Dans certains cas, par exemple, s’il existe un conflit dans les connexions en cours d’activation, cette méthode à son tour appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode pour mettre fin à la connexion problématique. Pendant le processus de déconnexion du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement est déclenché. Les développeurs peuvent généralement annuler cet événement, mais dans le cas où il s’agit de conflit entre les connexions, il ne peut pas être annulée, car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a besoin résoudre le conflit pour terminer le processus d’activation des connexions. Pour plus d’informations, consultez <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou contrôle serveur ou utilisateur) à ajouter à une page Web ou à ouvrir sur une page.</param>
        <param name="zone">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> auquel <c>webPart</c> est ajouté.</param>
        <param name="zoneIndex">Entier qui représente la position ordinale occupée par <c>webPart</c> dans <c>zone</c> par rapport à d'autres contrôles dans <c>zone</c>.</param>
        <summary>Fournit la méthode par programme standard pour ajouter des contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à une page Web.</summary>
        <returns>Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> qui a été ajouté à la page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode est utilisée à la fois pour ajouter la nouvelle dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à une page et pour rouvrir les contrôles statiques ou dynamiques qui ont été précédemment fermés sur une page. Lorsque la méthode est appelée pour ajouter un nouveau contrôle, elle crée une copie du contrôle référencé dans le `webPart` paramètre. Un nouvel ID est généré pour la copie du contrôle, donc les développeurs doivent référencer le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle renvoyé par la méthode à obtenir la nouvelle valeur de code. Lorsque la méthode est appelée pour rouvrir un contrôle fermé précédemment, elle retourne une référence directe au contrôle référencé par le `webPart` paramètre.  
  
> [!IMPORTANT]
>  Vous devez toujours utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode, plutôt que la <xref:System.Web.UI.ControlCollection.Add%2A> méthode de la collection de contrôles référencés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> propriété, à ajouter <xref:System.Web.UI.WebControls.WebParts.WebPart> par programmation des contrôles à la page, car à l’aide de la <xref:System.Web.UI.ControlCollection.Add%2A> méthode lève une exception. Pour ajouter un contrôle qui n’est pas un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (en d’autres termes, un contrôle serveur qui sera encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle au moment de l’exécution), vous devez d’abord appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode pour créer le contrôle, puis appelez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode pour ajouter le contrôle. Pour une démonstration de cette approche, consultez la section exemple.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode pour ajouter un contrôle serveur par programmation à une page. Le balisage de page contient vide `<asp:webpartzone>` élément et un `<asp:webpartmanager>` élément. La première fois le **ajouter un calendrier** bouton, le code au gestionnaire d’événements crée un <xref:System.Web.UI.WebControls.Calendar> de contrôle et l’ajoute à une zone en tant qu’un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet, l’appel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> (méthode).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.  
  
 \- ou -  
  
 <paramref name="zone" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> n'est pas enregistrée dans la collection de zones du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
 \- ou -  
  
 <paramref name="webPart" /> est déjà dans <paramref name="zone" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="zoneIndex" /> est inférieure à zéro.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la méthode <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> est appelée pour déterminer si un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur peut être ajouté à une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement se produit chaque fois qu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est ajouté à une page. Il existe un nombre de scénarios courants où un contrôle peut être ajouté à une page. Pour une description complète, consultez la section Notes pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode). Lorsqu’un contrôle est ajouté, il doit être vérifié pour voir si son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété a été définie et, dans ce cas, si le contrôle est autorisé à ajouter à la page.  
  
 Les développeurs peuvent créer des gestionnaires d’événements pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, afin de fournir un filtrage pour les contrôles. Si un contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valeur de propriété ne répond pas aux critères dans le code de gestionnaire d’événements, le contrôle n’est pas ajouté à la page.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir un gestionnaire d’événements personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, qui remplace automatiquement la valeur par défaut <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode).  
  
 Le code dans le `mgr1_AuthorizeWebPart` méthode vérifie si les contrôles sur la page ont respectives <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> les valeurs de propriété `user` et, si tel est le cas, retourne `true`, ce qui signifie qu’ils seront autorisés et ajoutés à la page. Cela suppose que l’approche par défaut consiste à permettre aux utilisateurs d’afficher des contrôles avec une page dans la portée de personnalisation utilisateur. Notez, toutefois, que dans l’exemple d’un des contrôles son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valeur de propriété `admin`. Les développeurs peuvent placer ce filtre sur un contrôle spécialisé qui a été conçu pour seulement les utilisateurs administratifs à voir. Ce contrôle échoue à la vérification d’autorisation lors de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement et ne seront pas affichées. Notez que les contrôles qui n’ont pas de définir la propriété sont affichés. ils sont supposés ne pas pour faire partie d’un scénario de filtrage, car leurs <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriétés ne sont pas définies.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection d'objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> qui sont disponibles pour créer des connexions WebPart entre les contrôles serveur.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> qui contient un ensemble d'objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété utilise la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> méthode pour créer la collection. Par défaut, il lit les transformateurs disponibles à partir du fichier de configuration d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle pour lequel la connexion est formée.</param>
        <summary>Démarre le processus de connexion de deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> méthode existe afin que le processus d’établir des connexions entre les contrôles peut être effectué dans des étapes distinctes, donnant ainsi aux développeurs de mieux contrôler le processus de connexion. La méthode exécute un ensemble de contrôles initiaux pour vous assurer que `webPart` est dans un état où une connexion peut être formée de manière légitime. Si `webPart` passe tous les contrôles, il est alors défini comme le contrôle actuellement sélectionné (voir la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété), et le processus de connexion peut continuer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le mode d'affichage actuel sur la page n'est pas <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> est fermé.  
  
 \- ou -  
  
 <paramref name="webPart" /> ne fait pas partie de la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 ou  
  
 <paramref name="webPart" /> est égal au contrôle <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <block subset="none" type="overrides">
          <para>Les développeurs qui ont besoin d’étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle souhaiterez peut-être substituer cette méthode dans une classe dérivée. Une approche consisterait à appeler la méthode de base et ajoutez ensuite une gestion personnalisée supplémentaire ; ou vous pouvez entièrement personnaliser le processus de démarrage d’une connexion entre les contrôles. Par exemple, vous voulez vérifier que certaines données sont disponibles avant de créer la connexion.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle à modifier.</param>
        <summary>Démarre le processus d'édition d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> méthode existe afin que le processus de contrôles d’édition peut être effectué dans des étapes distinctes, donnant ainsi aux développeurs de mieux contrôler le processus. La méthode exécute un ensemble de contrôles initiaux pour vous assurer que `webPart` est dans un état où il peut être modifié. Si `webPart` passe tous les contrôles, il est alors défini comme le contrôle actuellement sélectionné (voir la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété), et le processus de modification peut continuer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le mode d'affichage actuel sur la page n'est pas <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> est fermé.  
  
 \- ou -  
  
 <paramref name="webPart" /> ne fait pas partie de la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 ou  
  
 <paramref name="webPart" /> est égal au contrôle <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage par défaut pour les pages qui contiennent des contrôles WebPart. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet qui est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez faire référence à ce dernier directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsqu’une page qui contient les composants WebPart contrôles du premier chargement, il se trouve dans <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (mode de navigation) par défaut. Lorsque les utilisateurs naviguent simplement comme ils le feraient sur une page Web normale, la page reste en mode de navigation. Si les utilisateurs souhaitent personnaliser la disposition d’une page, contrôles, apparence ou le comportement, ils doivent faire basculer la page dans un des modes d’affichage spécialisés disponibles via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> champ par programme. Le code remplit une liste déroulante avec les modes d’affichage pris en charge, qui sont dans ce cas de parcourir et conception. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page qui indique que vous êtes en mode de navigation. Utiliser le contrôle de liste déroulante pour basculer la page en mode design. Notez que, en raison du code dans le `Page_PreRender` (méthode), l’étiquette est masqué.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vérifie les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> participant à une connexion pour déterminer s'ils peuvent être connectés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode est utilisée pour déterminer si deux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles peuvent être connectés. La méthode est généralement utilisée comme contrôle conditionnel avant d’appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (méthode).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode vérifie un nombre de critères qui doivent être remplies avant que les deux contrôles peuvent établir une connexion. La liste suivante résume les critères principaux pour établir une connexion. Si tous ces critères (plus quelques conditions internes supplémentaires) sont satisfaites, la méthode retourne `true`, ce qui signifie que les contrôles peuvent être connectés :  
  
-   Les contrôles de fournisseur et le consommateur ne peut pas être `null`, et ils doivent être contenus dans la collection de contrôles référencés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
-   Le fournisseur et le consommateur ne peut pas être le même contrôle. En d’autres termes une <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle ne peut pas se connecter à lui-même.  
  
-   Le <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> objets (points de connexion) pour le fournisseur et le consommateur ne peut pas être `null`.  
  
-   Le fournisseur et le consommateur ne peut pas être fermés (du contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> propriété peut être `true`).  
  
-   Le <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> propriété du contrôle de point de connexion doit correspondre au type de contrôle du consommateur et de fournisseur.  
  
-   Les points de connexion doivent être activées (leurs <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> méthodes doivent retourner `true`).  
  
-   Chaque point de connexion ne doit pas tenter de former plus de connexions que ce qui est spécifié dans son propre <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> propriété.  
  
-   Si un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet (transformateur) est requis pour connecter des contrôles incompatibles, il ne peut pas être `null`. Toutefois, si les contrôles sont déjà compatibles, le transformateur doit être `null`.  
  
-   Le transformateur (le cas échéant) doit être référencé dans la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> collection.  
  
-   Le transformateur (le cas échéant) doit avoir des interfaces qui sont compatibles avec le fournisseur et le consommateur afin qu’il peut transformer les données entre les deux contrôles. Les interfaces secondaires du consommateur et fournisseur doivent également être compatibles.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Contrôle qui fournit les données à <c>consumer</c> quand les contrôles sont connectés.</param>
        <param name="providerConnectionPoint">
          <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui permet à <c>provider</c> de participer à une connexion.</param>
        <param name="consumer">Contrôle qui reçoit les données de <c>provider</c> quand les contrôles sont connectés.</param>
        <param name="consumerConnectionPoint">
          <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui agit comme une méthode de rappel de façon à ce que <c>consumer</c> puisse participer à une connexion.</param>
        <summary>Vérifie les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> qui participeront à une connexion afin de déterminer s'ils peuvent être connectés lorsque les contrôles consommateur et fournisseur ont des interfaces compatibles et qu'un objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> n'est pas nécessaire.</summary>
        <returns>Valeur Boolean qui indique si <paramref name="provider" /> et <paramref name="consumer" /> peuvent être connectés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour se connecter `provider` et `consumer` lorsque les deux contrôles ont des types, de points de connexion compatibles afin qu’un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet n’est pas nécessaire. Vous souhaiterez peut-être utiliser cette méthode pour vérifier que les deux contrôles peuvent être connectés avant d’appeler <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> pour créer une connexion par programmation.  
  
 Cette surcharge utilise la même implémentation que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> la surcharge de méthode, à la seule exception est que cette surcharge ne requiert pas un transformateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette méthode.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, un `<asp:webpartmanager>` élément et un code de gestion des événements qui crée une connexion à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> (méthode).  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Le balisage déclaratif de la page Web contient `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si la connexion peut être créée et, si tel est le cas, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble de connexions statiques référencé par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Il contient une interface et deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles agissant comme un fournisseur et l’autre comme un consommateur. Car ils ont des points de connexion compatibles (les deux d'entre eux reconnaissent le `IZipCode` interface), un transformateur n’est pas nécessaire pour établir la connexion. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois que l’interface utilisateur de connexion (UI) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Contrôle qui fournit les données à <c>consumer</c> quand les contrôles sont connectés.</param>
        <param name="providerConnectionPoint">
          <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui agit comme une méthode de rappel de façon à ce que <c>provider</c> puisse participer à une connexion.</param>
        <param name="consumer">Contrôle qui reçoit les données de <c>provider</c> quand les contrôles sont connectés.</param>
        <param name="consumerConnectionPoint">
          <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui agit comme une méthode de rappel de façon à ce que <c>consumer</c> puisse participer à une connexion.</param>
        <param name="transformer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> qui permet à un <c>fournisseur</c> et un <c>consommateur</c> incompatibles de se connecter.</param>
        <summary>Vérifie les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> qui participeront à une connexion afin de déterminer s'ils peuvent être connectés, et utilise un objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> pour créer la connexion entre un consommateur et un fournisseur incompatibles.</summary>
        <returns>Valeur Boolean qui indique si <paramref name="provider" /> et <paramref name="consumer" /> peuvent former une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour se connecter `provider` et `consumer` lorsque les deux contrôles ont des types, de points de connexion incompatibles afin qu’un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet est requis. Vous souhaiterez peut-être utiliser cette méthode pour vérifier que les deux contrôles peuvent être connectés avant d’appeler <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> pour créer une connexion par programmation.  
  
 Cette surcharge utilise la même implémentation que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> la surcharge de méthode, à la seule exception est que cette surcharge requiert un transformateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage utilisé pour l'ajout de contrôles serveur à une page Web à partir d'un catalogue de contrôles. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet qui est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez faire référence à ce dernier directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsque les utilisateurs souhaitent ajouter des contrôles à une page, si un catalogue de contrôles serveur est disponible, ils peuvent faire basculer la page pour <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (mode catalogue), et l’interface utilisateur du catalogue (UI) s’affiche. L’interface utilisateur pour un catalogue WebPart est fournie par un <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> contrôle de zone. Les développeurs ajoutent cette zone à la page au moment du design et puis ajoutez des contrôles serveur à la zone, afin que les utilisateurs en mesure d’ajouter ces contrôles à leurs pages en cours d’exécution. Une fois que le développeur a ajouté ces contrôles, le mode catalogue devient un mode d’affichage pris en charge sur la page, car les contrôles sont là pour activer le mode de catalogue.  
  
 Lorsqu’un utilisateur bascule une page pour le mode, la zone et tous les contrôles serveur qui ont été ajoutés deviennent visibles du catalogue, et l’utilisateur peut sélectionner des contrôles à partir du catalogue à ajouter à la page, ou supprimer des contrôles à partir de la page. Une fois que les contrôles ont été ajoutés à la page, ils apparaissent dans le mode de navigation normal et la page est mise à jour.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> champ par programme. Le code remplit une liste déroulante avec les modes d’affichage pris en charge pour la page, qui sont dans ce cas de navigation, de conception et de catalogue. Le mode catalogue est disponible car le `<asp:CatalogZone>` élément et ses éléments enfants dans la page Web. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page est masquée. Utiliser le contrôle de liste déroulante pour basculer la page en mode catalogue. Notez que, en raison du code dans le `Page_PreRender` , l’étiquette est maintenant visible. Vous pouvez sélectionner le contrôle dans le catalogue et l’ajouter à une des deux zones sur la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie les fonctionnalités du navigateur qui effectue la demande et la valeur de la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />, afin de déterminer s'il faut ou non restituer le script client.</summary>
        <returns>Valeur Boolean qui indique s'il faut restituer le script client.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un avertissement qui s'affiche lorsqu'un utilisateur ferme un contrôle qui agit comme un fournisseur pour les autres contrôles d'une connexion.</summary>
        <value>Chaîne qui contient le message d'avertissement. La valeur par défaut est un message spécifique à la culture fourni par le .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur ferme un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, aucun message ne s’affiche normalement. Pour plus d’informations sur ce que signifie fermer un contrôle, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> (méthode).  
  
 Toutefois, lorsqu’un contrôle est connecté à un autre contrôle et agit comme un fournisseur de données à l’autre, un message d’avertissement par défaut s’affiche lorsqu’un utilisateur tente de fermer le contrôle. Le message informe les utilisateurs qu’un contrôle fournisseur est sur le point de fermer, ce qui signifie que les contrôles sont connectés à ce fournisseur comme consommateurs n’aura plus de données à consommer. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété permet aux développeurs de personnaliser le message d’avertissement qui s’affiche à l’utilisateur.  
  
 Si un développeur de pages assigne une valeur de chaîne vide ou null à cette propriété, aucune boîte de message d’avertissement ne s’affichera lorsque l’utilisateur ferme un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle qui est un fournisseur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété pour afficher un avertissement personnalisé pour les utilisateurs.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> les contrôles qui peuvent être connectées et un `<asp:webpartmanager>` élément.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 Le code suivant contient uniquement la partie de la page Web de l’exemple. Vous devez également le contrôle utilisateur personnalisé et le code source pour les contrôles personnalisés mentionnés ci-dessus. Obtenir ces deux éléments à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Le code de page Web suivant montre comment assigner un message d’avertissement personnalisé à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété dans le balisage déclaratif dans le `<asp:webpartmanager>` élément.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois l’interface utilisateur de connexion (UI) s’affiche, cliquez sur le **créer une connexion à un consommateur** lien. Une cellule apparaît avec un contrôle de liste déroulante. Sélectionnez **contrôle météo** dans la liste déroulante, puis cliquez sur **connexion** pour établir la connexion des deux contrôles. Cliquez sur **fermer**, puis utilisez le **Mode d’affichage** liste déroulante, pour retourner la page en mode de navigation normal. Enfin, cliquez sur le menu des verbes pour la **Code postal** contrôler (qui est dans ce cas le contrôle de fournisseur) et sélectionnez **fermer**. Le message personnalisé affecté à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété s’affiche.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur fermé dans un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</param>
        <summary>Ferme un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> de façon telle qu'il n'est pas restitué sur une page Web, mais qu'il peut être rouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode supprime un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou autre contrôle serveur afin qu’il n’est pas rendu sur la page Web qui contenait à l’origine. Le contrôle fermé est ajouté à un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> objet, qui conserve une référence au contrôle fermé et rend possible pour le contrôle d’être restauré dans la page. Un fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle apparaît toujours dans la collection référencée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
 Fermeture d’un contrôle est différente de sa suppression. Les contrôles fermés sont toujours disponibles pour être restaurée à une page, mais une instance de contrôle supprimée est définitivement supprimée et ne peut jamais être restaurée. Indépendamment de si un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur soit statique (déclaré dans le balisage d’une page) ou dynamique (ajouté à la page par programme ou par un utilisateur à partir d’un catalogue de composants WebPart), il peut être fermé et rouvert sur une page.  
  
 En règle générale, les utilisateurs peuvent fermer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle en cliquant sur son menu d’actions verbales et en sélectionnant le verbe de fermeture. Un contrôle peut également être fermé en appelant directement la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> (méthode) et en lui passant une référence à `webPart`.  
  
 Sur une page où <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles ont été fermés, si un développeur déclare un `<asp:catalogzone>` élément et lui ajoute un `<asp:pagecatalogpart>` élément, il fournit une interface utilisateur simple (IU) permettant aux utilisateurs de restaurer les contrôles fermés à la page en cours d’exécution. Les utilisateurs peuvent basculer la page en mode d’affichage catalogue, et les contrôles fermés apparaîtront dans le catalogue de la page. Les utilisateurs peuvent sélectionner des contrôles fermés et les ajouter à la page à la position qu’il souhaite, puis les contrôles sélectionnés sont et restaurés sur la page rendues sous la forme normales.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode est appelée, elle déclenche plusieurs événements : <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (s’il existe plusieurs contrôles), et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (s’il existe des contrôles connectés). Les développeurs peuvent généralement annuler ces événements, mais dans certains cas, il n’est pas possible de les annuler. Pour plus d’informations, consultez la documentation relative à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événements.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui vous permet de modifier les modes d’affichage de page.  
  
-   Personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
-   Une page Web.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple de code est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise l’approche de compilation dynamique ; Il est donc aucune `Assembly` l’attribut dans la `Register` directive pour ce contrôle en haut de la page Web. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 La troisième partie de l’exemple de code est la page Web. La page contient un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, avec un <`asp:pagecatalogpart>` élément déclaré à l’intérieur. C’est ce que contiendra la fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler et permettre aux utilisateurs d’ajouter à la page. Le `Button1_Click` méthode appelle directement la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode de fermeture personnalisée <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, bien qu’un utilisateur peut également fermer le contrôle via le menu d’actions verbales.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, fermez personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle en cliquant sur le menu des verbes (la flèche) dans l’en-tête du contrôle, en cliquant sur **fermer**. Maintenant modifier la page en mode catalogue en sélectionnant **catalogue** dans les **Mode d’affichage** contrôle de liste déroulante. Le catalogue de la page s’affiche avec le contrôle fermé. Sélectionnez la case à cocher en regard du contrôle fermé, cliquez sur **ajouter** à ajouter à la page, puis cliquez sur **fermer** pour retourner la page en mode de navigation. Le contrôle est restauré sur la page. Maintenant le fermer, cette fois en cliquant sur le **fermer le composant WebPart** bouton.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> ne figure pas dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 \- ou -  
  
 <paramref name="webPart" /> est un contrôle partagé qui a déjà été fermé par un autre utilisateur.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage utilisé pour afficher une interface utilisateur spéciale afin que les utilisateurs puissent gérer les connexions entre les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet qui est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez faire référence à ce dernier directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsque les utilisateurs souhaitent gérer des connexions entre <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle sur une page Web, si un <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> zone a été déclaré dans la page, ils peuvent faire basculer la page dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode. Le mode d’affichage de connexion affiche une interface utilisateur spéciale pour gérer les connexions, qui inclut la possibilité de se connecter ou déconnecter des contrôles et modifier les détails des connexions existantes.  
  
 Si vous souhaitez fournir aux utilisateurs la possibilité de gérer les connexions avec l’interface utilisateur fournie par le jeu de composants WebPart, vous devez déclarer un `<asp:connectionszone>` élément dans le balisage d’une page. Contrairement aux éléments pour les autres types de <xref:System.Web.UI.WebControls.WebParts.WebZone> zones, vous ne souhaitez pas ajouter d’autres balises dans cet élément ; vous déclarez simplement l’élément à lui-même.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode.  
  
 L’exemple de code comprend trois parties :  
  
-   Un fichier source qui contient une interface et le personnaliser <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent établir une connexion.  
  
-   Une page Web qui fournit une interface utilisateur de connexion et illustre l’utilisation du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode.  
  
-   Explication de l’exécution de l’exemple.  
  
 La première partie de l’exemple de code est un fichier source qui contient une interface et deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sont conçus de manière à pouvoir être connectés. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise l’approche de compilation dynamique. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 La deuxième partie de l’exemple est une page Web qui héberge les contrôles personnalisés. Au sein du serveur `<script>` balises dans la page existe plusieurs méthodes qui remplissent une liste déroulante avec les modes d’affichage disponibles sur la page. Un utilisateur peut sélectionner à partir de la liste déroulante pour modifier le mode d’affichage de la page. Un des modes d’affichage disponibles est en mode d’affichage, connexion, car un `<asp:connectionszone>` élément est déclaré dans le balisage de la page. Notez que cet élément ne contient pas d’autres éléments enfants ; Il existe uniquement pour activer la gestion des connexions de l’interface utilisateur pour les utilisateurs.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode apparaît dans cet exemple à deux endroits. Tout d’abord, dans le `Page_Init` méthode, le mode d’affichage de la connexion est ajouté à la liste déroulante des modes d’affichage, en tant que le code parcourt la collection référencée dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété. Ensuite, le `Page_PreRender` méthode vérifie le mode d’affichage actuel sur la page, et si le mode actuel est <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, un message s’affiche dans un <xref:System.Web.UI.WebControls.Label> contrôle.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, cliquez sur la liste déroulante et sélectionnez **connexion** pour basculer la page en mode d’affichage. Notez qu’un message apparaît, indiquant que la page est en mode d’affichage de connexion. Maintenant, cliquez sur le menu d’actions verbales (symbolisé par une flèche) dans la barre de titre de l’un de le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, puis cliquez sur **Connect** dans le menu d’actions verbales. Une fois la connexion de que l’interface utilisateur s’affiche, cliquez sur le lien pour créer une connexion. Utilisez la liste déroulante dans la connexion de l’interface utilisateur qui s’affiche, sélectionnez l’autre contrôle qui participera à la connexion, cliquez sur le **Connect** bouton. La connexion est établie. Cliquez sur le **fermer** bouton, puis utilisez la liste déroulante en haut de la page pour retourner la page en mode d’affichage de navigation.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la collection de toutes les connexions actives sur une page Web.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> qui contient un ensemble d'objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriété permet d’accéder à l’ensemble actuel de connexions sur une page. La collection elle-même est en lecture seule et les développeurs qui souhaitent manipuler une connexion spécifique à partir de la collection doivent utiliser <xref:System.Web.UI.WebControls.WebParts.WebPartManager> méthodes telles que <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation déclarative et par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 Le code suivant contient uniquement la partie de la page Web de l’exemple. Vous devez également le contrôle utilisateur personnalisé et le code source pour les contrôles personnalisés mentionnés ci-dessus. Obtenir ces deux éléments à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Le code de page Web suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriété par programmation à obtenir le nombre de connexions en cours sur une page. Notez que dans le `<script>` section de la balise, le code pour gérer les deux événements pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler l’accès à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriété pour obtenir le nombre.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois l’interface utilisateur de connexion (UI) s’affiche, cliquez sur le **créer une connexion à un consommateur** lien. Une cellule apparaît avec un contrôle de liste déroulante. Sélectionnez **contrôle météo** dans la liste déroulante, puis cliquez sur **connexion** pour établir la connexion des deux contrôles. Cliquez sur **fermer**, puis utilisez le **Mode d’affichage** liste déroulante, pour retourner la page en mode de navigation normal. Notez qu’une étiquette affiche maintenant le nombre de connexions et le nombre de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. Si vous revenez en mode connexion et déconnectez les deux contrôles, lorsque vous revenez au mode de navigation, le contenu de l’étiquette doit être mis à jour et il ne doit y avoir aucune connexion.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que toutes les connexions WebPart actuelles d'une page sont non seulement connectées, mais ont commencé activement à partager les données entre les contrôles consommateur et fournisseur impliqués dans chaque connexion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le cycle de vie des connexions, cet événement se produit après qu’une page a terminé son processus de chargement. Il se produit également après le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement, qui indique uniquement que la <xref:System.Web.UI.WebControls.WebParts.WebPart> ou les contrôles serveur impliqués dans une connexion spécifique se sont correctement connectés. Dans un cas où il existe plusieurs connexions sur une page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> méthode indique que toutes les connexions WebPart valides sur une page sont maintenant active et peut partager des données. Sachant que toutes les connexions sont actives, les développeurs peuvent exécuter n’importe quel nombre de tâches, y compris la notification des utilisateurs de l’état de toutes les connexions, notifier les contrôles consommateur pour traiter et afficher des données à partir de leurs fournisseurs et ainsi de suite.  
  
 Cet événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> méthode qui déclenche l’événement et permet aux développeurs de créer des gestionnaires personnalisés pour l’événement.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour l’événement en ajoutant le `OnConnectionsActivated` attribut le `<asp:webpartmanager>` élément dans la page, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus d'activation de toutes les connexions WebPart établies sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le cycle de vie des connexions, cet événement se produit lorsqu’une page termine son processus de chargement, juste avant la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée. Il est différent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> événement, ce qui implique une connexion particulière entre <xref:System.Web.UI.WebControls.WebParts.WebPart> ou d’autres contrôles serveur. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> événement se produit lorsque toutes les connexions possibles sur une page ont été connectées et doivent être activés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> (méthode), laquelle déclenche l’événement. Les développeurs de contrôles qui souhaitent étendre le type de connexions qui peuvent être ajoutés à une page peuvent substituer protégé <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> (méthode) et activer des types de connexions supplémentaires.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour l’événement en ajoutant le `OnConnectionsActivating` attribut le `<asp:webpartmanager>` élément dans la page, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une connexion entre deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou d'autres contrôles serveur capables de former des connexions) qui résident dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> méthode constitue une connexion entre deux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés. Avant d’appeler cette méthode pour créer une connexion, vous pouvez également appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode dans un contrôle conditionnel pour vous assurer que les contrôles satisfont les conditions requises pour établir une connexion.  
  
> [!NOTE]
>  Il est également possible de créer une connexion entre deux contrôles serveur qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. En règle générale, les deux contrôles doivent être des contrôles serveur personnalisés (par exemple, les contrôles qui héritent de <xref:System.Web.UI.WebControls.WebControl> ou des contrôles serveur ASP.NET existants) afin que vous puissiez ajouter les membres requis. Les contrôles doivent également répondre à la configuration requise spécifiée ci-dessous.  
  
 N’importe quel type de scénario de connexion entre deux contrôles doit répondre aux exigences suivantes pour pouvoir se connecter :  
  
-   Chaque contrôle réside dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone (il ne doit pas être la même zone).  
  
-   Tel qu’implémenté dans le jeu de composants WebPart, le contrôle de fournisseur dans une connexion implémente une interface comme une méthode publique qui sert de rappel au fournisseur et a un `ConnectionProvider` attribut de métadonnées sur la méthode pour l’identifier comme une connexion de fournisseur point. Étant donné que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> méthode que le fournisseur récupère les points de connexion est virtuelle, un dérivée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ne doit pas nécessairement utiliser le même attribut de métadonnées.  
  
-   Tel qu’implémenté dans le jeu de composants WebPart, le contrôle consommateur dans une connexion a également une méthode spéciale qui lui permet d’obtenir une référence à l’interface exposée dans la méthode de rappel du fournisseur, et le consommateur a un `ConnectionConsumer` attribut de métadonnées sur la méthode pour l’identifier en tant que consommateur connexion point. Étant donné que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> méthode que récupère les points de connexion consommateur est virtuelle, un dérivée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ne doit pas nécessairement utiliser le même attribut de métadonnées.  
  
-   Les méthodes de rappel doivent être compatibles, dans la mesure où le consommateur peut utiliser le type d’interface fourni dans la méthode de rappel du fournisseur (ce qui signifie que le consommateur et le fournisseur peuvent partager les données directement), soit le développeur doit utiliser un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> pour l’objet transformer les données à partir du fournisseur dans un formulaire que le consommateur peut utiliser.  
  
    > [!IMPORTANT]
    >  Lorsque vous n’avez pas besoin d’un transformateur, utilisez la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> surcharge de méthode. Lorsque vous avez besoin d’un transformateur, utilisez la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de fournir des données à un autre contrôle connecté.</param>
        <param name="providerConnectionPoint">Méthode qui sert de méthode de rappel pour la connexion. Telle qu'elle est implémentée dans le jeu de composants WebPart, il s'agit d'une méthode publique dans <c>provider</c> qui est marquée avec un attribut de métadonnées <see langword="ConnectionProvider" />.</param>
        <param name="consumer">Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de recevoir des données de <c>provider</c>, et ensuite de les traiter ou de les afficher.</param>
        <param name="consumerConnectionPoint">Méthode qui se connecte avec <c>providerConnectionPoint</c> pour recevoir les données pour la connexion. Telle qu'elle est implémentée dans le jeu de composants WebPart, il s'agit d'une méthode publique dans <c>consumer</c> qui est marquée avec un attribut de métadonnées <see langword="ConnectionConsumer" />.</param>
        <summary>Crée une connexion entre deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> en utilisant uniquement les références aux contrôles et leurs objets <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> spécifiés.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> qui contient les différentes informations relatives au fournisseur et au consommateur nécessaires pour une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est utilisée pour connecter des contrôles lorsque leurs points de connexion sont suffisamment compatibles pour qu’ils puissent se connecter sans utiliser un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet. Lorsque cette surcharge de la méthode est appelée, elle simplement passe l’appel à l’autre version surchargée de la méthode et passe `null` pour le paramètre qui requiert un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet.  
  
 Lorsque vous essayez de vous connecter deux contrôles par programme, vous pouvez utiliser la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode dans un contrôle conditionnel pour déterminer si les contrôles peuvent être connectés directement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette méthode pour créer une connexion par programme. Pour obtenir le code complet requis pour exécuter l’exemple, consultez la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Dans cet exemple, vous devez le code source pour le contrôle utilisateur qui vous permet de modifier les modes d’affichage sur la page et le code source pour les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
 Le code de la page Web qui héberge les deux contrôles suit. La page utilise `Register` directives en haut pour déclarer le contrôle utilisateur et les contrôles personnalisés. Les contrôles personnalisés sont ensuite référencés de manière déclarative dans un `<asp:webpartzone>` élément. Le code qui gère la `Button1_Click` méthode crée une connexion entre les contrôles à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (méthode).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, cliquez sur le **connecter les contrôles WebPart** bouton pour former la connexion. Vous pouvez ensuite entrer des données dans la zone de texte, puis cliquez sur le **entrer le Code postal de 5 chiffres** bouton pour montrer que les contrôles sont connectés et que les données entrées dans le premier contrôle sont mis à jour dans la seconde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La collection de collections dynamiques du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> est en lecture seule.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de fournir des données à un autre contrôle connecté.</param>
        <param name="providerConnectionPoint">Méthode publique dans <c>provider</c> qui est marquée avec un attribut de métadonnées <see langword="ConnectionProvider" /> et qui sert de méthode de rappel pour la connexion.</param>
        <param name="consumer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de recevoir des données de <c>provider</c> ou de <c>transformer</c>, et ensuite de les traiter ou de les afficher.</param>
        <param name="consumerConnectionPoint">Méthode publique dans <c>consumer</c> qui est marquée avec un attribut de métadonnées <see langword="ConnectionConsumer" /> et se connecte avec <c>providerConnectionPoint</c> pour recevoir les données pour la connexion.</param>
        <param name="transformer">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> qui active une connexion entre deux contrôles en convertissant les données de <c>provider</c> dans un format pouvant être traité par <c>consumer</c>.</param>
        <summary>Crée une connexion entre deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> à l'aide des références aux contrôles, de leurs objets <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> spécifiés et d'un objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> qui contient les informations relatives au fournisseur, au consommateur et au transformateur nécessaires pour une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est utilisée pour connecter des contrôles lorsque leurs points de connexion sont incompatibles. L’incompatibilité se produit lorsque `consumer` implémente une interface différente de `provider` comme point de connexion. Le transformateur convertit les données en un type pouvant être compris par `consumer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Des connexions ont déjà été activées dans <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de tous les <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, contrôles serveur ou utilisateur contenus dans les zones <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> d'une page Web et gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>
          <see cref="T:System.Web.UI.ControlCollection" /> qui contient tous les contrôles gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> propriété ne référence pas les autres contrôles qui sont référencés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, tels que les différents contrôles, de zone <xref:System.Web.UI.WebControls.WebParts.EditorPart> ou <xref:System.Web.UI.WebControls.WebParts.CatalogPart> , mais autres.  
  
 Cette propriété est utilisée par le jeu de composants WebPart et dans la plupart des situations de développement qu'elle n’est pas destinée à être appelée à partir de votre code. Pour cette raison, même si la propriété est publique, il est masqué à partir d’IntelliSense. Les développeurs qui souhaitent accéder à la collection de <xref:System.Web.UI.WebControls.WebParts.WebPart> ou d’autres contrôles serveur gérés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle doit utiliser ses <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur à copier.</param>
        <summary>Utilisé par le jeu de composants WebPart pour créer une copie d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou d'un contrôle serveur en vue d'ajouter le contrôle à une page Web.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à ajouter à une page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> (méthode) directement à partir de votre code. Cette méthode est appelée en interne par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle en tant que partie du processus d’ajout d’un nouveau dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur à une page. Un contrôle dynamique est ajouté à une page par programme ou via l’interface utilisateur de composants WebPart (UI), par exemple par un utilisateur de l’ajout d’un contrôle à partir d’un catalogue de contrôles, par opposition à un contrôle statique, qui est déclaré directement dans le balisage d’une page.  
  
> [!NOTE]
>  La méthode peut être substituée dans une classe dérivée si les développeurs souhaitent activer la méthode pour gérer le contrôle des scénarios de copie. Pour plus d’informations, consultez les section Remarques à l’attention des héritiers.  
  
 Lorsqu’un nouveau contrôle dynamique est ajouté, s’il est un <xref:System.Web.UI.WebControls.WebParts.WebPart> (contrôle), le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode retourne une nouvelle instance du contrôle. Si le contrôle ajouté est un autre type de contrôle de serveur (par exemple, un contrôle utilisateur, un contrôle personnalisé ou un contrôle ASP.NET), le contrôle sera déjà été encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet par le jeu de composants WebPart. Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode rencontre un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle, elle retourne une nouvelle instance de la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle avec une nouvelle instance du contrôle enfant encapsulé dans celle-ci.  
  
 Lorsque la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode crée une copie d’un contrôle à retourner, elle réinitialise également les valeurs de toutes les propriétés à leurs valeurs par défaut. Notez que, si vous souhaitez conserver les valeurs des propriétés personnalisables et les copier dans la nouvelle instance de contrôle, vous devez appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> méthode ainsi. La dernière étape effectuée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode consiste à appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> méthode pour obtenir un nouvel ID pour le contrôle.  
  
> [!NOTE]
>  Étant donné que la méthode obtient un nouvel ID pour un contrôle copié, vous fiez pas sur le référencement d’un contrôle dynamique est ajouté à une page par son ID d’origine. Au lieu de cela, vous devez référencer la nouvelle instance du contrôle retourné par la méthode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La méthode est déclarée en tant que <see langword="virtual" /> afin que les développeurs puissent hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, substituez la méthode et fournir des scénarios supplémentaires dans lesquels elle pourrait créer des copies des contrôles. Par exemple, la méthode pourrait recevoir éventuellement comme entrée un contrôle qui a été sérialisé dans un fichier XML. La méthode peut désérialiser le code XML (le cas échéant), puis appelez la méthode de base pour gérer les cas existants et retourner une nouvelle instance d’un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> contrôle.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un jeu de transformateurs spécifié dans le fichier de configuration d'un site Web et l'ajoute à la collection de transformateurs référencée par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />.</summary>
        <returns>Collection des transformateurs spécifiés dans le fichier de configuration d'un site Web.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Cette méthode peut être substituée pour ajouter des transformateurs supplémentaires qui peuvent être utilisées par l’application. Par exemple, la méthode peut être écrite pour récupérer la liste des transformateurs disponibles à partir d’un service Web.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la collection de tous les contrôles gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> sur une page Web. Cette classe ne peut pas être héritée.</summary>
        <returns>
          <see cref="T:System.Web.UI.ControlCollection" /> qui se compose de tous les différents contrôles WebPart gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Étant donné que cette méthode est protégée et sealed, elle est visible pour les classes qui héritent de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, mais il ne peut pas être substituée.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée le jeu de tous les modes d'affichage possibles pour une application WebPart.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> qui contient tous les modes d'affichage pris en charge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée la liste de tous les modes d’affichage possibles, pas seulement les modes d’affichage pris en charge sur une page particulière. Pour plus d’informations sur les modes d’affichage pris en charge, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
 Par défaut, le jeu de contrôles WebPart crée le jeu suivant de modes d’affichage à utiliser sur les pages WebPart :  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 Les développeurs peuvent créer des modes d’affichage personnalisés, avec ou sans zones personnalisées associées qui dérivent de la <xref:System.Web.UI.WebControls.WebParts.WebZone> ou <xref:System.Web.UI.WebControls.WebParts.ToolZone> classes. Pour créer un mode d’affichage personnalisé, vous devez hériter de la <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> (classe), et pour ajouter votre mode d’affichage comme un mode pris en charge sur une page, vous devez hériter de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et substituer la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> (méthode).  
  
 Lorsque vous ajoutez des modes d’affichage à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> (méthode), vous devez les ajouter dans l’ordre que vous souhaitez qu’ils apparaissent dans les contrôles d’interface utilisateur utilisateur (comme un <xref:System.Web.UI.WebControls.ListBox> contrôle) qui fournissent aux utilisateurs les modes d’affichage possibles sur une page.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>.  
  
 L’exemple de code comprend cinq parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui héberge les autres contrôles.  
  
-   Un contrôle utilisateur qui réside dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone sur la page Web et vous permet d’entrer et d’afficher du texte dans une étiquette.  
  
-   Un fichier de code source qui contient deux contrôles. Un est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et l’autre est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet à ajouter aux modes d’affichage par défaut de la page.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple est la page Web. Il contient deux <xref:System.Web.UI.WebControls.WebParts.WebPartZone> des contrôles, les contrôles utilisateur et personnalisés <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Notez le `Register` directives en haut de la page pour référencer les contrôles utilisateur et l’espace de noms pour les contrôles compilés.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 La troisième partie de l’exemple est le contrôle utilisateur pour la saisie et l’affichage du texte. Il utilise un <xref:System.Web.UI.WebControls.MultiView> contrôle permet de créer plusieurs vues de l’interface utilisateur. Une vue apparaît avec le `Button1` bouton, l’autre sans. Notez que dans la `OnPreRender` méthode, le code vérifie si la page est actuellement en mode d’affichage personnalisé et, dans ce cas, affiche la première vue du contrôle utilisateur, qui inclut le bouton. Si la page n’est pas dans le mode d’affichage personnalisé, par exemple, si la page est en mode de navigation ou de la conception, le bouton est masqué.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 La quatrième partie de l’exemple est le fichier source pour les deux classes personnalisées. Notez que personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> substitue le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> (méthode), et qu’il appelle d’abord la méthode de base pour ajouter tous les modes d’affichage par défaut et ajoute ensuite le mode d’affichage personnalisé. La classe de mode d’affichage personnalisé, `InLineEditDisplayMode`, hérite simplement de <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, définit le nom de mode d’affichage dans le constructeur et substitue plusieurs propriétés de base pour établir les caractéristiques de l’affichage personnalisé.  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 Pour exécuter l’exemple de code, chargez la page dans un navigateur. Notez que la page est actuellement en mode de navigation, et aucun bouton n’est visible. À l’aide de la **Mode d’affichage** déroulante contrôle de liste, de modifier la page pour **Inline Edit Display** mode et notez qu’à présent le `Button1` bouton est visible dans le contrôle utilisateur inférieur. Ajouter du texte, puis cliquez sur le bouton pour mettre à jour le contrôle. Notez que l’affichage de la page est retournée au mode de navigation, le texte que vous avez entré est maintenant affiché et le bouton est de nouveau masqué, car la page n’est plus en mode d’affichage personnalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur unique pour servir d'ID pour une connexion dynamique.</summary>
        <returns>Chaîne qui contient un ID unique pour une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> méthode génère une valeur GUID et la convertit en une chaîne pour servir de l’ID unique pour une connexion. La méthode est appelée chaque fois qu’une connexion dynamique est créée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs peuvent substituer cette méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe pour modifier l’implémentation pour générer un ID unique.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">
          <see cref="T:System.Type" /> du contrôle pour lequel un ID est généré.</param>
        <summary>Génère un ID unique pour un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique.</summary>
        <returns>Chaîne qui contient l'ID unique pour un contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Web.UI.WebControls.WebParts.WebPart> sont ajoutés à une page Web, ils peuvent être statiques (ce qui signifie que le contrôle est déclaré dans le balisage de page) ou dynamique (ce qui signifie qu’ils sont ajoutés par programmation). Dans tout scénario où le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle crée de nouveaux contrôles dynamiques à ajouter à la page, il appelle cette méthode pour générer un ID unique.  
  
 La méthode est virtuelle, afin que les développeurs puissent la substituer s’ils souhaitent fournir une implémentation personnalisée pour générer l’ID.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">Chaîne qui constitue l'ID du contrôle défaillant. Si un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> est impliqué dans la défaillance, l'ID correspond à l'ID de son contrôle serveur enfant.</param>
        <param name="originalTypeName">Chaîne qui définit le nom du <see cref="T:System.Type" /> du contrôle défaillant. Si un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> est impliqué dans la défaillance, le nom de type correspond au type de son contrôle serveur enfant.</param>
        <param name="originalPath">Chaîne qui contient le chemin d'accès à un contrôle utilisateur si un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui contient un contrôle utilisateur enfant est impliqué dans la défaillance.</param>
        <param name="genericWebPartID">Chaîne qui retourne l'ID d'un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> si ce type de contrôle était impliqué dans l'échec de chargement ou de création d'un contrôle.</param>
        <param name="errorMessage">Chaîne qui contient le message d'erreur à afficher sur la page.</param>
        <summary>Crée un contrôle spécial qui est inséré dans une page et affiché à l'attention des utilisateurs finaux lorsqu'une tentative de chargement ou de création d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique échoue pour une raison quelconque.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> inséré dans une page à la place d'un contrôle dont le chargement ou la création a échoué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> méthode est appelée lorsque le jeu tente de charger ou créer une instance d’un dynamique de composants WebPart <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur et il échoue pour une raison quelconque. La méthode crée un <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> objet, lui assigne un message d’erreur et le retourne. Le <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> contrôle est inséré à la place du contrôle qui a échoué et le message d’erreur s’affiche sur la page.  
  
 Vous ne pouvez pas appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> (méthode) directement à partir de votre code. Toutefois, vous pouvez hériter de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et étendre la méthode. Pour plus d’informations, consultez les section Remarques à l’attention des héritiers.  
  
 Les utilisateurs finaux peuvent travailler avec un <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> de contrôle dans une page d’une grande partie comme ils le feraient normale <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour supprimer le message d’erreur, ils peuvent fermer le contrôle en cliquant sur le verbe close, auquel cas, le contrôle sera ajouté à un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> objet, comme tout autre contrôle fermé. Si un utilisateur final supprime un <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> est également supprimé du contrôle, le contrôle serveur qui n’a pas pu charger à partir de la page.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si vous souhaitez personnaliser les informations retournées dans le <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> (contrôle), vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> (méthode), appeler la méthode de base, affecter des valeurs différentes pour les paramètres passés à la méthode de base, puis retourner le résultant<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />contrôle. Par exemple, si vous ne souhaitez pas les utilisateurs finaux voient la <paramref name="originalPath" /> valeur (qui devrait indiquer le chemin d’accès du répertoire virtuel d’un contrôle utilisateur), lorsque vous appelez la méthode de base, vous pouvez passer une chaîne vide (« ») pour ce paramètre.  
  
 Vous pouvez également personnaliser le comportement de la <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> contrôle lui-même, en héritant de lui. Par exemple, vous souhaiterez peut-être substituer ses <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> ou <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> propriété.</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet de personnalisation pour contenir les données de personnalisation d'un utilisateur pour la page Web en cours.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> pour contenir les données de personnalisation d'un utilisateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> méthode retourne un objet pour contenir et gérer les paramètres de personnalisation de l’utilisateur pour la page actuelle. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle gère cet objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle serveur qui n'est pas un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</param>
        <summary>Encapsule un contrôle serveur qui n'est pas un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> avec un objet <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, de manière à ce que le contrôle puisse avoir les fonctionnalités WebPart.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui encapsule <paramref name="control" /> et lui permet de fonctionner comme un véritable contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> (méthode) est le mécanisme principal pour activer les contrôles serveur qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> à effectuer sur les mêmes fonctionnalités que les contrôles un <xref:System.Web.UI.WebControls.WebParts.WebPart> (contrôle) et par conséquent participer pleinement dans les applications WebPart. À l’aide de cette méthode, les développeurs considérablement augmenter le nombre de contrôles serveur qu’ils peuvent utiliser dans une application WebPart, car n’importe quel type de contrôle de serveur--contrôles ASP.NET standard, les contrôles utilisateur et des contrôles personnalisés, peuvent être utilisés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle utilise également cette méthode dans deux autres scénarios pour encapsuler des contrôles serveur avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet. Lorsque les utilisateurs ajouter des contrôles serveur à une page à l’aide de la <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> contrôler, si le contrôle importé n’est pas un <xref:System.Web.UI.WebControls.WebParts.WebPart> (contrôle), le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est appelée. En outre, lorsque les contrôles serveur sont déclarés dans le format de persistance dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone sur une page Web, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est appelée pour tous les contrôles qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
 Lorsque vous ajoutez par programme un contrôle serveur à une zone, une approche courante consiste à utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode d’encapsuler le contrôle avec une <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet, puis appelez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode pour ajouter le contrôle à la collection de tous les <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sur la page, ce qui est référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> (méthode). Dans le `Button2_Click method`, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est appelée pour encapsuler un <xref:System.Web.UI.WebControls.Calendar> contrôler avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet avant de l’ajouter à la zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cette méthode peut être substituée pour utiliser un dérivé <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> classe à la place de la classe de base fournie avec les composants WebPart jeu de contrôles.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un message d'avertissement personnalisé affiché à l'attention des utilisateurs finaux lorsqu'ils suppriment un contrôle.</summary>
        <value>Chaîne qui contient le texte du message d'avertissement. La valeur par défaut est un message d'avertissement localisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur supprime un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, un message d’avertissement par défaut s’affiche normalement. Il avertit l’utilisateur que lorsque cette instance d’un contrôle est supprimée, la suppression est permanente. Le développeur de pages peut fournir aux utilisateurs un moyen d’ajouter une nouvelle instance du contrôle à la page (tels que via un catalogue de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, ou certains moyens par programme), mais l’instance actuelle d’un contrôle est supprimé est définitivement supprimée. La boîte de dialogue qui affiche l’avertissement contient un bouton pour l’utilisateur d’annuler la suppression, si vous le souhaitez.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété permet aux développeurs de définir le message d’avertissement qui s’affiche à l’utilisateur.  
  
 Si un développeur de pages assigne une chaîne vide (« ») la valeur à cette propriété, aucun avertissement de boîte de dialogue de message s’affichera lorsqu’un utilisateur supprime un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété n’est pas affichée dans le cas statique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et des contrôles serveur. Les contrôles statiques sont des contrôles serveur qui sont déclarés dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone dans le balisage d’une page Web. Étant donné que ces contrôles sont statiques, ils ne peut pas être supprimés, donc le message d’avertissement de suppression n’est jamais affiché dans ce cas. Les contrôles statiques peuvent être fermés par un utilisateur, mais un contrôle fermé est ajouté au catalogue de pages, à partir de laquelle il peut être ajouté à la page par un utilisateur, tandis qu’un contrôle supprimé ne peut jamais être récupéré.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété de façon déclarative et par programme.  
  
 Il existe quatre parties pour l’exemple de code :  
  
-   Un contrôle utilisateur qui vous permet de modifier les modes d’affichage de page.  
  
-   Personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
-   Une page Web.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple de code est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise l’approche de compilation dynamique ; Il est donc aucune `Assembly` l’attribut dans la `Register` directive pour ce contrôle en haut de la page Web. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 La troisième partie de l’exemple de code est la page Web. La page contient un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, avec personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle déclaré dans la zone, afin qu’un utilisateur peut l’ajouter à la page en cours d’exécution. Notez que seuls les contrôles dynamiques (les contrôles qui sont ajoutés à une page par programme ou à partir d’un catalogue comme celui-ci) peuvent être supprimés à partir d’une page. Les contrôles statiques (contrôles déclarés dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone dans le balisage d’une page) peuvent être fermés, mais jamais supprimés. Le `<asp:webpartmanager>` élément déclare une valeur personnalisée pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété à l’aide de la `DeleteWarning` attribut. Le `Button1_Click` méthode assigne une autre valeur personnalisée à le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, vous devez ajouter le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à la page. À l’aide de la **Mode d’affichage** contrôle de liste déroulante, sélectionner le mode catalogue. Lorsque le catalogue s’affiche, activez la case à cocher en regard du contrôle personnalisé, cliquez sur **ajouter** à ajouter à la page, puis cliquez sur **fermer** pour retourner la page en mode de navigation. Maintenant que le contrôle est visible, vous pouvez le supprimer. À l’aide de la **Mode d’affichage** contrôler à nouveau, basculer la page en mode création (vous ne pouvez pas supprimer les contrôles lorsque la page est en mode de navigation). Cliquez sur le menu des verbes (la flèche) dans l’en-tête de la <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, puis sélectionnez **supprimer**. L’avertissement que vous définissez sur le `DeleteWarning` attribut apparaît. Cliquez sur **Annuler**. Cliquez maintenant sur le bouton intitulé **modifier supprimer l’avertissement**, ce qui modifie la valeur de propriété par programme. Dans le menu de verbes sur le contrôle, sélectionnez **supprimer** à nouveau et notez que cette fois l’autre message d’avertissement apparaît.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle serveur à supprimer.</param>
        <summary>Supprime définitivement une instance dynamique d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> d'une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> méthode supprime définitivement le contrôle représenté par le `webPart` paramètre à partir d’une page. Contrairement à un contrôle fermé, qui est ajouté à la <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> de contrôle et peut être ajouté à la page, une instance de contrôle supprimée ne peut jamais être ajoutée à la page.  
  
> [!NOTE]
>  Implémenté par le contrôle WebPart défini, la capacité des utilisateurs à supprimer un dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle dépend de l’utilisateur et la portée de personnalisation dans laquelle le contrôle a été ajouté à une page. Si le contrôle est ajouté lorsque la page est dans la portée partagée (par un utilisateur qui dispose des autorisations), le contrôle ne peut pas être supprimé par des utilisateurs individuels lorsque la page est dans la portée de l’utilisateur.  
  
 Seuls les contrôles dynamiques peuvent être supprimés. Les contrôles dynamiques sont ajoutés à une page par programme ou par les utilisateurs de l’ajout de contrôles à partir d’un catalogue. Les contrôles statiques sont ajoutés à une page de façon déclarative dans le format de balisage ou la persistance. Étant donné que les balises déclaratives sont présentes en permanence dans le balisage, les contrôles statiques ne peuvent jamais être supprimés, mais peut être fermés et rouvert.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>. La première fois le **ajouter un calendrier** bouton, le code au gestionnaire d’événements crée un <xref:System.Web.UI.WebControls.Calendar> de contrôle et l’ajoute à une zone en tant qu’un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet. Étant donné que le contrôle est ajouté par programme, il s’agit d’un contrôle dynamique et par conséquent, il peut être supprimé. Lorsqu’un utilisateur clique sur le **supprimer le calendrier** bouton, le code ainsi que le contrôle existe, puis le supprime en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> (méthode).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage utilisé pour modifier la disposition des pages Web qui contiennent des contrôles WebPart. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet qui est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez faire référence à ce dernier directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsqu’une page qui contient les composants WebPart contrôles du premier chargement, il se trouve dans <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (mode de navigation) par défaut. Lorsque les utilisateurs souhaitent modifier la disposition de la page en déplaçant des contrôles à des zones différentes ou dans les zones actuelles, ils doivent tout d’abord faire basculer la page pour <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (mode Création). Dans ce mode, l’interface utilisateur (IU) pour les différentes zones apparaît, et les utilisateurs peuvent ensuite faire glisser des contrôles pour modifier la disposition.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> champ par programme. Le code remplit une liste déroulante avec les modes d’affichage pris en charge pour la page, qui sont dans ce cas de parcourir et conception. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page est masquée. Utiliser le contrôle de liste déroulante pour basculer la page en mode design. Notez que, en raison du code dans le `Page_PreRender` , l’étiquette est maintenant visible.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à déconnecter.</param>
        <summary>Supprime un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou un contrôle serveur qui est fermé ou supprimé de toutes les connexions auxquelles il participe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode est appelée en interne par le contrôle WebPart défini lorsqu’un contrôle est fermé sur une page ou supprimé d’une page. Dans ce scénario, la méthode est appelée pour supprimer le contrôle de toutes les connexions où elle intervient en tant que consommateur ou fournisseur. Si le contrôle est supprimé de toutes les connexions, cette méthode appelle également la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode pour mettre fin à toutes les connexions dans lequel `webPart` a été impliqué.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode est appelée, elle déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement. Normalement, cet événement peut être annulé, mais il ne peut pas être annulée dans deux cas. Un cas se produit lors des demandes à la page, lorsque la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée. S’il existe un conflit parmi des connexions existantes, la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode sera appelée pour fermer l’une des connexions incompatibles et dans cette instance la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement ne peut pas être annulé, car le conflit doit être résolu.  
  
 L’autre cas se produit lorsqu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur qui est actuellement connecté est fermé ou supprimé. Dans ce cas, le contrôle est en cours de suppression à partir de la page, sa connexion doit être interrompue, par conséquent, par conception, il n’est pas possible d’annuler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement pour interrompre le processus de clôture de connexion. Pour plus d'informations, consultez l'événement <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>. À l’aide de deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, la page Web vous permet de créer une connexion entre les contrôles en cliquant sur un bouton, lors d’un autre bouton vous permet de déconnecter les contrôles. Si vous fermez un des contrôles, tandis que la page est en mode de navigation et les contrôles sont connectés, une substitution de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode déconnecte le contrôle fermé, met fin à la connexion et affiche un message.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur pour la modification des modes d’affichage.  
  
-   Un fichier source contenant personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
-   Une page Web pour héberger les contrôles.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie est le fichier contenant le code source pour les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> les contrôles qui seront connectés et personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise la compilation dynamique, donc la `Register` directive qui fait référence à ces composants dans la page Web est déclarée en conséquence en haut de la page Web. Pour une procédure pas à pas qui montre les options de compilation, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 Dans le code source, notez le contrôle hérité `MyWebPartManager` qui remplace le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> (méthode). Cette méthode vérifie chaque connexion dans une page pour voir si le contrôle fermé participe à la connexion et, dans ce cas, appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode à la fin de la connexion. Cela est identique à l’implémentation de base de la méthode dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. La méthode substituée personnalise ensuite l’implémentation de base en écrivant un message à la page.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 La troisième partie de l’exemple de code est la page Web. Notez que le haut de la page contient `Register` directives pour enregistrer le contrôle utilisateur et l’assembly compilé dynamiquement avec les <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. La page possède deux méthodes principales. Le `Button1_Click` méthode crée une connexion entre les contrôles, tandis que le `Button2_Click` méthode déconnecte les contrôles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Après le chargement de la page, cliquez sur le **connexion** pour connecter les contrôles bouton. Cliquez sur le menu d’actions verbales dans un des contrôles (la flèche vers le bas dans l’en-tête du contrôle), puis sélectionnez **fermer** à partir du menu d’actions verbales. Lorsque vous essayez de fermer le contrôle, la méthode substituée est appelée, la connexion est interrompue et le message est écrit dans la page. Si vous souhaitez réinitialiser la page pour restaurer le contrôle fermé et essayer d’autres options, cliquez sur le **réinitialiser l’état utilisateur** lien pour supprimer les données de personnalisation et restaurer l’état d’origine de la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> qui représente la connexion entre les contrôles serveur.</param>
        <summary>Exécute le processus de déconnexion des contrôles serveur connectés sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode exécute le processus complet de clôture d’une connexion entre <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôles de serveur, lorsque vous passez le `connection` paramètre.  
  
 Cette méthode est utilisée pour déconnecter des contrôles lorsque vous placez un `<asp:connectionszone>` élément dans une page Web, pour fournir une interface utilisateur (IU) pour gérer les connexions. Lorsqu’une page est en mode d’affichage de connexion (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) et il existe une connexion active, les utilisateurs peuvent cliquer sur un bouton qui appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode à la fin de la connexion.  
  
 Vous pouvez également appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> (méthode) directement à partir de votre code, si vous souhaitez déconnecter des contrôles par programme et sans avoir à ajouter un `<asp:connectionszone>` élément à une page.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>. À l’aide de deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, la page Web vous permet de créer une connexion entre les contrôles en cliquant sur un bouton, lors d’un autre bouton vous permet de déconnecter les contrôles.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur pour la modification des modes d’affichage.  
  
-   Un fichier source contenant personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
-   Une page Web pour héberger les contrôles.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie est un fichier contenant le code source pour les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> les contrôles qui seront connectés. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise la compilation dynamique, donc la `Register` directive qui fait référence à ces composants dans la page Web est déclarée en conséquence en haut de la page Web. Pour une procédure pas à pas qui montre les options de compilation, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 La troisième partie de l’exemple de code est la page Web. Notez que le haut de la page contient `Register` directives pour enregistrer le contrôle utilisateur et l’assembly compilé dynamiquement avec les <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. La page possède deux méthodes principales. Le `Button1_Click` méthode crée une connexion entre les contrôles et le `Button2_Click` méthode déconnecte les contrôles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Après le chargement de la page, vous pouvez cliquer sur le **connexion** pour connecter les contrôles bouton. Si vous entrez du texte dans le contrôle de zone de texte, puis cliquez sur le **entrée** bouton, le texte s’affichera dans le contrôle connecté (il ne s’affichera pas si les contrôles ont été déconnectées). Si vous cliquez sur le **déconnexion** bouton, les contrôles seront déconnectés. Vous pouvez vérifier l’état de connexion des contrôles à l’aide de la **Mode d’affichage** contrôle de liste déroulante pour basculer la page en **connexion** mode. Après cela, cliquez sur le menu d’actions verbales (représenté par une flèche) dans la barre de titre de l’un des contrôles, puis sélectionnez le **Connect** élément. L’interface utilisateur de connexion s’affiche. Il est disponible, car il existe un `<asp:connectionszone>` élément déclaré dans la page. Vous pouvez également vous connecter et déconnecter les contrôles à partir de cette interface utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> n'est pas contenu dans <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> ni dans <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> est en lecture seule.  
  
 \- ou -  
  
 <paramref name="connection" /> a déjà été déconnecté de <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />.  
  
 \- ou -  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> est en lecture seule.  
  
 \- ou -  
  
 <paramref name="connection" /> a déjà été déconnecté de <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <block subset="none" type="overrides">
          <para>Vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> méthode si vous souhaitez modifier l’implémentation par défaut pour déconnecter <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> contrôles. Si vous ne substituez pas la méthode, et que vous souhaitez simplement ajouter une implémentation à la méthode existante, vous pouvez appeler la méthode de base avant d’exécuter votre propre code.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode d'affichage actif pour une page Web qui contient des contrôles WebPart.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> qui détermine le mode d'affichage d'une page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une page qui contient des contrôles WebPart est toujours dans un des différents modes d’affichage possibles. Pour plus d’informations sur les modes d’affichage, consultez [Web Parts Page Display Modes](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4).  
  
 La <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe crée les modes d’affichage pour une page Web. À l’aide de la base de <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> (classe), la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle crée plusieurs objets de mode d’affichage standard qui peuvent être utilisées sur les pages qui contiennent des contrôles WebPart. Ces modes d’affichage standard sont décrits dans le <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> vue d’ensemble de la classe.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle gère également les modes d’affichage pour les pages qui utilisent des contrôles WebPart. À l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle conserve une référence au mode d’affichage actuel sur une page. Vous pouvez également utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété passer d’une page dans différents modes d’affichage. Pour obtenir un exemple de la modification des modes d’affichage sur une page qui utilise des contrôles WebPart, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Dans le cadre de la gestion du mode d’affichage, la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle fournit également des événements et gestionnaires d’événements liés aux modes d’affichage, telles que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> (méthode) et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> (méthode). Ces méthodes fournissent un mécanisme permettant de personnaliser le comportement d’une page et même pour l’ajout d’un mode d’affichage personnalisé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété. Après le chargement de la page dans un navigateur, vous pouvez utiliser les boutons au bas de la page pour basculer les modes d’affichage. La page est en mode de navigation par défaut lors de son chargement. Si vous basculez en mode Création, vous pouvez faire glisser les contrôles serveur à partir d’une zone à l’autre ou réorganiser deux contrôles dans une zone. Si vous basculez en mode édition, vous pouvez cliquer sur le menu d’actions verbales dans l’en-tête d’un des contrôles de serveur, sélectionnez **modifier**et modifier le contrôle à l’aide de l’interface utilisateur de modification fournie (IU).  
  
> [!NOTE]
>  Basculement entre les modes d’affichage dans une application WebPart est très courant, et vous souhaitez peut-être fournir un moyen cohérent et réutilisable pour effectuer cette opération sur toutes les pages qui contiennent des contrôles WebPart. Pour obtenir un exemple d’un contrôle utilisateur que modifications modes d’affichage et qui peut être réutilisé sur plusieurs pages, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> assigné à la propriété est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> assigné à la propriété n'est pas l'un des modes d'affichage pris en charge.  
  
 \- ou -  
  
 L'objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> assigné à la propriété est désactivé.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que le mode d'affichage actuel sur une page WebPart a été modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modes d’affichage font partie intégrante des applications WebPart. Lorsque les utilisateurs basculent vers un mode d’affichage différent sur une page Web, la page prend souvent une apparence très différente, selon l’objectif du nouveau mode d’affichage. Modification d’un mode d’affichage, vous pouvez souhaitez apporter certaines modifications à l’interface utilisateur (IU), comme le masquage ou afficher certains contrôles, modifier l’apparence des éléments d’interface utilisateur sélectionnés et ainsi de suite.  
  
> [!NOTE]
>  Pour plus d’informations sur les modes d’affichage, consultez [Web Parts Page Display Modes](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Pour plus d’informations sur l’utilisation des événements, consultez [Comment : consommer des événements dans une Application Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un utilisateur a cliqué sur un verbe dans une page Web, ce qui lance le processus de passage à un mode d'affichage différent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modes d’affichage font partie intégrante des applications WebPart. Lorsque les utilisateurs basculent vers un mode d’affichage différent sur une page Web, la page prend souvent une apparence très différente, selon l’objectif du nouveau mode d’affichage. Une fois un utilisateur lance le processus de modification à un nouveau mode d’affichage en cliquant sur un verbe, vous souhaiterez peut-être apporter certaines modifications dans l’interface utilisateur (IU) à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> propriété pour déterminer ce que sera le nouveau mode d’affichage et modification de l’interface utilisateur différentes éléments en conséquence. Une méthode utile pour ce faire consiste à remplacer la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> méthode pour personnaliser l’interface utilisateur.  
  
> [!NOTE]
>  Pour plus d’informations sur les modes d’affichage, consultez [Web Parts Page Display Modes](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Pour plus d’informations sur l’utilisation des événements, consultez [Comment : consommer des événements dans une Application Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection en lecture seule de tous les modes d'affichage associés à un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> qui contient l'ensemble des objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> associés au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> références de propriété associées modes d’affichage, contrairement à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété, qui référence uniquement les modes d’affichage qui sont disponibles (pris en charge) sur la page actuelle.  
  
 Parmi les modes d’affichage fourni, parcourir et de la conception sont toujours prises en charge sur une page. Les autres modes d’affichage de trois, modifier, catalogue et les connexions, sont pris en charge uniquement lorsqu’une page a le type correspondant de zone nécessaire pour un mode d’affichage particulier à utiliser. Par exemple, si votre page ne contient pas un <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone, le mode d’affichage édition apparaît dans la collection référencée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriété, mais n’apparaîtra pas dans la collection référencée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programmation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriété. Le code utilise cette propriété pour remplir la liste avec tous les modes d’affichage disponibles dans le jeu de composants WebPart, même ceux qui ne sont pas pris en charge sur la page actuelle. Dans ce cas, le catalogue et connecter affichage modes ne sont pas pris en charge, car leur correspondant requis zones ne sont pas dans la page.  
  
 Les trois autres modes d’affichage - navigation, design et édition - sont prises en charge sur la page. Modifier le mode est pris en charge, car la page contient un <xref:System.Web.UI.WebControls.WebParts.EditorZone> de zone, lors de la navigation et les modes de conception sont toujours compatibles.  
  
 Après le chargement de la page dans un navigateur, vous pouvez utiliser le contrôle de liste déroulante pour basculer la page en mode de navigation en mode Création, puis en mode édition. En mode édition, cliquez sur le menu des verbes de la liste déroulante dans l’en-tête de l’un des contrôles serveur, puis sélectionnez **modifier** pour modifier le contrôle. Notez que si vous sélectionnez **catalogue** ou **Connect** dans la liste déroulante, une page d’erreur est générée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de toutes les connexions dynamiques existant actuellement sur une page Web.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> qui contient les références à toutes les connexions dynamiques d'une page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les connexions dynamiques sont des connexions créées par programme, par opposition à statiquement. Connexions statiques sont créées en les déclarant dans le balisage d’une page Web Forms. Les connexions dynamiques sont formées par programme ou par un utilisateur qui crée une connexion à l’aide de l’interface utilisateur de connexion (IU).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> collection, si elle est en lecture seule et vous ne pouvez pas modifier son contenu, fournit l’accès par programme à chaque objet de connexion dynamique.  
  
> [!NOTE]
>  Pour effectuer des opérations courantes telles que la connexion ou la déconnexion <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, les développeurs doivent utiliser les méthodes publiques sur le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> class, telle que <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, au lieu d’essayer de modifier directement la connexion les objets dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> collection.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage dans lequel les utilisateurs finaux peuvent éditer et modifier les contrôles serveur. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet qui est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez faire référence à ce dernier directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsqu’une page qui contient les composants WebPart contrôles du premier chargement, il se trouve dans <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (mode de navigation) par défaut. Lorsque les utilisateurs à modifier un contrôle serveur, ils doivent tout d’abord faire basculer la page pour <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (mode édition). En second lieu, ils doivent sélectionner un contrôle serveur spécifique à modifier, en cliquant sur le verbe de modification dans le menu de verbes d’en-tête de ce contrôle. Une fois que le contrôle est en mode édition, l’interface utilisateur (IU) de modification s’affiche pour modifier le contrôle sélectionné.  
  
 Pour activer le mode édition sur une page, la page doit contenir au moins un <xref:System.Web.UI.WebControls.WebParts.EditorZone> contrôles de zone qui contient un ou plusieurs d’édition, tels que le <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> contrôle ou contrôles d’édition personnalisés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> champ par programme. Le code remplit une liste déroulante avec les modes d’affichage pris en charge pour la page, qui sont dans ce cas de navigation, de conception et d’édition. Pour prendre en charge la modification, un `<asp:EditorZone>` élément se trouve dans la page. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page est masquée. Utilisez le contrôle de liste déroulante pour basculer la page en mode édition. Notez que, en raison du code dans le `Page_PreRender` , l’étiquette est maintenant visible. Cliquez sur le **modifier** verbe dans le menu d’actions verbales sur l’un des contrôles, pour activer la modification de ce contrôle spécifique.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine si le script côté client est activé sur la page Web qui contient un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Valeur Boolean qui indique si le script client peut s'exécuter sur la page. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> propriété offre un moyen aux développeurs de désactiver les scripts client. Vous pourriez pour désactiver l’écriture de scripts pour des raisons de sécurité du client, ou pour vous assurer que tous les utilisateurs d’une page auront une expérience utilisateur similaire, même s’ils utilisent différents navigateurs.  
  
 Vous pouvez désactiver les scripts client en ajoutant une `EnableClientScript` attribut le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> élément sur une page Web, comme dans la ligne suivante de code déclaratif :  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 En outre, les développeurs pourront éliminer cette propriété en héritant de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> valeur de classe et en définissant la valeur par défaut `false`.  
  
 Le jeu de contrôles WebPart utilise des scripts pour fournir une partie du client de l’interface utilisateur (IU) et les fonctionnalités de personnalisation de client. Si vous désactivez le client de script, composants WebPart contrôles continueront de fonctionner, mais certaines fonctionnalités sont désactivées. La possibilité de faire glisser des contrôles vers différentes zones est désactivée, ainsi que la possibilité de restituer des verbes dans un menu de verbes de la liste déroulante dans la barre de titre d’un contrôle (les verbes sont plutôt affichés sous forme de liens dans la barre de titre du contrôle).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant que l'utilisation de thèmes est activée sur une page Web.</summary>
        <value>Valeur booléenne indiquant si les thèmes sont activés. <see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control remplace la base de <xref:System.Web.UI.Control.EnableTheming%2A> pour vous assurer qu’elle retourne toujours une valeur de propriété `true`. Pour cela, car les composants WebPart contrôle requiert l’utilisation de thèmes pour les composants WebPart de restituer les contrôles qui sont des contrôles enfants de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et qui forment l’interface utilisateur (IU) d’une page Web. Par exemple, les thèmes sont utilisés pour restituer les différentes zones, et les contrôles qui résident dans des zones, y compris les différents types de contrôles de la partie (contrôles qui héritent de la <xref:System.Web.UI.WebControls.WebParts.Part> classe), contrôles utilisateur, les contrôles serveur ASP.NET et serveur personnalisé contrôles.  
  
 Bien que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> propriété est implémentée comme une propriété en lecture/écriture conformément à sa propriété de base, vous ne peut pas définir la propriété, car par défaut, elle doit toujours retourner une valeur de `true`. Si vous essayez de définir la propriété, un <xref:System.NotSupportedException> exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Une tentative de définition de la valeur de propriété a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exécute le processus de connexion d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à un autre contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> méthode termine le processus de connexion un <xref:System.Web.UI.WebControls.WebParts.WebPart> vers un autre contrôle. C’est l’équivalent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> (méthode).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> méthode garantit que l’objet de personnalisation référencé par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété est modifiable, ce qui est nécessaire car la formation d’une connexion est elle-même un type de personnalisation. La méthode vérifie ensuite que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> objet n’est pas `null`et enfin appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle référencé par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Les développeurs qui ont besoin d’étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle souhaiterez peut-être substituer cette méthode dans une classe dérivée. Une approche consisterait à appeler la méthode de base et ajoutez ensuite une gestion personnalisée supplémentaire, ou vous souhaiterez peut-être personnaliser entièrement l’ensemble du processus de finalisation d’une connexion entre les contrôles.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met fin au processus de modification d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> méthode termine le processus de modification une <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. C’est l’équivalent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> (méthode).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> méthode garantit que l’objet de personnalisation référencé par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété est modifiable, ce qui est nécessaire, car la modification d’un contrôle est un processus qui nécessite des modifications de personnalisation. La méthode vérifie ensuite que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> objet n’est pas `null`, de sorte qu’actuellement sélectionné <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle peut changer, et enfin, il appelle le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle référencé par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Les développeurs qui ont besoin d’étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle souhaiterez peut-être substituer cette méthode dans une classe dérivée. Une approche consisterait à appeler la méthode de base et ajoutez ensuite une gestion personnalisée supplémentaire, ou vous souhaiterez peut-être personnaliser entièrement l’ensemble du processus de fin de la modification d’un contrôle. Par exemple, dans la méthode de substitution, vous pourriez d’abord appeler la méthode de base et ensuite ajouter du code qui détermine quelles modifications ont été apportées et affiche la liste des modifications de sauvegarde à l’utilisateur final comme une confirmation.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte d'un message d'avertissement affiché lorsqu'un utilisateur tente d'exporter des données d'état sensibles d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <value>Chaîne qui contient le message d'avertissement. Le message par défaut est une valeur spécifique à la culture fournie par le .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur tente d’exporter des données d’état sensibles d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, si les données en cours d’exportation provient d’un membre qui a été marqué comme sensible dans le code source, un message d’avertissement s’affiche à l’utilisateur dans une boîte de message, indiquant que sont en cours d’exportation des données sensibles et une possibilité d’annuler l’exportation. Les développeurs peuvent marquer les données d’un membre spécifique comme sensibles en définissant le `isSensitive` paramètre de la `[Personalizable]` attribut `true` sur le membre. Pour plus d’informations sur cet attribut et ce paramètre, consultez la <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> classe.  
  
> [!IMPORTANT]
>  Lorsque vous utilisez la fonctionnalité d’exportation de composants WebPart, les données sensibles peuvent éventuellement être exportées à des utilisateurs non autorisés. Pour plus d’informations sur la façon de se protéger contre cette menace, consultez [Securing Web Parts Pages](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 Le message par défaut s’affiche chaque fois que les utilisateurs tentent d’exportation. Toutefois, en affectant une valeur pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriété, vous pouvez fournir un message d’avertissement personnalisé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation déclarative de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriété.  
  
 Le code de la page Web suivante utilise une norme <xref:System.Web.UI.WebControls.BulletedList> et le place dans une zone. Le contrôle sera encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle au moment de l’exécution, ce qui lui permet d’agir comme un véritable <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour rendre le contrôle exportable, un `ExportMode` attribut est ajouté à la `<asp:bulletedlist>` élément et la valeur d’attribut est défini sur <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, ce qui signifie que les données sensibles et non sensibles peut être exportée. Notez également que, dans le `<asp:webpartmanager>` élément, le `ExportSensitiveDataWarning` attribut est assigné à une valeur personnalisée.  
  
 Notez que pour l’exemple de code fonctionne, il existe un paramètre, que vous devez ajouter dans le fichier Web.config pour permettre l’exportation des fichiers de description du WebPart. Assurez-vous que vous disposez d’un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il existe un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, cliquez sur le menu d’actions verbales (représenté par une flèche vers le bas) dans la barre de titre du contrôle qui contient les liens. Dans le menu d’actions verbales, sélectionnez **exporter**et notez qu’une boîte de message apparaît avec l’avertissement personnalisé. Si vous souhaitez poursuivre l’exportation, cliquez sur **OK**, ce qui vous permettra d’enregistrer une copie locale d’un fichier de description XML avec toutes les données relatives au contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle à partir duquel les données seront exportées.</param>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> qui écrit les données exportées depuis <c>webPart</c> dans un fichier de description XML.</param>
        <summary>Crée un fichier de description XML qui contient les données d'état et de propriété du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> méthode assemble différentes données d’état et de propriété à partir de `webPart` dans un fichier XML. Les données incluent des informations sur le contrôle lui-même, y compris son assembly, les données d’état et les données de propriété. L’utilisateur qui lance l’exportation peut enregistrer le fichier XML sur le disque sur l’ordinateur local ou le réseau. Les autres utilisateurs peuvent ensuite importer le fichier de description à une autre page ou un site Web et appliquent les données de l’état et de propriété à une autre instance de `webPart`. Fournit un mécanisme rapide et pratique pour les utilisateurs de partager et réutiliser leurs paramètres sur des contrôles de serveur, et il fournit également aux développeurs un moyen de contrôler l’apparence et le comportement des contrôles exportés et importés.  
  
 Propriétés de `webPart` ne sont pas exportés par défaut. Pour activer l’exportation d’une propriété, vous devez marquer avec le `[Personalizable]` attribut dans le code source. Vous pouvez éventuellement marquer une propriété exportable comme contenant des données sensibles, en définissant le `isSensitive` paramètre de la `[Personalizable]` attribut `true`. Par défaut, `isSensitive` est `false`. Les développeurs peuvent définir le paramètre `true` pour indiquer que les données sont sensibles.  
  
 Pour activer `webPart` pour l’exportation, un développeur définit sa <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> valeur de la propriété soit <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (qui inclut toutes les propriétés personnalisables et sensibles), ou la valeur <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, qui exporte tout à l’exception des propriétés sensibles .  
  
> [!IMPORTANT]
>  Ce qui permet aux utilisateurs d’exporter des données à partir de contrôles et importer des données dans d’autres contrôles, implique des risques de sécurité. Les développeurs doivent utiliser l’approche évoquée plus haut pour protéger les données sensibles, et s’ils souhaitent éviter le risque d’exposer des données complètement, ils ne doivent pas activer l’exportation `webPart` du tout. Pour plus d’informations sur les problèmes de sécurité WebPart, consultez [Securing Web Parts Pages](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.  
  
 \- ou -  
  
 <paramref name="writer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> n'est pas contenu dans la collection de contrôles référencée dans <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
 \- ou -  
  
 La propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> de <paramref name="webPart" /> a la valeur <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />, ce qui signifie que l'exportation est désactivée pour <paramref name="webPart" />.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Substitué pour empêcher le focus d'être défini sur le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, compte tenu qu'il n'a pas d'interface utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> méthode substitue à la base de <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> (méthode) et lève une exception si un appelant appelle la méthode. Étant donné que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle sans interface utilisateur et n’est jamais visible pour les utilisateurs, il ne peut jamais autoriser le focus à être défini sur lui-même.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Un appelant tente d'appeler la méthode <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />, ce qui n'est pas pris en charge dans un contrôle qui n'a pas d'interface utilisateur.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle serveur qui joue le rôle de consommateur dans une connexion.</param>
        <summary>Récupère la collection d'objets <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> qui peuvent agir comme des points de connexion d'un contrôle serveur qui joue le rôle de consommateur dans une connexion WebPart.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" /> qui contient tous les points de connexion du consommateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une connexion WebPart toujours implique exactement deux contrôles, un d'entre eux agissant en tant que fournisseur de données, l’autres agissant en tant que le consommateur de données. Chaque contrôle doit avoir une ou plusieurs méthodes qui sont définies en tant que points de connexion. Dans le cas d’un contrôle consommateur, ses points de connexion sont <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> objets. La récupération des points de connexion consommateur est une étape nécessaire dans la formation d’une connexion WebPart.  
  
 Un consommateur doit toujours avoir au moins un point de connexion pour être en mesure d’établir une connexion. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> méthode vérifie un contrôle consommateur et récupère une collection de tous ses points de connexion. Si un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle n’a aucun point de connexion, la méthode retourne une collection vide.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez la rubrique [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Le balisage déclaratif de la page Web contient `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si une connexion existe déjà et, dans le cas contraire, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble de connexions statiques référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété. Notez que la <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> objet récupéré à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> (méthode) est ensuite transmise à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode pour déterminer si une connexion entre les deux contrôles peut être créée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Vous pouvez obtenir ce code et les instructions de compilation, à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois que l’interface utilisateur de connexion (UI) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode). Si vous retournez à cette page dans une session de navigateur ultérieure, cette connexion statique sera déjà établie et n’avez pas besoin être recréée à chaque fois que la page se charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Page Web qui contient une instance du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</param>
        <summary>Récupère une référence à l'instance actuelle du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> sur une page.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui référence l'instance actuelle du contrôle sur une page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> méthode est utile dans les contextes où vous souhaitez récupérer une référence à le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Est d’un scénario courant où cela peut se produire si vous écrivez un contrôle personnalisé qui ne peut pas savoir pendant le développement, le ID de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle sur sa page sera.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> méthode est statique, vous pouvez l’appeler directement sans avoir besoin d’une instance d’un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Certains contrôles dans les composants WebPart jeu de contrôles, tels que <xref:System.Web.UI.WebControls.WebParts.WebPart> , les contrôles ont un <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> propriété qui peut récupérer une référence à le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Par conséquent, lorsque vous travaillez avec ces contrôles, vous devez utiliser cette propriété pour récupérer une référence.  
  
 Si vous codez dans un contexte où vous connaissez l’ID de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, telles que l’écriture de code incorporé dans une page Web, il est plus simple et plus efficace de faire référence directement à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle à l’aide de son ID.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>. L’exemple comporte deux parties : un contrôle serveur personnalisé et une page Web qui héberge le contrôle.  
  
 Personnalisé <xref:System.Web.UI.WebControls.Label> de contrôles utilise la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> méthode pour extraire l’ID de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle sur la page en cours, puis affiche le code.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 L’exemple de code suivant fournit la page Web qui héberge le contrôle dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, notez que l’ID de l’actuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle est affiché dans le personnalisé <xref:System.Web.UI.WebControls.Label> contrôle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle pour lequel la méthode retourne la valeur de <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />.</param>
        <summary>Obtient une chaîne contenant la valeur de la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Chaîne qui contient la valeur calculée de <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> pour <paramref name="webPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtient la valeur calculée de la <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> propriété `webPart`. Lorsque les développeurs n’affectent pas une valeur pour le <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> propriété d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> (contrôle), cette méthode produit la valeur à afficher comme titre. La valeur calculée pour les contrôles sans titre se compose d’un nombre ajouté à une chaîne, avec le numéro de séquence d’un contrôle dans la zone actuelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> ne figure pas dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.</exception>
        <block subset="none" type="overrides">
          <para>Cette méthode peut être substituée pour modifier la façon dont le titre par défaut est calculé.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> en cours d'exportation.</param>
        <summary>Obtient le chemin d'accès virtuel relatif et la chaîne de requête qui font partie de la demande lorsqu'un utilisateur tente d'exporter un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Chaîne contenant le chemin d'accès virtuel relatif et la chaîne de requête qui forment la demande d'exportation d'un contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> méthode est un chemin d’accès virtuel relatif à l’emplacement du serveur de la page qui contient le contrôle, ainsi que la valeur de chaîne de requête ajoutée qui forme la demande d’exportation soumise au serveur. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> méthode encode la chaîne avant d’autoriser la demande à envoyer, protection contre les attaques de script malveillant.  
  
> [!NOTE]
>  Pour plus d’informations sur la sécurisation des applications WebPart, consultez [Securing Web Parts Pages](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle serveur qui existe dans un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> et qui est encapsulé comme contrôle enfant d'un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> au moment de l'exécution.</param>
        <summary>Obtient une référence à l'instance du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui contient un contrôle serveur.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui encapsule <paramref name="control" /> comme contrôle enfant. La méthode retourne <see langword="null" /> si <paramref name="control" /> n'est pas contenu dans un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, il existe des deux catégories de contrôles que les développeurs se placent dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones devant être inclus dans les applications WebPart : <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, qui héritent de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe de base et d’autres contrôles serveur, qui peuvent être standards Contrôles ASP.NET, des contrôles personnalisés ou des contrôles utilisateur. Lorsque un de ces contrôles est placé dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone, il prend les fonctionnalités d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. A <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle possède cette fonctionnalité par nature, mais pas les autres types de contrôles serveur. Pour activer les autres contrôles serveur à agir en tant que <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle lorsqu’ils sont placés dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone, ASP.NET les encapsule avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle. Étant donné que la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle hérite directement de la <xref:System.Web.UI.WebControls.WebParts.WebPart> (classe), il fournit à ses contrôles enfants de véritables fonctionnalités WebPart.  
  
 Souvent, au moment de l’exécution, les développeurs de page souhaitent obtenir une référence à la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle contenant l’un des contrôles serveur dans une zone. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> méthode leur permet de récupérer une référence à la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> (méthode). L’exemple de code contient un <xref:System.Web.UI.WebControls.Calendar> contrôle déclaré dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone. Le `Button1_Click` méthode imprime tout d’abord l’ID de la <xref:System.Web.UI.WebControls.Calendar> contrôle à une étiquette, puis utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> pour récupérer une référence à la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle qui encapsule le calendrier. L’ID de la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle et l’ID de son contrôle enfant (qui est le <xref:System.Web.UI.WebControls.Calendar> contrôle), sont imprimés sur une deuxième étiquette.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle serveur qui joue le rôle de fournisseur dans une connexion.</param>
        <summary>Récupère la collection d'objets <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> qui peuvent agir comme des points de connexion d'un contrôle serveur qui joue le rôle de fournisseur dans une connexion WebPart.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" /> qui contient tous les points de connexion du fournisseur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une connexion WebPart toujours implique exactement deux contrôles, un d'entre eux agissant en tant que fournisseur de données, l’autres agissant en tant que le consommateur de données. Chaque contrôle doit avoir une ou plusieurs méthodes qui sont définies en tant que points de connexion. Dans le cas d’un contrôle de fournisseur, ses points de connexion sont <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> objets.  
  
 Un fournisseur doit toujours avoir au moins un point de connexion pour être en mesure d’établir une connexion. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> méthode vérifie un contrôle fournisseur et récupère une collection de tous ses points de connexion. La récupération des points de connexion fournisseur est une étape nécessaire dans la formation d’une connexion WebPart.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 L’exemple de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Le balisage déclaratif de la page Web contient `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si une connexion existe déjà et, dans le cas contraire, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble de connexions statiques référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété. Notez que la <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> objet récupéré à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> (méthode) est ensuite transmise à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode pour déterminer si une connexion entre les deux contrôles peut être créée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Vous pouvez obtenir ce code et les instructions de compilation, à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois que l’interface utilisateur de connexion (UI) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode). Si vous retournez à cette page dans une session de navigateur ultérieure, cette connexion statique sera déjà établie et n’avez pas besoin être recréée à chaque fois que la page se charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> qui lit les données d'état et de propriété à partir du fichier de description XML importé.</param>
        <param name="errorMessage">
          <see cref="T:System.String" /> qui s'affiche à l'attention de l'utilisateur si une erreur est rencontrée pendant l'importation.</param>
        <summary>Importe un fichier de description XML qui contient les données d'état et de propriété du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> et applique les données au contrôle.</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou contrôle serveur encapsulé par un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> et par conséquent traité comme un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />) qui est référencé dans le fichier de description XML importé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> méthode importe un fichier de description XML qui a été créé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> méthode pour un contrôle serveur. Il n’est pas le contrôle serveur réel qui est importé, mais uniquement le fichier de description contenant des données d’état et de propriété relatives au contrôle. Le contrôle et l’assembly référencé dans le fichier de description doivent déjà être disponibles sur le serveur où un utilisateur essaie d’importer le fichier de description.  
  
 Pour activer l’importation d’un contrôle, un développeur doit ajouter un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> contrôle sur la page où l’importation sera activée. Dans la zone, une <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> contrôle doit être ajouté. Ce contrôle fournit une boîte de dialogue qui permet aux utilisateurs de parcourir et localiser le fichier de description à importer.  
  
 Après qu’un utilisateur recherche un fichier de description et commence l’importation, le fichier de description est lu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> (méthode). Si aucun message d’erreur et si l’assembly et le contrôle sont trouvés, le contrôle serveur est ajouté au catalogue dans le <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> contrôle et les différentes données de propriété et d’état spécifiées dans le fichier de description sont appliquées au contrôle. L’utilisateur peut ensuite sélectionner le contrôle et l’ajouter à la page.  
  
> [!IMPORTANT]
>  Comme le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> (méthode), la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> méthode présente certains risque aux risques de sécurité. Car elle implique l’importation de données dans un site Web, un utilisateur malveillant pourrait tenter d’insérer des données incorrectes ou le code de script de même dans le fichier de description qui est importé. Les données incorrectes peut apparaître sur une page ou dans une base de données, ou le script inséré pourrait s’exécuter. Pour une vue d’ensemble des risques potentiels associés à l’importation des fichiers de description et moyens d’éviter ces risques, consultez [Securing Web Parts Pages](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> n'a pas pu lire le fichier.  
  
 \- ou -  
  
 <paramref name="reader" /> devait afficher un message d'erreur d'importation mais n'en a pas trouvé dans le fichier.  
  
 \- ou -  
  
 <paramref name="reader" /> a atteint la fin du fichier sans trouver l'élément XML qui contient les données exportées.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> utilisée pour combiner et séparer un jeu de méthodes qui sont réellement implémentées dans la classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> mais qui sont surtout utiles aux développeurs de contrôles.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> via lequel un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> peut référencer les différentes méthodes qui ont été séparées dans <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété expose les API à appeler dans un jeu de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> méthodes sont utilisées principalement dans les cas d’extensibilité.  
  
 La manière prévue d’utiliser ces méthodes internes est d’y accéder via le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété. Étant donné que la propriété est protégée, vous pouvez uniquement y accéder et appeler les méthodes dans une instance de la <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe en héritant de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe.  
  
> [!NOTE]
>  Cette propriété est masquée à partir d’IntelliSense dans [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]. Toutefois, dans une dérivée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> (classe), vous pouvez toujours accéder à la propriété et ses différents membres.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur peut être ajouté à une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Partie de la flexibilité de la fonctionnalité WebPart est la possibilité d’ajouter des contrôles serveur aux pages Web en cours d’exécution. Il existe un nombre de scénarios courants dans lesquels un contrôle serveur (qui peut être personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, un contrôle serveur personnalisé, un contrôle utilisateur ou un contrôle ASP.NET) peut être ajouté.  
  
 Dans les scénarios courants suivants, le WebPart ensemble tente d’ajouter des contrôles serveur à une page et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode est appelée pour les autoriser :  
  
-   Lorsqu’un contrôle serveur est ajouté en le déclarant dans le balisage d’une page Web dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone.  
  
-   Lorsqu’un contrôle serveur est ajouté par programme à une zone.  
  
-   Lorsqu’un utilisateur importe un contrôle serveur dans un catalogue de composants WebPart de contrôles.  
  
-   Lorsqu’un un contrôle serveur est chargé à partir du magasin de données de personnalisation.  
  
-   Lorsqu’un contrôle serveur est ajouté à un <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> contrôle pour le rendre disponible dans un catalogue de contrôles serveur.  
  
 Dans chaque scénario dans lequel les contrôles sont ajoutés, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode est appelée pour vous assurer que tous les critères d’autorisation ont été remplies pour permettre à un contrôle à ajouter. Lorsqu’un contrôle est autorisé, il est ajouté normalement comme il le serait si il y a aucun scénario de filtrage. Lorsqu’un contrôle n’est pas autorisé, le jeu de contrôles WebPart peut répondre de plusieurs façons, selon le contexte. Le jeu de contrôles peut échouer en mode silencieux ajouter une partie non autorisée (s’il n’y a pas besoin d’informer l’utilisateur), il peut afficher un message d’erreur, ou il peut ajouter une instance de la <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> classe comme un espace réservé. Cet objet d’espace réservé n’est pas visible sur la page, mais est visible dans le code source de la page pour indiquer qu’un contrôle non autorisé a été exclu.  
  
 Le déterminant de si un contrôle est autorisé est le filtre d’autorisation. Un filtre d’autorisation est une fonctionnalité dans le jeu de composants WebPart qui permet aux développeurs d’exclure d’une page tous les contrôles qui ne répondent pas aux critères spécifiés.  
  
 Pour créer un scénario de filtrage, les développeurs doivent faire deux choses. Tout d’abord, ils doivent affecter une valeur de chaîne (la valeur peut être arbitraire) à la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> prévoient d’utiliser dans le scénario de contrôle. Ils peuvent également affecter une valeur à cette propriété pour les autres types de contrôles serveur qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, étant donné que s’ils sont placés dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones, ces contrôles sont encapsulés avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> un contrôle au moment de l’exécution et ce contrôle hérite le <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété.  
  
 La deuxième étape nécessaire pour la création d’un scénario de filtrage est soit de substituer le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> (méthode), ou pour créer un gestionnaire d’événements pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement. Dans ces méthodes, un développeur peut vérifier le <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété, et si la valeur indique que le contrôle ne doit pas être autorisé, le développeur s’assure que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode retourne une valeur de `false`.  
  
> [!NOTE]
>  Pour des exemples de code et une description de la configuration d’un scénario de filtrage personnalisé à l’aide du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), consultez les rubriques pour les surcharges de la méthode.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur dont l'autorisation est vérifiée.</param>
        <summary>Exécute les étapes initiales en déterminant si l'ajout d'un contrôle à une page est autorisé.</summary>
        <returns>Valeur Boolean qui indique si <paramref name="webPart" /> peut être ajouté à une page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode est la méthode initiale appelée par le contrôle de composants WebPart pour vérifier l’autorisation pour définir un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Il accepte `webPart` en tant que paramètre et lance un processus qui finalement détermine si le contrôle sera ajouté à une page. Appelez cette méthode depuis votre code directement lorsque vous devez déterminer si un contrôle donné est autorisé.  
  
 Cette méthode effectue les tâches initiales permettant de déterminer si le contrôle hérite de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe ou est un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de contrôle et, dans ce cas, le type de contrôle enfant qu’il contient. Pour terminer la tâche d’autorisation, elle appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> méthode depuis votre code pour déterminer si un contrôle est autorisé à être ajouté à une page.  
  
 L’exemple de code comprend trois parties :  
  
-   Personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle qui substitue le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode).  
  
-   Une page Web qui crée un filtre pour un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
-   Explication de l’exécution de l’exemple de code.  
  
 Cet exemple de code utilise une personnalisée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle qui substitue le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de méthode pour fournir une gestion personnalisée de la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété. Ce contrôle vérifie une valeur de propriété `admin` et, si la valeur est présente, autorise le contrôle. Si un contrôle a une valeur différente, il n’est pas autorisé ; contrôles sans la valeur de propriété sont autorisés, car elles sont censées ne pas faire partie du scénario de filtrage.  
  
 Pour exécuter cet exemple de code, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise la méthode de compilation dynamique. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 La deuxième partie de l’exemple de code crée un filtre qui peut potentiellement exclure un contrôle. La page Web suivante contient trois contrôles de serveur ASP.NET dans un `<asp:webpartzone>` élément. Notez que les premier et deuxième contrôles ont leurs <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriétés définies sur des valeurs différentes, et le troisième n’affecte pas la propriété. Cette valeur d’autorisation peut être vérifiée au moment de l’exécution, et le contrôle peut être ajouté à la page si le filtre correspond aux critères définis par le développeur. Notez également que, dans le `Page_Load` (méthode), le code appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> méthode pour déterminer si chacun des contrôles est autorisé, et si, par conséquent, il définit de chaque contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Notez que pour l’exemple de code fonctionne, vous devez ajouter un paramètre dans le fichier Web.config pour permettre l’exportation des fichiers de description du WebPart. Assurez-vous que vous disposez d’un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il existe un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Après le chargement de la page dans un navigateur, notez que le premier contrôle est affiché, car il correspond aux critères dans la méthode substituée. Le deuxième contrôle n’est pas ajouté à la page, car il est exclu par le filtre. Le troisième contrôle est également ajouté, car il n’a pas son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> jeu de propriétés. Notez que si vous cliquez sur l’icône du menu de verbes dans la barre de titre d’un contrôle, ils peuvent tous deux être exportée parce que respectives <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> valeurs de propriété ont été attribués.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Cette méthode est appelée directement depuis votre code. Si vous souhaitez garantir un meilleur contrôle par programmation sur le processus d’autorisation, vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> surcharge de méthode.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> du contrôle qui est vérifié pour autorisation.</param>
        <param name="path">Chemin d'accès relatif de l'application au fichier source pour le contrôle autorisé, s'il s'agit d'un contrôle utilisateur.</param>
        <param name="authorizationFilter">Valeur de chaîne arbitraire assignée à la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, utilisée pour autoriser l'ajout d'un contrôle à une page.</param>
        <param name="isShared">Indique si le contrôle qui est vérifié pour autorisation est un contrôle partagé, c'est-à-dire visible pour la plupart ou tous les utilisateurs de l'application et si sa propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> a la valeur <see langword="true" />.</param>
        <summary>Exécute les étapes finales en déterminant si l'ajout d'un contrôle à une page est autorisé.</summary>
        <returns>Valeur Boolean qui indique si l'ajout d'un contrôle à une page est autorisé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> la surcharge de méthode exécute les étapes finales de déterminer si un contrôle est autorisé à être ajouté à une page. La méthode garantit que `type` est un type valide et que `path` a une valeur uniquement si le contrôle en cours de vérification est un contrôle utilisateur. Ensuite, il appelle la critique <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode qui déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode pour déterminer si un contrôle est autorisé à être ajouté à une page.  
  
 La première étape consiste à créer un filtre qui peut potentiellement exclure un contrôle. La page Web suivante contient trois contrôles de serveur ASP.NET dans un `<asp:webpartzone>` élément. Notez que les premier et deuxième contrôles ont leurs <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriétés définies sur des valeurs différentes, et le troisième n’affecte pas la propriété. Cette valeur d’autorisation peut être vérifiée au moment de l’exécution, et le contrôle peut être ajouté à la page si le filtre correspond aux critères définis par le développeur.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 La deuxième étape consiste à remplacer le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> (méthode) et créer la gestion personnalisée pour les filtres d’autorisation. Notez que le code vérifie d’abord si la propriété a une valeur, afin que tout contrôle qui n’affecte pas le <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété sera ajoutée automatiquement. Si un contrôle a un filtre, le code retourne `true` uniquement si la valeur de filtre est égale à `admin`. Cela présente un mécanisme simple, que vous pouvez utiliser pour afficher certains contrôles à certains utilisateurs, en fonction de leur rôle. Alors qu’il est un exemple complet à l’aide de rôles dépasse le cadre de cette rubrique, vous pouvez utiliser la même logique que la méthode substituée dans cet exemple de code, à ceci près que vous pouvez vérifier si l’utilisateur actuel est dans un rôle qui correspond à la valeur du filtre d’autorisation , puis ajoutez le contrôle uniquement pour cet utilisateur. Cela vous permettrait de créer des pages où certains utilisateurs visualiserez tous les contrôles et autres utilisateurs seraient voient uniquement les contrôles sélectionnés. Voici comment la logique qui vérifie le filtre peut se présenter si vous avez utilisé des rôles :  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise la méthode de compilation dynamique. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 Après le chargement de la page dans un navigateur, notez que le premier contrôle est affiché, car il correspond aux critères dans la méthode substituée. Le deuxième contrôle n’est pas ajouté à la page, car sa valeur de filtre est exclu. Le troisième contrôle est ajouté, car il n’a pas son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> jeu de propriétés. Si vous modifiez la valeur de propriété sur le deuxième contrôle correspond à celui du premier contrôle, puis exécutez à nouveau la page, le deuxième contrôle est également ajouté.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> est un contrôle utilisateur et <paramref name="path" /> est soit <see langword="null" />, soit une chaîne vide ("").  
  
 \- ou -  
  
 <paramref name="type" /> n'est pas un contrôle utilisateur et <paramref name="path" /> a une valeur qui lui est assignée.</exception>
        <block subset="none" type="overrides">
          <para>Cette méthode peut être substituée en héritant de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, si vous souhaitez fournir une gestion supplémentaire lors de la vérification d’autorisation. Vous souhaiterez peut-être substituer la méthode pour vérifier certaines valeurs le <paramref name="authorizationFilter" /> paramètre et selon la valeur, retourner une valeur booléenne qui détermine si le contrôle sera ajouté à une page.  
  
 Pour les développeurs de pages qui souhaitent également pour rechercher des filtres d’autorisation et de fournir une gestion personnalisée, il est une option pour faire en ligne dans une page .aspx, ou dans un fichier code-behind, sans avoir à hériter des classes. Vous pouvez déclarer un gestionnaire d’événements de remplacement dans la page pour le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> méthode de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle. Pour plus d’informations et obtenir un exemple, consultez la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> (méthode).</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les modifications de personnalisation apportées affectent les détails de personnalisation au niveau de la page contrôlés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Valeur Boolean qui indique si des modifications de personnalisation ont été apportées. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de contrôles utilise la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> propriété en interne pour suivre si les données qu’il gère la personnalisation au niveau de la page a été modifiée. Les données de personnalisation sont modifiées lorsque les utilisateurs exécutent différentes actions de personnalisation au niveau de la page, telles que l’ajout ou la suppression <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, la connexion ou la déconnexion des contrôles, la modification de la mise en page en déplaçant des contrôles et autres actions.  
  
> [!NOTE]
>  Les utilisateurs peuvent effectuer la personnalisation au niveau du contrôle, ce qui signifie qu’ils apportent des modifications de personnalisation à un contrôle spécifique, et les modifications affectent uniquement ce contrôle. Un exemple serait le contrôle d’édition et modifier le texte du titre ou sa couleur d’arrière-plan. La personnalisation au niveau du contrôle n’affecte pas les données de personnalisation au niveau de la page suivies par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et donc la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> valeur de propriété n’est pas modifiée en `true` lorsque la personnalisation au niveau de contrôle se produit.  
  
 Bien que la méthode est protégée et ne peut pas être accessible directement par un appelant, la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété est accessible directement par les appelants, et elle retourne la valeur de cette propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Contient les données d'état persistantes à charger.</param>
        <summary>Charge les données d'état du contrôle qui ont été enregistrées par une demande de page antérieure et doivent être restaurées sur une demande ultérieure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> méthode est utile pour restaurer les données de propriété qui doivent être persistante entre les publications (postback) d’une page, même lorsque le <xref:System.Web.UI.Control.EnableViewState%2A> est définie sur `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> n’est pas un <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> valide.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> contenant les données d’état à charger.</param>
        <summary>Stocke les données de personnalisation qui ont été transmises au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> par les objets de personnalisation, en vue d’une utilisation ultérieure pendant le processus d’initialisation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> méthode fournit des données d’état enregistrées sous la forme d’un <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> objet. Ces données sont éventuellement utilisées pour charger des données de personnalisation dans les contrôles WebPart et effectuer d’autres tâches d’initialisation.  
  
> [!NOTE]
>  Cette méthode est appelée par une séquence de méthodes qui commence lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> méthode demande initialement associé <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> objet à fournir des données de personnalisation à le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Vous ne pouvez pas appeler cette méthode directement à partir de votre code. Vous pouvez, toutefois, appeler directement la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> (méthode), qui elle-même appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> méthode et retourne les données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</summary>
        <value>Objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.PermissionSet> objet qui est retourné par cette propriété est utilisée lors de l’importation pour la désérialisation de type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</summary>
        <value>Obtient un objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.PermissionSet> objet retourné par cette propriété est utilisée lors de l’importation pour tout sauf la désérialisation de type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur déplacé.</param>
        <param name="zone">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> cible vers laquelle <c>webPart</c> est déplacé.</param>
        <param name="zoneIndex">Entier qui indique l'index de <c>webPart</c> par rapport aux autres contrôles de <c>zone</c>.</param>
        <summary>Déplace un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur d'une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> à l'autre ou à une nouvelle position dans la même zone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de contrôles utilise la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode pour déplacer `webPart` vers un nouvel emplacement dans la même zone, ou dans un autre fuseau horaire. Vous pouvez appeler cette méthode directement à partir de code, et il est également appelée lorsqu’un utilisateur déplace un contrôle à une nouvelle position dans l’interface utilisateur de composants WebPart (IU) à l’aide de différentes options.  
  
 Un certain nombre de conditions doit être remplie avant `webPart` peuvent être déplacés, et la plupart de ceux-ci est indiquée par les éléments répertoriés dans la section Exceptions de cette rubrique. Si `webPart` ne figure pas dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone pour commencer, il ne peut pas être déplacé dans une zone.  
  
 Une fois que les conditions sont remplies, la séquence d’actions suivante se produit pour déplacer `webPart`:  
  
1.  La méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> déclenche l'événement <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>.  
  
2.  `webPart` est supprimé de sa zone actuelle (si nécessaire) et ajouté à sa nouvelle zone ou une nouvelle position dans sa zone actuelle.  
  
3.  La méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> déclenche l'événement <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>.  
  
4.  Le `zoneIndex` de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle dans les zones d’origine et de destination est réinitialisé pour refléter le contrôle déplacé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> (méthode) directement à partir de code pour déplacer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à partir d’une zone à l’autre.  
  
 L’exemple de code comprend trois parties :  
  
-   Un contrôle utilisateur pour la modification des modes d’affichage.  
  
-   Une page Web pour héberger les contrôles.  
  
-   Explication de l’exécution de l’exemple de code.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple est une page Web qui contient deux zones, chacun d’eux contient deux contrôles serveur. Lorsqu’un utilisateur clique sur le **déplacer le WebPart** bouton dans la page, le code dans la `Button1_Click` méthode déplace un contrôle de la première zone vers une nouvelle position dans la deuxième zone. Notez que le code doit tout d’abord appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> pour récupérer le <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet qui encapsule le `list1` contrôle. Cela est nécessaire car le premier paramètre de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode requiert un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, tandis que `list1` est un contrôle serveur ASP.NET.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 Une fois le chargement de la page, cliquez sur le **déplacer le WebPart** bouton et notez que le contrôle qui contient les liens se déplace à la position centrale dans la deuxième zone. Ce déplacement du contrôle s’effectue par programme en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> (méthode). Vous pouvez également utiliser le **Mode d’affichage** contrôle de liste déroulante pour basculer la page en mode design et en mode Création, vous pouvez faire glisser les contrôles vers différentes zones ou des positions différentes dans leurs zones. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode est également appelée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour gérer ces initiée par l’utilisateur se déplace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> n'est pas contenu dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
 \- ou -  
  
 <paramref name="zone" /> n'est pas contenu dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
 \- ou -  
  
 La zone référencée par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> du contrôle <paramref name="webPart" /> est <see langword="null" />, ce qui signifie que <paramref name="webPart" /> n'est pas contenu actuellement dans une zone.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ou <paramref name="zone" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> est inférieur à zéro.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" /> qui contient les données de l'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> et appelle un gestionnaire pour l'événement, le cas échéant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode est appelée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), lorsqu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> vérification d’autorisation à ajouter à une page de contrôle. Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode est appelée, elle déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, et s’il existe une méthode de gestionnaire pour l’événement, il appelle le gestionnaire.  
  
 Le processus d’autorisation <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles est une fonctionnalité importante du WebPart. Chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur qui est ajouté à une zone en les <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle passe par un processus d’autorisation pour déterminer si le contrôle peut être ajouté. Par défaut, le jeu de composants WebPart ne fournit pas de critères de filtrage pour empêcher l’ajout à une zone de contrôles. Mais le jeu de contrôles fournit les mécanismes nécessaires aux développeurs de créer leurs propres critères de filtrage. À l’aide de ces mécanismes, vous pouvez créer des scénarios de filtrage personnalisées. Par exemple, vous pouvez créer un filtre, afin que, si un utilisateur est dans un rôle d’administrateur, certains contrôles seraient être ajoutés à une zone lorsque la page est restituée, et si l’utilisateur est dans un rôle d’utilisateur, ces contrôles ne seront pas ajoutés.  
  
 Les mécanismes de filtrage des contrôles pendant le processus d’autorisation sont les <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété sur <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthodes et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement sur le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Pour créer un scénario de filtrage, il existe essentiellement deux tâches. Tout d’abord, vous assignez des chaînes à la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle que vous souhaitez filtrer. Ces valeurs de chaîne peuvent être arbitraires, mais elles doivent contenir les critères que vous souhaitez filtrer. Par exemple, si vous souhaitez un contrôle donné à ajouter à une zone uniquement si un administrateur utilisateur consulte la page, puis vous pouvez affecter une valeur de chaîne `admin` à la propriété. Puis vous pourriez utiliser la fonctionnalité de rôles ASP.NET et ajouter tous les utilisateurs de votre site à différents rôles comme administrateur, gestionnaire et utilisateur. Lors du chargement d’une page, votre code de filtrage serait Vérifiez quel rôle d’un utilisateur se trouve dans, comparez-la à la valeur du filtre d’autorisation sur un contrôle en cours de vérification et si (par exemple) l’utilisateur est dans un rôle d’administrateur et que vous aviez défini du contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valeur `admin`, le contrôle peut être ajouté.  
  
 La deuxième étape de création d’un scénario de filtrage consiste à écrire du code pour vérifier la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> des valeurs de propriété sur <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle et déterminer si chaque contrôle est autorisé avant d’être ajouté à sa zone. Il existe deux options pour l’emplacement de ce code de filtrage. La première option est l’option recommandée pour les développeurs de page. Vous pouvez créer une méthode pour gérer les <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement directement dans le code de script de serveur de page Web ou dans un fichier de séparation de code. Associer votre méthode à l’événement en ajoutant le `OnAuthorizeWebPart` d’attribut à la balise pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de contrôle dans la page, comme indiqué dans l’exemple de code de balisage suivant.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 Tout votre méthode personnalisée a à faire est cocher chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle pour les critères de filtrage et basées sur les résultats, puis assigner la valeur booléenne à la <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> propriété de la <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> objet pour indiquer si le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle peut être ajouté. Le code dans la section exemple montre comment effectuer cette opération.  
  
 La deuxième option permettant de savoir où placer votre code de filtrage consiste à hériter la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et substituer une méthode pour vérifier les critères de filtre. Les deux méthodes que vous pouvez substituer pour associées sont les <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> méthode ou la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode). Bien que les deux méthodes fonctionnent, dans la plupart des cas, il est préférable de substituer le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), car celle-ci fournit un plus grand contrôle par programmation sur le processus d’autorisation entier, alors que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode effectue une seule tâche spécifique , qui consiste à déclencher l’événement et à vérifier un gestionnaire. Pour obtenir un exemple de code de personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe qui remplace le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de la méthode.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir un gestionnaire d’événements personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, afin que le gestionnaire peut fournir un code de filtrage personnalisé pour la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode). Cet exemple est un moyen classique pour un développeur de pages fournir un scénario de filtrage et l’autorisation de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles à ajouter à une page.  
  
 Dans la page Web, notez que le `<asp:webpartmanager>` élément a le `OnAuthorizeWebPart` attribut avec le nom du Gestionnaire d’événements qui lui est affecté. La méthode vérifie si les contrôles sur la page ont respectives <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> les valeurs de propriété `admin` et, si tel est le cas, retourne `true`, ce qui signifie qu’ils seront autorisés et ajoutés à la page.  
  
> [!NOTE]
>  Notez que les contrôles qui n’ont pas de toute valeur affectée à la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété sont également ajoutés, car ils sont supposés ne pas pour faire partie d’un scénario de filtrage. Il s’agit d’une approche courante dans un scénario de filtrage : certains contrôles sont filtrés, et d’autres ne serait pas, car elles sont supposées être disponibles pour tous les utilisateurs.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 Configuration d’utilisateurs dans les rôles étant dépasse le cadre de cette rubrique, cet exemple de code ne vérifie pas les rôles d’utilisateur dans le filtrage. Toutefois, le scénario de filtrage des contrôles en fonction des rôles d’utilisateur est susceptible d’être une des utilisations plus courantes de cette fonctionnalité de filtrage. Si vous disposez de rôles sur votre site, et que vous souhaitez vérifier les rôles d’utilisateur dans cette méthode pour filtrer les contrôles, la méthode ressemble à ce bloc de code suivant (par opposition à l’approche la plus simple dans l’exemple de code précédent, qui n’utilise pas de rôles).  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> pour indiquer qu'une page et ses contrôles sont chargés, et que les connexions sur la page ont été activées pour commencer le partage des données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> événement après une page a terminé le processus de chargement. La méthode fournit un moyen d’ajouter un gestionnaire pour l’événement.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnConnectionsActivated` attribut le `<asp:webpartmanager>` élément dans une page, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> pour indiquer qu'une page et ses contrôles ont été chargés et que le processus d'activation des connexions peut commencer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> événement, qui fournit aux développeurs un mécanisme pour la personnalisation par programmation le processus d’activation des connexions.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnConnectionsActivating` attribut le `<asp:webpartmanager>` élément dans une page, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" /> qui contient les données d'événement associées à un mode d'affichage modifié.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> pour indiquer que le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> a terminé le processus de basculement d'un mode d'affichage à l'autre sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> méthode dans sa base forment déclenche simplement la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> (méthode). Par exemple, après un changement de mode d’affichage, vous pouvez souhaiter modifier quelque chose dans l’apparence de l’interface utilisateur (IU), en fonction de l’affichage qui mode est contenu dans le <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> propriété. Ou vous souhaiterez peut-être certains contenus de masquer ou afficher un contrôle.  
  
 Lorsque vous substituez la méthode, vous devez normalement appeler la méthode de base en tant que la dernière étape de la méthode substituée, afin que votre code personnalisé s’exécute en premier, l’événement est déclenché en dernier, indiquant que le changement de mode est terminé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement associées à un changement de mode d'affichage.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> pour indiquer que le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> est en train de basculer d'un mode d'affichage à l'autre sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> méthode dans sa base forment déclenche simplement la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> (méthode). Par exemple, lorsqu’un mode d’affichage est modifié, vous pouvez souhaiter vérifier ce que sera le nouveau mode d’affichage (à l’aide de la <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> propriété) et modifier quelque chose dans l’interface utilisateur (IU) en fonction de ce que sera le nouveau mode d’affichage. Si vous aviez un mode d’affichage personnalisé, vous souhaiterez rendre certains contrôles visibles si le mode personnalisé sera le nouveau mode d’affichage.  
  
 Lorsque vous substituez cette méthode, vous devez normalement appeler la méthode de base comme la première étape de la méthode substituée, afin que l’événement est déclenché pour indiquer qu'un mode d’affichage commence à modifier. Ensuite, votre code personnalisé peut apporter des modifications dans l’interface utilisateur (IU) avant que le mode d’affichage est réellement affiché.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Init" /> qui est le premier événement dans le cycle de vie du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> méthode appelle la méthode de base, laquelle déclenche le <xref:System.Web.UI.Control.Init> événement pour le contrôle, puis exécute plusieurs étapes préparatoires, telles que de telle sorte qu’une seule instance de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> sur une page et le chargement données de personnalisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il existe un autre contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> dans la page.</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.PreRender" /> qui se produit juste avant qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ne soit rendu sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> méthode appelle la méthode de base, laquelle déclenche le <xref:System.Web.UI.Control.PreRender> contrôle l’événement pour le contrôle, puis inscrit plusieurs scripts clients nécessaires sur les pages qui contiennent des composants WebPart.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />, qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été récemment sélectionné ou dont la sélection a fait l'objet d'une suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> événement, qui correspond généralement à un point dans le temps où un développeur peut modifier l’apparence de l’interface utilisateur (IU). Par exemple, lorsqu’un nouveau <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est sélectionné, le contrôle WebPart jeu modifie le rendu du contrôle qui vient d’être sélectionné. Une fois la sélection d’un contrôle est désactivée, le rendu est redevenu normal.  
  
 Une fois que l’utilisateur sélectionne un particulier <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle pour la modification, la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode est appelée. Lorsque l’utilisateur a fini de modifier le contrôle et le ferme, avec pour résultat que la sélection du contrôle est désactivée, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode est appelée à nouveau.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il existe plusieurs options relatives à la <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> événement, afin de permettre aux développeurs de personnaliser le rendu qui se produit après que le contrôle sélectionné a changé. Dans le code déclaratif, dans le <see langword="&lt;asp:webpartmanager&gt;" /> élément, vous pouvez définir le <see langword="OnSelectedWebPartChanged" /> d’attribut et lui affecter le nom d’une méthode personnalisée. Dans la méthode personnalisée, vous pouvez modifier le rendu des contrôles sélectionnés lorsque l’événement se produit. Une autre option consiste à hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe et substituer la méthode. Une troisième option consiste à personnaliser le rendu au niveau de la zone ; par exemple, vous pouvez hériter de la <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> classe et substituer sa <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> (méthode), pour personnaliser le rendu des contrôles sélectionnés et effacés pendant le processus de modification.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> qui se produit pendant le processus de changement du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> actuellement sélectionné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement qui se produit pendant le processus de changement <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle actuellement sélectionné.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle utilise cette méthode et l’événement associé, pour fournir une opportunité d’annuler un processus dans lequel le contrôle sélectionné est modifié. Par exemple, la méthode est appelée au sein de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> (méthode), ainsi que dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> (méthode), offre un moyen d’annuler le processus. Si un utilisateur clique sur le verbe cancel sur un contrôle qui est en cours de modification, le contrôle n’est plus sélectionné et les modifications apportées ne sont pas enregistrées, car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> méthode vous permet d’annuler les modifications.  
  
> [!NOTE]
>  La méthode est appelée de la même façon au cours des méthodes qui commencent et terminent le processus de connexion un <xref:System.Web.UI.WebControls.WebParts.WebPart> vers un autre contrôle, pour permettre l’annulation de ce processus.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement en ajoutant le `OnSelectedWebPartChanging` attribut le `<asp:webpartmanager>` élément dans le balisage de page déclarative et en affectant à l’attribut le nom d’une méthode personnalisée.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement associées à la suppression du contrôle.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Unload" /> de base et supprime l'instance de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> d'une page Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été ajouté à une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> méthode est appelée pendant le processus d’ajout un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou autre contrôle serveur qui est ajouté à un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone) à une page.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement en ajoutant le `OnWebPartAdded` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> qui se produit au cours du processus d'ajout d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou d'un contrôle serveur ou utilisateur) à une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> événement pour indiquer qu’un contrôle est en cours d’ajout. La méthode offre également la possibilité d’annuler le processus d’ajout. Si le contrôle est ajouté avec succès, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartAdding` attribut le `<asp:webpartmanager>` élément sur une page Web, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> méthode pour personnaliser la gestion des événements.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> pour signaler qu'un contrôle a été supprimé d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement pour indiquer qu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou autre contrôle serveur ou utilisateur) a été fermé avec succès sur une page.  
  
 Pour fermer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle consiste à supprimer d’une page afin qu’il n’est pas rendu, et également du pour placer dans un spécial objet appelé un catalogue de pages. Un catalogue de pages, qui correspond à la <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôler, conserve les références à fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles pour chaque page. Si un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôle est déclaré sur une page dans un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, les utilisateurs peuvent faire basculer la page en mode d’affichage catalogue et ajouter à la page tous les contrôles précédemment fermés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> méthode permet aux développeurs de créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement. Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnWebPartClosed` attribut le `<asp:webpartmanager>` élément dans une page, puis en attribuant un nom de méthode personnalisé à l’attribut. Une tâche utile qu’un développeur peut exécuter dans cette méthode consiste à afficher un espace réservé à la place du contrôle fermé, avec une info-bulle qui informera les utilisateurs comment ajouter le contrôle à la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> qui se produit au cours du traitement d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou d'un contrôle serveur supprimé d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement pour indiquer qu’un contrôle est en cours de fermé ou supprimé d’une page. La méthode offre également la possibilité d’annuler le processus de fermeture. Si le contrôle est correctement supprimé de la page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartClosinging` attribut le `<asp:webpartmanager>` élément sur une page Web, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été supprimé définitivement d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> méthode est appelée pendant le processus de suppression d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou autre contrôle serveur qui est ajouté à un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone) à partir d’une page.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement en ajoutant le `OnWebPartDeleted` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> qui indique qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique (ou contrôle serveur ou utilisateur contenu dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />) est en cours de suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uniquement dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles peuvent être supprimés, et lorsqu’un contrôle est supprimé, l’instance de contrôle est supprimée définitivement d’une page et ne peut pas être restaurée. Dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sont ceux qui sont ajoutés par programmation ou à partir d’un catalogue de composants WebPart, par opposition aux contrôles statiques qui sont déclarés dans le balisage d’une page Web.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> événement pour indiquer qu’un contrôle est supprimé définitivement de sa zone. La méthode offre également la possibilité d’annuler le processus de suppression. Si le contrôle est correctement supprimé de la page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartDeleting` attribut le `<asp:webpartmanager>` élément sur une page Web, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été déplacé à un emplacement différent sur une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement à la fin de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> (méthode), ce qui garantit que le processus de déplacement d’un contrôle est terminé avant que tout code de l’événement s’exécute le gestionnaire.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement est déclenché lorsqu’un contrôle est déplacé dans sa zone actuelle, ou à une autre zone, et il n’a pas d’importance si le déplacement est effectué par programme ou à un utilisateur en faisant glisser le contrôle.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement en ajoutant le `OnWebPartMoved` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> qui indique qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou un contrôle serveur ou utilisateur dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> est en cours de déplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> événement qui se produit lorsqu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou autre contrôle serveur est déplacé dans sa zone ou vers une autre zone. La méthode offre également la possibilité d’annuler le processus de déplacement. Si le déplacement est terminé, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartMoving` attribut le `<asp:webpartmanager>` élément sur une page Web, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> méthode pour personnaliser la gestion des événements.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> qui se produit après qu'une connexion a été établie entre des contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> méthode déclenche son événement correspondant à la fin de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (méthode), ce qui garantit que les étapes nécessaires pour connecter les deux contrôles sont effectuées avant l’exécution de tout code dans le Gestionnaire d’événements.  
  
 La méthode fournit le contrôle par programmation sur le processus de création de connexions et l’événement associé est un point pratique auquel mettre à jour l’interface utilisateur (IU) ou pour avertir un utilisateur qu’une connexion a été établie.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement en ajoutant le `OnWebPartsConnected` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> qui se produit au cours du processus d'établissement d'une connexion entre deux <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur ou utilisateur contenus dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> événement qui se produit lorsque deux contrôles tentent d’établir une connexion. La méthode fournit la possibilité d’annuler la tentative de connexion. Si la connexion est établie, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartsConnecting` attribut le `<asp:webpartmanager>` élément sur une page Web, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> qui se produit après qu'une connexion entre contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a pris fin.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> méthode déclenche son événement correspondant à la fin de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> (méthode), qui exécute le processus d’arrêt d’une connexion entre deux contrôles.  
  
 La méthode fournit un contrôle par programmation sur le processus de clôture d’une connexion, afin que les développeurs puissent informer l’utilisateur, apporter des modifications à l’interface utilisateur (IU) ou apporter d’autres modifications à l’application.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement en ajoutant le `OnWebPartsDisconnected` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> qui indique que deux <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur ou utilisateur dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> sont en cours de clôture de connexion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> méthode déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement qui se produit lorsque deux contrôles mettent fin à une connexion. La méthode fournit la possibilité d’annuler le processus de déconnexion. Si la connexion est supprimée avec succès, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartsDisconnecting` attribut le `<asp:webpartmanager>` élément sur une page Web, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à un objet qui contient des données de personnalisation pour une page Web.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> qui contient des données de personnalisation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété fournit un moyen d’accéder à la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> objet qui est associé à une page via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. À l’aide de cette propriété, vous pouvez accéder les différents membres de l’objet de personnalisation. Par exemple, vous pouvez utiliser la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> méthode pour basculer la portée de personnalisation de la page à partir de partagé à la portée de l’utilisateur, ou vice versa. Découvrez la portée de personnalisation actuelle de la page, si la personnalisation est encore activée dans la page, le fournisseur utilisé pour les données de personnalisation et bien plus encore.  
  
 Notez que les données référencées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété est uniquement les données de personnalisation au niveau de la page qui sont suivies par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Les données de personnalisation spécifiques au contrôle, telles que les valeurs des propriétés personnalisables sur <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, est ne font pas partie de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété.  
  
> [!NOTE]
>  Pour plus d’informations sur la personnalisation des composants WebPart, consultez [Web Parts Personalization Overview](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété par programmation.  
  
 La page Web suivante permet à un utilisateur d’entrer en mode édition pour modifier certains aspects de la <xref:System.Web.UI.WebControls.Calendar> contrôle. Le **bascule étendue** bouton bascule de la page à l’utilisateur ou de la portée de personnalisation partagée. Le **Mode d’édition** et **Browse Mode** boutons font basculer la page dans le mode d’affichage approprié. Notez que dans le `<script>` balise section du fichier, deux des méthodes qui gèrent les événements utilisent le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété pour accéder aux membres utiles de l’objet sous-jacent. Plus précisément, ces méthodes utilisent le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> (méthode) et le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> propriété sur l’objet accédé via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 Pour l’exemple de code à exécuter, vous devez également activer un ou plusieurs utilisateurs à personnaliser des pages dans la portée partagée. Ajouter une entrée au fichier Web.config, dans la `<system.web>` section, qui ressemble à la balise suivante.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 Après le chargement de la page dans un navigateur, cliquez sur le **bascule étendue** bouton et notez que la page indique à présent la portée partagée. Cliquez sur **Mode d’édition** pour modifier le mode d’affichage, cliquez sur le menu d’actions verbales sur le contrôle visible, puis sélectionnez **modifier** à partir du menu. Notez que l’interface utilisateur (IU) pour les deux contrôles d’édition s’affiche. Maintenant, cliquez sur **Browse Mode** pour retourner à la navigation normale. Si la page indique qu’il est dans la portée partagée, cliquez sur **bascule étendue** à nouveau pour vous assurer de la page est dans la portée de l’utilisateur. Ensuite, suivez les mêmes étapes pour modifier le contrôle à nouveau, mais notez qu’à présent dans l’interface utilisateur, le <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> contrôle n’apparaît pas. C’est parce que ce contrôle fonctionne uniquement lorsque la page est dans la portée de personnalisation partagée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Autorise le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> à émettre un script côté client utilisé pour diverses fonctionnalités de personnalisation, telles que le glisser-déplacer de contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dans une page Web.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> qui reçoit le contenu du contrôle à écrire sur la page.</param>
        <summary>Substitué pour empêcher le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de rendre du contenu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre les données d'état du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de manière à ce que les données puissent être restaurées sur demande ultérieure à la page Web qui contient le contrôle.</summary>
        <returns>
          <see cref="T:System.Object" /> pour contenir les données d'état enregistrées du contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> méthode enregistre les données d’état pour les propriétés qui doivent être rendues persistantes des publications de pages, même lorsque le <xref:System.Web.UI.Control.EnableViewState%2A> est définie sur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> contenant les données d’état à charger.</param>
        <summary>Enregistre les données d'état de personnalisation personnalisées conservées dans le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, de manière à ce que ces données puissent être rechargées à chaque fois que la page est rechargée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> méthode est critique en cours de personnalisation, car elle permet des paramètres utilisateur personnalisés à stocker pour les futures sessions de navigateur et visites à une page. La méthode enregistre les données d’état de personnalisation, qui inclut des éléments tels que les éléments suivants : dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> ou qui ont été ajoutés à une page ou supprimés à partir d’une page ; les contrôles qui ont été déplacés sur une page ; et les connexions dynamiques qui ont des contrôles de serveur créé ou supprimé.  
  
 Vous ne pouvez pas appeler cette méthode directement à partir de votre code. Toutefois, vous pouvez appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> (méthode), qui elle-même appelle cette méthode pour enregistrer les données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Les développeurs peuvent substituer cette méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe pour personnaliser le processus d’enregistrement des données de personnalisation.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou un autre contrôle serveur actuellement sélectionné pour modifier ou pour créer une connexion avec un autre contrôle.</summary>
        <value>Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> actuellement sélectionné pour modifier ou former une connexion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété retourne une référence à un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou un autre contrôle serveur qui est sélectionné pour la modification ou de création d’une connexion avec un autre contrôle.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle fournit plusieurs méthodes et événements utiles pour gérer le processus de sélection d’un contrôle. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement se produit juste après qu’un contrôle est sélectionné, mais avant que des modifications sont apportées. Pour exécuter des actions sur le contrôle qu’elle est sélectionnée, substituez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> (méthode). Par exemple, vous pouvez modifier l’apparence d’un contrôle qui est sélectionné mais n’a pas encore modifié pour souligner visuellement le contrôle sélectionné.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> événement se produit juste après le contrôle sélectionné a été modifié. Pour exécuter des actions sur le contrôle lorsqu’il a modifié, substituez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que la sélection d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été modifiée et déplacée vers un autre contrôle d'une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement peut être utilisé conjointement avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode pour modifier l’interface utilisateur (IU) d’un contrôle sélectionné. Par exemple, si l’utilisateur bascule la page en mode création (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>), puis sélectionne un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle avec l’intention du faire glisser vers un nouvel emplacement, il est courant pour modifier le rendu du contrôle sélectionné, par exemple en modifiant la couleur de son bordure ou en arrière-plan lorsqu’il est sélectionné.  
  
> [!NOTE]
>  Pour plus d’informations sur l’utilisation des événements, consultez [Comment : consommer des événements dans une Application Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de modification du <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur actuellement sélectionné sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement peut être utilisé conjointement avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> (méthode). Les développeurs de pages peuvent créer un gestionnaire d’événements dans leur code en ajoutant le `OnSelectedWebPartChanging` attribut le `<asp:webpartmanager>` élément dans une page et la définition de la valeur de l’attribut sur le nom d’une méthode personnalisée qui gérera l’événement.  
  
 Cet événement est déclenché pendant le processus de début ou de fin d’une connexion entre les contrôles et lorsque le début et de fin d’une modification d’un contrôle. Pour plus d’informations, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> (méthode).  
  
 Normalement, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement est déclenché en conséquence directe d’action d’un utilisateur qui modifie le contrôle sélectionné, l’événement peut être annulé. Toutefois, il est un scénario dans lequel l’événement ne peut pas être annulée. Si un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> contrôle est supprimé, le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qu’il contient doivent tous être fermés, sinon ils sont orphelins. Dans ce cas le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ferme le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, pas l’utilisateur et il doivent déterminer quel contrôle est actuellement sélectionné et modification de la sélection sans risque d’interruption, afin qu’il peut terminer le processus de nettoyage tous les contrôles. Par conséquent, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> méthode ne peut pas être annulée dans ce scénario. Pour un événement associé qui peut être annulé, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit un indicateur qui signale que les données de personnalisation personnalisées du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ont été modifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> méthode définit un indicateur via lequel les composants de personnalisation dans le WebPart configuré pour enregistrer les données de personnalisation mises à jour. Pour plus d’informations sur les scénarios qui peuvent entraîner des modifications dans les données de personnalisation suivies par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> du contrôle, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> méthode ne peut pas être appelée directement depuis votre code et ne peut pas être substitué, car elle est utilisée en interne par le contrôle WebPart défini dans le cadre de la fonctionnalité de personnalisation des composants WebPart.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La méthode peut être appelée par une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe. Il serait utile si vous souhaitez personnaliser les composants du contrôle WebPart définie et doivent à contrôler le processus de définition d’indicateurs pour les données de personnalisation de personnalisation.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur qui a été sélectionné.</param>
        <summary>Définit la valeur de propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> égale au <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> actuellement sélectionné ou au contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> méthode est appelée pendant les processus de début ou de fin de modification du contrôle spécifié par le `webPart` paramètre et celles qui commencer ou se terminer à une connexion qui inclut `webPart`.  
  
 Au début des processus de modification et de connexion, `webPart` est le contrôle qui a été sélectionné pour être modifié ou pour entrer une connexion.  
  
 À la fin des processus de modification et de connexion, `null` est passé à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> (méthode), ce qui entraîne le contrôle actuellement sélectionné n’est plus sélectionné.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une chaîne vide ("") de manière à ce qu'aucune apparence ne puisse être appliquée au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Chaîne vide qui empêche le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> d'avoir une apparence assignée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> héritées de substitutions de propriété <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> propriété pour empêcher le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle, qui est un contrôle invisible, à partir de l’utilisation d’enveloppes. L’implémentation de la propriété empêche une apparence d’être assignée en retournant toujours une chaîne vide à partir de la `get` accesseur et toujours en levant une exception si une tentative de définir une valeur dans la `set` accesseur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Une tentative de définition de la valeur de propriété a été effectuée.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la collection de tous les objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> d'une page Web définis comme des connexions statiques.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> qui contient toutes les connexions statiques de la page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété est utilisée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour suivre et gérer toutes les connexions statiques sur une page. Une connexion statique, contrairement à une connexion dynamique, n’a pas besoin être ajouté à une page chaque fois que la page est rendue.  
  
 La collection référencée par cette propriété contient toutes les connexions statiques qui existent sur la page, si elles sont créées par programme ou spécifiés avec un `<asp:webpartconnection>` élément dans le balisage de la page.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Une explication du fonctionne de l’exemple dans un navigateur.  
  
 Le code suivant contient uniquement la partie de la page Web de l’exemple. Vous devrez également obtenir les deux premières parties de l’exemple - le contrôle utilisateur personnalisé et le code source pour les contrôles personnalisés et l’interface--à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Cette rubrique décrit également vos options de compilation la <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
 La troisième partie de l’exemple de code est la page Web. Le balisage déclaratif pour la page contient `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si une connexion existe déjà et, dans le cas contraire, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble de connexions statiques référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** contrôle de liste déroulante, puis sélectionnez **connexion** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. En mode connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** pour activer son menu de verbes de contrôle, puis cliquez sur **connexion**. Une fois que l’interface utilisateur de connexion (UI) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode). Si vous retournez à cette page dans une session de navigateur ultérieure, cette connexion statique sera déjà établie et n’avez pas besoin être recréée à chaque fois que la page se charge.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection en lecture seule de tous les modes d'affichage disponibles sur une page Web particulière.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> qui contient l'ensemble des objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> disponibles sur une page Web spécifique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété contient uniquement les modes d’affichage disponibles sur une page, compte tenue des types de contrôles de zone présents sur la page.  
  
> [!NOTE]
>  Modes d’affichage peuvent être désactivés, et quand un mode d’affichage est désactivé, il n’est pas ajouté à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> collection, même lorsque le type de zone qui prend en charge ce mode d’affichage correspondant est présent sur la page.  
  
 Mode de navigation et en mode création sont toujours pris en charge. Les modes d’affichage qui peuvent varier sont la modifier, catalogue et modes de connexion. Chacun de ces modes d’affichage est associé à un type particulier de <xref:System.Web.UI.WebControls.WebParts.ToolZone> contrôle. C’est la présence de cette zone spécialement typée sur une page Web qui provoque un mode d’affichage particulier à ajouter à la collection référencée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété. Par exemple, si une page Web contient un <xref:System.Web.UI.WebControls.WebParts.EditorZone> mais pas de zone une <xref:System.Web.UI.WebControls.WebParts.CatalogZone> de zone, le mode d’affichage édition est un des modes pris en charge sur cette page, mais le mode d’affichage catalogue n’est pas pris en charge.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> diffère de la propriété du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriété, qui fait référence à une collection contenant tous les modes d’affichage qui sont disponibles pour actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, même ceux qui ne sont pas pris en charge sur une page particulière.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programmation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété. Le code utilise cette propriété pour remplir la liste avec uniquement les modes d’affichage disponibles dans la page Web actuelle.  
  
 Il existe trois pris en charge les modes d’affichage sur cette page : navigation, design et modifier. Les deux premiers sont toujours disponibles et le mode édition est disponible dans cet exemple de code, car la page contient un <xref:System.Web.UI.WebControls.WebParts.EditorZone> contrôle. Le catalogue et connectez-vous affichage modes ne sont pas affichés, car leurs zones correspondantes ne sont pas sur cette page.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, vous pouvez utiliser le contrôle de liste déroulante pour basculer la page en mode de navigation en mode Création, puis en mode édition. En mode édition, cliquez sur le menu des verbes de la liste déroulante dans l’en-tête de l’un des contrôles serveur, puis sélectionnez **modifier** pour modifier le contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les données d'état de personnalisation personnalisées gérées par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ont été modifiées sur une page Web.</summary>
        <value>Valeur Boolean qui indique si les données d'état de personnalisation ont été modifiées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété offre un moyen aux appelants de déterminer si les données qui sont gérées par l’état personnalisation la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a changé. Lorsque les utilisateurs personnalisent les détails au niveau de la page, par exemple en modifiant la mise en page, la création ou la suppression des connexions et ajout ou suppression de contrôles, les données de personnalisation gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle change. Il s’agit d’une méthode directe qui retourne aux appelants la valeur de la méthode protégée <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> propriété, qui ne sont pas accessibles directement par les appelants.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété n’indique pas si les valeurs de propriété personnalisables ou les propriétés individuelles qui affectent l’apparence de personne <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, ont été modifiés. La personnalisation au niveau du contrôle suivi est effectuée pour chaque contrôle individuellement. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété indique uniquement si les données de personnalisation qui est au niveau de la page et est géré par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a changé.  
  
 La liste suivante décrit quelques instances courantes de personnalisation qui provoquerait le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> pour retourner une valeur de propriété `true`, qui indique qui le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle possède des données de personnalisation modifiées :  
  
-   Fermeture statique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou un contrôle serveur ou utilisateur) sur une page.  
  
-   Restauration statique fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à partir d’un catalogue de la page à une page.  
  
-   Déplacement de n’importe quel contrôle dans sa zone ou vers une autre zone.  
  
-   Ajout d’un contrôle dans un catalogue de <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôles de serveur, ou ajout d’un contrôle par programmation.  
  
-   Création d’une connexion entre deux <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, soit par programme ou à l’aide de l’interface utilisateur de connexion (IU).  
  
-   Suppression d’une connexion entre deux <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, soit par programme ou à l’aide de l’interface utilisateur de connexion.  
  
 Pour accéder à cette valeur de propriété, vous devez effectuer un cast le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance de contrôle à la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interface ; vous pouvez ensuite lire le <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> valeur de propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre une utilisation simple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> instances de la propriété, pour indiquer une personnalisation de page courantes qui entraînent une <xref:System.Web.UI.WebControls.WebParts.WebPartManager> des données de personnalisation du contrôle à modifier.  
  
 L’exemple de code de quatre parties :  
  
-   Un contrôle utilisateur qui vous permet de modifier les modes d’affichage sur une page qui contient des contrôles WebPart.  
  
-   Un fichier source qui contient le code personnalisé de deux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés et une interface.  
  
-   Une page Web qui héberge tous les contrôles.  
  
-   Une explication du fonctionne de l’exemple de code.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : modification des Modes d’affichage sur une Page WebPart](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple est le fichier source avec les contrôles personnalisés et l’interface. Notez que la `IZipCode` interface expose une méthode, et que cette méthode comme étant implémentées dans personnalisé `ZipCodeWebPart` contrôle sert de méthode de rappel pour activer `ZipCodeWebPart` d’agir comme un fournisseur dans un scénario de connexion. L’autre contrôle, `WeatherWebPart`, dans une connexion de contrôle agit comme le consommateur ; il peut consommer l’interface particulière fournie par `ZipCodeWebPart`. Dans une application réelle, `WeatherWebPart` peut consommer une valeur de Code postal personnalisée à partir du fournisseur, puis fournir des informations météo graphiques aux utilisateurs.  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise la compilation dynamique ; Par conséquent, notez que le `Register` directive pour ce composant en haut de la page Web contienne uniquement `TagPrefix` et `Namespace` attributs sans un `Assembly` attribut. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : développement et à l’aide d’un contrôle de serveur Web personnalisé](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 La troisième partie de l’exemple de code est la page Web. Notez qu’il contient deux <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zones, par la première contenant les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. Il existe également un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone qui contient une norme <xref:System.Web.UI.WebControls.Calendar> contrôle que les utilisateurs peuvent ajouter à la page. Le `<asp:connectionszone>` élément fournit une interface utilisateur pour créer des connexions entre les contrôles de connexion. Dans le `Page_PreRender` méthode, notez qu’il vérifie si les données de personnalisation a changé et, si tel est le cas, met à jour le texte de `Label1`.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 Après le chargement de la page dans un navigateur, essayez de créer des scénarios répertoriés dans la section Notes de cette rubrique qui modifiera les données de personnalisation. Lorsque vous apportez des modifications différentes, lorsqu’une modification implique un des scénarios de personnalisation suivis par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, le texte de la `Label1` contrôle s’affiche pour indiquer que les données de personnalisation a été modifiée. Par exemple, vous pouvez :  
  
-   Créer une connexion entre les contrôles en cliquant sur le **connecter les contrôles WebPart** bouton.  
  
-   Utilisez le **Mode d’affichage** contrôle de liste déroulante pour basculer la page en mode catalogue et ajouter la **mon calendrier** contrôle à la seconde <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone.  
  
-   Modification de la page pour le mode de navigation, cliquez sur le menu d’actions verbales (symbolisé par une flèche dans la barre de titre) pour le **mon calendrier** contrôler, puis sélectionnez **fermer** pour fermer et l’ajouter au catalogue de pages.  
  
-   Retourner la page en mode catalogue et ajouter la **mon calendrier** le contrôle à la page.  
  
-   Utilisez le **Mode d’affichage** contrôler pour basculer la page en mode design et réorganisez la disposition des contrôles en faisant glisser un ou plusieurs d'entre eux vers une autre zone ou à un autre emplacement dans la même zone.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> contenant les données d’état à charger.</param>
        <summary>Retourne les données d’état de personnalisation précédemment enregistrées à charger dans le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une implémentation de la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> (méthode), qui offre un moyen pour le WebPart défini pour accéder directement à la méthode protégée <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> (méthode). Lorsque cette méthode est appelée, elle stocke les données de personnalisation personnalisées qui sont gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et qui a été précédemment enregistré dans le magasin de données permanentes pour une utilisation ultérieure dans le processus d’initialisation.  
  
> [!NOTE]
>  Dans la plupart des cas, le code de développeur de page et le contrôle n’a pas besoin d’appeler cette méthode, car elle est principalement utilisée par le contrôles WebPart définir en tant que mécanisme de récupération des données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Un scénario dans lequel les développeurs utilise cette méthode pour développer une infrastructure de personnalisation personnalisée à utiliser à la place de celui fourni par le jeu de composants WebPart. Dans ce cas, les développeurs puissent hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe et substituer les <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> méthode pour retourner une implémentation personnalisée d’un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet. Personnalisé <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet appellerait l’implémentation de la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> méthode au moment approprié pour charger des données de personnalisation.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> qui contient les données d'état à enregistrer.</param>
        <summary>Enregistre les données d'état de personnalisation personnalisées qui sont gérées par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> méthode est une implémentation de la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> (méthode), qui offre un moyen pour le WebPart défini pour accéder directement à la méthode protégée <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> (méthode). Lorsque cette méthode est appelée, elle enregistre toutes les données personnalisées qui sont gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle dans le magasin de données permanentes configuré pour une application WebPart.  
  
> [!NOTE]
>  Dans la plupart des cas, le code de développeur de page et le contrôle n’a pas besoin d’appeler cette méthode, car elle est principalement utilisée par le contrôles WebPart définir en tant que mécanisme d’enregistrement des données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Un scénario dans lequel les développeurs utiliseraient avec cette méthode pour développer une infrastructure de personnalisation personnalisée à utiliser à la place de celui fourni par le jeu de composants WebPart. Dans ce cas, les développeurs puissent hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe et substituer les <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> méthode pour retourner une implémentation personnalisée d’un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet. Personnalisé <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet appellerait l’implémentation de la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> méthode au moment approprié pour enregistrer les données de personnalisation.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Applique les données d'état de personnalisation au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> et appelle la méthode de base pour activer le suivi des modifications apportées aux données d'état d'affichage du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les modifications apportées aux données d’état d’affichage sont stockées dans un <xref:System.Web.UI.StateBag> de l’objet et sont accessibles par le biais du contrôle <xref:System.Web.UI.Control.ViewState%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui permet aux contrôles enfants d'être visibles.</summary>
        <value>Valeur booléenne indiquant si un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> et ses contrôles enfants sont visibles. <see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control remplace la base de <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> retournent toujours une valeur de propriété `true` pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriété. Bien que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle lui-même n’est pas visible, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriété doit être définie sur `true` afin que tous ses contrôles enfants sont visibles par défaut.  
  
 Si vous essayez de définir la valeur de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriété, il génère toujours une erreur car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a remplacé le comportement de la propriété de base et empêche de lui assigner une valeur à la propriété.  
  
 Cette propriété n’est pas pouvant être liée dans les concepteurs visuels, mais peut être liée à l’exécution. Pour plus d'informations, consultez <xref:System.ComponentModel.BindableAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Une tentative d'assignation d'une valeur à la propriété a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique ou autre contrôle serveur a été ajouté à une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, pour indiquer que le contrôle a été ajouté avec succès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement est utile pour indiquer qu’un contrôle dynamique (contrôle ajouté par programme, par opposition à la déclaré dans le balisage de page) a été ajouté à une zone. Conjointement avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> méthode, l’événement fournit aux développeurs un moyen de mettre à jour de l’interface utilisateur (IU) ou de notifier les utilisateurs qu’un contrôle a été ajouté.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit pendant le processus d'ajout d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique ou d'un autre contrôle serveur à une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> événement est déclenché par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> méthode une fois le processus d’ajout d’un contrôle à une zone a commencé. Cet événement offre la possibilité d’annuler le processus avant la fin. Si le processus d’ajout est réussi, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement.  
  
 Les développeurs de pages peuvent fournir des gestionnaires personnalisés pour l’événement en ajoutant le `OnWebPartAdding` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou un contrôle serveur ou utilisateur) est supprimé d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement indique qu’un contrôle a été correctement fermé, soit par un utilisateur ou par programme. Pour fermer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle consiste à supprimer d’une page afin qu’il n’est pas rendu, et également du pour placer dans un spécial objet appelé un catalogue de pages. Un catalogue de pages, qui correspond à la <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôler, conserve les références à fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles pour chaque page. Si un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôle est déclaré sur une page dans un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, les utilisateurs peuvent faire basculer une page en mode d’affichage catalogue et ajouter à une page de contrôles précédemment fermés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> (méthode), qui déclenche l’événement et lui fournit un gestionnaire.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnWebPartClosed` attribut le `<asp:webpartmanager>` élément dans une page, puis en attribuant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de suppression d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou d'un contrôle serveur ou utilisateur) d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> méthode lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle est en cours de fermeture d’un contrôle. Si la suppression du contrôle est réussie, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartClosed` d’attribut pour le <`asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 Normalement, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement est déclenché en conséquence directe d’une fermeture de l’utilisateur un <xref:System.Web.UI.WebControls.WebParts.WebPart> (contrôle), l’événement peut être annulé. Toutefois, il est un scénario dans lequel l’événement ne peut pas être annulée. Si un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> contrôle est supprimé, le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qu’il contient doivent tous être fermés, sinon ils sont orphelins. Dans ce cas le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ferme le <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, pas l’utilisateur. Et à quel moment le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle est en cours de l’appel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode pour fermer chaque contrôle et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement est déclenché, l’événement ne peut pas être annulée (par conception), car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> doit terminer la tâche de nettoyage tous les contrôles zone.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur a été supprimé d'une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement est utile pour indiquer qu’un contrôle dynamique (contrôle ajouté par programme, par opposition à la déclaré dans le balisage de page) a été supprimé d’une zone. Conjointement avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> méthode, l’événement fournit aux développeurs un moyen de mettre à jour de l’interface utilisateur (IU) ou de notifier les utilisateurs qu’un contrôle a été supprimé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de suppression définitive d'une instance d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique ou d'un autre contrôle serveur d'une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> événement est déclenché par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> méthode, au cours du processus de suppression d’un contrôle dynamique (qui a été ajouté par programme ou par un utilisateur via l’interface utilisateur de composants WebPart). L’événement offre la possibilité d’annuler le processus avant la fin. Si le processus de suppression est terminé avec succès, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement.  
  
 Les développeurs de pages peuvent fournir des gestionnaires personnalisés pour l’événement en ajoutant le `OnWebPartDeleting` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur a été déplacé vers un emplacement différent sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement s’applique à la fois statique (déclaré dans le balisage d’une page Web) et des contrôles dynamiques. Il est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> (méthode). Étant donné que l’événement est déclenché après un déplacement, les développeurs peuvent inclure un gestionnaire d’événements pour fournir une notification aux utilisateurs, une validation ou d’autres actions. Pour ajouter un gestionnaire d’événements, vous pouvez ajouter un `OnWebPartMoved` attribut le `<asp:webpartmanager>` élément dans une page et assigner le nom d’une méthode personnalisée à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de déplacement d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou d'un autre contrôle serveur contenu dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> événement est déclenché quand un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou un autre contrôle serveur est déplacé dans sa propre zone ou vers une autre zone. Cela peut se produire lorsqu’un utilisateur fait glisser un contrôle, et lorsqu’il existe un déplacement par programmation.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> (méthode) et il fournit la possibilité d’annuler le processus de déplacement avant la fin. Si le déplacement est terminé et que le contrôle soit placé dans une nouvelle position, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartMoving` attribut le `<asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à tous les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> suivis par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> d'une page Web.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> qui contient des références à un jeu de composants <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété est utilisée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour effectuer le suivi de tous les <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui sont contenus dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones sur la page. Bien que la collection est en lecture seule, vous pouvez accéder à des <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles par programmation via les collection et apporter des modifications à ceux-ci.  
  
> [!NOTE]
>  Il est possible d’avoir un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle placé sur une page en dehors d’un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone, ce qui entraîne le contrôle ne pas suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler ou référencés dans son <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> collection. Toutefois, il est recommandé d’utiliser un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle en dehors d’une zone, car il perd ses fonctionnalités WebPart et agit comme un contrôle du fonctionnement normal du serveur.  
  
 Tout type de contrôle qui peut être placé dans une zone, si une personnalisée <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, un contrôle ASP.NET standard, un contrôle utilisateur ou un contrôle serveur personnalisé, peut être traité comme un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle au moment de l’exécution. Lorsqu’un contrôle qui n’est pas un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est placé dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone, en cours d’exécution ASP.NET encapsule le contrôle avec une <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet, afin que le contrôle peut se comporter comme un véritable <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Par conséquent, à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle peut effectuer le suivi de n’importe quel type de contrôle de serveur, indépendamment de si elle est dérivée de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété par programmation à accès individuel <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. Notez que dans le balisage déclaratif de la page Web, dans le `<asp:webpartzone>` élément il sont deux des contrôles serveur ASP.NET standard. Bien que ceux-ci n’héritent pas de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe, car elles sont dans une zone, ils sont encapsulés dans un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet en cours d’exécution et donc être inclus dans la collection référencée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété. Vous pouvez également ajouter personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, des contrôles utilisateur ou serveur personnalisé des contrôles dans cette zone, et ils seraient gérés de la même façon.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 Notez que pour l’exemple de code fonctionne, vous devez ajouter un paramètre dans le fichier Web.config pour permettre l’exportation des fichiers de description du WebPart. Assurez-vous que vous disposez d’un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il existe un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Après avoir chargé la page dans un navigateur, si vous cliquez sur le **nombre de WebPart** bouton, le code utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété pour retourner le nombre de contrôles dans la collection. Si vous cliquez sur le **masquer le titre du calendrier** bouton, le code modifie le calendrier afin qu’elle s’affiche avec seulement une bordure et non un titre.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'une connexion spécifique a été établie entre des contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou contrôles serveur ou utilisateur).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> (méthode). L’événement est utile car une fois que vous savez qu’une connexion est terminée, vous pouvez informer l’utilisateur du fait, ou même de modifier l’interface utilisateur (IU) de la page. Par exemple, vous souhaiterez peut-être afficher une image graphique qui suggère une connexion réussie entre les deux contrôles, ou afficher un bref message et modifiez le mode d’affichage de page en vue de mode de navigation.  
  
 Les développeurs de pages peuvent associer un gestionnaire d’événements personnalisé à cet événement en ajoutant le `OnWebPartsConnected` attribut le `<asp:webpartmanager>` élément dans la page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de création d'une connexion entre les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou les contrôles serveur ou utilisateur placés dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> (méthode), et il signale que le processus de connexion a commencé (par exemple, un utilisateur a sélectionné un contrôle et cliqué sur un verbe connect), mais n’est ne pas encore terminée. L’événement offre la possibilité d’annuler une connexion avant la fin. Si la connexion est effectuée avec succès, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartsConnecting` attribut le `<asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'il a été mis fin à une connexion entre deux <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> (méthode). L’événement est utile car une fois que vous savez qu’une connexion est interrompue, vous pouvez informer l’utilisateur, effectuer des actions de nettoyage dans le code ou apporter d’autres modifications dans l’interface utilisateur (IU).  
  
 Les développeurs de pages peuvent associer un gestionnaire d’événements personnalisé à cet événement en ajoutant le `OnWebPartsDisConnected` attribut le `<asp:webpartmanager>` élément dans la page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de clôture de connexion entre des <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur précédemment connectés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> (méthode) et il signale le fait qu’un utilisateur a cliqué sur un verbe disconnect ou <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode a été appelée autrement. L’événement offre la possibilité d’annuler le processus de clôture d’une connexion avant la fin. Si la connexion est terminée avec succès, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartsDisconnecting` attribut le `<asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 Normalement, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement est déclenché en conséquence directe d’action d’un utilisateur qui se termine par une connexion, l’événement peut être annulé. Toutefois, il existe plusieurs scénarios dans lesquels l’événement ne peut pas être annulée. Le premier scénario est, si un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> contrôle est supprimé, le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qu’il contient doivent tous être fermés, sinon ils sont orphelins. Dans ce cas le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ferme le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, pas l’utilisateur et il doivent également être en mesure de terminer les connexions de tous les contrôles connectés sans risque d’interruption, afin qu’il peut terminer le processus de nettoyage et de fermeture tous les contrôles. Par conséquent, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> méthode ne peut pas être annulée dans ce scénario. Pour un événement associé qui peut être annulé, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement.  
  
 Le deuxième scénario dans lequel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement ne peut pas être annulé lorsque la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée (appelée pendant chaque demande à une page, par exemple), et il existe un type de conflit dans les connexions existantes sur une page. Par exemple, un utilisateur connecte le contrôle x au contrôle y, mais un utilisateur partagé connecte le contrôle x au contrôle z et encore contrôle x n’est pas autorisé à former plusieurs connexions. Dans ce cas, les paramètres de l’utilisateur pour la connexion sont prioritaires et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle résout le conflit en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> de méthode et de fin de la connexion entre x et z pour l’utilisateur particulier. Étant donné que cette déconnexion est essentielle à la résolution de conflit, par conception le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement ne peut pas être annulé dans ce scénario.  
  
 Le troisième scénario dans lequel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> méthode ne peut pas être annulée est quand un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur qui est actuellement connecté est supprimée ou fermé. Étant donné que le contrôle définitivement va être supprimé de la page, il est logique de supprimer sa connexion. Par conséquent, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> (méthode), qui à son tour déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement, par conception, il est sans risque de l’annulation de l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à une collection de toutes les zones <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> d'une page Web.</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> qui référence un jeu de zones <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété est utilisée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle à suivre le <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones sur une page Web. Notez que la propriété ne fait pas référence à tous les types de zones ; Il fait référence uniquement les zones qui dérivent de la <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> classe, y compris <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zones.  
  
 Bien que la collection référencée par la propriété est en lecture seule, vous pouvez l’utiliser pour accéder à des objets individuels dans la collection et de les manipuler par programme.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété par programmation à accès individuel <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> contrôles de zone. Notez que dans le balisage déclaratif de la page Web, il existe deux `<asp:webpartzone>` éléments, chacun contenant un contrôle serveur. Dans le `<script>` section de la page, le code utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété pour accéder aux zones individuelles, en répertoriant tous les ID de zone et en modifiant la couleur d’arrière-plan de la deuxième zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 Notez que pour l’exemple de code fonctionne, vous devez ajouter un paramètre dans le fichier Web.config pour permettre l’exportation des fichiers de description du WebPart. Assurez-vous que vous disposez d’un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il existe un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Après avoir chargé la page dans un navigateur, si vous cliquez sur le **ID de Zone de liste** bouton, le code utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété pour répertorier les ID de toutes les zones dans la collection. Si vous cliquez sur le **BackColor de Zone de modification** bouton, le code modifie la couleur d’arrière-plan de la deuxième zone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>