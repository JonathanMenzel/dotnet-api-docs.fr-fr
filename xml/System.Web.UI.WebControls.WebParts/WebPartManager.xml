<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9ef4b57b0bb8fb17e12fcf418dcacd9c65bb22b7" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395511" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Sert de classe centrale du jeu de composants webPart en gérant l’ensemble des contrôles, fonctionnalités et événements webPart qui se produisent sur une page web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle agit comme centre hub ou un contrôle d’une application WebPart. Il doit y avoir un seul--et unique--<xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance de contrôle sur chaque page qui utilise des contrôles WebPart. Comme avec la plupart des aspects des applications WebPart, les <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle fonctionne uniquement avec les utilisateurs authentifiés. En outre, ses fonctionnalités fonctionnent presque entièrement avec des contrôles serveur qui résident dans les zones WebPart qui héritent de la <xref:System.Web.UI.WebControls.WebParts.WebZone> classe. Les contrôles serveur qui résident sur une page en dehors de ces zones peuvent avoir très peu de fonctionnalités WebPart ou d’interaction avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 En tant que le hub pour les fonctionnalités WebPart sur une page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle exécute les types de tâches décrites dans le tableau suivant.  
  
|Catégorie de tâche|Ce que fait le contrôle|  
|-------------------|---------------------------|  
|Suivi des contrôles WebPart|Effectue le suivi de la grande diversité de contrôles sur une page qui fournissent des fonctionnalités de Web Parts, y compris <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, les connexions, les zones et autres utilisateurs.|  
|Ajout et suppression de contrôles WebPart|Fournit les méthodes pour l’ajout, la suppression et la fermeture <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sur une page.|  
|Administration des connexions|Crée des connexions entre les contrôles et surveille les connexions, ainsi que les processus d’ajout et de les supprimer.|  
|Personnalisation des contrôles et pages|Permet aux utilisateurs de déplacer les contrôles vers différents emplacements sur une page et lance les vues dans lequel les utilisateurs peuvent modifier l’apparence, propriétés et le comportement des contrôles. Conserve les paramètres de personnalisation spécifiques à l’utilisateur sur chaque page.|  
|Bascule entre les différents affichages de page|Bascule une page entre les différentes vues spécialisées de la page, afin que les utilisateurs puissent exécuter certaines tâches telles que la mise en page de modification ou de contrôles d’édition.|  
|Déclenchement d’événements de cycle de vie de composants WebPart|Définit, déclenche et permet aux développeurs de gérer les événements de cycle de vie de contrôles WebPart, telles que lorsque les contrôles sont ajoutés, déplacés, connectés ou supprimés.|  
|L’activation de l’importation et exportation de contrôles|Exporte le flux XML qui contiennent l’état des propriétés de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, et permet aux utilisateurs d’importer les fichiers pour faciliter la personnalisation des contrôles complexes dans d’autres pages ou les sites.|  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe a un grand ensemble de propriétés. Cohérente avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> rôle de suivi d’autres contrôles, il a un nombre de propriétés qui référencent des collections de contrôles WebPart ou d’autres objets WebPart spéciaux. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriétés sont toutes les collections utilisées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour son suivi et d’autres tâches de gestion.  
  
 Un autre groupe de propriétés contient des avertissements personnalisables qui s’appliquent dans certains scénarios qui se produisent dans une application WebPart. Ceux-ci incluent le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriétés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe substitue certaines propriétés de base héritées, qui sont utilisées par nombreux contrôles serveur Web. Ceux-ci incluent le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriétés.  
  
 Enfin, un groupe de propriétés est utile pour accéder à l’état actuel de l’application. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété indique le mode d’affichage actuel figurant dans une page. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> propriété indique si un contrôle est autorisé à restituer le script côté client, qui est pertinent dans les situations dans lesquelles les utilisateurs peuvent avoir des navigateurs avec des fonctionnalités différentes ou avoir désactivé les scripts. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété est utile pour faire référence à une classe utilitaire qui contient les appels à un nombre de méthodes Web Parts importantes qui sont utilisés pour les cas d’extensibilité. En masquant les appels à ces méthodes dans une classe distincte (le <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe), le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> API de la classe est simplifiée. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété fournit l’accès aux objets de personnalisation qui stockent les paramètres de personnalisation des utilisateurs et de conserver ces données dans un stockage permanent. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété indique quelle <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle sur une page est actuellement sélectionnée par l’utilisateur ou l’application. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété indique si les données de personnalisation personnalisées sur un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle a changé.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle contient cinq modes d’affichage intégrés ou des vues d’une page Web. Les développeurs peuvent étendre cette fonctionnalité en créant des modes d’affichage personnalisé en étendant les types tels que le <xref:System.Web.UI.WebControls.WebParts.WebZone> classe ou la <xref:System.Web.UI.WebControls.WebParts.ToolZone> classe. Les utilisateurs peuvent basculer une page dans les différents modes d’affichage, condition que le type approprié de contrôles qui correspondent à un mode d’affichage donné sont présentes sur une page.  
  
> [!NOTE]
>  Il est possible d’étendre cette fonctionnalité afin que les utilisateurs peuvent basculer dans un mode d’affichage personnalisé sans avoir de zone correspondante sur la page. Toutefois, le comportement par défaut est que les modes d’affichage correspondent aux zones.  
  
 Les modes d’affichage standard sont représentés par les champs publics dans la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. Le tableau suivant résume les champs et les modes d’affichage à qu'ils font référence. Le mode d’affichage actuel d’une page, comme indiqué plus haut, est toujours référencé dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété et le jeu de modes d’affichage possible sur une page particulière, compte tenue du type de zones qui sont présents dans la page, est contenue dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
|Champ|Affichage des détails de mode|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|La vue de l’utilisateur normal d’une page Web ; mode d’affichage la valeur par défaut et les plus courantes.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|La vue dans laquelle les utilisateurs peuvent réorganiser ou supprimer des contrôles pour modifier la mise en page.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|Affichage dans lequel une interface utilisateur (IU) de modification devient visible ; les utilisateurs peuvent modifier l’apparence, propriétés et le comportement des contrôles qui sont visibles dans le mode de navigation normal.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|Affichage dans lequel un interface utilisateur du catalogue devient visible ; les utilisateurs peuvent ajouter des contrôles à une page à partir des catalogues de contrôles disponibles.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|Affichage dans lequel une interface utilisateur de connexion devient visible ; les utilisateurs peuvent se connecter, gérer ou déconnecter les connexions entre les contrôles.|  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle contient également un nombre d’événements critiques dans le cycle de vie des pages de composants WebPart et des contrôles. Ces événements fournissent un contrôle par programmation précis sur le comportement de contrôles WebPart. La plupart des méthodes se rapportent directement à <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles (ou d’autres contrôles serveur ou utilisateur placés dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> afin qu’ils peuvent se comportent comme des zones <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles). Toutefois, quelques événements se rapportent à l’état de la page ou les connexions sur la page. Le tableau suivant répertorie les événements disponibles et résume leurs fonctions.  
  
> [!NOTE]
>  Dans tous les cas dans le tableau suivant, le mot « contrôle » fait référence à un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle ou n’importe quel contrôle serveur qui réside dans une zone et qui est encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet en cours d’exécution.  
  
|événement|Description |  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|Se produit juste avant un contrôle est ajouté à une page pour vérifier qu’il est autorisé.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|Se produit une fois que toutes les connexions sur une page ont été activées.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|Se produit juste avant le processus d’activation de toutes les connexions sur une page.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|Se produit une fois que le mode d’affichage actuel d’une page a changé.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|Se produit juste avant le processus de changement de mode d’affichage d’une page.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|Se produit après que la sélection d’un contrôle a été annulée.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|Se produit juste avant le processus d’annulation de la sélection d’un contrôle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|Se produit après qu’un contrôle a été ajouté à une zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|Se produit juste avant le processus d’ajout d’un contrôle à une zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|Se produit après qu’un contrôle a été fermé (supprimé d’une page).|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|Se produit juste avant le processus de fermeture d’un contrôle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|Se produit après qu’une instance d’un contrôle dynamique (celui qui a été créé par programme ou à partir d’un catalogue) a été supprimée définitivement.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|Se produit juste avant le processus de suppression d’un contrôle dynamique.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|Se produit après qu’un contrôle a été déplacé dans sa zone ou à une autre zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|Se produit juste avant le processus de déplacement d’un contrôle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|Se produit après que deux contrôles sélectionnés pour participer à une connexion ont établi la connexion.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|Se produit juste avant le processus de connexion de deux contrôles.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|Se produit après la déconnexion de deux contrôles connectés.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|Se produit juste avant le processus de déconnexion de deux contrôles.|  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle dispose de nombreuses méthodes pour gérer les pages de composants WebPart. Un grand ensemble de méthodes, non répertoriées ici, les méthodes dont les noms prennent la forme de On*EventName*. Ces méthodes généralement déclencher son événement associé et fournissent à l’événement avec un gestionnaire de type <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>. La plupart de ces méthodes peut être substituée par les développeurs qui héritent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. En outre, les développeurs de pages peuvent fournir des gestionnaires personnalisés pour les événements associés à ces méthodes. Par exemple, dans le cas de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement, un développeur de pages peut ajouter un `OnWebPartAdded` attribut le `<asp:webpartmanager>` élément dans le balisage d’une page Web, puis attribuer une méthode personnalisée nom et à l’attribut pour fournir une gestion personnalisée pour l’événement. L’attribut correspond à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> (méthode) et ce modèle de base de gestion fonctionne pour la plupart des événements WebPart et leurs méthodes associées d’événements.  
  
 En outre, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle dispose de méthodes particulières à la tâche de gestion <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles (et les contrôles serveur ou utilisateur utilisés comme <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles). Ces méthodes incluent <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.  
  
 Un autre ensemble de méthodes est spécialisé pour les connexions. Cela inclut des méthodes telles que <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 Enfin, certaines <xref:System.Web.UI.WebControls.WebParts.WebPartManager> méthodes vous concentrer sur les fonctionnalités de personnalisation. Il s’agit notamment de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.  
  
 Pour plus d’informations sur les autres <xref:System.Web.UI.WebControls.WebParts.WebPartManager> les méthodes qui sont accessibles via le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété, consultez la documentation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation déclarative et par programmation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 Le contrôle utilisateur a un contrôle de liste déroulante qui affiche les modes d’affichage possibles sur une page, compte tenue des contrôles WebPart qui sont présents sur la page. Dans la page Web pour cet exemple de code, ce contrôle utilisateur est déclaré juste en dessous de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> élément dans le balisage de la page et qu’il existe un `Register` directive au début de la page Web pour enregistrer le contrôle. Pour plus d’informations sur les modes d’affichage et une description du code source dans ce contrôle, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Contient le balisage déclaratif pour la page Web `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. La page contient également du code incorporé qui gère les événements liés à la connexion pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler ; vous pouvez voir l’effet de ce code comme vous vous connecter et déconnectez les contrôles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Notez qu’il existe une interface nommée `IZipCode`, et cette interface est implémentée dans le `ZipCodeWebPart` classe. Cette classe a une méthode de rappel spéciale nommée `ProvideIZipCode` qui sert de fournisseur. L’autre type, nommé `WeatherWebPart`, est également implémenté avec une méthode spéciale nommée `GetIZipCode`, ce qui permet au contrôle d’agir comme un consommateur de l’autre contrôle.  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code suppose que vous avez compilé la source dans un assembly et le `Register` directive dans la page Web fait référence au nom de l’assembly. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois l’interface utilisateur de connexion s’affiche, cliquez sur le **créer une connexion à un consommateur** lien. Une cellule s’affiche avec un contrôle de liste déroulante. Sélectionnez **contrôle météo** dans la liste déroulante, puis cliquez sur **Connect** pour établir la connexion des deux contrôles. Cliquez sur **fermer**, puis utilisez le **Mode d’affichage** liste déroulante, pour retourner la page en mode de navigation normal. Vous pouvez entrer un Code postal et le contrôle consommateur sera actualisée avec la valeur d’entrée. Étant donné que le `ZipCode` a été marquée avec le `Personalizable` dans le code source, cette valeur de propriété sera conservé entre les sessions de navigateur, ce qui évite la valeur entrée par un utilisateur. Un contrôle consommateur plus sophistiqué pourrait prendre les informations de code postal, rechercher des informations météorologiques en fonction du code et affichez-la à un utilisateur.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle est conçu pour être étendu. Étant donné qu’il est central pour les applications WebPart, lorsque vous souhaitez étendre un type spécifique ou de contrôle dans le jeu de composants WebPart, dans de nombreux cas, vous devez également étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, car il est probable qu’une propriété ou une méthode qui est requis pour rendre  votre type personnalisé fonctionne dans le contexte d’une application WebPart. Documentation de référence les composants WebPart (voir <see cref="N:System.Web.UI.WebControls.WebParts" />), lorsque vous expliquant comment étendre une WebPart type mentions ce qui doit être fait pour étendre la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe ainsi ou montre comment l’étendre dans un exemple de code.</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> constructeur initialise plusieurs variables importantes utilisées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Une assignation influe directement sur toutes les pages de composants WebPart est le fait que le mode d’affichage page par défaut est défini sur mode de navigation (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend actives toutes les connexions d'une page Web actuellement inactives.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée sur chaque demande à une page pour activer les connexions existantes entre <xref:System.Web.UI.WebControls.WebParts.WebPart> et d’autres contrôles serveur résidant dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones. Dans certains cas, par exemple s’il existe un conflit dans les connexions en cours d’activation, cette méthode à son tour appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode à la fin de la connexion problématique. Pendant le processus de déconnexion du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement est déclenché. Les développeurs peuvent généralement annuler cet événement, mais dans le cas où il s’agit de conflit entre les connexions, il ne peut pas être annulée, car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a besoin résoudre le conflit afin de terminer le processus d’activation des connexions. Pour plus d’informations, consultez <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou contrôle serveur ou utilisateur) à ajouter à une page Web ou à ouvrir sur une page.</param>
        <param name="zone"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> auquel <paramref name="webPart" /> est ajouté.</param>
        <param name="zoneIndex">Entier qui représente la position ordinale occupée par <paramref name="webPart" /> dans <paramref name="zone" /> par rapport à d'autres contrôles dans <paramref name="zone" />.</param>
        <summary>Fournit la méthode par programme standard pour ajouter des contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à une page Web.</summary>
        <returns>Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> qui a été ajouté à la page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode est utilisée à la fois pour ajouter le nouveau dynamic <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à une page et pour rouvrir les contrôles statiques ou dynamiques qui ont été précédemment fermés sur une page. Lorsque la méthode est appelée pour ajouter un nouveau contrôle, il crée en fait une copie du contrôle référencé dans le `webPart` paramètre. Un nouvel ID est généré pour la copie du contrôle, afin que les développeurs doivent référencer le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle renvoyé par la méthode à obtenir la valeur d’ID. Lorsque la méthode est appelée pour rouvrir un contrôle fermé précédemment, elle retourne une référence directe au contrôle référencé par le `webPart` paramètre.  
  
> [!IMPORTANT]
>  Vous devez toujours utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> (méthode), plutôt que la <xref:System.Web.UI.ControlCollection.Add%2A> méthode de la collection de contrôles référencés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> propriété, pour ajouter <xref:System.Web.UI.WebControls.WebParts.WebPart> par programmation des contrôles à la page, car à l’aide de la <xref:System.Web.UI.ControlCollection.Add%2A> méthode lève une exception. Pour ajouter un contrôle qui n’est pas un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (en d’autres termes, un contrôle serveur qui sera encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle au moment de l’exécution), vous devez d’abord appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode pour créer le contrôle, puis appelez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode pour ajouter le contrôle. Pour une démonstration de cette approche, consultez la section exemple.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode pour ajouter un contrôle serveur par programmation à une page. Le balisage de page contient un vide `<asp:webpartzone>` élément et un `<asp:webpartmanager>` élément. La première fois le **ajouter un calendrier** bouton, le code au gestionnaire d’événements crée un <xref:System.Web.UI.WebControls.Calendar> contrôler et l’ajoute à une zone en tant qu’un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet, en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> (méthode).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="zone" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" /> n'est pas enregistrée dans la collection de zones du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
- ou - 
 <paramref name="webPart" /> est déjà dans <paramref name="zone" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="zoneIndex" /> est inférieure à zéro.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la méthode <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> est appelée pour déterminer si un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur peut être ajouté à une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement se produit chaque fois qu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est ajouté à une page. Il existe un nombre de scénarios courants où un contrôle peut être ajouté à une page. Pour une description complète, consultez la section Notes pour la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode). Lorsqu’un contrôle est ajouté, il doit être vérifié pour voir si son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété a été définie et, dans ce cas, si le contrôle est autorisé à ajouter à la page.  
  
 Les développeurs peuvent créer des gestionnaires d’événements pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, afin de fournir un filtrage pour les contrôles. Si un contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valeur de propriété ne répond pas aux critères dans le code de gestionnaire d’événements, le contrôle n’est pas ajouté à la page.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir un gestionnaire d’événements personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, qui remplace automatiquement la valeur par défaut <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode).  
  
 Le code dans le `mgr1_AuthorizeWebPart` méthode vérifie si les contrôles sur la page ont leur respectifs <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> les valeurs de propriété définies sur `user` et, dans ce cas, retourne `true`, ce qui signifie qu’ils seront autorisés et ajoutés à la page. Cela suppose que l’approche par défaut consiste à permettre aux utilisateurs d’afficher des contrôles avec une page dans la portée de personnalisation utilisateur. Notez, toutefois, que dans l’exemple d’un des contrôles son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valeur de propriété `admin`. Les développeurs peuvent placer ce filtre sur un contrôle spécialisé qui a été conçu pour seulement les utilisateurs administratifs à voir. Ce contrôle échoue la vérification d’autorisation pendant la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement et ne seront pas affichées. Notez que les contrôles qui n’ont pas de définir la propriété sont affichés. ils sont supposés ne pas pour faire partie d’un scénario de filtrage, car leurs <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriétés ne sont pas définies.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection d'objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> qui sont disponibles pour créer des connexions WebPart entre les contrôles serveur.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> qui contient un ensemble d'objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété utilise la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> méthode pour créer la collection. Par défaut, il lit les transformateurs disponibles à partir du fichier de configuration d’application.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/d98cfd0f-ebd6-4871-89d5-abbd2cdef67b">Vue d’ensemble des connexions de composants Web</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle pour lequel la connexion est formée.</param>
        <summary>Démarre le processus de connexion de deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> méthode existe afin que le processus d’établir des connexions entre les contrôles peut être effectué dans les étapes distinctes, offrant ainsi aux développeurs de mieux contrôler le processus de connexion. La méthode exécute un ensemble de contrôles initiaux pour vous assurer que `webPart` est dans un état où une connexion peut être formée de manière légitime. Si `webPart` passe tous les contrôles, il est alors défini comme le contrôle actuellement sélectionné (voir la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété), et le processus de connexion peut continuer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le mode d'affichage actuel sur la page n'est pas <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> est fermé.  
  
- ou - 
 <paramref name="webPart" /> ne fait pas partie de la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
ou 
 <paramref name="webPart" /> est égal au contrôle <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <block subset="none" type="overrides"><para>Les développeurs qui souhaitent étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle souhaiterez peut-être substituer cette méthode dans une classe dérivée. Une approche consisterait à appeler la méthode de base, puis ajoutez une gestion personnalisée supplémentaire ; ou vous souhaiterez peut-être personnaliser entièrement le processus de démarrage d’une connexion entre les contrôles. Par exemple, vous souhaiterez peut-être vérifier que certaines données sont disponibles avant de créer la connexion.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle à modifier.</param>
        <summary>Démarre le processus d'édition d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> méthode existe afin que le processus de modification des contrôles est possible dans les étapes distinctes, offrant ainsi aux développeurs de mieux contrôler le processus. La méthode exécute un ensemble de contrôles initiaux pour vous assurer que `webPart` est dans un état où il peut être modifié. Si `webPart` passe tous les contrôles, il est alors défini comme le contrôle actuellement sélectionné (voir la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété), et le processus de modification peut continuer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le mode d'affichage actuel sur la page n'est pas <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> est fermé.  
  
ou 
 <paramref name="webPart" /> ne fait pas partie de la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
ou 
 <paramref name="webPart" /> est égal au contrôle <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage par défaut pour les pages qui contiennent des contrôles WebPart. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez y faire référence en directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsqu’une page qui contient les composants WebPart contrôles du premier chargement, il est en <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (mode de navigation) par défaut. Lorsque les utilisateurs naviguent simplement comme ils le feraient sur une page Web normale, la page reste en mode de navigation. Si les utilisateurs souhaitent personnaliser la disposition d’une page, contrôles, apparence ou le comportement, ils doivent faire basculer la page dans un des modes d’affichage spécialisés disponibles via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment travailler avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> champ par programmation. Le code remplit une liste déroulante avec les modes d’affichage pris en charge, qui sont dans ce cas de parcourir et conception. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez l’étiquette sur la page qui indique que vous êtes en mode de navigation. Utilisez le contrôle de liste déroulante pour basculer la page en mode design. Notez que, en raison du code dans le `Page_PreRender` (méthode), l’étiquette est masqué.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vérifie les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> participant à une connexion pour déterminer s'ils peuvent être connectés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode est utilisée pour déterminer si deux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles peuvent être connectés. La méthode est généralement utilisée comme contrôle conditionnel avant d’appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (méthode).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode vérifie un certain nombre de critères qui doivent être remplies avant que les deux contrôles peuvent former une connexion. La liste suivante résume les critères principaux pour établir une connexion. Si tous ces critères (plus quelques conditions internes supplémentaires) sont remplies, la méthode retourne `true`, ce qui signifie que les contrôles peuvent être connectés :  
  
-   Les contrôles consommateur et fournisseur ne peut pas être `null`, et ils doivent figurer dans la collection de contrôles référencés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
-   Le fournisseur et le consommateur ne peut pas être le même contrôle. En d’autres termes un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle ne peut pas se connecter à lui-même.  
  
-   Le <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> objets (points de connexion) pour le fournisseur et le consommateur ne peut pas être `null`.  
  
-   Le fournisseur et le consommateur ne peut pas être fermés (du contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> propriété peut être `true`).  
  
-   Le <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> propriété du contrôle de point de connexion doit correspondre au type de contrôle du consommateur et fournisseur.  
  
-   Les points de connexion doivent être activées (leurs <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> méthodes doivent retourner `true`).  
  
-   Chaque point de connexion ne doit pas essayer former de plus de connexions que ce qui est spécifié dans son propre <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> propriété.  
  
-   Si un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet (transformateur) est requis pour connecter des contrôles incompatibles, il ne peut pas être `null`. Toutefois, si les contrôles sont déjà compatibles, le transformateur doit être `null`.  
  
-   Le transformateur (le cas échéant) doit être référencé dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> collection.  
  
-   Le transformateur (le cas échéant) doit avoir des interfaces qui sont compatibles avec le fournisseur et le consommateur afin qu’il peut transformer des données entre les deux contrôles. Les interfaces secondaires du consommateur et fournisseur doivent également être compatibles.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Contrôle qui fournit les données à <paramref name="consumer" /> lorsque les contrôles sont connectés.</param>
        <param name="providerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui permet à <paramref name="provider" /> de participer à une connexion.</param>
        <param name="consumer">Contrôle qui reçoit les données de <paramref name="provider" /> lorsque les contrôles sont connectés.</param>
        <param name="consumerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui agit comme une méthode de rappel de manière à ce que <paramref name="consumer" /> puisse participer à une connexion.</param>
        <summary>Vérifie les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> qui participeront à une connexion afin de déterminer s'ils peuvent être connectés lorsque les contrôles consommateur et fournisseur ont des interfaces compatibles et qu'un objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> n'est pas nécessaire.</summary>
        <returns>Valeur Boolean qui indique si <paramref name="provider" /> et <paramref name="consumer" /> peuvent être connectés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour se connecter `provider` et `consumer` lorsque les deux contrôles ont des types, de points de connexion compatibles afin qu’un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet n’est pas nécessaire. Vous souhaiterez peut-être utiliser cette méthode pour vérifier que les deux contrôles peuvent être connectés avant d’appeler <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> pour créer une connexion par programme.  
  
 Cette surcharge utilise la même implémentation que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> surcharge de méthode, avec la seule exception étant que cette surcharge ne nécessite pas un transformateur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette méthode.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, un `<asp:webpartmanager>` élément et un code de gestion des événements qui crée une connexion à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> (méthode).  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Contient le balisage déclaratif pour la page Web `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si la connexion peut être effectuée et, si tel est le cas, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble des connexions statiques référencé par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Il contient une interface et deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles agissant comme un fournisseur et l’autre en tant que consommateur. Parce qu’ils ont des points de connexion compatibles (les deux d'entre eux reconnaissent le `IZipCode` interface), un transformateur n’est pas nécessaire pour établir la connexion. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois que l’interface utilisateur de connexion (IU) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Contrôle qui fournit les données à <paramref name="consumer" /> lorsque les contrôles sont connectés.</param>
        <param name="providerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui agit comme une méthode de rappel de manière à ce que <paramref name="provider" /> puisse participer à une connexion.</param>
        <param name="consumer">Contrôle qui reçoit les données de <paramref name="provider" /> lorsque les contrôles sont connectés.</param>
        <param name="consumerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> qui agit comme une méthode de rappel de manière à ce que <paramref name="consumer" /> puisse participer à une connexion.</param>
        <param name="transformer"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> qui permet à un <paramref name="provider" /> et un <paramref name="consumer" /> incompatibles de se connecter.</param>
        <summary>Vérifie les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> qui participeront à une connexion afin de déterminer s'ils peuvent être connectés, et utilise un objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> pour créer la connexion entre un consommateur et un fournisseur incompatibles.</summary>
        <returns>Valeur Boolean qui indique si <paramref name="provider" /> et <paramref name="consumer" /> peuvent former une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour se connecter `provider` et `consumer` lorsque les deux contrôles ont des types, de points de connexion incompatibles afin qu’un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet est requis. Vous souhaiterez peut-être utiliser cette méthode pour vérifier que les deux contrôles peuvent être connectés avant d’appeler <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> pour créer une connexion par programme.  
  
 Cette surcharge utilise la même implémentation que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> surcharge de méthode, avec la seule exception étant que cette surcharge requiert un transformateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage utilisé pour l'ajout de contrôles serveur à une page Web à partir d'un catalogue de contrôles. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez y faire référence en directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsque les utilisateurs souhaitent ajouter des contrôles à une page, si un catalogue de contrôles serveur est disponible, ils peuvent basculer la page pour <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (mode catalogue), et l’interface utilisateur de catalogue (IU) s’affiche. L’interface utilisateur pour un catalogue de composants WebPart est fournie par un <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> contrôle de zone. Les développeurs ajoutent cette zone à la page au moment du design, puis ajoutez des contrôles serveur à la zone, afin que les utilisateurs pourront ajouter ces contrôles à leurs pages en cours d’exécution. Une fois que le développeur a ajouté ces contrôles, le mode catalogue devient un mode d’affichage pris en charge sur la page, car les contrôles nécessaires sont là pour activer le mode de catalogue.  
  
 Quand un utilisateur bascule une page pour le mode, la zone et tous les contrôles serveur qui ont été ajoutés deviennent visibles du catalogue, et l’utilisateur peut sélectionner des contrôles à partir du catalogue à ajouter à la page, ou supprimer des contrôles de la page. Une fois les contrôles ont été ajoutés à la page, ils apparaissent dans le mode de navigation normal et la page est mise à jour.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment travailler avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> champ par programmation. Le code remplit une liste déroulante avec les modes d’affichage pris en charge pour la page, qui sont dans ce cas de navigation, de conception et de catalogue. Le mode de catalogue est disponible car le `<asp:CatalogZone>` élément et ses éléments enfants dans la page Web. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page est masquée. Utilisez le contrôle de liste déroulante pour basculer la page en mode catalogue. Notez que, en raison du code dans le `Page_PreRender` méthode, l’étiquette est désormais visible. Vous pouvez sélectionner le contrôle dans le catalogue et l’ajouter à une des deux zones sur la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie les fonctionnalités du navigateur qui effectue la demande et la valeur de la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />, afin de déterminer s'il faut ou non restituer le script client.</summary>
        <returns>Valeur Boolean qui indique s'il faut restituer le script client.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un avertissement qui s'affiche lorsqu'un utilisateur ferme un contrôle qui agit comme un fournisseur pour les autres contrôles d'une connexion.</summary>
        <value>Chaîne qui contient le message d'avertissement. La valeur par défaut est un message spécifique à la culture fourni par le .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur ferme un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, aucun message ne s’affiche normalement. Pour plus d’informations sur ce que cela signifie pour fermer un contrôle, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> (méthode).  
  
 Toutefois, lorsqu’un contrôle est connecté à un autre contrôle et agit en tant que fournisseur de données à l’autre, un message d’avertissement par défaut s’affiche lorsqu’un utilisateur tente de fermer le contrôle. Le message indique aux utilisateurs qu’un contrôle fournisseur est sur le point de fermer, ce qui signifie que les contrôles connectés à ce fournisseur comme consommateurs n’aura plus de données à consommer. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété permet aux développeurs de personnaliser le message d’avertissement qui s’affiche à l’utilisateur.  
  
 Si un développeur de pages assigne une valeur de chaîne vide ou null à cette propriété, aucune boîte de message d’avertissement ne s’affichera lorsqu’un utilisateur ferme un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle qui est un fournisseur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété à afficher un avertissement personnalisé aux utilisateurs.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> les contrôles qui peuvent être connectées et un `<asp:webpartmanager>` élément.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 Le code suivant contient uniquement la partie de la page Web de l’exemple. Vous aurez également besoin du contrôle utilisateur personnalisé et le code source pour les contrôles personnalisés mentionnés ci-dessus. Obtenir ces deux éléments à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Le code de page Web suivant montre comment affecter un message d’avertissement personnalisé à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété dans le balisage déclaratif dans le `<asp:webpartmanager>` élément.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois l’interface utilisateur de connexion (IU) s’affiche, cliquez sur le **créer une connexion à un consommateur** lien. Une cellule s’affiche avec un contrôle de liste déroulante. Sélectionnez **contrôle météo** dans la liste déroulante, puis cliquez sur **Connect** pour établir la connexion des deux contrôles. Cliquez sur **fermer**, puis utilisez le **Mode d’affichage** liste déroulante, pour retourner la page en mode de navigation normal. Enfin, cliquez sur le menu d’actions verbales pour le **Code postal** contrôler (c'est-à-dire le contrôle fournisseur dans ce cas) et sélectionnez **fermer**. Le message personnalisé affecté à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriété s’affiche.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur fermé dans un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</param>
        <summary>Ferme un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> de façon telle qu'il n'est pas restitué sur une page Web, mais qu'il peut être rouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode supprime un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou autre contrôle serveur afin qu’il n’est pas restitué sur la page Web qui le contenait à l’origine. Le contrôle fermé est ajouté à un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> objet, qui conserve une référence au contrôle fermé et rend possible pour le contrôle d’être restauré dans la page. Un fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle apparaît toujours dans la collection référencée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
 Fermeture d’un contrôle est différente de sa suppression. Les contrôles fermés sont toujours disponibles pour être restaurée vers une page, mais une instance de contrôle supprimé est définitivement supprimée et ne peut jamais être restaurée. Ait ou non un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur est statique (déclaré dans le balisage d’une page) ou dynamique (ajouté à la page par programme ou par un utilisateur à partir d’un catalogue de composants WebPart), il peut être fermé et rouvert sur une page.  
  
 En règle générale, les utilisateurs peuvent fermer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle en cliquant sur son menu d’actions verbales et en sélectionnant le verbe close. Un contrôle peut également être fermé en appelant directement le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> (méthode) et en lui passant une référence à `webPart`.  
  
 Sur une page où <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles ont été fermés, si un développeur déclare un `<asp:catalogzone>` élément et lui ajoute un `<asp:pagecatalogpart>` élément, il fournit une interface utilisateur simple (IU) permettant aux utilisateurs de restaurer les contrôles fermés à la page en cours d’exécution. Les utilisateurs peuvent basculer la page en mode d’affichage catalogue, et les contrôles fermés apparaîtront dans le catalogue de la page. Les utilisateurs peuvent sélectionner des contrôles fermés et les ajouter à la page à la position désirée, puis les contrôles sélectionnés sont et restaurés sur la page restitués comme d’habitude.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> est appelée, elle déclenche plusieurs événements : <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (s’il existe plusieurs contrôles), et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (absence de contrôles connectés). Les développeurs peuvent généralement annuler ces événements, mais dans certains cas, il n’est pas possible de les annuler. Pour plus d’informations, consultez la documentation pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événements.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage de page.  
  
-   Personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
-   Une page Web.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple de code est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise l’approche de compilation dynamique ; Il y a donc aucun `Assembly` d’attribut dans la `Register` directive pour ce contrôle en haut de la page Web. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 La troisième partie de l’exemple de code est la page Web. La page contient un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, avec un <`asp:pagecatalogpart>` élément déclaré qu’il contient. C’est ce que contiendra fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler et de permettre aux utilisateurs pour l’ajouter à la page. Le `Button1_Click` méthode appelle directement la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode pour fermer personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, bien qu’un utilisateur peut également fermer le contrôle via le menu d’actions verbales.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, fermez personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle en cliquant sur le menu d’actions verbales (le symbole de flèche) dans l’en-tête du contrôle, en cliquant sur **fermer**. Maintenant modifier la page en mode catalogue en sélectionnant **catalogue** dans le **Mode d’affichage** contrôle de liste déroulante. Le catalogue de la page s’affiche avec le contrôle fermé. Sélectionnez la case à cocher en regard du contrôle fermé, cliquez sur **ajouter** à ajouter à la page, puis cliquez sur **fermer** pour retourner la page en mode de navigation. Le contrôle est restauré sur la page. Fermer maintenant, cette fois en cliquant sur le **Close WebPart** bouton.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> ne figure pas dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
ou 
 <paramref name="webPart" /> est un contrôle partagé qui a déjà été fermé par un autre utilisateur.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage utilisé pour afficher une interface utilisateur spéciale afin que les utilisateurs puissent gérer les connexions entre les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez y faire référence en directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsque les utilisateurs souhaitent gérer les connexions entre <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle sur une page Web, si un <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> zone a été déclarée dans la page, ils peuvent basculer la page dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode. Le mode d’affichage de connexion affiche une interface utilisateur spéciale pour la gestion des connexions, qui inclut la possibilité de se connecter ou déconnecter des contrôles et modifier les détails des connexions existantes.  
  
 Si vous souhaitez fournir aux utilisateurs la possibilité de gérer les connexions avec l’interface utilisateur fournie par le jeu de composants WebPart, vous devez déclarer un `<asp:connectionszone>` élément dans le balisage d’une page. Contrairement aux éléments pour les autres types de <xref:System.Web.UI.WebControls.WebParts.WebZone> zones, vous n’avez pas besoin d’ajouter d’autres balises dans cet élément ; vous déclarez simplement l’élément par lui-même.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode.  
  
 L’exemple de code comprend trois parties :  
  
-   Un fichier source qui contient une interface et une personnalisée <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent établir une connexion.  
  
-   Une page Web qui fournit une interface utilisateur de connexion et illustre l’utilisation du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode.  
  
-   Une explication de l’exécution de l’exemple.  
  
 La première partie de l’exemple de code est un fichier source qui contient une interface et deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sont conçus de manière à pouvoir être connectés. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise l’approche de compilation dynamique. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 La deuxième partie de l’exemple est une page Web qui héberge les contrôles personnalisés. Au sein du serveur `<script>` balises dans la page existe plusieurs méthodes qui remplissent une liste déroulante avec les modes d’affichage disponibles sur la page. Un utilisateur peut sélectionner à partir de la liste déroulante pour modifier le mode d’affichage de la page. Un des modes d’affichage disponibles est en mode d’affichage, connexion, car un `<asp:connectionszone>` élément est déclaré dans le balisage de la page. Notez que cet élément ne contient pas tous les éléments enfants ; Il existe uniquement pour activer l’interface utilisateur de gestion de connexion pour les utilisateurs.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> mode s’affiche dans cet exemple à deux endroits. Tout d’abord, dans le `Page_Init` méthode, le mode d’affichage de connexion est ajouté à la liste déroulante des modes d’affichage, en tant que le code parcourt la collection référencée dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété. Ensuite, le `Page_PreRender` méthode vérifie le mode d’affichage actuel sur la page, et si le mode actuel est <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, un message s’affiche dans un <xref:System.Web.UI.WebControls.Label> contrôle.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, cliquez sur la liste déroulante et sélectionnez **Connect** pour basculer la page en mode d’affichage. Notez qu’un message apparaît, indiquant que la page est en mode d’affichage de connexion. Cliquez maintenant sur le menu d’actions verbales (symbolisé par une flèche) dans la barre de titre de l’un de le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, puis cliquez sur **Connect** dans le menu d’actions verbales. Une fois la connexion de que l’interface utilisateur s’affiche, cliquez sur le lien pour créer une connexion. Utilisez la liste déroulante au sein de la connexion de l’interface utilisateur qui s’affiche, sélectionnez l’autre contrôle qui participera à la connexion, cliquez sur le **Connect** bouton. La connexion est établie. Cliquez sur le **fermer** bouton et utilisez la liste déroulante en haut de la page pour retourner la page pour parcourir le mode d’affichage.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la collection de toutes les connexions actives sur une page Web.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> qui contient un ensemble d'objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriété offre un moyen pour accéder au jeu actuel de connexions sur une page. La collection elle-même est en lecture seule, et les développeurs qui souhaitent manipuler une connexion spécifique à partir de la collection doivent utiliser <xref:System.Web.UI.WebControls.WebParts.WebPartManager> méthodes telles que <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation déclarative et par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 Le code suivant contient uniquement la partie de la page Web de l’exemple. Vous aurez également besoin du contrôle utilisateur personnalisé et le code source pour les contrôles personnalisés mentionnés ci-dessus. Obtenir ces deux éléments à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Le code de page Web suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriété par programmation pour obtenir le nombre de connexions en cours sur une page. Notez que dans le `<script>` section de la balise, le code pour gérer les deux événements pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler l’accès à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriété pour obtenir le nombre.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois l’interface utilisateur de connexion (IU) s’affiche, cliquez sur le **créer une connexion à un consommateur** lien. Une cellule s’affiche avec un contrôle de liste déroulante. Sélectionnez **contrôle météo** dans la liste déroulante, puis cliquez sur **Connect** pour établir la connexion des deux contrôles. Cliquez sur **fermer**, puis utilisez le **Mode d’affichage** liste déroulante, pour retourner la page en mode de navigation normal. Notez qu’une étiquette affiche maintenant le nombre de connexions et le nombre de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. Si vous retournez maintenant en mode connexion et de déconnecter les deux contrôles, lorsque vous revenez au mode de navigation, contenu de l’étiquette doit être mis à jour et qu’il ne doit y avoir aucune connexion.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que toutes les connexions WebPart actuelles d'une page sont non seulement connectées, mais ont commencé activement à partager les données entre les contrôles consommateur et fournisseur impliqués dans chaque connexion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le cycle de vie des connexions, cet événement se produit après une page de son processus de chargement. Il se produit également après le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement, qui indique uniquement que le <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôles serveur impliqués dans une connexion spécifique se sont correctement connectés. Dans un cas où il existe plusieurs connexions d’une page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> méthode indique que toutes les connexions WebPart valides sur une page sont maintenant active et en mesure de partager des données. Sachant que toutes les connexions sont actives, les développeurs peuvent exécuter n’importe quel nombre de tâches, notifier les utilisateurs de l’état de toutes les connexions, notifier les contrôles consommateur pour traiter et afficher des données à partir de leurs fournisseurs et ainsi de suite.  
  
 Cet événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> (méthode), ce qui déclenche l’événement et permet aux développeurs de créer des gestionnaires personnalisés pour l’événement.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour l’événement en ajoutant le `OnConnectionsActivated` attribut le `<asp:webpartmanager>` élément dans la page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus d'activation de toutes les connexions WebPart établies sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le cycle de vie des connexions, cet événement se produit lorsqu’une page termine son processus de chargement, juste avant la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée. Il est différent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> événement, ce qui implique une connexion particulière entre <xref:System.Web.UI.WebControls.WebParts.WebPart> ou d’autres contrôles serveur. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> événement se produit lorsque toutes les connexions possibles sur une page ont été connectées et doivent être activés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> (méthode), ce qui déclenche l’événement. Les développeurs de contrôles qui souhaitent étendre le type de connexions qui peuvent être ajoutées à une page peut remplacer l’élément protégé <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> (méthode) et activer des types de connexions supplémentaires.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour l’événement en ajoutant le `OnConnectionsActivating` attribut le `<asp:webpartmanager>` élément dans la page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une connexion entre deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou d'autres contrôles serveur capables de former des connexions) qui résident dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> méthode constitue une connexion entre deux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés. Avant d’appeler cette méthode pour créer une connexion, vous pouvez également appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode dans un contrôle conditionnel pour vous assurer que les contrôles satisfont les conditions requises pour former une connexion.  
  
> [!NOTE]
>  Il est également possible de créer une connexion entre deux contrôles serveur qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. En général, les deux contrôles doivent être des contrôles serveur personnalisés (par exemple, les contrôles qui héritent de <xref:System.Web.UI.WebControls.WebControl> ou contrôles serveur ASP.NET existants) afin que vous pouvez ajouter les membres requis. Les contrôles doivent également répondre aux exigences spécifiées ci-dessous.  
  
 N’importe quel type de scénario de connexion entre deux contrôles doit répondre aux exigences suivantes pour pouvoir se connecter :  
  
-   Chaque contrôle réside dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone (il ne doit pas être la même zone).  
  
-   Tel qu’implémenté dans le jeu de composants WebPart, le contrôle de fournisseur dans une connexion implémente une interface comme une méthode publique qui sert de rappel au fournisseur et a un `ConnectionProvider` attribut de métadonnées sur la méthode pour l’identifier comme une connexion de fournisseur point. Étant donné que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> méthode que récupère les points de connexion fournisseur est virtuelle, une dérivée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ne doit pas nécessairement utiliser le même attribut de métadonnées.  
  
-   Tel qu’implémenté dans le jeu de composants WebPart, le contrôle consommateur dans une connexion a également une méthode spéciale qui lui permet d’obtenir une référence à l’interface est exposée dans la méthode de rappel du fournisseur et le consommateur a un `ConnectionConsumer` attribut de métadonnées sur point de la méthode pour l’identifier comme une connexion consommateur. Étant donné que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> méthode que récupère les points de connexion consommateur est virtuelle, une dérivée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle ne doit pas nécessairement utiliser le même attribut de métadonnées.  
  
-   Les méthodes de rappel doivent soit être compatibles, car le consommateur peut utiliser le type d’interface fourni dans la méthode de rappel du fournisseur (ce qui signifie que le consommateur et le fournisseur peuvent partager des données directement), ou le développeur doit utiliser un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet transformer les données à partir du fournisseur dans un formulaire qui le consommateur peut utiliser.  
  
    > [!IMPORTANT]
    >  Lorsque vous n’avez pas besoin d’un transformateur, utilisez la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> surcharge de méthode. Lorsque vous avez besoin d’un transformateur, utilisez la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de fournir des données à un autre contrôle connecté.</param>
        <param name="providerConnectionPoint">Méthode qui sert de méthode de rappel pour la connexion. Tel qu'implémenté dans le jeu de composants WebPart, il s'agit d'une méthode publique dans <paramref name="provider" /> qui est marquée avec un attribut de métadonnées <see langword="ConnectionProvider" />.</param>
        <param name="consumer">Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de recevoir des données de <paramref name="provider" /> et de les traiter ensuite ou de les afficher.</param>
        <param name="consumerConnectionPoint">Méthode qui se connecte avec <paramref name="providerConnectionPoint" /> pour recevoir les données pour la connexion. Tel qu'implémenté dans le jeu de composants WebPart, il s'agit d'une méthode publique dans <paramref name="consumer" /> qui est marquée avec un attribut de métadonnées <see langword="ConnectionConsumer" />.</param>
        <summary>Crée une connexion entre deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> en utilisant uniquement les références aux contrôles et leurs objets <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> spécifiés.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> qui contient les différentes informations relatives au fournisseur et au consommateur nécessaires pour une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est utilisée pour connecter des contrôles lorsque leurs points de connexion sont suffisamment compatibles pour qu’ils puissent se connecter sans utiliser un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet. Lorsque cette surcharge de la méthode est appelée, elle simplement transmet l’appel à l’autre version surchargée de la méthode et transmet `null` pour le paramètre nécessite un <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objet.  
  
 Lorsque vous tentez de connecter deux contrôles par programme, vous pouvez utiliser la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode dans un contrôle conditionnel pour déterminer si les contrôles peuvent être connectés directement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser cette méthode pour créer une connexion par programme. Pour le code complet requis pour exécuter l’exemple, consultez la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. À partir de cet exemple, vous devez le code source pour le contrôle utilisateur qui vous permet de modifier les modes d’affichage dans la page et le code source pour les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
 Le code de la page Web qui héberge les deux contrôles suit. La page utilise `Register` directives en haut pour déclarer le contrôle utilisateur et les contrôles personnalisés. Les contrôles personnalisés sont ensuite référencés de manière déclarative dans un `<asp:webpartzone>` élément. Le code qui gère la `Button1_Click` méthode crée une connexion entre les contrôles à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (méthode).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, cliquez sur le **connecter les contrôles WebPart** bouton pour former la connexion. Vous pouvez ensuite entrer des données dans la zone de texte, puis cliquez sur le **saisir le Code postal à 5 chiffres** bouton pour montrer que les contrôles sont connectés et que les données entrées dans le premier contrôle sont mis à jour dans la seconde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La collection de collections dynamiques du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> est en lecture seule.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de fournir des données à un autre contrôle connecté.</param>
        <param name="providerConnectionPoint">Méthode publique dans <paramref name="provider" /> qui est marquée avec un attribut de métadonnées <see langword="ConnectionProvider" /> et qui sert de méthode de rappel pour la connexion.</param>
        <param name="consumer"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dont le rôle est de recevoir des données de <paramref name="provider" /> ou de <paramref name="transformer" /> et de les traiter ou de les afficher.</param>
        <param name="consumerConnectionPoint">Méthode publique dans <paramref name="consumer" /> qui est marquée avec un attribut de métadonnées <see langword="ConnectionConsumer" /> et se connecte avec <paramref name="providerConnectionPoint" /> pour recevoir les données pour la connexion.</param>
        <param name="transformer"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> qui active une connexion entre deux contrôles en convertissant les données de <paramref name="provider" /> dans un format pouvant être traité par <paramref name="consumer" />.</param>
        <summary>Crée une connexion entre deux contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> à l'aide des références aux contrôles, de leurs objets <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> spécifiés et d'un objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> qui contient les informations relatives au fournisseur, au consommateur et au transformateur nécessaires pour une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est utilisée pour connecter des contrôles lorsque leurs points de connexion sont incompatibles. L’incompatibilité se produit lorsque `consumer` implémente une interface différente de `provider` comme point de connexion. Le transformateur convertit les données en un type qui peut être reconnu par `consumer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Des connexions ont déjà été activées dans <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de tous les <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, contrôles serveur ou utilisateur contenus dans les zones <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> d'une page Web et gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value><see cref="T:System.Web.UI.ControlCollection" /> qui contient tous les contrôles gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> propriété ne référence pas les autres contrôles qui sont référencés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, telles que les différents contrôles, de la zone <xref:System.Web.UI.WebControls.WebParts.EditorPart> ou <xref:System.Web.UI.WebControls.WebParts.CatalogPart> , mais autres.  
  
 Cette propriété est utilisée par le jeu de composants WebPart et dans la plupart des situations de développement qu'il n’est pas destiné à être appelée à partir de votre code. Pour cette raison, bien que la propriété est publique, il est masqué à partir d’IntelliSense. Les développeurs qui souhaitent accéder à la collection de <xref:System.Web.UI.WebControls.WebParts.WebPart> ou d’autres contrôles serveur gérés par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle doit utiliser son <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur à copier.</param>
        <summary>Utilisé par le jeu de composants WebPart pour créer une copie d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou d'un contrôle serveur en vue d'ajouter le contrôle à une page Web.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à ajouter à une page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode directement à partir de votre code. Cette méthode est appelée en interne par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle en tant que partie du processus d’ajout d’un nouveau dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur à une page. Un contrôle dynamique est ajouté à une page par programmation ou via l’interface utilisateur de composants WebPart (IU), par exemple par un utilisateur de l’ajout d’un contrôle à partir d’un catalogue de contrôles, par opposition à un contrôle statique, ce qui est déclaré directement dans le balisage d’une page.  
  
> [!NOTE]
>  La méthode peut être substituée dans une classe dérivée si les développeurs souhaitent activer la méthode pour gérer des scénarios de copie de contrôles supplémentaires. Pour plus d’informations, consultez les section Remarques à l’attention des héritiers.  
  
 Quand un nouveau contrôle dynamique est ajouté, s’il s’agit une <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode retourne une nouvelle instance du contrôle. Si le contrôle ajouté est un autre type de contrôle de serveur (par exemple, un contrôle utilisateur, un contrôle personnalisé ou un contrôle ASP.NET), le contrôle est déjà été encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet par le jeu de contrôles WebPart. Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode rencontre un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle, elle retourne une nouvelle instance de la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle avec une nouvelle instance du contrôle enfant encapsulé dans celle-ci.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode crée une copie d’un contrôle à retourner, elle réinitialise également les valeurs de toutes les propriétés leurs valeurs par défaut. Notez que, si vous souhaitez conserver les valeurs des propriétés personnalisables et les copier vers la nouvelle instance de contrôle, vous devez appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> méthode également. La dernière étape effectuée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> méthode consiste à appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> méthode pour obtenir un nouvel ID pour le contrôle.  
  
> [!NOTE]
>  Étant donné que la méthode obtient un nouvel ID pour un contrôle copié, vous fiez pas à faisant référence à un contrôle dynamique qui est ajouté à une page par son ID d’origine. Au lieu de cela, vous devez référencer la nouvelle instance du contrôle retourné par la méthode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La méthode est déclarée en tant que <see langword="virtual" /> afin que les développeurs puissent hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, substituez la méthode et fournir des scénarios supplémentaires dans lesquels elle pourrait créer des copies des contrôles. Par exemple, la méthode pourrait recevoir éventuellement comme entrée un contrôle qui a été sérialisé dans un fichier XML. La méthode peut désérialiser le code XML (le cas échéant), puis appelez la méthode de base pour gérer les cas existants et retourner une nouvelle instance d’un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> contrôle.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un jeu de transformateurs spécifié dans le fichier de configuration d'un site Web et l'ajoute à la collection de transformateurs référencée par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />.</summary>
        <returns>Collection des transformateurs spécifiés dans le fichier de configuration d'un site Web.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Cette méthode peut être substituée pour ajouter des transformateurs supplémentaires qui peuvent être utilisées par l’application. Par exemple, la méthode peut être écrite pour récupérer une liste de transformateurs disponibles à partir d’un service Web.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la collection de tous les contrôles gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> sur une page Web. Cette classe ne peut pas être héritée.</summary>
        <returns><see cref="T:System.Web.UI.ControlCollection" /> qui se compose de tous les différents contrôles WebPart gérés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Étant donné que cette méthode est protégée et sealed, elle est visible pour les classes qui héritent de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, mais il ne peut pas être substituée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée le jeu de tous les modes d'affichage possibles pour une application WebPart.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> qui contient tous les modes d'affichage pris en charge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée la liste de tous les modes d’affichage possibles, pas seulement les modes d’affichage pris en charge sur une page particulière. Pour plus d’informations sur les modes d’affichage pris en charge, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
 Par défaut, le jeu de composants WebPart crée le jeu suivant de modes d’affichage à utiliser sur les pages WebPart :  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 Les développeurs peuvent créer des modes d’affichage personnalisés, avec ou sans zones personnalisées associées qui dérivent de la <xref:System.Web.UI.WebControls.WebParts.WebZone> ou <xref:System.Web.UI.WebControls.WebParts.ToolZone> classes. Pour créer un mode d’affichage personnalisé, vous devez hériter la <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> (classe), et pour ajouter votre mode d’affichage comme un mode pris en charge sur une page, vous devez hériter la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et substituer les <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> (méthode).  
  
 Lorsque vous ajoutez des modes d’affichage à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> (méthode), vous devez les ajouter dans l’ordre que vous souhaitez faire apparaître dans les contrôles d’interface (UI) utilisateur (comme un <xref:System.Web.UI.WebControls.ListBox> contrôle) qui fournissent aux utilisateurs les modes d’affichage possibles sur une page.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>.  
  
 L’exemple de code comprend cinq parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui héberge les autres contrôles.  
  
-   Un contrôle utilisateur qui réside dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone sur la page Web et vous permet d’entrer et afficher du texte dans une étiquette.  
  
-   Un fichier de code source qui contient deux contrôles. Un est un personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et l’autre est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet à ajouter aux modes d’affichage de la page par défaut.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple est la page Web. Il contient deux <xref:System.Web.UI.WebControls.WebParts.WebPartZone> des contrôles, les contrôles utilisateur et personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Notez que le `Register` directives en haut de la page pour référencer les contrôles utilisateur et l’espace de noms pour les contrôles compilés.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 La troisième partie de l’exemple est le contrôle utilisateur pour la saisie et l’affichage du texte. Il utilise un <xref:System.Web.UI.WebControls.MultiView> contrôle à créer plusieurs vues de l’interface utilisateur. Une vue apparaît avec le `Button1` bouton, l’autre sans. Notez que dans substituées `OnPreRender` (méthode), le code vérifie si la page est actuellement en mode d’affichage personnalisé et, dans ce cas, affiche la première vue du contrôle utilisateur, qui inclut le bouton. Si la page n’est pas dans le mode d’affichage personnalisé, par exemple, si la page est en mode de navigation ou de la conception, le bouton est masqué.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 La quatrième partie de l’exemple est le fichier source pour les deux classes personnalisées. Notez que le custom <xref:System.Web.UI.WebControls.WebParts.WebPartManager> substitue le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> (méthode), et qu’il appelle d’abord la méthode de base pour ajouter tous les modes d’affichage par défaut et ajoute ensuite le mode d’affichage personnalisé. La classe de mode d’affichage personnalisé, `InLineEditDisplayMode`, hérite simplement <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, définit le nom de mode d’affichage dans le constructeur et substitue plusieurs propriétés de base pour établir les caractéristiques de l’affichage personnalisé.  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 Pour exécuter l’exemple de code, chargez la page dans un navigateur. Notez que la page est actuellement en mode de navigation, et aucun bouton n’est visible. À l’aide de la **Mode d’affichage** déroulante contrôle de liste, modifiez la page à **Inline Edit Display** mode et notez qu’à présent le `Button1` bouton est visible dans le contrôle utilisateur inférieur. Ajouter du texte, puis cliquez sur le bouton pour mettre à jour le contrôle. Notez que l’affichage de page revient au mode de navigation, le texte que vous avez entré est maintenant affiché, et le bouton est de nouveau masqué, car la page n’est plus dans le mode d’affichage personnalisé.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">Procédure pas à pas : Modification des Modes d’affichage sur une Page WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur unique pour servir d'ID pour une connexion dynamique.</summary>
        <returns>Chaîne qui contient un ID unique pour une connexion.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> méthode génère une valeur GUID et la convertit en une chaîne pour servir de l’ID unique pour une connexion. La méthode est appelée chaque fois qu’une connexion dynamique est créée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs peuvent substituer cette méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe pour modifier l’implémentation pour générer un ID unique.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType"><see cref="T:System.Type" /> du contrôle pour lequel un ID est généré.</param>
        <summary>Génère un ID unique pour un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique.</summary>
        <returns>Chaîne qui contient l'ID unique pour un contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sont ajoutés à une page Web, ils peuvent être statiques (ce qui signifie que le contrôle est déclaré dans le balisage de page) ou dynamique (ce qui signifie qu’ils sont ajoutés par programmation). Dans tout scénario où le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle crée de nouveaux contrôles dynamiques à ajouter à la page, il appelle cette méthode pour générer un ID unique.  
  
 La méthode est virtuelle afin que les développeurs puissent la substituer s’ils souhaitent fournir une implémentation personnalisée pour générer le code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">Chaîne qui constitue l'ID du contrôle défaillant. Si un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> est impliqué dans la défaillance, l'ID correspond à l'ID de son contrôle serveur enfant.</param>
        <param name="originalTypeName">Chaîne qui définit le nom du <see cref="T:System.Type" /> du contrôle défaillant. Si un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> est impliqué dans la défaillance, le nom de type correspond au type de son contrôle serveur enfant.</param>
        <param name="originalPath">Chaîne qui contient le chemin d'accès à un contrôle utilisateur si un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui contient un contrôle utilisateur enfant est impliqué dans la défaillance.</param>
        <param name="genericWebPartID">Chaîne qui retourne l'ID d'un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> si ce type de contrôle était impliqué dans l'échec de chargement ou de création d'un contrôle.</param>
        <param name="errorMessage">Chaîne qui contient le message d'erreur à afficher sur la page.</param>
        <summary>Crée un contrôle spécial qui est inséré dans une page et affiché à l'attention des utilisateurs finaux lorsqu'une tentative de chargement ou de création d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique échoue pour une raison quelconque.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> inséré dans une page à la place d'un contrôle dont le chargement ou la création a échoué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> méthode est appelée lorsque le jeu tente de charger ou créer une instance de la dynamique de composants WebPart <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur et il échoue pour une raison quelconque. La méthode crée un <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> objet, lui affecte un message d’erreur et le retourne. Le <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> contrôle est inséré à la place le contrôle qui a échoué et son message d’erreur s’affiche sur la page.  
  
 Vous ne pouvez pas appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> méthode directement à partir de votre code. Toutefois, vous pouvez hériter la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et étendre la méthode. Pour plus d’informations, consultez les section Remarques aux héritiers.  
  
 Les utilisateurs finaux peuvent travailler avec un <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> un contrôle dans une page une grande partie comme ils paient un normal <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour supprimer le message d’erreur, ils peuvent fermer le contrôle en cliquant sur le verbe close, après quoi, le contrôle est ajouté à un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> objet, comme tout autre contrôle fermé. Si un utilisateur final supprime un <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> est également supprimé du contrôle, le contrôle serveur qui n’a pas pu charger à partir de la page.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous souhaitez personnaliser les informations qui sont retournées dans le <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> contrôle, vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> méthode, appelez la méthode de base, affecter des valeurs différentes pour les paramètres passés à la méthode de base, puis revenez le résultant<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />contrôle. Par exemple, si vous ne souhaitez pas les utilisateurs finaux pour voir le <paramref name="originalPath" /> valeur (qui affiche le chemin d’accès du répertoire virtuel d’un contrôle utilisateur), lorsque vous appelez la méthode de base, vous pouvez transmettre une chaîne vide (" ») pour ce paramètre.  
  
Vous pouvez également personnaliser le comportement de la <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> contrôle lui-même, en héritant à partir de celui-ci. Par exemple, vous souhaiterez peut-être substituer ses <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> ou <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> propriété.</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet de personnalisation pour contenir les données de personnalisation d'un utilisateur pour la page Web en cours.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> pour contenir les données de personnalisation d'un utilisateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> méthode retourne un objet pour contenir et gérer les paramètres de personnalisation de l’utilisateur pour la page actuelle. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle gère cet objet.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Vue d’ensemble de personnalisation de parties Web</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle serveur qui n'est pas un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</param>
        <summary>Encapsule un contrôle serveur qui n'est pas un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> avec un objet <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, de manière à ce que le contrôle puisse avoir les fonctionnalités WebPart.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui encapsule <paramref name="control" /> et lui permet de fonctionner comme un véritable contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est le mécanisme principal permettant d’activer les contrôles serveur qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles à effectuer sur les mêmes fonctionnalités qu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle et par conséquent participer pleinement les applications WebPart. Grâce à cette méthode, les développeurs largement augmentera le nombre de contrôles serveur qu’ils peuvent utiliser dans une application WebPart, étant donné que n’importe quel type de contrôle de serveur--contrôles ASP.NET standard, les contrôles utilisateur et les contrôles personnalisés--utilisable.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle utilise également cette méthode dans les deux autres scénarios pour encapsuler des contrôles de serveur avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet. Lorsque les utilisateurs ajouter des contrôles serveur à une page à l’aide de la <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> contrôler, si le contrôle importé n’est pas un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est appelée. En outre, lorsque les contrôles serveur sont déclarés dans le format de persistance dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone sur une page Web, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est appelée pour tous les contrôles qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
 Lorsque vous ajoutez par programmation un contrôle serveur à une zone, une approche courante consiste à utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode d’encapsuler le contrôle avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet, puis appelez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> méthode pour ajouter le contrôle à la collection de tous les <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sur la page, ce qui est référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> (méthode). Dans le `Button2_Click method`, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> méthode est appelée pour encapsuler un <xref:System.Web.UI.WebControls.Calendar> contrôler avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet avant de l’ajouter à la zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cette méthode peut être substituée pour utiliser une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> classe à la place de la classe de base fournie avec les composants WebPart jeu de contrôles.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un message d'avertissement personnalisé affiché à l'attention des utilisateurs finaux lorsqu'ils suppriment un contrôle.</summary>
        <value>Chaîne qui contient le texte du message d'avertissement. La valeur par défaut est un message d'avertissement localisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur supprime un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, un message d’avertissement par défaut s’affiche normalement. Il avertit l’utilisateur que lorsque cette instance d’un contrôle est supprimée, la suppression est définitive. Le développeur de pages peut fournir aux utilisateurs un moyen d’ajouter une nouvelle instance du contrôle à la page (comme dans un catalogue de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, ou certains moyens par programme), mais l’instance actuelle d’un contrôle est supprimé est définitivement supprimé. La boîte de dialogue qui affiche l’avertissement inclut un bouton pour l’utilisateur d’annuler la suppression, si vous le souhaitez.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété permet aux développeurs de définir le message d’avertissement qui s’affiche à l’utilisateur.  
  
 Si un développeur de pages assigne une chaîne vide (" ») la valeur à cette propriété, aucune boîte de dialogue de message avertissement s’affichera lorsqu’un utilisateur supprime un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété n’est pas affichée dans le cas statique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et des contrôles serveur. Contrôles statiques sont des contrôles serveur qui sont déclarés dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone dans le balisage d’une page Web. Étant donné que ces contrôles sont statiques, elles ne peut pas être supprimés, afin que le message d’avertissement de suppression n’est jamais affiché dans ce cas. Contrôles statiques peuvent être fermées par un utilisateur, mais un contrôle fermé est ajouté au catalogue de pages, à partir duquel il peut être ajouté à la page par un utilisateur, tandis qu’un contrôle supprimé ne peut jamais être récupéré.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété de façon déclarative et par programme.  
  
 Il existe quatre parties dans l’exemple de code :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage de page.  
  
-   Personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
-   Une page Web.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple de code est personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise l’approche de compilation dynamique ; Il y a donc aucun `Assembly` d’attribut dans la `Register` directive pour ce contrôle en haut de la page Web. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 La troisième partie de l’exemple de code est la page Web. La page contient un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, avec personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle déclaré dans la zone, afin qu’un utilisateur peut l’ajouter à la page en cours d’exécution. Notez que seuls les contrôles dynamiques (les contrôles qui sont ajoutés à une page par programme ou à partir d’un catalogue comme celui-ci) peuvent être supprimés à partir d’une page. Contrôles statiques (contrôles déclarés dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone dans le balisage d’une page) peuvent être fermés, mais jamais supprimés. Le `<asp:webpartmanager>` élément déclare une valeur personnalisée pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété à l’aide de la `DeleteWarning` attribut. Le `Button1_Click` méthode assigne une autre valeur personnalisée à le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, vous devez ajouter le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à la page. À l’aide de la **Mode d’affichage** contrôle de liste déroulante, sélectionner le mode catalogue. Lorsque le catalogue s’affiche, sélectionnez la case à cocher en regard du contrôle personnalisé, cliquez sur **ajouter** à ajouter à la page, puis cliquez sur **fermer** pour retourner la page en mode de navigation. Maintenant que le contrôle est visible, vous pouvez le supprimer. À l’aide de la **Mode d’affichage** contrôler à nouveau, basculez la page en mode design (vous ne pouvez pas supprimer les contrôles lorsque la page est en mode de navigation). Cliquez sur le menu d’actions verbales (le symbole de flèche) dans l’en-tête de la <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, puis sélectionnez **supprimer**. L’avertissement que vous définissez sur le `DeleteWarning` attribut apparaît. Cliquez sur **Annuler**. Cliquez maintenant sur le bouton intitulé **modifier supprimer l’avertissement**, ce qui modifie la valeur de propriété par programmation. Dans le menu d’actions verbales sur le contrôle, sélectionnez **supprimer** à nouveau et notez que cette fois l’autre message d’avertissement s’affiche.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle serveur à supprimer.</param>
        <summary>Supprime définitivement une instance dynamique d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> d'une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> méthode supprime définitivement le contrôle représenté par le `webPart` paramètre à partir d’une page. Contrairement à un contrôle fermé, qui est ajouté à la <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôler et peut être ajouté à la page, une instance de contrôle supprimée ne peut jamais être ajoutée à la page.  
  
> [!NOTE]
>  Implémenté par le contrôle WebPart définie, la capacité pour les utilisateurs à supprimer un dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle dépend de l’utilisateur et la portée de personnalisation dans lequel le contrôle a été ajouté à une page. Si le contrôle est ajouté lorsque la page est en portée partagée (par un utilisateur disposant des autorisations), le contrôle ne peut pas être supprimé par des utilisateurs individuels lorsque la page est dans la portée de l’utilisateur.  
  
 Seuls les contrôles dynamiques peuvent être supprimés. Contrôles dynamiques sont ajoutés à une page par programme ou par les utilisateurs de l’ajout de contrôles à partir d’un catalogue. Les contrôles statiques sont ajoutés à une page de façon déclarative dans le format de balisage ou de persistance. Étant donné que les balises déclaratives sont définitivement présents dans le balisage, les contrôles statiques ne peuvent jamais être supprimés, mais peut être fermés et rouvert.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>. La première fois le **ajouter un calendrier** bouton, le code au gestionnaire d’événements crée un <xref:System.Web.UI.WebControls.Calendar> contrôler et l’ajoute à une zone en tant qu’un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet. Étant donné que le contrôle est ajouté par programme, il s’agit d’un contrôle dynamique, et par conséquent, il peut être supprimé. Lorsqu’un utilisateur clique sur le **supprimer le calendrier** bouton, le code garantit que le contrôle existe, puis le supprime en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> (méthode).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage utilisé pour modifier la disposition des pages Web qui contiennent des contrôles WebPart. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez y faire référence en directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsqu’une page qui contient les composants WebPart contrôles du premier chargement, il est en <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (mode de navigation) par défaut. Lorsque les utilisateurs souhaitent changer la disposition de la page en déplaçant des contrôles à des zones différentes ou dans les zones actuelles, ils doivent tout d’abord faire basculer la page pour <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (mode Création). En mode Création, l’interface utilisateur (IU) pour les différentes zones apparaît, et les utilisateurs peuvent ensuite faire glisser des contrôles pour modifier la disposition.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment travailler avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> champ par programmation. Le code remplit une liste déroulante avec les modes d’affichage pris en charge pour la page, qui sont dans ce cas de parcourir et conception. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page est masquée. Utilisez le contrôle de liste déroulante pour basculer la page en mode design. Notez que, en raison du code dans le `Page_PreRender` méthode, l’étiquette est désormais visible.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à déconnecter.</param>
        <summary>Supprime un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou un contrôle serveur qui est fermé ou supprimé de toutes les connexions auxquelles il participe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode est appelée en interne par le contrôle WebPart lorsqu’un contrôle est fermé sur une page ou supprimé d’une page. Dans ce scénario, la méthode est appelée pour supprimer le contrôle de toutes les connexions où il est impliqué en tant que consommateur ou fournisseur. Si le contrôle est supprimé à partir de n’importe quelle connexion, cette méthode appelle également la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode à la fin de toutes les connexions dans lequel `webPart` a été impliqué.  
  
 Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode est appelée, elle déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement. Normalement, cet événement peut être annulé, mais il ne peut pas être annulée dans deux cas. Un cas se produit lors des demandes à la page, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée. S’il existe un conflit entre les connexions existantes, la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode sera appelée pour fermer l’une des connexions incompatibles et dans cette instance le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement ne peut pas être annulé, car le conflit doit être résolu.  
  
 L’autre cas se produit lorsqu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur qui est actuellement connecté est fermé ou supprimé. Dans ce cas, le contrôle est en cours de suppression à partir de la page, sa connexion doit également arrêté, par conséquent, par conception, il n’est pas possible d’annuler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement pour interrompre le processus de clôture de connexion. Pour plus d'informations, consultez l'événement <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>. À l’aide de deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, la page Web vous permet de créer une connexion entre les contrôles en cliquant sur un bouton, tandis qu’un autre bouton vous permet de déconnecter les contrôles. Si vous fermez un des contrôles, tandis que la page est en mode de navigation et les contrôles sont connectés, une substitution de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> méthode déconnecte le contrôle fermé, met fin à la connexion et affiche un message.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur pour la modification des modes d’affichage.  
  
-   Un fichier source contenant personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
-   Une page Web pour héberger les contrôles.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie est le fichier contenant le code source pour les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> un personnalisés et les contrôles qui seront connectés <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise la compilation dynamique, afin que la `Register` directive qui fait référence à ces composants dans la page Web est déclarée en conséquence en haut de la page Web. Pour une procédure pas à pas qui montre les options de compilation, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 Dans le code source, notez le contrôle hérité `MyWebPartManager` qui remplace le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> (méthode). Cette méthode vérifie chaque connexion dans une page pour voir si le contrôle en cours de fermeture participe à la connexion et, le cas échéant, appelle le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode à la fin de la connexion. Cela est identique à l’implémentation de base de la méthode dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. La méthode substituée personnalise ensuite l’implémentation de base en écrivant un message à la page.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 La troisième partie de l’exemple de code est la page Web. Notez que le haut de la page contient `Register` directives pour enregistrer le contrôle utilisateur et l’assembly compilé dynamiquement avec la <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. La page a deux méthodes principales. Le `Button1_Click` méthode crée une connexion entre les contrôles, tandis que le `Button2_Click` méthode déconnecte les contrôles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Une fois que vous chargez la page, cliquez sur le **Connect** bouton connecter les contrôles. Cliquez sur le menu d’actions verbales dans un des contrôles (la flèche vers le bas dans l’en-tête du contrôle), puis sélectionnez **fermer** à partir du menu d’actions verbales. Lorsque vous essayez de fermer le contrôle, la méthode substituée est appelée, la connexion est terminée, et le message est écrit dans la page. Si vous souhaitez réinitialiser la page pour restaurer le contrôle fermé et faire des essais avec d’autres options, cliquez sur le **réinitialiser l’état utilisateur** lien pour supprimer les données de personnalisation et restaurer l’état d’origine de la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> qui représente la connexion entre les contrôles serveur.</param>
        <summary>Exécute le processus de déconnexion des contrôles serveur connectés sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode exécute le processus complet de clôture de connexion entre <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôles serveur lorsque vous lui transmettez le `connection` paramètre.  
  
 Cette méthode est utilisée pour déconnecter des contrôles lorsque vous placez un `<asp:connectionszone>` élément dans une page Web, pour fournir une interface utilisateur (IU) pour gérer les connexions. Lorsqu’une page est en mode d’affichage de connexion (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) et il existe une connexion active, les utilisateurs peuvent cliquer sur un bouton qui appelle le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode à la fin de la connexion.  
  
 Vous pouvez également appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode directement à partir de votre code, si vous souhaitez vous déconnecter de contrôles par programmation et sans avoir à ajouter un `<asp:connectionszone>` élément à une page.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>. À l’aide de deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, la page Web vous permet de créer une connexion entre les contrôles en cliquant sur un bouton, tandis qu’un autre bouton vous permet de déconnecter les contrôles.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur pour la modification des modes d’affichage.  
  
-   Un fichier source contenant personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
-   Une page Web pour héberger les contrôles.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie est un fichier contenant le code source pour les deux fonctions personnalisées <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui seront connectés. Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple utilise la compilation dynamique, afin que la `Register` directive qui fait référence à ces composants dans la page Web est déclarée en conséquence en haut de la page Web. Pour une procédure pas à pas qui montre les options de compilation, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 La troisième partie de l’exemple de code est la page Web. Notez que le haut de la page contient `Register` directives pour enregistrer le contrôle utilisateur et l’assembly compilé dynamiquement avec la <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. La page a deux méthodes principales. Le `Button1_Click` méthode crée une connexion entre les contrôles et le `Button2_Click` méthode déconnecte les contrôles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Une fois que vous chargez la page, vous pouvez cliquer sur le **Connect** bouton connecter les contrôles. Si vous entrez du texte dans le contrôle de zone de texte, puis cliquez sur le **entrée** bouton, le texte s’affichera dans le contrôle connecté (il ne s’affichera pas si les contrôles ont été déconnectées). Si vous cliquez sur le **déconnexion** bouton, les contrôles seront déconnectés. Vous pouvez vérifier l’état de connexion des contrôles à l’aide de la **Mode d’affichage** contrôle de liste déroulante pour basculer la page en **Connect** mode. Après cela, cliquez sur le menu d’actions verbales (représenté par une flèche) dans la barre de titre d’un des contrôles, puis sélectionnez le **Connect** élément. L’interface utilisateur de connexion s’affiche ; Il est disponible, car il existe un `<asp:connectionszone>` élément déclaré dans la page. Vous pouvez également vous connecter et déconnecter les contrôles à partir de cette interface utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> n'est pas contenu dans <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> ni dans <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> est en lecture seule.  
  
ou 
 <paramref name="connection" /> a déjà été déconnecté de <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />.  
  
- ou - 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> est en lecture seule.  
  
ou 
 <paramref name="connection" /> a déjà été déconnecté de <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <block subset="none" type="overrides"><para>Vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> méthode si vous souhaitez modifier l’implémentation par défaut pour déconnecter <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> contrôles. Si vous substituez la méthode et que vous souhaitez simplement ajouter une implémentation à la méthode existante, vous pouvez appeler la méthode de base avant d’exécuter votre propre code.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode d'affichage actif pour une page Web qui contient des contrôles WebPart.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> qui détermine le mode d'affichage d'une page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une page qui contient des contrôles WebPart est toujours dans un des divers modes d’affichage possibles. Pour plus d’informations sur les modes d’affichage, consultez [Web Parts Page Display Modes](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe crée les modes d’affichage pour une page Web. À l’aide de la base de <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> (classe), le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle crée plusieurs objets de mode d’affichage standard qui peuvent être utilisés sur les pages qui contiennent des contrôles WebPart. Ces modes d’affichage standard sont décrits dans le <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> vue d’ensemble de la classe.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle gère également les modes d’affichage pour les pages qui utilisent des contrôles WebPart. À l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle conserve une référence à la mode d’affichage actuel sur une page. Vous pouvez également utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété pour basculer d’une page dans différents modes d’affichage. Pour obtenir un exemple de la modification des modes d’affichage sur une page qui utilise des contrôles WebPart, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Dans le cadre de la gestion du mode d’affichage, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle fournit également des événements et gestionnaires d’événements relatifs aux modes d’affichage, telles que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> (méthode) et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> (méthode). Ces méthodes fournissent un mécanisme permettant de personnaliser le comportement d’une page et même pour l’ajout d’un mode d’affichage personnalisé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété. Après le chargement de la page dans un navigateur, vous pouvez utiliser les boutons au bas de la page pour basculer les modes d’affichage. La page est en mode de navigation par défaut lors de son chargement. Si vous basculez en mode Création, vous pouvez faire glisser les contrôles serveur à partir d’une zone à l’autre, ou réorganiser deux contrôles dans une zone. Si vous basculez en mode édition, vous pouvez cliquer sur le menu d’actions verbales dans l’en-tête d’un des contrôles serveur, sélectionnez **modifier**et modifier le contrôle à l’aide de l’interface utilisateur de modification fourni (IU).  
  
> [!NOTE]
>  Bascule entre les modes d’affichage dans une application WebPart est très courant, et vous souhaiterez peut-être fournir un moyen cohérent et réutilisable pour ce faire dans toutes les pages qui contiennent des contrôles WebPart. Pour un exemple d’un contrôle utilisateur que modifications modes d’affichage et qui peut être réutilisé sur plusieurs pages, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> assigné à la propriété est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> assigné à la propriété n'est pas l'un des modes d'affichage pris en charge.  
  
- ou - 
L'objet <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> assigné à la propriété est désactivé.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">Procédure pas à pas : Modification des Modes d’affichage sur une Page WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que le mode d'affichage actuel sur une page WebPart a été modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modes d’affichage font partie intégrante des applications WebPart. Lorsque les utilisateurs basculent vers un mode d’affichage différent sur une page Web, la page prend souvent une apparence très différente, selon l’objectif du nouveau mode d’affichage. Après qu’un mode d’affichage a changé, vous pouvez vouloir apporter certaines modifications à l’interface utilisateur (IU), comme le masquage ou affichage de certains contrôles, modifier l’apparence des éléments d’interface utilisateur sélectionnés et ainsi de suite.  
  
> [!NOTE]
>  Pour plus d’informations sur les modes d’affichage, consultez [Web Parts Page Display Modes](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Pour plus d’informations sur l’utilisation des événements, consultez [Comment : Consommer des événements dans une Application Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un utilisateur a cliqué sur un verbe dans une page Web, ce qui lance le processus de passage à un mode d'affichage différent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modes d’affichage font partie intégrante des applications WebPart. Lorsque les utilisateurs basculent vers un mode d’affichage différent sur une page Web, la page prend souvent une apparence très différente, selon l’objectif du nouveau mode d’affichage. Une fois un utilisateur lance le processus de passage à un nouveau mode d’affichage en cliquant sur un verbe, vous souhaiterez peut-être apporter certaines modifications dans l’interface utilisateur (IU) à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> propriété afin de déterminer quel sera le nouveau mode d’affichage et modification de l’interface utilisateur différentes éléments en conséquence. Un moyen utile pour ce faire consiste à substituer la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> méthode pour personnaliser l’interface utilisateur.  
  
> [!NOTE]
>  Pour plus d’informations sur les modes d’affichage, consultez [Web Parts Page Display Modes](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Pour plus d’informations sur l’utilisation des événements, consultez [Comment : Consommer des événements dans une Application Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection en lecture seule de tous les modes d'affichage associés à un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> qui contient l'ensemble des objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> associés au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> références de propriété de tous les modes d’affichage, contrairement à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété, qui référence uniquement les modes d’affichage qui sont disponibles (pris en charge) sur la page actuelle.  
  
 Deux des modes d’affichage fourni, de parcourir et de conception, sont toujours pris en charge sur une page. Les autres modes d’affichage de trois, edit, catalogue et connexions, sont pris en charge uniquement lorsqu’une page a le type correspondant de zone nécessaire pour un mode d’affichage particulier à utiliser. Par exemple, si votre page ne contient pas une <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone, le mode d’affichage édition s’affiche dans la collection référencée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriété, mais n’apparaîtra pas dans la collection référencée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programmation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriété. Le code utilise cette propriété pour remplir la liste avec tous les modes d’affichage disponibles dans le jeu de composants WebPart, même ceux qui ne sont pas pris en charge sur la page actuelle. Dans ce cas, le catalogue et connecter display modes ne sont pas pris en charge, car leur correspondant requis zones ne sont pas dans la page.  
  
 Les trois autres modes d’affichage - navigation, de conception et d’édition--sont pris en charge sur la page. Modifier le mode est pris en charge, car la page contient un <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone lors de la navigation et les modes de conception sont toujours compatibles.  
  
 Une fois que vous chargez la page dans un navigateur, vous pouvez utiliser le contrôle de liste déroulante pour basculer la page en mode de navigation en mode Création, puis en mode édition. En mode édition, cliquez sur le menu d’actions verbales déroulant dans l’en-tête d’un des contrôles serveur et sélectionnez **modifier** pour modifier le contrôle. Notez que si vous sélectionnez **catalogue** ou **Connect** dans la liste déroulante, une page d’erreur est générée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">Procédure pas à pas : Modification des Modes d’affichage sur une Page WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de toutes les connexions dynamiques existant actuellement sur une page Web.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> qui contient les références à toutes les connexions dynamiques d'une page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les connexions dynamiques sont des connexions créées par programme, par opposition aux statiquement. Connexions statiques sont créées en les déclarant dans le balisage d’une page Web Forms. Les connexions dynamiques sont formées par programme ou par un utilisateur qui crée une connexion à l’aide de l’interface utilisateur de connexion (IU).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> collection, cependant il est en lecture seule et vous ne pouvez pas modifier son contenu, fournit un accès par programme à chaque objet de connexion dynamique.  
  
> [!NOTE]
>  Pour effectuer des opérations courantes telles que la connexion ou la déconnexion <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, les développeurs doivent utiliser les méthodes publiques sur le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe, telle que <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, au lieu d’essayer de modifier directement la connexion objets dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> collection.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le mode d'affichage dans lequel les utilisateurs finaux peuvent éditer et modifier les contrôles serveur. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> références de champ personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objet est créé et contenu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Comme il s’agit d’un objet statique, vous pouvez y faire référence en directement via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sans avoir besoin d’une instance du contrôle.  
  
 Lorsqu’une page qui contient les composants WebPart contrôles du premier chargement, il est en <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (mode de navigation) par défaut. Lorsque les utilisateurs à modifier un contrôle serveur, ils doivent tout d’abord faire basculer la page pour <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (mode édition). Ensuite, ils doivent sélectionner un contrôle de serveur spécifique à modifier, en cliquant sur le verbe de modification sur le menu d’actions verbales dans l’en-tête de ce contrôle. Une fois que le contrôle est en mode édition, l’interface utilisateur (IU) de modification s’affiche pour la modification du contrôle sélectionné.  
  
 Pour activer le mode d’édition sur une page, la page doit contenir au moins un <xref:System.Web.UI.WebControls.WebParts.EditorZone> contrôles de zone qui contient un ou plusieurs d’édition, tels que le <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> contrôle ou les contrôles d’édition personnalisés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment travailler avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> champ par programmation. Le code remplit une liste déroulante avec les modes d’affichage pris en charge pour la page, qui sont dans ce cas de navigation, de conception et d’édition. Pour prendre en charge la modification, un `<asp:EditorZone>` élément se trouve dans la page. Notez que, dans le `Page_PreRender` (méthode), le code vérifie si actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriété est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>. Dans ce cas, `Label1` seront visibles et dans le cas contraire, `Label1` sera masquée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, vous êtes en mode de navigation par défaut. Notez que l’étiquette sur la page est masquée. Utilisez le contrôle de liste déroulante pour basculer la page en mode édition. Notez que, en raison du code dans le `Page_PreRender` méthode, l’étiquette est désormais visible. Cliquez sur le **modifier** verbe dans le menu d’actions verbales sur l’un des contrôles, pour activer la modification de ce contrôle spécifique.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine si le script côté client est activé sur la page Web qui contient un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Valeur Boolean qui indique si le script client peut s'exécuter sur la page. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> propriété offre un moyen aux développeurs de désactiver les scripts client. Justifieraient pour désactiver l’écriture de scripts pour des raisons de sécurité du client, ou pour vous assurer que tous les utilisateurs d’une page auront une expérience utilisateur similaire, même s’ils utilisent différents navigateurs.  
  
 Vous pouvez désactiver les scripts client en ajoutant un `EnableClientScript` attribut le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> élément sur une page Web, comme dans la ligne de code déclaratif suivante :  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 En outre, les développeurs pourront éliminer cette propriété en héritant de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et en définissant la valeur par défaut valeur `false`.  
  
 Le jeu de composants WebPart utilise des scripts client pour fournir une partie du client de l’interface utilisateur (IU) et les fonctionnalités de personnalisation. Si vous désactivez le client de script, composants WebPart contrôles fonctionnent toujours, mais certaines fonctionnalités sont désactivées. La possibilité de faire glisser des contrôles vers différentes zones est désactivée, ainsi que la possibilité de restituer des verbes dans un menu d’actions verbales déroulant dans la barre de titre d’un contrôle (les verbes sont affichés à la place sous forme de liens dans la barre de titre du contrôle).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant que l'utilisation de thèmes est activée sur une page Web.</summary>
        <value>Valeur booléenne indiquant si les thèmes sont activés. <see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control remplace la base de <xref:System.Web.UI.Control.EnableTheming%2A> à garantir qu’elle retourne toujours une valeur de propriété `true`. Pour cela, car les composants WebPart jeu exige le contrôle de l’utilisation de thèmes pour restituer les composants WebPart qui sont des contrôles enfants de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et qui forment l’interface utilisateur (IU) d’une page Web. Par exemple, les thèmes sont utilisés pour restituer les différentes zones, et les contrôles qui résident dans les zones, y compris les différents types de partie des contrôles (contrôles qui héritent de la <xref:System.Web.UI.WebControls.WebParts.Part> classe), contrôles utilisateur, les contrôles serveur ASP.NET et serveur personnalisé contrôles.  
  
 Bien que substituées <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> propriété est implémentée comme une propriété en lecture/écriture conformément à sa propriété de base, vous ne pouvez pas définir la propriété, car par sa conception, elle doit toujours retourner une valeur de `true`. Si vous essayez de définir la propriété, un <xref:System.NotSupportedException> exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Une tentative de définition de la valeur de propriété a été effectuée.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exécute le processus de connexion d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> à un autre contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> méthode termine le processus de connexion un <xref:System.Web.UI.WebControls.WebParts.WebPart> vers un autre contrôle. Il est l’équivalent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> (méthode).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> méthode garantit que l’objet de personnalisation référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété est modifiable, ce qui est nécessaire, car la formation d’une connexion est elle-même un type de personnalisation. La méthode vérifie ensuite que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> objet n’est pas `null`et enfin appelle le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle référencé par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Les développeurs qui souhaitent étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle souhaiterez peut-être substituer cette méthode dans une classe dérivée. Une approche serait d’appeler la méthode de base, puis ajouter une gestion personnalisée supplémentaire ou vous souhaiterez peut-être personnaliser entièrement l’ensemble du processus de fin d’une connexion entre les contrôles.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met fin au processus de modification d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> méthode termine le processus de modification une <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Il est l’équivalent de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> (méthode).  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> méthode garantit que l’objet de personnalisation référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété est modifiable, ce qui est nécessaire, car la modification d’un contrôle est un processus qui nécessite des modifications de personnalisation. La méthode vérifie ensuite que la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> objet n’est pas `null`, de sorte qu’actuellement sélectionné <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle peut changer, et enfin, il appelle le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le contrôle référencé par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Les développeurs qui souhaitent étendre le <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle souhaiterez peut-être substituer cette méthode dans une classe dérivée. Une approche serait d’appeler la méthode de base, puis ajouter une gestion personnalisée supplémentaire ou vous souhaiterez peut-être personnaliser entièrement l’ensemble du processus de fin de la modification d’un contrôle. Par exemple, dans la méthode de substitution, vous pouvez appeler la méthode de base en premier et ensuite ajouter du code qui détermine quelles modifications ont été apportées et affiche la liste des modifications de revenir à l’utilisateur final comme une confirmation.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte d'un message d'avertissement affiché lorsqu'un utilisateur tente d'exporter des données d'état sensibles d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <value>Chaîne qui contient le message d'avertissement. Le message par défaut est une valeur spécifique à la culture fournie par le .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un utilisateur tente d’exporter des données d’état sensibles d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, si les données en cours d’exportation provient d’un membre qui a été marqué comme étant sensible dans le code source, un message d’avertissement s’affiche à l’utilisateur dans une boîte de message, indiquant que exportation des données sensibles et en fournissant une possibilité d’annuler l’exportation. Les développeurs peuvent marquer les données d’un membre spécifique comme sensibles en définissant le `isSensitive` paramètre de la `[Personalizable]` attribut `true` sur le membre. Pour plus d’informations sur cet attribut et le paramètre, consultez la <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> classe.  
  
> [!IMPORTANT]
>  Lorsque vous utilisez la fonctionnalité d’exportation de composants WebPart, les données sensibles peuvent éventuellement être exportées pour les utilisateurs non autorisés. Pour plus d’informations sur la façon de se protéger contre cette menace, consultez [sécuriser les Pages Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 Le message par défaut s’affiche chaque fois que les utilisateurs tentent d’exportation. Toutefois, en affectant une valeur pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriété, vous pouvez fournir un message d’avertissement personnalisé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation déclarative de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriété.  
  
 Le code de la page Web suivante utilise une norme <xref:System.Web.UI.WebControls.BulletedList> et le place dans une zone. Le contrôle sera encapsulé avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle au moment de l’exécution, ce qui lui permet d’agir comme un véritable <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Pour rendre le contrôle exportable, un `ExportMode` attribut est ajouté à la `<asp:bulletedlist>` élément et la valeur d’attribut est définie sur <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, ce qui signifie que ces données sensibles et non sensibles peut être exportée. Notez également que dans le `<asp:webpartmanager>` élément, le `ExportSensitiveDataWarning` attribut est affecté une valeur personnalisée.  
  
 Notez que pour l’exemple de code fonctionne, il existe un paramètre, que vous devez ajouter dans le fichier Web.config pour activer l’exportation des fichiers de description des composants WebPart. Assurez-vous d’avoir un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il y a un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, cliquez sur le menu d’actions verbales (représenté par une flèche vers le bas) dans la barre de titre du contrôle qui contient les liens. Dans le menu d’actions verbales, sélectionnez **exporter**et notez qu’une boîte de message apparaît avec l’avertissement personnalisé. Si vous souhaitez continuer avec l’exportation, cliquez sur **OK**, qui vous permettra d’enregistrer une copie locale d’un fichier de description XML avec toutes les données relatives au contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle à partir duquel les données seront exportées.</param>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> qui écrit les données exportées de <paramref name="webPart" /> dans un fichier de description XML.</param>
        <summary>Crée un fichier de description XML qui contient les données d'état et de propriété du contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> méthode assemble différentes données d’état et de propriété à partir de `webPart` dans un fichier XML. Les données incluent des informations sur le contrôle lui-même, y compris son assembly, les données d’état et les données de propriété. L’utilisateur qui lance l’exportation peut enregistrer le fichier XML sur le disque sur l’ordinateur local ou le réseau. Autres utilisateurs peuvent ensuite importer le fichier de description à une autre page ou un site Web et appliquer les données d’état et de propriété à une autre instance de `webPart`. Fournit un mécanisme rapide et pratique permettant aux utilisateurs de partager et réutiliser leurs paramètres sur des contrôles serveur, et il fournit également aux développeurs un moyen de contrôler l’apparence et le comportement des contrôles exportés et importés.  
  
 Propriétés sur `webPart` ne sont pas exportés par défaut. Pour activer l’exportation d’une propriété, vous devez le marquer avec le `[Personalizable]` attribut dans le code source. Vous pouvez également marquer une propriété exportable comme contenant des données sensibles, en définissant le `isSensitive` paramètre de la `[Personalizable]` attribut `true`. Par défaut, `isSensitive` est `false`. Les développeurs peuvent définir le paramètre `true` pour indiquer que les données sont sensibles.  
  
 Pour activer `webPart` pour l’exportation, un développeur définit sa <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> valeur de la propriété soit <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (qui inclut toutes les propriétés personnalisables et sensibles), ou la valeur <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, qui exporte tout à l’exception des propriétés sensibles .  
  
> [!IMPORTANT]
>  Ce qui permet aux utilisateurs d’exporter des données à partir de contrôles et importer des données dans d’autres contrôles implique certains risques de sécurité. Les développeurs doivent utiliser l’approche décrite ci-dessus pour protéger les données sensibles, et s’ils souhaitent éviter le risque d’exposition des données complètement, ils ne doivent pas activer exportation sur `webPart` du tout. Pour plus d’informations sur les problèmes de sécurité de composants WebPart, consultez [sécuriser les Pages Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.  
  
ou 
 <paramref name="writer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> n'est pas contenu dans la collection de contrôles référencée dans <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
ou 
La propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> de <paramref name="webPart" /> a la valeur <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />, ce qui signifie que l'exportation est désactivée pour <paramref name="webPart" />.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Sécurisation de Web Pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Substitué pour empêcher le focus d'être défini sur le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, compte tenu qu'il n'a pas d'interface utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> méthode substitue à la base de <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> (méthode) et lève une exception si un appelant appelle la méthode. Étant donné que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle sans interface utilisateur et n’est jamais visible aux utilisateurs, il ne peut jamais autoriser le focus à être défini sur lui-même.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Un appelant tente d'appeler la méthode <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />, ce qui n'est pas pris en charge dans un contrôle qui n'a pas d'interface utilisateur.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle serveur qui joue le rôle de consommateur dans une connexion.</param>
        <summary>Récupère la collection d'objets <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> qui peuvent agir comme des points de connexion d'un contrôle serveur qui joue le rôle de consommateur dans une connexion WebPart.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" /> qui contient tous les points de connexion du consommateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une connexion WebPart toujours implique exactement deux contrôles, un agissant comme fournisseur de données, l’autre agissant comme consommateur de données. Chaque contrôle doit avoir une ou plusieurs méthodes qui sont définies en tant que points de connexion. Dans le cas d’un contrôle consommateur, ses points de connexion sont <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> objets. La récupération des points de connexion consommateur est une étape nécessaire dans la formation d’une connexion WebPart.  
  
 Un consommateur doit toujours avoir au moins un point de connexion pour être en mesure d’établir une connexion. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> méthode vérifie un contrôle consommateur et récupère une collection de tous ses points de connexion. Si un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle n’a aucun point de connexion, la méthode retourne une collection vide.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez la rubrique [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Contient le balisage déclaratif pour la page Web `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si une connexion existe déjà et, dans le cas contraire, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble des connexions statiques référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété. Notez que le <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> objet est récupéré à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> méthode est ensuite transmise à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode pour déterminer si une connexion entre les deux contrôles peut être créée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Vous pouvez obtenir ce code et les instructions pour compiler, dans la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois que l’interface utilisateur de connexion (IU) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode). Si vous retournez à cette page dans une session de navigateur ultérieure, cette connexion statique sera déjà établie et n’avez pas besoin être recréés chaque fois que la page se charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Page Web qui contient une instance du <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</param>
        <summary>Récupère une référence à l'instance actuelle du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> sur une page.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> qui référence l'instance actuelle du contrôle sur une page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> méthode est utile dans les contextes où vous souhaitez récupérer une référence à l’actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Est d’un scénario courant où cela pourrait se produire si vous écrivez un contrôle personnalisé qui ne peut pas savoir pendant le développement, le ID de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle sur sa page sera.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> méthode est statique, vous pouvez l’appeler directement sans avoir besoin d’une instance d’un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Certains contrôles dans les composants WebPart jeu de contrôles, tels que <xref:System.Web.UI.WebControls.WebParts.WebPart> , les contrôles ont un <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> propriété qui peut récupérer une référence à l’actuel <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Par conséquent, lorsque vous travaillez avec ces contrôles, vous devez utiliser cette propriété pour récupérer une référence.  
  
 Si vous codez dans un contexte où vous connaissez l’ID de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, telles que l’écriture de code incorporé dans une page Web, il est plus simple et plus efficace de faire référence directement à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle à l’aide de son ID.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>. L’exemple comporte deux parties : un contrôle serveur personnalisé et une page Web qui héberge le contrôle.  
  
 Personnalisé <xref:System.Web.UI.WebControls.Label> de contrôles utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> méthode pour récupérer l’ID de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle sur la page actuelle, puis affiche le code.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 L’exemple de code suivant fournit la page Web qui héberge le contrôle dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, notez que l’ID du cours <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle s’affiche dans personnalisé <xref:System.Web.UI.WebControls.Label> contrôle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle pour lequel la méthode retourne la valeur de <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />.</param>
        <summary>Obtient une chaîne contenant la valeur de la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Chaîne qui contient la valeur calculée de <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> pour <paramref name="webPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtient la valeur calculée de la <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> propriété pour `webPart`. Lorsque les développeurs n’assignent pas une valeur pour le <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> propriété d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, cette méthode produit la valeur à afficher comme titre. La valeur calculée pour les contrôles sans titre se compose d’un nombre ajouté à une chaîne, avec le numéro de séquence d’un contrôle dans la zone actuelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> ne figure pas dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.</exception>
        <block subset="none" type="overrides"><para>Cette méthode peut être substituée pour modifier la façon dont le titre affiché par défaut est calculé.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> en cours d'exportation.</param>
        <summary>Obtient le chemin d'accès virtuel relatif et la chaîne de requête qui font partie de la demande lorsqu'un utilisateur tente d'exporter un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Chaîne contenant le chemin d'accès virtuel relatif et la chaîne de requête qui forment la demande d'exportation d'un contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> méthode est un chemin d’accès virtuel relatif à l’emplacement du serveur de la page qui contient le contrôle, ainsi que la valeur de chaîne de requête ajoutée qui forme la demande d’exportation soumise au serveur. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> méthode encode la chaîne avant d’autoriser la demande à envoyer, protection contre les attaques de script malveillant.  
  
> [!NOTE]
>  Pour plus d’informations sur la sécurisation des applications WebPart, consultez [sécuriser les Pages Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle serveur qui existe dans un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> et qui est encapsulé comme contrôle enfant d'un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> au moment de l'exécution.</param>
        <summary>Obtient une référence à l'instance du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui contient un contrôle serveur.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> qui encapsule <paramref name="control" /> comme contrôle enfant. La méthode retourne <see langword="null" /> si <paramref name="control" /> n'est pas contenu dans un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, il existe deux catégories de contrôles que les développeurs se placent dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones de participer aux applications WebPart : <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, qui hérite de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe de base et d’autres contrôles serveur, qui peuvent être standards Contrôles ASP.NET, les contrôles personnalisés ou les contrôles utilisateur. Lorsque un de ces contrôles est placé dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone, il prend les fonctionnalités d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle a cette fonctionnalité par nature, mais pas les autres types de contrôles serveur. Pour activer les autres contrôles serveur à agir en tant que <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle lorsqu’ils sont placés dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone, ASP.NET les encapsule avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle. Étant donné que le <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle hérite directement de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe, il fournit ses contrôles enfants de véritables fonctionnalités WebPart.  
  
 Souvent au moment de l’exécution, aux développeurs de pages souhaitent obtenir une référence à la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle qui contient l’un des contrôles serveur dans une zone. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> méthode leur permet de récupérer une référence à la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> (méthode). L’exemple de code contient un <xref:System.Web.UI.WebControls.Calendar> contrôle déclaré au sein d’un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone. Le `Button1_Click` méthode imprime tout d’abord l’ID de la <xref:System.Web.UI.WebControls.Calendar> contrôle à une étiquette, puis utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> méthode pour récupérer une référence à la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle qui encapsule le calendrier. L’ID de la <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle et l’ID de son contrôle enfant (qui est le <xref:System.Web.UI.WebControls.Calendar> contrôle), sont imprimés sur une deuxième étiquette.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Contrôle serveur qui joue le rôle de fournisseur dans une connexion.</param>
        <summary>Récupère la collection d'objets <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> qui peuvent agir comme des points de connexion d'un contrôle serveur qui joue le rôle de fournisseur dans une connexion WebPart.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" /> qui contient tous les points de connexion du fournisseur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une connexion WebPart toujours implique exactement deux contrôles, un agissant comme fournisseur de données, l’autre agissant comme consommateur de données. Chaque contrôle doit avoir une ou plusieurs méthodes qui sont définies en tant que points de connexion. Dans le cas d’un contrôle fournisseur, ses points de connexion sont <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> objets.  
  
 Un fournisseur doit toujours avoir au moins un point de connexion pour être en mesure d’établir une connexion. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> méthode vérifie un contrôle fournisseur et récupère une collection de tous ses points de connexion. La récupération des points de connexion fournisseur est une étape nécessaire dans la formation d’une connexion WebPart.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 L’exemple comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Contient le balisage déclaratif pour la page Web `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si une connexion existe déjà et, dans le cas contraire, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble des connexions statiques référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété. Notez que le <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> objet est récupéré à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> méthode est ensuite transmise à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> méthode pour déterminer si une connexion entre les deux contrôles peut être créée.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 La troisième partie de l’exemple est le code source pour les contrôles. Vous pouvez obtenir ce code et les instructions pour compiler, dans la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe.  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois que l’interface utilisateur de connexion (IU) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode). Si vous retournez à cette page dans une session de navigateur ultérieure, cette connexion statique sera déjà établie et n’avez pas besoin être recréés chaque fois que la page se charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /> qui lit les données d'état et de propriété à partir du fichier de description XML importé.</param>
        <param name="errorMessage"><see cref="T:System.String" /> qui s'affiche à l'attention de l'utilisateur si une erreur est rencontrée pendant l'importation.</param>
        <summary>Importe un fichier de description XML qui contient les données d'état et de propriété du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> et applique les données au contrôle.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou contrôle serveur encapsulé par un <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> et par conséquent traité comme un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />) qui est référencé dans le fichier de description XML importé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> méthode importe un fichier de description XML qui a été créé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> méthode pour un contrôle serveur. Il n’est pas le contrôle de serveur réel qui est importé, mais seul le fichier de description contenant les données d’état et de propriété sur le contrôle. Le contrôle et l’assembly référencé dans le fichier de description doivent déjà être disponibles sur le serveur où un utilisateur essaie d’importer le fichier de description.  
  
 Pour activer l’importation d’un contrôle, un développeur doit ajouter un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> contrôle sur la page où l’importation sera activée. Dans la zone, un <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> contrôle doit être ajouté. Ce contrôle fournit une boîte de dialogue qui permet aux utilisateurs de parcourir et recherchez le fichier de description à importer.  
  
 Après qu’un utilisateur trouve un fichier de description et commence l’importation, le fichier de description est lu par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> (méthode). Si aucune erreur et si l’assembly et le contrôle sont trouvés, le contrôle serveur est ajouté au catalogue dans le <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> contrôle et les différentes données de propriété et d’état spécifiées dans le fichier de description sont appliquées au contrôle. L’utilisateur peut ensuite sélectionner le contrôle et l’ajouter à la page.  
  
> [!IMPORTANT]
>  Comme le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> (méthode), le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> méthode a du potentiel pour les risques de sécurité. Parce qu’il implique l’importation de données dans un site Web, un utilisateur malveillant pourrait tenter d’insérer des données incorrectes ou code de script même dans le fichier de description qui est importé. Puis les données incorrectes peut apparaître sur une page ou dans une base de données, ou le script inséré peut s’exécuter. Pour une vue d’ensemble des risques potentiels associés à l’importation de fichiers de description et les façons d’éviter ces risques, consultez [sécuriser les Pages Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" /> n'a pas pu lire le fichier.  
  
- ou - 
 <paramref name="reader" /> devait afficher un message d'erreur d'importation mais n'en a pas trouvé dans le fichier.  
  
ou 
 <paramref name="reader" /> a atteint la fin du fichier sans trouver l'élément XML qui contient les données exportées.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Sécurisation de Web Pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> utilisée pour combiner et séparer un jeu de méthodes qui sont réellement implémentées dans la classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> mais qui sont surtout utiles aux développeurs de contrôles.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> via lequel un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> peut référencer les différentes méthodes qui ont été séparées dans <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété expose les API à appeler dans un jeu de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> méthodes sont utilisées principalement dans les cas d’extensibilité.  
  
 La manière prévue d’utiliser ces méthodes internes est d’y accéder via le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriété. Étant donné que la propriété est protégée, vous pouvez uniquement y accéder et appeler les méthodes dans une instance de la <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe en héritant de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe.  
  
> [!NOTE]
>  Cette propriété est masquée à partir d’IntelliSense dans [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]. Toutefois, dans une dérivée <xref:System.Web.UI.WebControls.WebParts.WebPartManager> (classe), vous pouvez toujours accéder à la propriété et ses différents membres.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur peut être ajouté à une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Partie de la flexibilité de la fonctionnalité de composants WebPart est la possibilité d’ajouter des contrôles serveur aux pages Web en cours d’exécution. Il existe un certain nombre des scénarios courants dans lesquels un contrôle serveur (qui peut être personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, un contrôle serveur personnalisé, un contrôle utilisateur ou un contrôle ASP.NET) peut être ajouté.  
  
 Dans les scénarios courants suivants, le contrôle WebPart ensemble tente d’ajouter des contrôles serveur à une page et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode est appelée pour les autoriser :  
  
-   Lorsqu’un contrôle serveur est ajouté en le déclarant dans le balisage d’une page Web dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone.  
  
-   Quand un contrôle serveur est ajouté par programme à une zone.  
  
-   Quand un utilisateur importe un contrôle serveur dans un catalogue de composants WebPart de contrôles.  
  
-   Quand un existant, contrôle serveur est chargé à partir du magasin de données de personnalisation.  
  
-   Lorsqu’un contrôle serveur est ajouté à un <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> contrôle pour le rendre disponible dans un catalogue de contrôles serveur.  
  
 Dans chaque scénario dans lequel les contrôles sont ajoutés, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode est appelée pour s’assurer que tous les critères d’autorisation ont été remplies pour permettre un contrôle à ajouter. Lorsqu’un contrôle est autorisé, il est ajouté normalement comme il le serait si il y a aucun scénario de filtrage. Lorsqu’un contrôle n’est pas autorisé, le jeu de composants WebPart peut répondre de plusieurs façons, selon le contexte. Le jeu de contrôles peut échouer en mode silencieux ajouter une partie non autorisée (s’il est inutile d’informer l’utilisateur), il peut afficher un message d’erreur, ou il peut ajouter une instance de la <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> classe comme un espace réservé. Cet objet d’espace réservé n’est pas visible sur la page, mais est visible dans le code source de page pour indiquer qu’un contrôle non autorisé a été exclu.  
  
 Le déterminant d’indique si un contrôle est autorisé est le filtre d’autorisation. Un filtre d’autorisation est une fonctionnalité dans le jeu de composants WebPart qui permet aux développeurs d’exclure d’une page tous les contrôles qui ne répondent pas aux critères spécifiés.  
  
 Pour créer un scénario de filtrage, les développeurs doivent faire deux choses. Tout d’abord, ils doivent assigner une valeur de chaîne (la valeur peut être arbitraire) à la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> ils prévoient d’utiliser dans le scénario de contrôle. Ils peuvent également affecter une valeur à cette propriété pour les autres types de contrôles serveur qui ne sont pas <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, étant donné que s’ils sont placés dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones, ces contrôles sont encapsulés dans un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle au moment de l’exécution et ce contrôle hérite de le <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété.  
  
 La deuxième étape nécessaire pour la création d’un scénario de filtrage est soit de substituer le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> (méthode), ou pour créer un gestionnaire d’événements pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement. Dans ces méthodes, un développeur peut vérifier le <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété, et si la valeur indique que le contrôle ne doit pas être autorisé, le développeur s’assure que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode retourne une valeur de `false`.  
  
> [!NOTE]
>  Pour des exemples de code et une description de la configuration d’un scénario de filtrage personnalisé à l’aide du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), consultez les rubriques pour les surcharges de la méthode.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur dont l'autorisation est vérifiée.</param>
        <summary>Exécute les étapes initiales en déterminant si l'ajout d'un contrôle à une page est autorisé.</summary>
        <returns>Valeur Boolean qui indique si <paramref name="webPart" /> peut être ajouté à une page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode est la méthode initiale appelée par le contrôle WebPart défini pour vérifier l’autorisation pour un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Il accepte `webPart` en tant que paramètre et lance un processus qui finalement détermine si le contrôle sera ajouté à une page. Appelez cette méthode à partir de votre code directement lorsque vous avez besoin déterminer si un contrôle donné est autorisé.  
  
 Cette méthode effectue les tâches initiales permettant de déterminer si le contrôle hérite de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe ou est un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> contrôle et, dans ce cas, quel type de contrôle enfant qu’il contient. Pour terminer la tâche d’autorisation, il appelle le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> méthode à partir de votre code pour déterminer si un contrôle est autorisé à être ajouté à une page.  
  
 L’exemple de code comprend trois parties :  
  
-   Personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle qui substitue le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode).  
  
-   Une page Web qui crée un filtre pour un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle.  
  
-   Une explication de l’exécution de l’exemple de code.  
  
 Cet exemple de code utilise un personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle qui substitue le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> surcharge de méthode pour fournir une gestion personnalisée de la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété. Ce contrôle vérifie une valeur de propriété `admin` et, si la valeur est présente, autorise le contrôle. Si un contrôle a une valeur différente, il n’est pas autorisé ; contrôles sans la valeur de propriété sont autorisés, car elles sont censées de ne pas faire partie du scénario de filtrage.  
  
 Pour exécuter cet exemple de code, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise la méthode de compilation dynamique. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 La deuxième partie de l’exemple de code crée un filtre qui peut potentiellement exclure un contrôle. La page Web suivante contient trois contrôles de serveur ASP.NET dans un `<asp:webpartzone>` élément. Notez que les première et deuxième contrôles ont leur <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriétés définies sur des valeurs différentes, et le troisième n’affecte pas la propriété. Cette valeur d’autorisation peut être vérifiée au moment de l’exécution, et le contrôle peut être ajouté à la page si le filtre correspond aux critères définis par le développeur. Notez également que dans le `Page_Load` (méthode), le code appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> méthode pour déterminer si chacun des contrôles est autorisé et, si par conséquent, elle définit de chaque contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Notez que pour l’exemple de code fonctionne, vous devez ajouter un paramètre dans le fichier Web.config pour activer l’exportation des fichiers de description des composants WebPart. Assurez-vous d’avoir un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il y a un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Une fois que vous chargez la page dans un navigateur, notez que le premier contrôle est affiché, car il correspond aux critères dans la méthode substituée. Le deuxième contrôle n’est pas ajouté à la page, car il est exclu par le filtre. Le troisième contrôle est également ajouté, car il n’a pas son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> jeu de propriétés. Notez que si vous cliquez sur l’icône de menu d’actions verbales dans la barre de titre d’un contrôle, ils peuvent tous deux être exporté, car leurs respectifs <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> valeurs de propriété ont été affectées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Cette méthode est appelée directement à partir de votre code. Si vous souhaitez mieux contrôler par programmation sur le processus d’autorisation, vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> surcharge de méthode.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> du contrôle qui est vérifié pour autorisation.</param>
        <param name="path">Chemin d'accès relatif de l'application au fichier source pour le contrôle autorisé, s'il s'agit d'un contrôle utilisateur.</param>
        <param name="authorizationFilter">Valeur de chaîne arbitraire assignée à la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, utilisée pour autoriser l'ajout d'un contrôle à une page.</param>
        <param name="isShared">Indique si le contrôle qui est vérifié pour autorisation est un contrôle partagé, c'est-à-dire visible pour la plupart ou tous les utilisateurs de l'application et si sa propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> a la valeur <see langword="true" />.</param>
        <summary>Exécute les étapes finales en déterminant si l'ajout d'un contrôle à une page est autorisé.</summary>
        <returns>Valeur Boolean qui indique si l'ajout d'un contrôle à une page est autorisé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> la surcharge de méthode exécute les étapes finales en déterminant si un contrôle est autorisé à être ajouté à une page. La méthode garantit que `type` est un type valide et que `path` a une valeur uniquement si le contrôle en cours de vérification est un contrôle utilisateur. Ensuite, il appelle la critique <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode), ce qui déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> méthode pour déterminer si un contrôle est autorisé à être ajouté à une page.  
  
 La première étape consiste à créer un filtre qui peut potentiellement exclure un contrôle. La page Web suivante contient trois contrôles de serveur ASP.NET dans un `<asp:webpartzone>` élément. Notez que les première et deuxième contrôles ont leur <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriétés définies sur des valeurs différentes, et le troisième n’affecte pas la propriété. Cette valeur d’autorisation peut être vérifiée au moment de l’exécution, et le contrôle peut être ajouté à la page si le filtre correspond aux critères définis par le développeur.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 La deuxième étape consiste à remplacer le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> (méthode) et créer la gestion personnalisée pour les filtres d’autorisation. Notez que le code vérifie d’abord si la propriété a la valeur, afin que tout contrôle qui n’affecte pas le <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété sera ajoutée automatiquement. Si un contrôle a un filtre, le code retourne `true` uniquement si la valeur de filtre est égale à `admin`. Cet exemple montre un mécanisme simple, que vous pouvez utiliser pour afficher certains contrôles à certains utilisateurs, en fonction de leur rôle. Bien qu’il soit un exemple complet à l’aide de rôles dépasse le cadre de cette rubrique, vous pouvez utiliser la même logique que la méthode substituée dans cet exemple de code, à ceci près que vous pouvez vérifier si l’utilisateur actuel est dans un rôle qui correspond à la valeur de filtre d’autorisation , puis ajoutez le contrôle uniquement pour cet utilisateur. Cela vous permettrait de créer des pages où certains utilisateurs verriez tous les contrôles et les autres utilisateurs voudraient voir uniquement les contrôles sélectionnés. Voici comment la logique qui vérifie le filtre peut se présenter si vous avez utilisé des rôles :  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise la méthode de compilation dynamique. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 Une fois que vous chargez la page dans un navigateur, notez que le premier contrôle est affiché, car il correspond aux critères dans la méthode substituée. Le deuxième contrôle n’est pas ajouté à la page, car sa valeur de filtre est exclu. Le troisième contrôle est ajouté, car il n’a pas son <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> jeu de propriétés. Si vous modifiez la valeur de propriété sur le deuxième contrôle correspond à celui du premier contrôle, puis exécutez à nouveau la page, le deuxième contrôle est également ajouté.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> est un contrôle utilisateur et <paramref name="path" /> est soit <see langword="null" />, soit une chaîne vide ("").  
  
ou 
 <paramref name="type" /> n'est pas un contrôle utilisateur et <paramref name="path" /> a une valeur qui lui est assignée.</exception>
        <block subset="none" type="overrides"><para>Cette méthode peut être substituée en héritant de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, si vous souhaitez fournir une gestion supplémentaire lors de la vérification d’autorisation. Vous souhaiterez peut-être substituer la méthode afin de vérifier certaines valeurs le <paramref name="authorizationFilter" /> paramètre et selon la valeur, retourner une valeur booléenne qui détermine si le contrôle sera ajouté à une page.  
  
Pour les développeurs de pages qui souhaitent également de vérifier les filtres d’autorisation et de fournir une gestion personnalisée, il existe une option pour faire en ligne dans une page .aspx, ou dans un fichier code-behind, sans avoir à hériter de toutes les classes. Vous pouvez déclarer un gestionnaire d’événements de remplacement dans la page pour le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> méthode de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> contrôle. Pour plus d’informations et un exemple, consultez le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> (méthode).</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les modifications de personnalisation apportées affectent les détails de personnalisation au niveau de la page contrôlés par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Valeur Boolean qui indique si des modifications de personnalisation ont été apportées. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de contrôles utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> propriété en interne pour suivre si les données qu’il gère la personnalisation au niveau de la page a été modifiée. Les données de personnalisation sont modifiées lorsque les utilisateurs exécutent différentes actions de personnalisation au niveau de la page, comme l’ajout ou suppression <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, la connexion ou la déconnexion des contrôles, la modification de la mise en page en déplaçant des contrôles et autres actions.  
  
> [!NOTE]
>  Les utilisateurs peuvent effectuer également la personnalisation au niveau du contrôle, ce qui signifie que les utilisateurs apporter des modifications de personnalisation à un contrôle spécifique, et les modifications affectent uniquement ce contrôle. Un exemple serait le contrôle d’édition et modifier le texte du titre ou sa couleur d’arrière-plan. La personnalisation au niveau du contrôle n’affecte pas les données de personnalisation au niveau de la page suivies par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et donc la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> valeur de propriété n’est pas modifiée pour `true` lorsque la personnalisation au niveau de contrôle se produit.  
  
 Bien que la méthode est protégée et ne peut pas être accessible directement par un appelant, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété est accessible directement par les appelants, et elle retourne la valeur de cette propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Contient les données d'état persistantes à charger.</param>
        <summary>Charge les données d'état du contrôle qui ont été enregistrées par une demande de page antérieure et doivent être restaurées sur une demande ultérieure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> méthode est utile pour restaurer les données de propriété qui doivent être persistante pendant les publications (postback) d’une page, même lorsque le <xref:System.Web.UI.Control.EnableViewState%2A> propriété est définie sur `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" /> n’est pas un <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> valide.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> contenant les données d’état à charger.</param>
        <summary>Stocke les données de personnalisation qui ont été transmises au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> par les objets de personnalisation, en vue d’une utilisation ultérieure pendant le processus d’initialisation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> méthode fournit des données d’état enregistrées sous la forme d’un <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> objet. Ces données sont utilisées par la suite pour charger des données de personnalisation dans les contrôles WebPart et effectuer d’autres tâches d’initialisation.  
  
> [!NOTE]
>  Cette méthode est appelée par une séquence de méthodes qui commence lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> méthode demande initialement associé <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> objet pour fournir des données de personnalisation à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Vous ne pouvez pas appeler cette méthode directement à partir de votre code. Vous pouvez, toutefois, directement appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> (méthode), qui elle-même appelle la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> méthode et retourne les données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</summary>
        <value>Objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.PermissionSet> objet qui est retourné par cette propriété est utilisée lors de l’importation pour la désérialisation de type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</summary>
        <value>Obtient un objet <see cref="T:System.Security.PermissionSet" /> qui autorise uniquement l'autorisation <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> et l'autorisation <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Security.PermissionSet> objet retourné par cette propriété est utilisée lors de l’importation pour tout sauf la désérialisation de type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur déplacé.</param>
        <param name="zone"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> cible vers laquelle <paramref name="webPart" /> est déplacé.</param>
        <param name="zoneIndex">Un entier qui indique l'index de <paramref name="webPart" /> par rapport aux autres contrôles de <paramref name="zone" />.</param>
        <summary>Déplace un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur d'une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> à l'autre ou à une nouvelle position dans la même zone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de contrôles utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode pour déplacer `webPart` vers un nouvel emplacement dans la même zone ou dans une zone différente. Vous pouvez appeler cette méthode directement à partir du code, et il est également appelée lorsqu’un utilisateur déplace un contrôle vers une nouvelle position à l’aide de différentes options dans l’interface utilisateur de composants WebPart (IU).  
  
 Un certain nombre de conditions doit être remplie avant `webPart` peut être déplacé, et la plupart d'entre elles est indiquée par les éléments répertoriés dans la section Exceptions de cette rubrique. Si `webPart` n’étaient pas incluses dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone pour commencer, il ne peut pas être déplacé dans une zone.  
  
 Une fois que les conditions sont remplies, la séquence d’actions suivante se produit pour déplacer `webPart`:  
  
1.  La méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> déclenche l'événement <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>.  
  
2.  `webPart` est supprimé de sa zone actuelle (si nécessaire) et ajouté à sa nouvelle zone ou une nouvelle position dans sa zone actuelle.  
  
3.  La méthode <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> déclenche l'événement <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>.  
  
4.  Le `zoneIndex` de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle dans les zones d’origine et de destination est réinitialisé pour refléter le contrôle déplacé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment appeler le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode directement à partir de code pour déplacer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle d’un fuseau vers un autre.  
  
 L’exemple de code comprend trois parties :  
  
-   Un contrôle utilisateur pour la modification des modes d’affichage.  
  
-   Une page Web pour héberger les contrôles.  
  
-   Une explication de l’exécution de l’exemple de code.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple est une page Web qui contient deux zones, chacune contenant deux contrôles serveur. Lorsqu’un utilisateur clique sur le **déplacer le WebPart** bouton sur la page, le code dans le `Button1_Click` méthode déplace un contrôle à partir de la première zone vers une nouvelle position dans la deuxième zone. Notez que le code doit tout d’abord appeler la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> méthode pour récupérer le <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objet qui encapsule le `list1` contrôle. Cela est nécessaire car le premier paramètre de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode requiert un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler, tandis que `list1` est un contrôle serveur ASP.NET.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 Une fois la page chargée, cliquez sur le **déplacer le WebPart** bouton et notez que le contrôle qui contient les liens se déplace à la position centrale dans la deuxième zone. Ce déplacement du contrôle s’effectue par programmation en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> (méthode). Vous pouvez également utiliser le **Mode d’affichage** contrôle de liste déroulante pour basculer la page en mode design et en mode Création, vous pouvez faire glisser les contrôles vers différentes zones ou des positions différentes dans leurs zones. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> méthode est également appelée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> déplace du contrôle pour gérer ces initiée par l’utilisateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> n'est pas contenu dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
ou 
 <paramref name="zone" /> n'est pas contenu dans la collection <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
ou 
La zone référencée par la propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> du contrôle <paramref name="webPart" /> est <see langword="null" />, ce qui signifie que <paramref name="webPart" /> n'est pas contenu actuellement dans une zone.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> ou <paramref name="zone" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> est inférieur à zéro.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" /> qui contient des données d’événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> et appelle un gestionnaire pour l'événement, le cas échéant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode est appelée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), quand un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est en cours de vérification pour l’autorisation à ajouter à une page. Lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode est appelée, elle déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, et s’il existe une méthode de gestionnaire pour l’événement, il appelle le gestionnaire.  
  
 Le processus d’autorisation <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles est une fonctionnalité importante de composants WebPart. Chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur qui est ajouté à une zone par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle passe par un processus d’autorisation pour déterminer si le contrôle peut être ajouté. Par défaut, le jeu de composants WebPart ne fournit pas les critères de filtrage pour empêcher l’ajout à une zone de contrôles. Mais le jeu de contrôles fournit les mécanismes nécessaires aux développeurs de créer leurs propres critères de filtrage. À l’aide de ces mécanismes, vous pouvez créer des scénarios de filtrage personnalisés. Par exemple, vous pouvez créer un filtre afin que, si un utilisateur est dans un rôle d’administrateur, certains contrôles seraient ajoutés à une zone lors de la page est affichée, et si l’utilisateur est dans un rôle d’utilisateur, ces contrôles ne seront pas ajoutés.  
  
 Les mécanismes de filtrage des contrôles pendant le processus d’autorisation sont la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété sur <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> et <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthodes et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement sur le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle.  
  
 Pour créer un scénario de filtrage, il existe essentiellement deux tâches. Tout d’abord, vous assignez des chaînes à la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle que vous souhaitez filtrer. Ces valeurs de chaîne peuvent être arbitraires, mais elles doivent contenir les critères que vous souhaitez filtrer. Par exemple, si vous souhaitez un contrôle donné à ajouter à un zone uniquement si un administrateur utilisateur consulte la page, vous pouvez affecter une valeur de chaîne de `admin` à la propriété. Vous pouvez ensuite utiliser la fonctionnalité de rôles ASP.NET et ajouter tous les utilisateurs de votre site à différents rôles, administrateur et utilisateur manager. Lors du chargement d’une page, votre code de filtrage voulez-vous vérifier quel rôle un utilisateur est en cours, comparez-la à la valeur de filtre d’autorisation sur un contrôle en cours de vérification et si (par exemple) l’utilisateur est dans un rôle d’administrateur et que vous avez défini le contrôle <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valeur à `admin`, le contrôle peut être ajouté.  
  
 La deuxième étape de création d’un scénario de filtrage consiste à écrire du code pour vérifier la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> des valeurs de propriété sur <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle et déterminer si chaque contrôle est autorisé avant d’être ajouté à sa zone. Il existe deux options pour où placer ce code de filtrage. La première option est l’option recommandée pour les développeurs de pages. Vous pouvez créer une méthode pour gérer la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement directement dans le code de script de page Web server, ou dans un fichier de séparation de code. Associer votre méthode à l’événement en ajoutant le `OnAuthorizeWebPart` d’attribut à la balise pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler dans la page, comme indiqué dans l’exemple de code de balisage suivant.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 Tout votre méthode personnalisée a à faire est de vérification de chaque <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle pour les critères de filtrage et puis, en fonction des résultats, affecter une valeur booléenne pour la <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> propriété de la <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> objet pour indiquer si le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle peut être ajouté. Le code dans la section exemple montre comment effectuer cette opération.  
  
 La deuxième option permettant de savoir où placer votre code de filtrage consiste à hériter de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe et substituer une méthode pour vérifier les critères de filtre. Les deux méthodes que vous pouvez remplacer pour faire sont la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> méthode ou le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode). Bien que les deux méthodes fonctionnent, dans la plupart des cas, il est préférable de substituer le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), car vous offre un meilleur contrôle par programmation sur le processus d’autorisation ensemble, tandis que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> méthode n'effectue qu’une seule tâche spécifique , qui consiste à déclencher l’événement et à vérifier un gestionnaire. Pour obtenir un exemple de code de personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe qui remplace le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> (méthode), consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de la méthode.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir un gestionnaire d’événements personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> événement, afin que le gestionnaire puisse fournir un code de filtrage personnalisé pour la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> (méthode). Cet exemple serait un moyen classique pour un développeur de pages de fournir un scénario de filtrage et l’autorisation de <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles à ajouter à une page.  
  
 Dans la page Web, notez que le `<asp:webpartmanager>` élément a le `OnAuthorizeWebPart` attribut avec le nom du Gestionnaire d’événements qui lui est assigné. La méthode vérifie si les contrôles sur la page ont leur respectifs <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> les valeurs de propriété définies sur `admin` et, dans ce cas, retourne `true`, ce qui signifie qu’ils seront autorisés et ajoutés à la page.  
  
> [!NOTE]
>  Notez que les contrôles qui n’ont pas de n’importe quelle valeur affectée à la <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriété sont également ajoutés, car ils sont supposés ne pas pour faire partie d’un scénario de filtrage. Il s’agit d’une approche courante dans un scénario de filtrage : certains contrôles sont filtrés, et d’autres ne serait pas, elles sont censées être disponibles pour tous les utilisateurs.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 Configuration d’utilisateurs dans les rôles étant dépasse le cadre de cette rubrique, cet exemple de code ne vérifie pas les rôles d’utilisateur dans le filtrage. Toutefois, le scénario de filtrage des contrôles en fonction des rôles d’utilisateur est susceptible d’être une des utilisations plus courantes de cette fonctionnalité de filtrage. Si vous disposez de rôles sur votre site et que vous souhaitez vérifier les rôles d’utilisateur dans cette méthode pour filtrer les contrôles, la méthode peut se présenter comme le bloc de code suivant (par opposition à l’approche plus simple dans l’exemple de code précédent, qui n’utilise pas de rôles).  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> pour indiquer qu'une page et ses contrôles sont chargés, et que les connexions sur la page ont été activées pour commencer le partage des données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> événement après qu’une page a terminé le processus de chargement. La méthode fournit un moyen d’ajouter un gestionnaire pour l’événement.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnConnectionsActivated` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> pour indiquer qu'une page et ses contrôles ont été chargés et que le processus d'activation des connexions peut commencer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> événement, qui fournit aux développeurs un mécanisme permettant de personnaliser par programmation le processus d’activation des connexions.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnConnectionsActivating` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" /> qui contient les données d'événement associées à un mode d'affichage modifié.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> pour indiquer que le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> a terminé le processus de basculement d'un mode d'affichage à l'autre sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> méthode dans la base de son formulaire lève simplement le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> (méthode). Par exemple, après un changement de mode d’affichage, vous souhaiterez peut-être modifier quelque chose dans l’apparence de l’interface utilisateur (IU), en fonction de l’affichage qui mode est contenu dans le <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> propriété. Ou vous souhaiterez peut-être certains contenus de masquer ou afficher un certain contrôle.  
  
Lorsque vous substituez la méthode, vous devez normalement appeler la méthode de base comme la dernière étape de la méthode substituée, afin que votre code personnalisé s’exécute en premier, et l’événement est déclenché en dernier, indiquant que le changement de mode est terminé.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement associées à un changement de mode d'affichage.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> pour indiquer que le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> est en train de basculer d'un mode d'affichage à l'autre sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> méthode dans la base de son formulaire lève simplement le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous pouvez remplacer le <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> (méthode). Par exemple, que la modification d’un mode d’affichage, vous souhaiterez peut-être vérifier quel sera le nouveau mode d’affichage (à l’aide de la <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> propriété) et modifier quelque chose dans l’interface utilisateur (IU) en fonction de ce que sera le nouveau mode d’affichage. Si vous aviez un mode d’affichage personnalisé, vous souhaiterez probablement rendre certains contrôles visibles si le mode personnalisé sera le nouveau mode d’affichage.  
  
Lorsque vous substituez cette méthode, vous devez normalement appeler la méthode de base comme la première étape de la méthode substituée, afin que l’événement est déclenché pour indiquer qu'un mode d’affichage commence à modifier. Ensuite, votre code personnalisé peut apporter des modifications dans l’interface utilisateur (IU) avant que le nouveau mode d’affichage est réellement affiché.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Init" /> qui est le premier événement dans le cycle de vie du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> méthode appelle la méthode de base, ce qui déclenche la <xref:System.Web.UI.Control.Init> événement pour le contrôle, puis exécute plusieurs étapes préparatoires, telles que de telle sorte qu’une seule instance de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control sur une page et le chargement données de personnalisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il existe un autre contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> dans la page.</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.PreRender" /> qui se produit juste avant qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ne soit rendu sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> méthode appelle la méthode de base, ce qui déclenche la <xref:System.Web.UI.Control.PreRender> contrôle l’événement du contrôle et registres plusieurs scripts de client qui sont nécessaires sur les pages qui contiennent des composants WebPart.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />, qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été récemment sélectionné ou dont la sélection a fait l'objet d'une suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> événement, qui est généralement un point dans le temps où un développeur peut souhaiter modifier l’apparence de l’interface utilisateur (IU). Par exemple, lorsqu’un nouveau <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est sélectionné, le contrôle WebPart jeu modifie le rendu du contrôle qui vient d’être sélectionné. Une fois la sélection d’un contrôle est désactivée, le rendu est retourné à la normale.  
  
 Une fois un utilisateur sélectionne un particulier <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle pour la modification, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode est appelée. Lorsque l’utilisateur a fini de modifier le contrôle et le ferme, avec le résultat que la sélection du contrôle est désactivée, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode est appelée à nouveau.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Il existe plusieurs options relatives à la <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> événement, pour permettre aux développeurs de personnaliser le rendu qui se produit après que le contrôle sélectionné a été modifié. Dans le code déclaratif, dans le <see langword="&lt;asp:webpartmanager&gt;" /> élément que vous pouvez définir le <see langword="OnSelectedWebPartChanged" /> attribut et lui affecter le nom d’une méthode personnalisée. Dans la méthode personnalisée, vous pouvez modifier le rendu des contrôles sélectionnés lorsque l’événement se produit. Une autre option consiste à hériter de la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe et substituer la méthode. Une troisième option consiste à personnaliser le rendu au niveau de la zone ; par exemple, vous pouvez hériter la <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> classe et substituer sa <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> (méthode), pour personnaliser le rendu des contrôles sélectionnés et effacés pendant le processus de modification.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> qui se produit pendant le processus de changement du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> actuellement sélectionné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement qui se produit pendant le processus de changement <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle actuellement sélectionné.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle utilise cette méthode et l’événement associé, pour fournir la possibilité d’annuler un processus dans lequel le contrôle sélectionné est modifié. Par exemple, la méthode est appelée au sein de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> (méthode) et également dans le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> (méthode), afin de fournir un moyen d’annuler le processus. Si un utilisateur clique sur le verbe cancel sur un contrôle qui est en cours de modification, le contrôle n’est plus sélectionné et les modifications apportées ne sont pas enregistrées, car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> méthode vous permet d’annuler les modifications.  
  
> [!NOTE]
>  La méthode est appelée même pendant les méthodes qui commencent et terminent le processus de connexion un <xref:System.Web.UI.WebControls.WebParts.WebPart> vers un autre contrôle, pour permettre l’annulation de ce processus.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événements en ajoutant le `OnSelectedWebPartChanging` attribut le `<asp:webpartmanager>` élément dans le balisage de page déclaratif et en affectant à l’attribut le nom d’une méthode personnalisée.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement associées à la suppression du contrôle.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.Control.Unload" /> de base et supprime l'instance de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> d'une page Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été ajouté à une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> méthode est appelée pendant le processus d’ajout d’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou autre contrôle serveur qui est ajouté à un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone) à une page.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événements en ajoutant le `OnWebPartAdded` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> qui se produit au cours du processus d'ajout d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou d'un contrôle serveur ou utilisateur) à une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> événement pour indiquer qu’un contrôle est en cours d’ajout. La méthode offre également la possibilité d’annuler le processus d’ajout. Si le contrôle est ajouté avec succès, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartAdding` attribut le `<asp:webpartmanager>` élément sur une page Web et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> méthode pour personnaliser la gestion des événements.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> pour signaler qu'un contrôle a été supprimé d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement pour indiquer qu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou autre contrôle serveur ou utilisateur) a été fermé avec succès sur une page.  
  
 Pour fermer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle signifie le supprimer à partir d’une page afin qu’il n’est pas restitué, et également du pour placer dans un spécial objet appelé un catalogue de pages. Un catalogue de pages, qui correspond à la <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôler, conserve les références à fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles pour chaque page. Si un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôle est déclaré sur une page dans un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, les utilisateurs peuvent basculer la page en mode d’affichage catalogue et ajouter à la page tous les contrôles précédemment fermés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> méthode offre la possibilité aux développeurs de créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement. Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnWebPartClosed` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut. Une tâche utile qu’un développeur peut exécuter dans cette méthode consiste à afficher un espace réservé à la place du contrôle fermé, avec une info-bulle qui informera les utilisateurs comment ajouter le contrôle à la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> qui se produit au cours du traitement d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou d'un contrôle serveur supprimé d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement pour indiquer qu’un contrôle est en cours de fermé ou supprimé d’une page. La méthode offre également la possibilité d’annuler le processus de fermeture. Si le contrôle est correctement supprimé de la page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartClosinging` attribut le `<asp:webpartmanager>` élément sur une page Web et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été supprimé définitivement d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> méthode est appelée pendant le processus de suppression une <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou autre contrôle serveur qui est ajouté à un <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zone) à partir d’une page.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événements en ajoutant le `OnWebPartDeleted` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> qui indique qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique (ou contrôle serveur ou utilisateur contenu dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />) est en cours de suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uniquement dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles peuvent être supprimés, et lorsqu’un contrôle est supprimé, l’instance de contrôle est supprimé définitivement d’une page et ne peut pas être restauré. Dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles sont ceux qui sont ajoutés par programmation ou à partir d’un catalogue de composants WebPart, par opposition aux contrôles statiques qui sont déclarés dans le balisage d’une page Web.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> événement pour indiquer qu’un contrôle est supprimé définitivement de sa zone. La méthode fournit également la possibilité d’annuler le processus de suppression. Si le contrôle est correctement supprimé de la page, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartDeleting` attribut le `<asp:webpartmanager>` élément sur une page Web et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> qui se produit après qu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été déplacé à un emplacement différent sur une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement à la fin de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> (méthode), ce qui garantit que le processus de déplacement d’un contrôle est terminé avant que tout code de l’événement gestionnaire s’exécute.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement est déclenché lorsqu’un contrôle est déplacé dans sa zone actuelle, ou à une autre zone, et il n’a pas d’importance si le déplacement est effectué par programme ou à un utilisateur en faisant glisser le contrôle.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événements en ajoutant le `OnWebPartMoved` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> qui indique qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou un contrôle serveur ou utilisateur dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> est en cours de déplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> événement qui se produit lorsqu’un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou autre contrôle serveur est déplacé dans sa zone ou vers une autre zone. La méthode fournit également la possibilité d’annuler le processus de déplacement. Si le déplacement est terminé, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartMoving` attribut le `<asp:webpartmanager>` élément sur une page Web et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> méthode pour personnaliser la gestion des événements.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> qui se produit après qu'une connexion a été établie entre des contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> méthode déclenche son événement correspondant à la fin de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> (méthode), ce qui garantit que les étapes nécessaires pour connecter deux contrôles sont effectuées avant l’exécution de code dans le Gestionnaire d’événements.  
  
 La méthode fournit un contrôle par programmation sur le processus de création de connexions et l’événement associé est un point pratique auquel mettre à jour de l’interface utilisateur (IU) ou notifier un utilisateur qu’une connexion a été établie.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événements en ajoutant le `OnWebPartsConnected` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> qui se produit au cours du processus d'établissement d'une connexion entre deux <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur ou utilisateur contenus dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> événement qui se produit lorsque deux contrôles tentent d’établir une connexion. La méthode offre la possibilité d’annuler la tentative de connexion. Si la connexion est établie, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartsConnecting` attribut le `<asp:webpartmanager>` élément sur une page Web et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> qui se produit après qu'une connexion entre contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a pris fin.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> méthode déclenche son événement correspondant à la fin de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> (méthode), qui exécute le processus d’arrêt d’une connexion entre deux contrôles.  
  
 La méthode fournit un contrôle par programmation sur le processus de clôture de connexion, afin que les développeurs peuvent informer l’utilisateur, apporter des modifications à l’interface utilisateur (IU), ou apporter d’autres modifications à l’application.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événements en ajoutant le `OnWebPartsDisconnected` attribut le <`asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> qui indique que deux <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur ou utilisateur dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> sont en cours de clôture de connexion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> méthode déclenche la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement qui se produit lorsque deux contrôles mettent fin à une connexion. La méthode offre la possibilité d’annuler le processus de déconnexion. Si la connexion est supprimée avec succès, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement suit.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement associé en ajoutant le `OnWebPartsDisconnecting` attribut le `<asp:webpartmanager>` élément sur une page Web et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs qui créent dérivées <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> les classes peuvent substituer la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> méthode pour personnaliser la gestion des événements.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à un objet qui contient des données de personnalisation pour une page Web.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> qui contient des données de personnalisation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété offre un moyen d’accéder à la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> objet qui est associé à une page via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. À l’aide de cette propriété, vous pouvez accéder les différents membres de l’objet de personnalisation. Par exemple, vous pouvez utiliser la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> méthode pour basculer la portée de personnalisation de la page à partir de partagé à la portée utilisateur, ou vice versa. Découvrez la portée de personnalisation actuelle de la page, si la personnalisation est encore activée sur la page, le fournisseur utilisé pour les données de personnalisation et bien plus encore.  
  
 Notez que les données référencées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété est uniquement les données de personnalisation au niveau de la page sont suivies par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle. Les données de personnalisation spécifiques au contrôle, telles que les valeurs des propriétés personnalisables sur <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, est ne fait pas partie de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété.  
  
> [!NOTE]
>  Pour plus d’informations sur la personnalisation des WebParts, consultez [Web Parts Personalization Overview](https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété par programmation.  
  
 La page Web suivante permet à un utilisateur à entrer en mode édition pour modifier certains aspects de la <xref:System.Web.UI.WebControls.Calendar> contrôle. Le **bascule étendue** bouton bascule la page utilisateur ou de la portée de personnalisation partagées. Le **Mode d’édition** et **Browse Mode** boutons font basculer la page dans le mode d’affichage approprié. Notez que dans le `<script>` balise section du fichier, deux des méthodes qui gèrent les événements utilisent le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété pour accéder aux membres utiles de l’objet sous-jacent. Plus précisément, ces méthodes utilisent la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> (méthode) et le <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> propriété sur l’objet accédé via la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 Pour l’exemple de code à exécuter, vous devez également activer un ou plusieurs utilisateurs à personnaliser des pages en portée partagée. Ajouter une entrée au fichier Web.config, dans la `<system.web>` section, il semble que le balisage suivant.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 Une fois que vous chargez la page dans un navigateur, cliquez sur le **bascule étendue** bouton et notez que la page indique à présent la portée partagée. Cliquez sur **Mode d’édition** pour modifier le mode d’affichage, cliquez sur le menu d’actions verbales sur le contrôle visible, puis sélectionnez **modifier** à partir du menu. Notez que l’interface utilisateur (IU) pour les deux contrôles d’édition s’affiche. Cliquez maintenant sur **Browse Mode** pour retourner à la navigation normale. Si la page indique qu’il est en portée partagée, cliquez sur **bascule étendue** à nouveau pour vous assurer de la page est dans la portée de l’utilisateur. Ensuite, suivez les mêmes étapes pour modifier le contrôle à nouveau, mais notez qu’à présent dans l’interface utilisateur de modification, le <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> contrôle n’apparaît pas. C’est parce que ce contrôle fonctionne uniquement lorsque la page est dans la portée de personnalisation partagées.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Vue d’ensemble de personnalisation de parties Web</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Autorise le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> à émettre un script côté client utilisé pour diverses fonctionnalités de personnalisation, telles que le glisser-déplacer de contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dans une page Web.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> qui reçoit le contenu du contrôle à écrire sur la page.</param>
        <summary>Substitué pour empêcher le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de rendre du contenu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre les données d'état du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de manière à ce que les données puissent être restaurées sur demande ultérieure à la page Web qui contient le contrôle.</summary>
        <returns><see cref="T:System.Object" /> pour contenir les données d'état enregistrées du contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> méthode enregistre les données d’état pour les propriétés qui doivent être rendues persistantes entre les postbacks de page, même lorsque le <xref:System.Web.UI.Control.EnableViewState%2A> propriété est définie sur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> contenant les données d’état à charger.</param>
        <summary>Enregistre les données d'état de personnalisation personnalisées conservées dans le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, de manière à ce que ces données puissent être rechargées à chaque fois que la page est rechargée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> méthode est critique en cours de personnalisation, car il permet aux paramètres utilisateur personnalisés doivent être enregistrées pour les futures sessions de navigateur et de visites à une page. La méthode enregistre les données d’état de personnalisation personnalisées, qui inclut des éléments tels que les éléments suivants : dynamique <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôles serveur qui ont été ajoutés à une page ou supprimés à partir d’une page ; les contrôles qui ont été déplacés sur une page ; et les connexions dynamiques qui ont été créé ou supprimé.  
  
 Vous ne pouvez pas appeler cette méthode directement à partir de votre code. Vous pouvez, toutefois, appelez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> (méthode), qui elle-même appelle cette méthode pour enregistrer les données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les développeurs peuvent substituer cette méthode dans une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe pour personnaliser le processus d’enregistrement des données de personnalisation.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou un autre contrôle serveur actuellement sélectionné pour modifier ou pour créer une connexion avec un autre contrôle.</summary>
        <value>Contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> actuellement sélectionné pour modifier ou former une connexion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriété retourne une référence à un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou autre contrôle serveur actuellement sélectionné pour la modification ou de création d’une connexion avec un autre contrôle.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle fournit plusieurs méthodes et événements utiles pour gérer le processus de sélection d’un contrôle. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement se produit juste après qu’un contrôle est sélectionné, mais avant que des modifications sont apportées. Pour exécuter certaines actions sur le contrôle qu’elle est sélectionnée, substituez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> (méthode). Par exemple, vous souhaiterez peut-être modifier l’apparence d’un contrôle qui est sélectionné mais n’a pas encore modifié pour souligner visuellement le contrôle sélectionné.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> événement se produit juste après le contrôle sélectionné a été modifié. Pour exécuter certaines actions sur le contrôle lorsqu’il a modifié, substituez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que la sélection d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a été modifiée et déplacée vers un autre contrôle d'une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement peut être utilisé conjointement avec la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> méthode pour modifier l’interface utilisateur (IU) d’un contrôle sélectionné. Par exemple, si l’utilisateur bascule la page en mode de conception (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>), puis sélectionne un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle avec l’intention du faire glisser vers une nouvelle position, il est courant pour modifier le rendu du contrôle sélectionné, par exemple en modifiant la couleur de son bordure ou un arrière-plan lorsqu’il est sélectionné.  
  
> [!NOTE]
>  Pour plus d’informations sur l’utilisation des événements, consultez [Comment : Consommer des événements dans une Application Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de modification du <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur actuellement sélectionné sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement peut être utilisé conjointement avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> (méthode). Les développeurs de pages peuvent créer un gestionnaire d’événements dans leur code en ajoutant le `OnSelectedWebPartChanging` attribut le `<asp:webpartmanager>` élément dans une page et définissez la valeur de l’attribut sur le nom d’une méthode personnalisée qui gérera l’événement.  
  
 Cet événement est déclenché pendant le processus de début ou de fin d’une connexion entre les contrôles et lorsque le début et de fin d’une modification d’un contrôle. Pour plus d’informations, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> (méthode).  
  
 Normalement, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> événement est déclenché comme résultat direct de l’action d’un utilisateur qui modifie le contrôle sélectionné, l’événement peut être annulée. Toutefois, il est un scénario dans lequel l’événement ne peut pas être annulée. Si un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> contrôle est supprimé, le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qu’il contient doivent tous être fermés, sinon ils seraient orphelin. Dans ce cas le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle se ferme le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, pas l’utilisateur et il doivent déterminer quel contrôle est actuellement sélectionné et modification de la sélection sans risque d’interruption, afin qu’il peut terminer le processus de nettoyage tous les contrôles. Par conséquent, par conception le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> méthode ne peut pas être annulée dans ce scénario. Pour un événement associé qui peut être annulé, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit un indicateur qui signale que les données de personnalisation personnalisées du contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ont été modifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> méthode définit un indicateur qui provoque finalement les composants de personnalisation dans le contrôle WebPart défini pour enregistrer les données de personnalisation mises à jour. Pour plus d’informations sur les scénarios qui peuvent provoquer des modifications apportées aux données de personnalisation suivies par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> du contrôle, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> méthode ne peut pas être appelée directement à partir de votre code et ne peut pas être substituée, car elle est utilisée en interne par le contrôle WebPart défini comme faisant partie de la fonctionnalité de personnalisation WebPart.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La méthode peut être appelée par une dérivée <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe. Il se peut que cela peut être utile si vous souhaitez personnaliser les composants du contrôle WebPart définie et doivent à contrôler le processus de définition d’indicateurs pour les données de personnalisation de personnalisation.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur qui a été sélectionné.</param>
        <summary>Définit la valeur de propriété <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> égale au <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> actuellement sélectionné ou au contrôle serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> méthode est appelée pendant les processus de début ou de fin de modification du contrôle spécifié par le `webPart` paramètre et ceux qui démarrent ou mettez fin à une connexion qui inclut `webPart`.  
  
 Au début des processus de modification et de connexion, `webPart` est le contrôle qui a été sélectionné pour être modifié ou pour entrer une connexion.  
  
 À la fin des processus de modification et de connexion, `null` est passé à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> (méthode), ce qui entraîne le contrôle actuellement sélectionné n’est plus sélectionné.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une chaîne vide ("") de manière à ce qu'aucune apparence ne puisse être appliquée au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Chaîne vide qui empêche le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> d'avoir une apparence assignée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> héritées de substitutions de propriété <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> propriété pour empêcher le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle, qui est un contrôle invisible, d’utiliser des apparences. L’implémentation de la propriété empêche une apparence d’être assignée en retournant toujours une chaîne vide à partir de la `get` accesseur et toujours en levant une exception si une tentative pour définir une valeur la `set` accesseur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Une tentative de définition de la valeur de propriété a été effectuée.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la collection de tous les objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> d'une page Web définis comme des connexions statiques.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> qui contient toutes les connexions statiques de la page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété est utilisée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour suivre et gérer toutes les connexions statiques sur une page. Une connexion statique, contrairement à une connexion dynamique, n’a pas besoin être ajouté à une page chaque fois que la page est affichée.  
  
 La collection référencée par cette propriété contient toutes les connexions statiques qui existent dans la page, qu’ils soient créées par programmation ou spécifiés avec un `<asp:webpartconnection>` élément dans le balisage de la page.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programme de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui permet de modifier les modes d’affichage sur une page WebPart.  
  
-   Un fichier de code source qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles et une interface personnalisée.  
  
-   Une page Web qui contient deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés, et un `<asp:webpartmanager>` élément.  
  
-   Explication du fonctionne de l’exemple dans un navigateur.  
  
 Le code suivant contient uniquement la partie de la page Web de l’exemple. Vous devrez également obtenir les deux premières parties de l’exemple - le contrôle utilisateur personnalisé et le code source pour les contrôles personnalisés et l’interface--à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Cette rubrique décrit également vos options de compilation la <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles.  
  
 La troisième partie de l’exemple de code est la page Web. Contient le balisage déclaratif pour la page `Register` directives pour le contrôle utilisateur et les contrôles personnalisés. Il existe un `<asp:webpartmanager>` élément, un `<asp:webpartzone>` élément doit contenir les contrôles personnalisés et un `<asp:connectionszone>` élément. Notez que dans le `Page_Load` (méthode), le code vérifie si une connexion existe déjà et, dans le cas contraire, définit un fournisseur, un consommateur et leurs points de connexion respectifs, puis ajoute une nouvelle connexion à l’ensemble des connexions statiques référencé par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriété.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Une fois que vous avez chargé la page Web dans un navigateur, cliquez sur le **Mode d’affichage** le contrôle de liste déroulante et sélectionnez **Connect** pour basculer la page en mode connexion. Le mode connexion utilise le `<asp:connectionszone>` élément pour vous permettre de créer des connexions entre les contrôles. Dans le mode de connexion, cliquez sur la flèche vers le bas dans la barre de titre de la **Code postal** contrôler pour activer son menu d’actions verbales, puis cliquez sur **Connect**. Une fois que l’interface utilisateur de connexion (IU) s’affiche, notez qu’une connexion a déjà été créée par le code contenu dans le `Page_Load` (méthode). Si vous retournez à cette page dans une session de navigateur ultérieure, cette connexion statique sera déjà établie et n’avez pas besoin être recréés chaque fois que la page se charge.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection en lecture seule de tous les modes d'affichage disponibles sur une page Web particulière.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> qui contient l'ensemble des objets <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> disponibles sur une page Web spécifique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété contient uniquement les modes d’affichage qui sont réellement disponibles sur une page, compte tenue des types de contrôles de zone présents sur la page.  
  
> [!NOTE]
>  Modes d’affichage peuvent être désactivés, et lorsqu’un mode d’affichage est désactivé, il n’est pas ajouté à la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> collection, même lorsque le type de zone qui prend en charge ce mode d’affichage correspondant est présent sur la page.  
  
 Mode de navigation et le mode de conception sont toujours pris en charge. Les modes d’affichage qui peuvent varier sont la modification, catalogue et modes de connexion. Chacun de ces modes d’affichage est associé à un type particulier de <xref:System.Web.UI.WebControls.WebParts.ToolZone> contrôle. C’est la présence de cette zone spécialement typée sur une page Web qui provoque un mode d’affichage particulier à ajouter à la collection référencée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété. Par exemple, si une page Web contient un <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone, mais pas un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> de zone, puis le mode d’affichage édition est un des modes pris en charge sur cette page, mais le mode d’affichage catalogue n’est pas pris en charge.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété diffère de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriété, qui fait référence à une collection contenant tous les modes d’affichage qui sont disponibles pour le cours <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, y compris celles qui ne sont pas pris en charge sur une page particulière.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation par programmation de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriété. Le code utilise cette propriété pour remplir la liste avec uniquement les modes d’affichage disponibles dans la page Web actuelle.  
  
 Il existe trois pris en charge les modes d’affichage sur cette page : Parcourir, conception et à modifier. Les deux premiers sont toujours disponibles, et le mode édition est disponible dans cet exemple de code, car la page contient un <xref:System.Web.UI.WebControls.WebParts.EditorZone> contrôle. Le catalogue et connecter display modes ne sont pas affichés, car leurs zones correspondantes ne sont pas sur cette page.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, vous pouvez utiliser le contrôle de liste déroulante pour basculer la page en mode de navigation en mode Création, puis en mode édition. En mode édition, cliquez sur le menu d’actions verbales déroulant dans l’en-tête d’un des contrôles serveur et sélectionnez **modifier** pour modifier le contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modes d’affichage des pages WebPart</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les données d'état de personnalisation personnalisées gérées par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ont été modifiées sur une page Web.</summary>
        <value>Valeur Boolean qui indique si les données d'état de personnalisation ont été modifiées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété offre un moyen aux appelants de déterminer si l’état de personnalisation données qui sont gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a changé. Lorsque les utilisateurs personnaliser les détails au niveau de la page, par exemple en modifiant la mise en page, la création ou la suppression des connexions et ajout ou suppression de contrôles, les données de personnalisation gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle change. Il s’agit d’une méthode directe qui retourne aux appelants la valeur de l’élément protégé <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> propriété, qui ne peut pas être directement accessible aux appelants.  
  
> [!NOTE]
>  Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété n’indique pas si les valeurs de propriété personnalisables ou les propriétés individuelles qui affectent l’apparence de l’individu <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, ont été modifiés. Personnalisation au niveau de contrôle est suivie pour chaque contrôle individuellement. Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriété indique uniquement si les données de personnalisation qui est au niveau de la page et est géré par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a changé.  
  
 La liste suivante décrit quelques instances courantes de personnalisation qui entraînerait la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> à retourner une valeur de propriété `true`, qui indique qui le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle possède des données de personnalisation modifiées :  
  
-   Fermeture statique <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle (ou contrôle serveur ou utilisateur) sur une page.  
  
-   Restauration statique fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle à partir d’un catalogue de pages à une page.  
  
-   Le déplacement n’importe quel contrôle dans sa zone ou vers une autre zone.  
  
-   Ajout d’un contrôle à partir d’un catalogue de <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôles serveur ou ajout d’un contrôle par programmation.  
  
-   Création d’une connexion entre deux <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, soit par programme ou à l’aide de l’interface utilisateur de connexion (IU).  
  
-   Suppression d’une connexion entre deux <xref:System.Web.UI.WebControls.WebParts.WebPart> des contrôles, soit par programme ou à l’aide de l’interface utilisateur de connexion.  
  
 Pour accéder à cette valeur de propriété, vous devez caster la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instance de contrôle à la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interface ; vous pouvez ensuite en lecture la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> valeur de propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre une utilisation simple du <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> instances de la propriété, pour indiquer une personnalisation de page courantes qui entraînent un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> des données de personnalisation du contrôle à modifier.  
  
 L’exemple de code comprend quatre parties :  
  
-   Un contrôle utilisateur qui vous permet de modifier les modes d’affichage sur une page qui contient des contrôles WebPart.  
  
-   Un fichier source qui contient le code pour l’installation personnalisée de deux <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qui peuvent être connectés et une interface.  
  
-   Une page Web qui héberge tous les contrôles.  
  
-   Explication du fonctionne de l’exemple de code.  
  
 La première partie de l’exemple de code est le contrôle utilisateur pour la modification des modes d’affichage. Vous pouvez obtenir le code source pour le contrôle utilisateur à partir de la section exemple de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager> vue d’ensemble de la classe. Pour plus d’informations sur les modes d’affichage et le fonctionnement du contrôle de l’utilisateur, consultez [procédure pas à pas : Page de parties de modification des Modes d’affichage sur un serveur Web](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 La deuxième partie de l’exemple est le fichier source avec les contrôles personnalisés et l’interface. Notez que le `IZipCode` interface expose une méthode, et que cette méthode comme implémenté dans personnalisé `ZipCodeWebPart` contrôle sert à une méthode de rappel pour activer `ZipCodeWebPart` d’agir en tant que fournisseur dans un scénario de connexion. L’autre contrôle, `WeatherWebPart`, contrôle et agit comme consommateur dans une connexion ; il peut consommer l’interface particulière fournie par `ZipCodeWebPart`. Dans une application réelle, `WeatherWebPart` peut consommer une valeur de Code postal personnalisée à partir du fournisseur, puis fournir des informations météo graphiques aux utilisateurs.  
  
 Pour l’exemple de code à exécuter, vous devez compiler ce code source. Vous pouvez compiler explicitement et placer l’assembly résultant dans le dossier Bin de votre site Web ou le global assembly cache. Vous pouvez également mettre le code source dans le dossier App_Code de votre site, où il sera compilé dynamiquement au moment de l’exécution. Cet exemple de code utilise la compilation dynamique ; Par conséquent, notez que le `Register` directive pour ce composant en haut de la page Web contient uniquement `TagPrefix` et `Namespace` attributs sans un `Assembly` attribut. Pour une procédure pas à pas qui montre comment compiler, consultez [procédure pas à pas : Contrôle serveur Web de développement et à l’aide d’un](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 La troisième partie de l’exemple de code est la page Web. Notez qu’il contient deux <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zones, par la première contenant deux personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. Il existe également un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone qui contient une norme <xref:System.Web.UI.WebControls.Calendar> contrôle que les utilisateurs peuvent ajouter à la page. Le `<asp:connectionszone>` élément fournit une interface utilisateur pour créer des connexions entre les contrôles de connexion. Dans le `Page_PreRender` (méthode), notez qu’il vérifie si les données de personnalisation ont changé et, le cas échéant, met à jour le texte de `Label1`.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 Une fois que vous chargez la page dans un navigateur, essayez de créer quelques-uns des scénarios répertoriés dans la section Notes de cette rubrique qui va changer les données de personnalisation. Lorsque vous apportez des modifications différentes, lorsqu’une modification implique un des scénarios de personnalisation suivis par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler, le texte de la `Label1` contrôle s’affiche pour indiquer que les données de personnalisation ont changé. Par exemple, vous pouvez :  
  
-   Créer une connexion entre les contrôles en cliquant sur le **connecter les contrôles WebPart** bouton.  
  
-   Utilisez le **Mode d’affichage** contrôle de liste déroulante pour basculer la page en mode catalogue et ajouter la **mon calendrier** contrôle à la seconde <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone.  
  
-   Modification de la page de revenir au mode de navigation, cliquez sur le menu d’actions verbales (indiqué par une flèche dans la barre de titre) pour le **mon calendrier** contrôler, puis sélectionnez **fermer** pour le fermer et l’ajouter au catalogue de pages.  
  
-   Retourner la page en mode catalogue et ajouter la **mon calendrier** contrôle à la page.  
  
-   Utilisez le **Mode d’affichage** contrôler pour basculer la page en mode design et réorganisez la disposition des contrôles en faisant glisser un ou plusieurs d'entre eux vers une autre zone, ou vers un autre emplacement dans la même zone.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart .NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> contenant les données d’état à charger.</param>
        <summary>Retourne les données d’état de personnalisation précédemment enregistrées à charger dans le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une implémentation de la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> (méthode), qui offre un moyen pour le contrôle WebPart défini pour accéder directement à l’élément protégé <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> (méthode). Lorsque cette méthode est appelée, elle stocke les données de personnalisation personnalisées qui sont gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle et qui a été précédemment enregistré dans le magasin de données permanent pour une utilisation plus loin dans le processus d’initialisation.  
  
> [!NOTE]
>  Dans la plupart des cas, code de développeur de page et le contrôle est inutile d’appeler cette méthode, car il est principalement utilisé par le contrôle WebPart définir en tant que mécanisme de récupération des données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Un scénario dans lequel les développeurs utiliseraient cette méthode pour développer une infrastructure de personnalisation personnalisées à utiliser à la place de celui fourni par le jeu de contrôles WebPart. Dans ce cas, les développeurs puissent hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe et substituer les <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> méthode pour retourner une implémentation personnalisée d’un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet. Personnalisé <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet appellerait l’implémentation de la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> méthode au moment approprié pour charger des données de personnalisation personnalisées.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> qui contient les données d'état à enregistrer.</param>
        <summary>Enregistre les données d'état de personnalisation personnalisées qui sont gérées par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> méthode est une implémentation de la <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> (méthode), qui offre un moyen pour le contrôle WebPart défini pour accéder directement à l’élément protégé <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> (méthode). Lorsque cette méthode est appelée, elle enregistre toutes les données personnalisées sont gérées par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle au magasin de données permanentes configuré pour une application WebPart.  
  
> [!NOTE]
>  Dans la plupart des cas, code de développeur de page et le contrôle est inutile d’appeler cette méthode, car il est principalement utilisé par le contrôle WebPart définir en tant que mécanisme d’enregistrement des données de personnalisation.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Un scénario dans lequel les développeurs utiliseraient avec cette méthode pour développer une infrastructure de personnalisation personnalisées à utiliser à la place de celui fourni par le jeu de contrôles WebPart. Dans ce cas, les développeurs puissent hériter la <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe et substituer les <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> méthode pour retourner une implémentation personnalisée d’un <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet. Personnalisé <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objet appellerait l’implémentation de la <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> méthode au moment approprié pour enregistrer les données de personnalisation personnalisées.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Applique les données d'état de personnalisation au contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> et appelle la méthode de base pour activer le suivi des modifications apportées aux données d'état d'affichage du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les modifications apportées à l’état d’affichage de données sont stockées dans un <xref:System.Web.UI.StateBag> de l’objet et sont accessibles par le biais du contrôle <xref:System.Web.UI.Control.ViewState%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui permet aux contrôles enfants d'être visibles.</summary>
        <value>Valeur booléenne indiquant si un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> et ses contrôles enfants sont visibles. <see langword="true" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control remplace la base de <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> à toujours retourner une valeur de propriété `true` pour le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriété. Bien que le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle proprement dit n’est pas visible, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriété doit être définie sur `true` afin que tous ses contrôles enfants sont visibles par défaut.  
  
 Si vous essayez de définir la valeur de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriété, il génère toujours une erreur, car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle a remplacé le comportement de la propriété de base et empêche de lui assigner une valeur à la propriété.  
  
 Cette propriété n’est pas pouvant être liée dans les concepteurs visuels, mais peut être liée à l’exécution. Pour plus d'informations, consultez <xref:System.ComponentModel.BindableAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Une tentative d'assignation d'une valeur à la propriété a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique ou autre contrôle serveur a été ajouté à une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, pour indiquer que le contrôle a été ajouté avec succès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement est utile pour indiquer qu’un contrôle dynamique (contrôle ajouté par programme, par opposition à déclaré dans le balisage de page) a été ajouté à une zone. Conjointement avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> (méthode), l’événement fournit aux développeurs un moyen de mettre à jour l’interface utilisateur (IU) ou de notifier les utilisateurs qu’un contrôle a été ajouté avec succès.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit pendant le processus d'ajout d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique ou d'un autre contrôle serveur à une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> événement est déclenché par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> méthode une fois le processus d’ajout d’un contrôle à une zone a commencé. Cet événement offre la possibilité d’annuler le processus avant la fin. Si le processus d’ajout est réussi, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> événement.  
  
 Les développeurs de pages peuvent fournir des gestionnaires personnalisés pour l’événement en ajoutant le `OnWebPartAdding` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou un contrôle serveur ou utilisateur) est supprimé d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement indique qu’un contrôle a été fermé avec succès, par un utilisateur ou par programmation. Pour fermer un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle signifie le supprimer à partir d’une page afin qu’il n’est pas restitué, et également du pour placer dans un spécial objet appelé un catalogue de pages. Un catalogue de pages, qui correspond à la <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôler, conserve les références à fermé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles pour chaque page. Si un <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> contrôle est déclaré sur une page dans un <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, les utilisateurs peuvent basculer une page en mode d’affichage catalogue et ajouter à une page tous les contrôles précédemment fermés.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> (méthode), qui déclenche l’événement et lui fournit un gestionnaire.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant un `OnWebPartClosed` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de suppression d'un contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou d'un contrôle serveur ou utilisateur) d'une page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> méthode lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle est en cours de fermeture d’un contrôle. Si la suppression du contrôle est réussie, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> événement.  
  
 Les développeurs de pages peuvent fournir un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartClosed` d’attribut à la <`asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 Normalement, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement est déclenché comme conséquence directe d’une fermeture de l’utilisateur un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, l’événement peut être annulée. Toutefois, il est un scénario dans lequel l’événement ne peut pas être annulée. Si un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> contrôle est supprimé, le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qu’il contient doivent tous être fermés, sinon ils seraient orphelin. Dans ce cas le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle se ferme le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, pas l’utilisateur. Et à quel moment le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle est en cours de l’appel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> méthode pour fermer chaque contrôle et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement est déclenché, l’événement ne peut pas être annulée (par conception), car le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> a besoin d’effectuer la tâche de nettoyage tous les contrôles de la zone.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou autre contrôle serveur a été supprimé d'une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement est utile pour indiquer qu’un contrôle dynamique (contrôle ajouté par programme, par opposition à déclaré dans le balisage de page) a été supprimé d’une zone. Conjointement avec le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> (méthode), l’événement fournit aux développeurs un moyen de mettre à jour l’interface utilisateur (IU) ou de notifier les utilisateurs qu’un contrôle a été supprimé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de suppression définitive d'une instance d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dynamique ou d'un autre contrôle serveur d'une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> (méthode), pendant le processus de suppression d’un contrôle dynamique (celui qui a été ajouté par programme ou par un utilisateur via l’interface utilisateur de composants WebPart). L’événement offre la possibilité d’annuler le processus avant la fin. Si le processus de suppression est terminé avec succès, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> événement.  
  
 Les développeurs de pages peuvent fournir des gestionnaires personnalisés pour l’événement en ajoutant le `OnWebPartDeleting` attribut le `<asp:webpartmanager>` élément dans une page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôle serveur a été déplacé vers un emplacement différent sur une page Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement s’applique à la fois statique (déclaré dans le balisage d’une page Web) et des contrôles dynamiques. Il est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> (méthode). Étant donné que l’événement est déclenché après qu’un déplacement est terminé, les développeurs peuvent inclure un gestionnaire d’événements pour fournir une notification aux utilisateurs, une validation ou d’autres actions. Pour ajouter un gestionnaire d’événements, vous pouvez ajouter un `OnWebPartMoved` attribut le `<asp:webpartmanager>` élément dans une page et attribuez le nom d’une méthode personnalisée à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de déplacement d'un <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou d'un autre contrôle serveur contenu dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> événement est déclenché quand un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou un autre contrôle serveur est déplacé dans sa propre zone, ou à une autre zone. Cela peut se produire lorsqu’un utilisateur fait glisser un contrôle, et lorsqu’il existe un déplacement par programmation.  
  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> événement est déclenché par la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> méthode et qu’elle offre la possibilité d’annuler le processus de déplacement avant la fin. Si le déplacement est terminé et que le contrôle soit placé dans une nouvelle position, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> événement.  
  
 Les développeurs de pages peuvent créer un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartMoving` attribut le `<asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à tous les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> suivis par le contrôle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> d'une page Web.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> qui contient des références à un jeu de composants <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété est utilisée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle pour effectuer le suivi de toutes les <xref:System.Web.UI.WebControls.WebParts.WebPart> les contrôles qui sont contenus dans <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones sur la page. Bien que la collection est en lecture seule, vous pouvez accéder à individuels <xref:System.Web.UI.WebControls.WebParts.WebPart> par programmation des contrôles via les collection et apporter des modifications à leur.  
  
> [!NOTE]
>  Il est possible d’avoir un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle placé sur une page en dehors d’un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone, ce qui entraîne le contrôle ne pas suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôler ou référencés dans son <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> collection. Toutefois, il est recommandé d’utiliser un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôler en dehors d’une zone, car il perd ses fonctionnalités WebPart et agit comme un contrôle serveur normal.  
  
 N’importe quel type de contrôle qui peut être placé dans une zone, si un personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle, un contrôle ASP.NET standard, un contrôle utilisateur ou un contrôle serveur personnalisé, peut être traité comme un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle au moment de l’exécution. Lorsqu’un contrôle qui n’est pas un <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle est placé dans un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zone, en cours d’exécution ASP.NET encapsule le contrôle avec un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet, afin que le contrôle peut se comporter comme un véritable <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôle. Par conséquent, à l’aide de la <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété, le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle peut effectuer le suivi de n’importe quel type de contrôle de serveur, indépendamment de si elle est dérivée de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété par programmation à accès individuel <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles. Notez que dans le balisage déclaratif pour la page Web, dans le `<asp:webpartzone>` élément sont deux des contrôles serveur ASP.NET standard. Bien que ceux-ci n’héritent pas de la <xref:System.Web.UI.WebControls.WebParts.WebPart> classe, car elles se trouvent dans une zone, ils sont encapsulés dans un <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> de l’objet en cours d’exécution et donc être inclus dans la collection référencée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété. Vous pouvez également ajouter personnalisé <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, des contrôles utilisateur ou serveur personnalisé contrôle dans cette zone, et elles sont gérées de la même façon.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 Notez que pour l’exemple de code fonctionne, vous devez ajouter un paramètre dans le fichier Web.config pour activer l’exportation des fichiers de description des composants WebPart. Assurez-vous d’avoir un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il y a un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Après avoir chargé la page dans un navigateur, si vous cliquez sur le **nombre de WebPart** bouton, le code utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriété à retourner le nombre de contrôles dans la collection. Si vous cliquez sur le **masquer le titre du calendrier** bouton, le code modifie le calendrier afin qu’il génère le rendu avec seulement une bordure et non un titre.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'une connexion spécifique a été établie entre des contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou contrôles serveur ou utilisateur).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> (méthode). L’événement est utile, car une fois que vous savez qu’une connexion est terminée, vous souhaiterez peut-être informer l’utilisateur du fait, ou même modifier l’interface utilisateur (IU) de la page. Par exemple, vous souhaiterez peut-être afficher une image de graphique qui suggère une connexion réussie entre deux contrôles ou afficher un bref message et modifiez le mode d’affichage page Reprenons le mode de navigation.  
  
 Les développeurs de pages peuvent associer un gestionnaire d’événements personnalisé à cet événement en ajoutant le `OnWebPartsConnected` attribut le `<asp:webpartmanager>` élément dans la page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de création d'une connexion entre les contrôles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou les contrôles serveur ou utilisateur placés dans une zone <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> (méthode), et il signale que le processus de connexion a commencé (par exemple, un utilisateur a sélectionné un contrôle et cliqué sur un verbe connect), mais n’est ne pas encore terminée. L’événement offre la possibilité d’annuler une connexion avant la fin. Si la connexion est terminée avec succès, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> événement.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartsConnecting` attribut le `<asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après qu'il a été mis fin à une connexion entre deux <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement est associé le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> (méthode). L’événement est utile, car une fois que vous savez qu’une connexion est interrompue, vous souhaiterez peut-être informer l’utilisateur, effectuer des actions de nettoyage dans le code ou apporter d’autres modifications dans l’interface utilisateur (IU).  
  
 Les développeurs de pages peuvent associer un gestionnaire d’événements personnalisé à cet événement en ajoutant le `OnWebPartsDisConnected` attribut le `<asp:webpartmanager>` élément dans la page et en assignant un nom de méthode personnalisé à l’attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit au cours du processus de clôture de connexion entre des <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou contrôles serveur précédemment connectés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement est déclenché par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> (méthode) et il signale le fait qu’un utilisateur a cliqué sur un verbe disconnect, ou le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> méthode a été appelée autrement. L’événement offre la possibilité d’annuler le processus de clôture de connexion avant la fin. Si la connexion est terminée avec succès, cet événement est suivi par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> événement.  
  
 Les développeurs de pages peuvent ajouter un gestionnaire personnalisé pour l’événement en ajoutant le `OnWebPartsDisconnecting` attribut le `<asp:webpartmanager>` élément et en assignant un nom de méthode personnalisé à l’attribut.  
  
 Normalement, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement est déclenché comme résultat direct de l’action d’un utilisateur qui met fin à une connexion, l’événement peut être annulée. Toutefois, il existe plusieurs scénarios dans lesquels l’événement ne peut pas être annulée. Le premier scénario est, si un <xref:System.Web.UI.WebControls.WebParts.WebPartZone> contrôle est supprimé, le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles qu’il contient doivent tous être fermés, sinon ils seraient orphelin. Dans ce cas le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle se ferme le <xref:System.Web.UI.WebControls.WebParts.WebPart> contrôles, pas l’utilisateur et il doivent également être en mesure de terminer les connexions de tous les contrôles connectés sans risque d’interruption, afin qu’il peut terminer le processus de nettoyage et de fermeture tous les contrôles. Par conséquent, par conception le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> méthode ne peut pas être annulée dans ce scénario. Pour un événement associé qui peut être annulé, consultez le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> événement.  
  
 Le deuxième scénario dans lequel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement ne peut pas être annulé est lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> méthode est appelée (appelée pendant chaque demande à une page, par exemple), et il existe un type de conflit dans les connexions existantes sur une page. Par exemple, un utilisateur connecte le contrôle x au contrôle y, mais un utilisateur partagé connecte le contrôle x au contrôle z, et encore contrôle x n’est pas autorisé à former plusieurs connexions. Dans ce cas, les paramètres de l’utilisateur pour la connexion sont prioritaires et le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle résout le conflit en appelant le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> de méthode et de fin de la connexion entre x et z pour l’utilisateur en question. Étant donné que cette déconnexion est essentielle à la résolution du conflit, par conception le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement ne peut pas être annulé dans ce scénario.  
  
 Le troisième scénario dans lequel le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> méthode ne peut pas être annulée est quand un <xref:System.Web.UI.WebControls.WebParts.WebPart> ou contrôle serveur qui est actuellement connecté est supprimée ou fermé. Étant donné que le contrôle est sans aucun doute va être supprimé à partir de la page, c’est une nécessité logique pour supprimer sa connexion. Par conséquent, lorsque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle invoque le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> (méthode), qui à son tour déclenche le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> événement, par conception il n’est pas possible d’annuler l’événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Pages de composants WebPart ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à une collection de toutes les zones <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> d'une page Web.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> qui référence un jeu de zones <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété est utilisée par le <xref:System.Web.UI.WebControls.WebParts.WebPartManager> contrôle à suivre le <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zones sur une page Web. Notez que la propriété ne fait pas référence à tous les types de zones ; elle fait référence uniquement les zones qui dérivent de la <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> classe, y compris <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zones.  
  
 Bien que la collection référencée par la propriété est en lecture seule, vous pouvez l’utiliser pour accéder à des objets individuels dans la collection et de les manipuler par programmation.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété par programmation à accès individuel <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> contrôles de zone. Notez que dans le balisage déclaratif pour la page Web, il existe deux `<asp:webpartzone>` éléments, chacun contenant un contrôle serveur. Dans le `<script>` section de la page, le code utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété pour accéder aux zones individuelles, en répertoriant tous les ID de zone, puis en modifiant la couleur d’arrière-plan de la deuxième zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 Notez que pour l’exemple de code fonctionne, vous devez ajouter un paramètre dans le fichier Web.config pour activer l’exportation des fichiers de description des composants WebPart. Assurez-vous d’avoir un fichier Web.config dans le même répertoire que la page Web pour cet exemple de code. Dans le `<system.web>` section, assurez-vous qu’il y a un `<webParts>` élément avec un `enableExport` attribut la valeur `true`, comme dans le balisage suivant.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Après avoir chargé la page dans un navigateur, si vous cliquez sur le **ID de Zone de liste** bouton, le code utilise le <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriété pour répertorier les ID de toutes les zones dans la collection. Si vous cliquez sur le **BackColor de Zone de modification** bouton, le code modifie la couleur d’arrière-plan de la deuxième zone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>