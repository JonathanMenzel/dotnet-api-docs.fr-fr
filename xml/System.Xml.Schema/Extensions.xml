<Type Name="Extensions" FullName="System.Xml.Schema.Extensions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="08b79d687c6aebde0052439757d5b07a17555129" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39765292" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Schema.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Cette classe contient les méthodes d’extension LINQ to XML pour la validation XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe contient également des méthodes pour obtenir le jeu d’informations postérieures à la validation du schéma (jeu PSVI) d’un nœud XML validé.  
  
 Lorsque vous validez un <xref:System.Xml.Linq.XDocument>, <xref:System.Xml.Linq.XElement>, ou <xref:System.Xml.Linq.XAttribute>, vous pouvez également remplir l’arborescence XML avec le jeu d’informations postérieures à la validation du schéma. Informations PSVI sont ajoutées en tant qu’annotation de type <xref:System.Xml.Schema.XmlSchemaInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Le langage XSD dans [exemple de fichier XSD : clients et commandes](http://msdn.microsoft.com/library/8b05efe3-cc5e-4c7b-b322-892dbda41687) contient un schéma qui peut être utilisé pour valider le document XML dans [exemple de fichier XML : clients et commandes (LINQ to XML)](http://msdn.microsoft.com/library/26790c41-5976-4558-a096-d0f67bfc4d92). L’exemple suivant charge le schéma et le document, valide le document, modifie le document de sorte que le `xs:key` et `xs:keyref` relation n’est pas valide, puis tente de valider à nouveau.  
  
```csharp  
  
                XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", "CustomersOrders.xsd");  
  
XDocument custOrd = XDocument.Load("CustomersOrders.xml");  
  
Console.WriteLine("Validating custOrd");  
bool errors = false;  
custOrd.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("custOrd {0}", errors ? "did not validate" : "validated");  
  
// Modify the custOrd tree so that it is no longer valid.  
custOrd.Root.Element("Orders").Element("Order").Element("CustomerID").Value = "AAAAA";  
  
Console.WriteLine();  
Console.WriteLine("Validating custOrd");  
errors = false;  
custOrd.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("custOrd {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", "CustomersOrders.xsd")  
  
    Console.WriteLine("Validating custOrd")  
    Dim custOrd As XDocument = XDocument.Load("CustomersOrders.xml")  
    errors = False  
    custOrd.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("custOrd {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating custOrd")  
    ' Modify the source document so that it will not validate.  
    custOrd.Root.Element("Orders").Element("Order").Element("CustomerID").Value = "AAAAA"  
    errors = False  
    custOrd.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("custOrd {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating custOrd  
custOrd validated  
  
Validating custOrd  
The key sequence 'AAAAA' in Keyref fails to refer to some key.  
custOrd did not validate  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetSchemaInfo">
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient le jeu d'informations postérieures à la validation du schéma (jeu PSVI) d'un nœud validé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois que vous avez validé un <xref:System.Xml.Linq.XDocument>, vous pouvez récupérer le jeu d’informations postérieures à la validation du schéma pour un <xref:System.Xml.Linq.XElement> ou <xref:System.Xml.Linq.XAttribute> qui est contenue dans le document.  
  
 Après avoir récupéré le <xref:System.Xml.Schema.IXmlSchemaInfo> de l’objet, vous pouvez utiliser la <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaAttribute%2A> ou <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaElement%2A> propriétés permettant d’obtenir un type de validation partielle (<xref:System.Xml.Schema.XmlSchemaElement> ou <xref:System.Xml.Schema.XmlSchemaAttribute>). Vous pouvez utiliser les types de validation partielle pour valider un attribut ou une sous-arborescence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSchemaInfo">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo (this System.Xml.Linq.XAttribute source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo(class System.Xml.Linq.XAttribute source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.GetSchemaInfo(System.Xml.Linq.XAttribute)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetSchemaInfo (source As XAttribute) As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Schema::IXmlSchemaInfo ^ GetSchemaInfo(System::Xml::Linq::XAttribute ^ source);" />
      <MemberSignature Language="F#" Value="static member GetSchemaInfo : System.Xml.Linq.XAttribute -&gt; System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.Schema.Extensions.GetSchemaInfo source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XAttribute" /> validé précédemment.</param>
        <summary>Obtient le jeu d'informations postérieures à la validation du schéma (jeu PSVI) d'un attribut validé.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> qui contient le jeu d'informations postérieures à la validation du schéma pour un <see cref="T:System.Xml.Linq.XAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Xml.Schema.IXmlSchemaInfo> retourné par cette méthode pour déterminer certaines caractéristiques d’un attribut validé. Par exemple, vous pouvez déterminer si l’attribut provient d’une valeur d’attribut par défaut dans un fichier XSD.  
  
 Vous utilisez le <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaAttribute%2A> propriété à obtenir un type de validation partielle (<xref:System.Xml.Schema.XmlSchemaAttribute>). Vous pouvez l’utiliser pour revalider un attribut sans valider un document entier.  
  
 Pour obtenir un exemple de cette propriété, consultez <xref:System.Xml.Schema.Extensions.Validate%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaInfo">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo (this System.Xml.Linq.XElement source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo(class System.Xml.Linq.XElement source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.GetSchemaInfo(System.Xml.Linq.XElement)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetSchemaInfo (source As XElement) As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Schema::IXmlSchemaInfo ^ GetSchemaInfo(System::Xml::Linq::XElement ^ source);" />
      <MemberSignature Language="F#" Value="static member GetSchemaInfo : System.Xml.Linq.XElement -&gt; System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.Schema.Extensions.GetSchemaInfo source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XElement" /> validé précédemment.</param>
        <summary>Obtient le jeu d'informations postérieures à la validation du schéma (jeu PSVI) d'un élément validé.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> qui contient le jeu d'informations postérieures à la validation du schéma (jeu PSVI) pour un <see cref="T:System.Xml.Linq.XElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Xml.Schema.IXmlSchemaInfo> retourné par cette méthode pour déterminer certaines caractéristiques d’un élément validé. Par exemple, vous pouvez déterminer le type de schéma dynamique de l’élément.  
  
 Vous utilisez le <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaElement%2A> propriété à obtenir un type de validation partielle (<xref:System.Xml.Schema.XmlSchemaElement>). Vous pouvez l’utiliser pour revalider une sous-arborescence avec un élément à sa racine sans valider un document entier.  
  
 Pour obtenir un exemple de cette propriété, consultez <xref:System.Xml.Schema.Extensions.Validate%2A>.  
  
   
  
## Examples  
 L’exemple suivant remplit l’arborescence avec un jeu PSVI. Après la validation, il imprime tous les éléments et attributs dans l’arborescence qui ne sont pas valides en fonction du PSVI.  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
    string xsdMarkup =  
         @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
   <xsd:simpleType name='GCType'>  
    <xsd:restriction base='xsd:token'>  
     <xsd:enumeration value='AAA'/>  
     <xsd:enumeration value='BBB'/>  
    </xsd:restriction>  
   </xsd:simpleType>  
   <xsd:element name='Root'>  
    <xsd:complexType>  
     <xsd:sequence>  
      <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
       <xsd:complexType>  
        <xsd:sequence>  
         <xsd:element name='GrandChild1' type='GCType'/>  
         <xsd:element name='GrandChild2' type='GCType'/>  
         <xsd:element name='GrandChild3' type='GCType'/>  
        </xsd:sequence>  
       </xsd:complexType>  
      </xsd:element>  
     </xsd:sequence>  
    </xsd:complexType>  
   </xsd:element>  
  </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XElement("Child1",  
                new XElement("GrandChild1", "AAA"),  
                new XElement("GrandChild2", "ZZZ"),  
                new XElement("GrandChild3", "ZZZ")  
            )  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:simpleType name='GCType'>  
            <xsd:restriction base='xsd:token'>  
                <xsd:enumeration value='AAA'/>  
                <xsd:enumeration value='BBB'/>  
            </xsd:restriction>  
        </xsd:simpleType>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                        <xsd:complexType>  
                            <xsd:sequence>  
                                <xsd:element name='GrandChild1' type='GCType'/>  
                                <xsd:element name='GrandChild2' type='GCType'/>  
                                <xsd:element name='GrandChild3' type='GCType'/>  
                            </xsd:sequence>  
                        </xsd:complexType>  
                    </xsd:element>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>  
            <GrandChild1>AAA</GrandChild1>  
            <GrandChild2>ZZZ</GrandChild2>  
            <GrandChild3>ZZZ</GrandChild3>  
        </Child1>  
    </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1 ...  
The 'GrandChild2' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
The 'GrandChild3' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
doc1 did not validate  
Invalid Element /Root  
Invalid Element /Root/Child1  
Invalid Element /Root/Child1/GrandChild2  
Invalid Element /Root/Child1/GrandChild3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valide le fait qu'un <see cref="T:System.Xml.Linq.XDocument" />, un <see cref="T:System.Xml.Linq.XElement" /> ou un <see cref="T:System.Xml.Linq.XAttribute" /> soit conforme à un XSD dans un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces méthodes utilisent un sous-jacent <xref:System.Xml.XmlReader> pour valider l’arborescence XML par rapport à un fichier XSD.  
  
 Erreur de validation et les messages d’avertissement sont gérées à l’aide de la <xref:System.Xml.Schema.ValidationEventHandler> déléguer. Si aucun gestionnaire d’événements n’est fourni à ces méthodes, les erreurs de validation sont exposées comme un <xref:System.Xml.Schema.XmlSchemaValidationException>. Avertissements de validation ne provoquent pas un <xref:System.Xml.Schema.XmlSchemaValidationException> levée.  
  
 Certaines de ces méthodes d’extension permettent éventuellement remplissage de l’ensemble d’informations postérieures à la validation du schéma (jeu PSVI).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XDocument source, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XDocument source, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XDocument,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XDocument ^ source, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XDocument * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XDocument" RefType="this" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XDocument" /> à valider.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> par rapport auquel effectuer la validation.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> pour un événement qui se produit lorsque le lecteur rencontre des erreurs de validation. Si la valeur est <see langword="null" />, une exception est levée en cas d'erreurs de validation.</param>
        <summary>Cette méthode valide le fait qu'un <see cref="T:System.Xml.Linq.XDocument" /> est conforme à un XSD dans un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode d’extension valide le fait que le <xref:System.Xml.Linq.XDocument> est conforme au modèle de contenu de schéma dans <xref:System.Xml.Schema.XmlSchemaSet>.  
  
   
  
## Examples  
 L'exemple suivant crée un objet <xref:System.Xml.Schema.XmlSchemaSet>, puis valide deux objets <xref:System.Xml.Linq.XDocument> par rapport au jeu de schémas. L'un des documents est valide, l'autre non.  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'/>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child2", "content1")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                    <xsd:element name='Child2' minOccurs='1' maxOccurs='1'/>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>content1</Child1>  
        <Child2>content2</Child2>  
    </Root>  
  
    Dim doc2 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>content1</Child1>  
        <Child3>content1</Child3>  
    </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Exception levée pour des erreurs de validation de langage XSD (XML Schema Definition).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XAttribute source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XAttribute source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XAttribute,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XAttribute ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XAttribute * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XAttribute" /> à valider.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> qui spécifie la sous-arborescence à valider.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> par rapport auquel effectuer la validation.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> pour un événement qui se produit lorsque le lecteur rencontre des erreurs de validation. Si la valeur est <see langword="null" />, une exception est levée en cas d'erreurs de validation.</param>
        <summary>Cette méthode valide le fait qu'un <see cref="T:System.Xml.Linq.XAttribute" /> est conforme à un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> spécifié et un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour valider le fait qu’un <xref:System.Xml.Linq.XAttribute> est conforme à un schéma. Vous utilisez généralement cette méthode lorsque vous avez modifié un attribut, et que vous souhaitez vous assurer qu’il est toujours conforme à son schéma. Vous pouvez valider le document entier, mais il prend moins de temps pour valider uniquement l’attribut.  
  
 Si vous transmettez `null` pour `validationEventHandler`, cette méthode lève une exception en cas d’erreurs de validation. Avertissements de validation ne lèvent pas d’exception.  
  
 Pour valider un attribut, vous utilisez une instance de <xref:System.Xml.Schema.XmlSchemaObject>. Vous pouvez obtenir cette instance de différentes manières. Un moyen simple est le suivant :  
  
1.  Valider qu’un document est conforme à un schéma.  
  
2.  Ajouter le jeu d’informations postérieures à la validation du schéma (jeu PSVI) en appelant le <xref:System.Xml.Schema.Extensions.Validate%2A> méthode d’extension.  
  
3.  Appelez le <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> méthode d’extension pour récupérer un objet qui implémente <xref:System.Xml.Schema.IXmlSchemaInfo>. À partir de l’objet récupéré, vous pouvez obtenir un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XElement>, le type sera <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XAttribute>, le type sera <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Une fois que vous avez une instance d’un <xref:System.Xml.Schema.XmlSchemaObject>, vous pouvez utiliser cette méthode pour valider un attribut.  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:simpleContent>  
          <xsd:extension base='xsd:string'>  
           <xsd:attribute name='Lang' use='required'>  
            <xsd:simpleType>  
             <xsd:restriction base='xsd:token'>  
              <xsd:enumeration value='C#'/>  
              <xsd:enumeration value='VB'/>  
             </xsd:restriction>  
            </xsd:simpleType>  
           </xsd:attribute>  
          </xsd:extension>  
         </xsd:simpleContent>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XAttribute("Lang", "C#")  
    )  
);  
  
Console.WriteLine("Validating doc1 ...");  
bool errors = false;  
doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating Lang attribute ...");  
XAttribute lang = doc1.Root.Attribute("Lang");  
  
errors = false;  
lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
  
// the following makes the Lang attribute invalid according to the schema  
lang.Value = "VC";  
  
Console.WriteLine();  
Console.WriteLine("Validating Lang attribute ...");  
  
errors = false;  
lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
      <?xml version='1.0'?>  
      <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
          <xsd:element name='Root'>  
              <xsd:complexType>  
                  <xsd:simpleContent>  
                      <xsd:extension base='xsd:string'>  
                          <xsd:attribute name='Lang' use='required'>  
                              <xsd:simpleType>  
                                  <xsd:restriction base='xsd:token'>  
                                      <xsd:enumeration value='C#'/>  
                                      <xsd:enumeration value='VB'/>  
                                  </xsd:restriction>  
                              </xsd:simpleType>  
                          </xsd:attribute>  
                      </xsd:extension>  
                  </xsd:simpleContent>  
              </xsd:complexType>  
          </xsd:element>  
      </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root Lang='C#'/>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
    Dim lang As XAttribute = doc1.Root.Attribute("Lang")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
  
    ' the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC"  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Lang attribute ...  
lang validated  
  
Validating Lang attribute ...  
The 'Lang' attribute is invalid - The value 'VC' is invalid according to its datatype 'Token' - The Enumeration constraint failed.  
lang did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Exception levée pour des erreurs de validation de langage XSD (XML Schema Definition).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XDocument source, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XDocument source, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XDocument,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XDocument ^ source, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XDocument * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XDocument" RefType="this" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XDocument" /> à valider.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> par rapport auquel effectuer la validation.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> pour un événement qui se produit lorsque le lecteur rencontre des erreurs de validation. Si la valeur est <see langword="null" />, une exception est levée en cas d'erreurs de validation.</param>
        <param name="addSchemaInfo">
          <see cref="T:System.Boolean" /> qui indique s'il convient de remplir le jeu d'informations postérieures à la validation du schéma (jeu PSVI).</param>
        <summary>Valide le fait qu'un <see cref="T:System.Xml.Linq.XDocument" /> est conforme à un XSD dans un <see cref="T:System.Xml.Schema.XmlSchemaSet" />, en remplissant en option l'arborescence XML à l'aide du jeu d'informations postérieures à la validation du schéma (jeu PSVI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode d’extension valide le fait que le <xref:System.Xml.Linq.XDocument> est conforme au modèle de contenu de schéma dans <xref:System.Xml.Schema.XmlSchemaSet>.  
  
 Si `addSchemaInfo` est `true`, cette méthode remplit l’arborescence XML avec le jeu d’informations postérieures à la validation du schéma (jeu PSVI).  
  
 Il existe deux étapes pour remplir l’arborescence XML avec le jeu PSVI.  
  
1.  Tout d’abord, une annotation est ajoutée à tous les nœuds dans l’arborescence pour vous permettre d’appeler <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> ou <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> sur un élément ou attribut dans l’arborescence.  
  
2.  En second lieu, les éléments par défaut et les attributs définis dans le schéma XSD sont ajoutés à l’arborescence XML. En appelant une de le <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> méthodes, vous pouvez déterminer si un élément spécifique ou un attribut a été ajouté à partir du XSD en tant qu’un attribut ou élément de la valeur par défaut.  
  
   
  
## Examples  
 L’exemple suivant contient un XSD qui définit le `Child2` élément avec un `Att1` attribut avec une valeur par défaut. Après avoir vérifié avec succès le document, l’attribut avec la valeur par défaut est ajouté à l’arborescence XML. Notez que l’attribut par défaut n’est pas ajouté à `doc2`, qui ne valide pas par rapport au schéma.  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:simpleContent>  
             <xsd:extension base='xsd:string'>  
              <xsd:attribute name='Att1' default='Att1 Default Value'/>  
             </xsd:extension>  
            </xsd:simpleContent>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "c1"),  
        new XElement("Child2", "c2")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                           {  
                               Console.WriteLine("{0}", e.Message);  
                               errors = true;  
                           }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc1:");  
Console.WriteLine(doc1);  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc2:");  
Console.WriteLine(doc2);  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                    <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
                        <xsd:complexType>  
                            <xsd:simpleContent>  
                                <xsd:extension base='xsd:string'>  
                                    <xsd:attribute name='Att1' default='Att1 Default Value'/>  
                                </xsd:extension>  
                            </xsd:simpleContent>  
                        </xsd:complexType>  
                    </xsd:element>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root>  
                                <Child1>c1</Child1>  
                                <Child2>c2</Child2>  
                            </Root>  
    Dim doc2 As XDocument = <?xml version='1.0'?>  
                            <Root>  
                                <Child1>content1</Child1>  
                                <Child3>content1</Child3>  
                            </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc1:")  
    Console.WriteLine(doc1)  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc2:")  
    Console.WriteLine(doc2)  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
  
Contents of doc1:  
<Root>  
  <Child1>c1</Child1>  
  <Child2 Att1="Att1 Default Value">c2</Child2>  
</Root>  
  
Contents of doc2:  
<Root>  
  <Child1>content1</Child1>  
  <Child3>content1</Child3>  
</Root>  
```  
  
 L’exemple suivant remplit l’arborescence avec PSVI. Après la validation, il imprime tous les éléments et attributs dans l’arborescence qui ne sont pas valides en fonction du PSVI.  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
   string xsdMarkup =  
        @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
           <xsd:simpleType name='GCType'>  
            <xsd:restriction base='xsd:token'>  
             <xsd:enumeration value='AAA'/>  
             <xsd:enumeration value='BBB'/>  
            </xsd:restriction>  
           </xsd:simpleType>  
           <xsd:element name='Root'>  
            <xsd:complexType>  
             <xsd:sequence>  
              <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
               <xsd:complexType>  
                <xsd:sequence>  
                 <xsd:element name='GrandChild1' type='GCType'/>  
                 <xsd:element name='GrandChild2' type='GCType'/>  
                 <xsd:element name='GrandChild3' type='GCType'/>  
                </xsd:sequence>  
               </xsd:complexType>  
              </xsd:element>  
             </xsd:sequence>  
            </xsd:complexType>  
           </xsd:element>  
          </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XElement("Child1",  
                new XElement("GrandChild1", "AAA"),  
                new XElement("GrandChild2", "ZZZ"),  
                new XElement("GrandChild3", "ZZZ")  
            )  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
        {  
            Console.WriteLine(e.Message);  
            errors = true;  
        }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:simpleType name='GCType'>  
                <xsd:restriction base='xsd:token'>  
                    <xsd:enumeration value='AAA'/>  
                    <xsd:enumeration value='BBB'/>  
                </xsd:restriction>  
            </xsd:simpleType>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:sequence>  
                                    <xsd:element name='GrandChild1' type='GCType'/>  
                                    <xsd:element name='GrandChild2' type='GCType'/>  
                                    <xsd:element name='GrandChild3' type='GCType'/>  
                                </xsd:sequence>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>  
                <GrandChild1>AAA</GrandChild1>  
                <GrandChild2>ZZZ</GrandChild2>  
                <GrandChild3>ZZZ</GrandChild3>  
            </Child1>  
        </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1 ...  
The 'GrandChild2' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
The 'GrandChild3' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
doc1 did not validate  
Invalid Element /Root  
Invalid Element /Root/Child1  
Invalid Element /Root/Child1/GrandChild2  
Invalid Element /Root/Child1/GrandChild3  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Exception levée pour des erreurs de validation de langage XSD (XML Schema Definition).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XElement source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XElement source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XElement,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XElement ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XElement * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XElement" /> à valider.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> qui spécifie la sous-arborescence à valider.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> par rapport auquel effectuer la validation.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> pour un événement qui se produit lorsque le lecteur rencontre des erreurs de validation. Si la valeur est <see langword="null" />, une exception est levée en cas d'erreurs de validation.</param>
        <summary>Cette méthode valide le fait qu'une sous-arborescence <see cref="T:System.Xml.Linq.XElement" /> est conforme à un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> spécifié et un <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour vérifier qu’une sous-arborescence (avec un <xref:System.Xml.Linq.XElement> à sa racine) est conforme à un schéma. Vous utilisez généralement cette méthode lorsque vous avez modifié une sous-arborescence et que vous souhaitez vous assurer qu’il est toujours conforme à son schéma. Vous pouvez valider le document entier, mais il prend moins de temps pour valider un simplement une sous-arborescence.  
  
 Si vous transmettez `null` pour `validationEventHandler`, cette méthode lève une exception en cas d’erreurs de validation. Avertissements de validation ne lèvent pas d’exception.  
  
 Pour valider une sous-arborescence, vous utilisez une instance de <xref:System.Xml.Schema.XmlSchemaObject>. Vous pouvez obtenir cette instance de différentes manières. Un moyen simple est le suivant :  
  
1.  Valider qu’un document est conforme à un schéma.  
  
2.  Ajouter le jeu d’informations postérieures à la validation du schéma (jeu PSVI) en appelant le <xref:System.Xml.Schema.Extensions.Validate%2A> méthode d’extension.  
  
3.  Appelez le <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> méthode d’extension pour récupérer un objet qui implémente <xref:System.Xml.Schema.IXmlSchemaInfo>. À partir de l’objet récupéré, vous pouvez obtenir un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XElement>, le type sera <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XAttribute>, le type sera <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Une fois que vous avez une instance d’un <xref:System.Xml.Schema.XmlSchemaObject>, vous pouvez utiliser cette méthode pour valider une sous-arborescence.  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:sequence>  
             <xsd:element name='GrandChild1' minOccurs='1' maxOccurs='1'/>  
             <xsd:element name='GrandChild2' minOccurs='1' maxOccurs='2'/>  
            </xsd:sequence>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1",  
            new XElement("GrandChild1", "gc"),  
            new XElement("GrandChild2", "gc")  
        )  
    )  
);  
  
Console.WriteLine("Validating doc1 ...");  
bool errors = false;  
doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating Child1 after first edit ...");  
XElement child1 = doc1.Element("Root").Element("Child1");  
child1.Add(new XElement("GrandChild2", "gc"));  
errors = false;  
child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("child1 {0}", errors ? "did not validate" : "validated");  
  
// the following makes the Child1 element invalid according to the schema  
child1.Add(new XElement("GrandChild3", "gc"));  
Console.WriteLine();  
Console.WriteLine("Validating Child1 after second edit ...");  
child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("child1 {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:sequence>  
                                    <xsd:element name='GrandChild1' minOccurs='1' maxOccurs='1'/>  
                                    <xsd:element name='GrandChild2' minOccurs='1' maxOccurs='2'/>  
                                </xsd:sequence>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>  
                <GrandChild1>gc</GrandChild1>  
                <GrandChild2>gc</GrandChild2>  
            </Child1>  
        </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Child1 after first edit ...")  
    Dim child1 As XElement = doc1.Element("Root").Element("Child1")  
    child1.Add(<GrandChild2>gc</GrandChild2>)  
    errors = False  
    child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, AddressOf XSDErrors)  
    Console.WriteLine("child1 {0}", IIf(errors, "did not validate", "validated"))  
  
    ' the following makes the Child1 element invalid according to the schema  
    child1.Add(<GrandChild3>gc</GrandChild3>)  
    Console.WriteLine()  
    Console.WriteLine("Validating Child1 after second edit ...")  
    child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, AddressOf XSDErrors)  
    Console.WriteLine("child1 {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Child1 after first edit ...  
child1 validated  
  
Validating Child1 after second edit ...  
The element 'Child1' has invalid child element 'GrandChild3'.  
child1 did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Exception levée pour des erreurs de validation de langage XSD (XML Schema Definition).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XAttribute source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XAttribute source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XAttribute,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XAttribute ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XAttribute * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XAttribute" /> à valider.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> qui spécifie la sous-arborescence à valider.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> par rapport auquel effectuer la validation.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> pour un événement qui se produit lorsque le lecteur rencontre des erreurs de validation. Si la valeur est <see langword="null" />, une exception est levée en cas d'erreurs de validation.</param>
        <param name="addSchemaInfo">
          <see cref="T:System.Boolean" /> qui indique s'il convient de remplir le jeu d'informations postérieures à la validation du schéma (jeu PSVI).</param>
        <summary>Valide le fait qu'un <see cref="T:System.Xml.Linq.XAttribute" /> est conforme à un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> spécifié et un <see cref="T:System.Xml.Schema.XmlSchemaSet" />, en remplissant en option l'arborescence XML à l'aide du jeu d'informations postérieures à la validation du schéma (jeu PSVI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour valider le fait qu’un <xref:System.Xml.Linq.XAttribute> est conforme à un schéma. Vous utilisez généralement cette méthode lorsque vous avez modifié un attribut, et que vous souhaitez vous assurer qu’il est toujours conforme à son schéma. Vous pouvez valider le document entier, mais il prend moins de temps pour valider uniquement l’attribut.  
  
 Si `addSchemaInfo` est `true`, cette méthode remplit l’attribut avec le jeu d’informations postérieures à la validation du schéma (jeu PSVI). Une fois que vous avez rempli l’arborescence XML avec le jeu PSVI, vous pouvez appeler <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> sur l’attribut validé. Cela est utile si vous écrivez du code qui s’appuie sur les données retournées par <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A>.  
  
 Si vous transmettez `null` pour `validationEventHandler`, cette méthode lève une exception en cas d’erreurs de validation. Avertissements de validation ne lèvent pas d’exception.  
  
 Pour valider un attribut, vous utilisez une instance de <xref:System.Xml.Schema.XmlSchemaObject>. Vous pouvez obtenir cette instance de différentes manières. Un moyen simple est le suivant :  
  
1.  Valider qu’un document est conforme à un schéma.  
  
2.  Ajouter le jeu d’informations postérieures à la validation du schéma (jeu PSVI) en appelant le <xref:System.Xml.Schema.Extensions.Validate%2A> méthode d’extension.  
  
3.  Appelez le <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> méthode d’extension pour récupérer un objet qui implémente <xref:System.Xml.Schema.IXmlSchemaInfo>. À partir de l’objet récupéré, vous pouvez obtenir un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XElement>, le type sera <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XAttribute>, le type sera <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Une fois que vous avez une instance d’un <xref:System.Xml.Schema.XmlSchemaObject>, vous pouvez utiliser cette méthode pour valider un attribut.  
  
   
  
## Examples  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
    string xsdMarkup =  
        @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:simpleContent>  
          <xsd:extension base='xsd:string'>  
           <xsd:attribute name='Lang' use='required'>  
            <xsd:simpleType>  
             <xsd:restriction base='xsd:token'>  
              <xsd:enumeration value='C#'/>  
              <xsd:enumeration value='VB'/>  
             </xsd:restriction>  
            </xsd:simpleType>  
           </xsd:attribute>  
          </xsd:extension>  
         </xsd:simpleContent>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XAttribute("Lang", "C#")  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
  
    Console.WriteLine();  
    Console.WriteLine("Validating Lang attribute ...");  
    XAttribute lang = doc1.Element("Root").Attribute("Lang");  
  
    errors = false;  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
  
    // the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC";  
  
    Console.WriteLine();  
    Console.WriteLine("Validating Lang attribute ...");  
  
    errors = false;  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:simpleContent>  
                        <xsd:extension base='xsd:string'>  
                            <xsd:attribute name='Lang' use='required'>  
                                <xsd:simpleType>  
                                    <xsd:restriction base='xsd:token'>  
                                        <xsd:enumeration value='C#'/>  
                                        <xsd:enumeration value='VB'/>  
                                    </xsd:restriction>  
                                </xsd:simpleType>  
                            </xsd:attribute>  
                        </xsd:extension>  
                    </xsd:simpleContent>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root Lang='C#'/>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
    Dim lang As XAttribute = doc1.Element("Root").Attribute("Lang")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
  
    ' the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC"  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Lang attribute ...  
lang validated  
  
Validating Lang attribute ...  
The 'Lang' attribute is invalid - The value 'VC' is invalid according to its datatype 'Token' - The Enumeration constraint failed.  
lang did not validate  
Invalid Attribute /Root/@Lang  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Exception levée pour des erreurs de validation de langage XSD (XML Schema Definition).</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XElement source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XElement source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XElement,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XElement ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XElement * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="T:System.Xml.Linq.XElement" /> à valider.</param>
        <param name="partialValidationType">
          <see cref="T:System.Xml.Schema.XmlSchemaObject" /> qui spécifie la sous-arborescence à valider.</param>
        <param name="schemas">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> par rapport auquel effectuer la validation.</param>
        <param name="validationEventHandler">
          <see cref="T:System.Xml.Schema.ValidationEventHandler" /> pour un événement qui se produit lorsque le lecteur rencontre des erreurs de validation. Si la valeur est <see langword="null" />, une exception est levée en cas d'erreurs de validation.</param>
        <param name="addSchemaInfo">
          <see cref="T:System.Boolean" /> qui indique s'il convient de remplir le jeu d'informations postérieures à la validation du schéma (jeu PSVI).</param>
        <summary>Valide le fait qu'une sous-arborescence <see cref="T:System.Xml.Linq.XElement" /> est conforme à un <see cref="T:System.Xml.Schema.XmlSchemaObject" /> spécifié et un <see cref="T:System.Xml.Schema.XmlSchemaSet" />, en remplissant en option l'arborescence XML à l'aide du jeu d'informations postérieures à la validation du schéma (jeu PSVI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour vérifier qu’une sous-arborescence (avec un <xref:System.Xml.Linq.XElement> à la racine de la sous-arborescence) est conforme à un schéma. Vous utilisez généralement cette méthode lorsque vous avez modifié une sous-arborescence et que vous souhaitez vous assurer qu’il est toujours conforme à son schéma. Vous pouvez valider le document entier, mais il prend moins de temps pour valider un simplement une sous-arborescence.  
  
 Si `addSchemaInfo` est `true`, cette méthode remplit l’arborescence XML avec le jeu d’informations postérieures à la validation du schéma (jeu PSVI).  
  
 Il existe deux aspects de remplissage de l’arborescence XML avec le jeu PSVI.  
  
 Tout d’abord, une annotation est ajoutée à tous les nœuds dans l’arborescence de sorte que vous pouvez maintenant appeler <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> sur un élément ou attribut dans l’arborescence.  
  
 En second lieu, les éléments par défaut et les attributs définis dans le schéma XSD sont ajoutés à l’arborescence XML. En appelant une de le <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> méthodes, vous pouvez déterminer si un élément spécifique ou un attribut a été ajouté à partir du XSD en tant qu’un attribut ou élément de la valeur par défaut.  
  
 Si vous transmettez `null` pour `validationEventHandler`, cette méthode lève une exception en cas d’erreurs de validation. Avertissements de validation ne lèvent pas d’exception.  
  
 Pour valider une sous-arborescence, vous utilisez une instance de <xref:System.Xml.Schema.XmlSchemaObject>. Vous pouvez obtenir cette instance de différentes manières. Un moyen simple est le suivant :  
  
1.  Valider qu’un document est conforme à un schéma.  
  
2.  Ajouter le jeu d’informations postérieures à la validation du schéma (jeu PSVI) en appelant le <xref:System.Xml.Schema.Extensions.Validate%2A> méthode d’extension.  
  
3.  Appelez le <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> méthode d’extension pour récupérer un objet qui implémente <xref:System.Xml.Schema.IXmlSchemaInfo>. À partir de l’objet récupéré, vous pouvez obtenir un <xref:System.Xml.Schema.XmlSchemaObject>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XElement>, le type sera <xref:System.Xml.Schema.XmlSchemaElement>.  
  
    -   Si vous obtenez un <xref:System.Xml.Schema.XmlSchemaObject> pour un <xref:System.Xml.Linq.XAttribute>, le type sera <xref:System.Xml.Schema.XmlSchemaAttribute>.  
  
 Une fois que vous avez une instance d’un <xref:System.Xml.Schema.XmlSchemaObject>, vous pouvez utiliser cette méthode pour valider une sous-arborescence...  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:simpleContent>  
             <xsd:extension base='xsd:string'>  
              <xsd:attribute name='Att1' default='Att1 Default Value'/>  
             </xsd:extension>  
            </xsd:simpleContent>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "c1"),  
        new XElement("Child2", "c2")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc1:");  
Console.WriteLine(doc1);  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc2:");  
Console.WriteLine(doc2);  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                        <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:simpleContent>  
                                    <xsd:extension base='xsd:string'>  
                                        <xsd:attribute name='Att1' default='Att1 Default Value'/>  
                                    </xsd:extension>  
                                </xsd:simpleContent>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>c1</Child1>  
            <Child2>c2</Child2>  
        </Root>  
  
    Dim doc2 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>content1</Child1>  
            <Child3>content1</Child3>  
        </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc1:")  
    Console.WriteLine(doc1)  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc2:")  
    Console.WriteLine(doc2)  
End Sub  
```  
  
 Cet exemple génère la sortie suivante :  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
  
Contents of doc1:  
<Root>  
  <Child1>c1</Child1>  
  <Child2 Att1="Att1 Default Value">c2</Child2>  
</Root>  
  
Contents of doc2:  
<Root>  
  <Child1>content1</Child1>  
  <Child3>content1</Child3>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Exception levée pour des erreurs de validation de langage XSD (XML Schema Definition).</exception>
      </Docs>
    </Member>
  </Members>
</Type>