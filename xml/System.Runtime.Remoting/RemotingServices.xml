<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7079665386ba489a868ca52e6f5f8c88efd711bf" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52239869" /></Metadata><TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit plusieurs méthodes pour utiliser et publier des objets et proxies distants. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sauf si vous êtes un fournisseur de services traitant de problèmes tels que l’activation, la gestion de la durée de vie ou les transactions, il est inutile du faire la distinction entre les références de proxy et les références d’objet. L’infrastructure de communication à distance utilise des proxies transparents qui donnent l’impression que les objets distants se trouvent dans l’espace du client. Les proxies permettent cela en transférant les appels effectués sur ces derniers à des objets réels à des emplacements distants.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un proxy pour un objet connu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy"><see cref="T:System.Type" /> d'un objet connu situé sur le serveur auquel vous souhaitez vous connecter.</param>
        <param name="url">URL de la classe de serveur.</param>
        <summary>Crée un proxy pour un objet connu, en fonction du <see cref="T:System.Type" /> et de l'URL.</summary>
        <returns>Proxy pour l'objet distant qui pointe vers un point de terminaison pris en charge par l'objet connu spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet proxy retourné pointe vers un point de terminaison pris en charge par l’objet connu spécifié. Aucuns messages ne sont envoyés sur le réseau jusqu'à ce qu’une méthode est appelée sur le proxy.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> méthode pour créer un proxy pour un objet connu.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas l'autorisation requise pour configurer les canaux et les types de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy"><see cref="T:System.Type" /> d'un objet connu auquel vous souhaitez vous connecter.</param>
        <param name="url">URL de l'objet connu.</param>
        <param name="data">Données spécifiques au canal. Peut être <see langword="null" />.</param>
        <summary>Crée un proxy pour un objet connu, en fonction du <see cref="T:System.Type" />, de l'URL et de données spécifiques de canal.</summary>
        <returns>Proxy qui pointe vers un point de terminaison pris en charge par l'objet connu demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet proxy retourné pointe vers un point de terminaison pris en charge par l’objet connu spécifié. Aucuns messages ne sont envoyés sur le réseau jusqu'à ce qu’une méthode est appelée sur le proxy.  
  
 Le `data` objet est utilisé pour communiquer des informations au canal et est passé à la <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas l'autorisation requise pour configurer les canaux et les types de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à déconnecter de son canal.</param>
        <summary>Interrompt la réception de messages provenant des canaux d'accès de communication à distance inscrits pour un objet.</summary>
        <returns><see langword="true" /> si l'objet a été correctement déconnecté des canaux de communication à distance inscrits ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> méthode pour déconnecter un objet des canaux de communication à distance.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="obj" /> est un proxy.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas l'autorisation requise pour configurer les canaux et les types de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Objet distant dont vous souhaitez appeler la méthode.</param>
        <param name="reqMsg">Message d'appel de méthode pour la méthode de l'objet distant spécifié.</param>
        <summary>Établit une connexion à l'objet distant spécifié et exécute le <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> fourni sur celui-ci.</summary>
        <returns>Réponse de la méthode distante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode actuelle est utilisée dans des cas spéciaux par le serveur pour transférer l’appel de méthode spécifiée à un autre objet à distance. Cette méthode peut être appelée uniquement lorsque l’appelant est dans le contexte approprié.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> méthode pour transférer les appels de méthode à des objets distants.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">La méthode a été appelée à partir d'un autre contexte que le contexte natif de l'objet.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Proxy de l'objet distant qui a demandé les récepteurs d'envoi qui sont associés à celui-ci.</param>
        <summary>Retourne une chaîne de récepteurs d'envoi qui doit être utilisée lors de l'envoi de messages à l'objet distant représenté par le proxy spécifié.</summary>
        <returns>Chaîne de récepteurs d'envoi associée au proxy spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récepteurs d’envoi sont des récepteurs envoyés avec le <xref:System.Runtime.Remoting.ObjRef> d’un objet qui est utilisé lorsque le retour de messages à cet objet. La méthode en cours retourne les récepteurs d’envoi qui sont utilisés pendant la communication entre le proxy de l’objet et l’objet lui-même.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Objet dont vous souhaitez obtenir le service de durée de vie.</param>
        <summary>Retourne un objet de service de durée de vie qui contrôle la stratégie de durée de vie de l'objet spécifié.</summary>
        <returns>Objet qui contrôle la durée de vie de <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour le service de durée de vie par défaut, l’objet retourné sera un objet de type <xref:System.Runtime.Remoting.Lifetime.ILease>. Si le `obj` paramètre est `null`, la méthode retourne `null`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> méthode pour obtenir un bail de durée de vie de l’objet spécifié.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Pour compiler et exécuter cet exemple, vous devez compiler et exécuter un serveur, timerserver.exe et compiler une bibliothèque partagée, timerservice.dll.  
  
 La source de timerserver.exe suit :  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 La source de timerservice.dll suit :  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Message de méthode à partir duquel extraire la méthode de base.</param>
        <summary>Retourne la base de méthode du <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> spécifié.</summary>
        <returns>Base de méthode extraite du paramètre <paramref name="msg" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce paramètre détermine la méthode de base à partir de la <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, et <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> propriétés de <xref:System.Runtime.Remoting.Messaging.IMethodMessage> et est utilisé par les classes implémentant le <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interface. Les consommateurs de <xref:System.Runtime.Remoting.Messaging.IMethodMessage> classes doivent référencer le <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Soit l'appelant immédiat ne dispose pas de l'autorisation d'infrastructure, soit au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation requise pour récupérer les informations de type des membres non publics.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">L'objet à sérialiser.</param>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> dans lequel l'objet est sérialisé.</param>
        <param name="context">Source et destination de la sérialisation.</param>
        <summary>Sérialise le marshal spécifié par objet de référence dans le <see cref="T:System.Runtime.Serialization.SerializationInfo" /> fourni.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> ou <paramref name="info" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.MarshalByRefObject" /> pour lequel un URI est demandé.</param>
        <summary>Récupère l'URI pour l'objet spécifié.</summary>
        <returns>URI de l'objet spécifié, s'il en possède un, ou <see langword="null" /> si l'objet n'a pas encore été marshalé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Proxy connecté à l'objet pour lequel vous souhaitez créer <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <summary>Retourne le <see cref="T:System.Runtime.Remoting.ObjRef" /> qui représente l'objet distant du proxy spécifié.</summary>
        <returns><see cref="T:System.Runtime.Remoting.ObjRef" /> représentant l'objet distant auquel le proxy spécifié est connecté, ou <see langword="null" /> si l'objet ou proxy n'a pas encore été marshalé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Runtime.Remoting.ObjRef> est une représentation sérialisable d’un objet utilisé pour transférer une référence d’objet sur une limite de domaine d’application. Création d’un <xref:System.Runtime.Remoting.ObjRef> pour un objet est appelé marshaling. Le <xref:System.Runtime.Remoting.ObjRef> peut être transféré via un canal dans un autre domaine d’application (éventuellement un autre processus ou ordinateur). Une fois dans l’autre domaine d’application, la <xref:System.Runtime.Remoting.ObjRef> doit être analysé pour créer un proxy pour l’objet, généralement connecté à l’objet réel. Cette opération est appelée unmarshaling. Pendant l’unmarshaling, le <xref:System.Runtime.Remoting.ObjRef> est analysé pour extraire les informations de méthode de l’objet distant et à la fois le proxy transparent et <xref:System.Runtime.Remoting.Proxies.RealProxy> objets sont créés.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contient des informations qui décrivent la <xref:System.Type> et de la classe de l’objet marshalé, un URI qui identifie de façon unique l’instance d’objet spécifique et la communication des informations sur l’accès à l’application distante où Il se trouve l’objet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir un <xref:System.Runtime.Remoting.ObjRef> instance pour l’objet spécifié.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Proxy transparent.</param>
        <summary>Retourne le proxy réel stockant le proxy transparent spécifié.</summary>
        <returns>Instance de proxy réel stockant le proxy transparent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un client qui utilise un objet de n’importe quel type de limite de communication à distance utilise un proxy transparent pour l’objet. Le proxy transparent donne l’impression que l’objet réel réside dans l’espace du client. Pour cela, en transférant les appels effectués sur celui-ci vers l’objet réel à l’aide de l’infrastructure de communication à distance.  
  
 Le proxy transparent est stocké par une instance d’une classe runtime managée de type <xref:System.Runtime.Remoting.Proxies.RealProxy>. Le <xref:System.Runtime.Remoting.Proxies.RealProxy> implémente une partie des fonctionnalités nécessaires pour transmettre les opérations à partir du proxy transparent.  
  
 Un objet proxy hérite de la sémantique associée aux objets managés tels que le garbage collection, la prise en charge des méthodes et les membres et peut être étendu pour former de nouvelles classes. Le proxy agit comme un objet de la même classe que l’objet distant (proxy transparent) et est également un objet managé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">URI de l'objet dont le <see cref="T:System.Type" /> est demandé.</param>
        <summary>Retourne le <see cref="T:System.Type" /> de l'objet avec l'URI spécifié.</summary>
        <returns><see cref="T:System.Type" /> de l'objet avec l'URI spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que la communication à distance identifie les points de terminaison à l’aide d’URI, le <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> méthode est très utile dans les parties enfichables de l’infrastructure de communication à distance (par exemple, les récepteurs de canal, récepteurs dynamiques et des récepteurs de contexte) qui utilisent <xref:System.Runtime.Remoting.Messaging.IMessage> objets, car en cours méthode retourne l’objet type associé à partir de l’URI.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Soit l'appelant immédiat ne dispose pas de l'autorisation d'infrastructure, soit au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation requise pour récupérer les informations de type des membres non publics.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour récupérer les informations de type des membres non publics. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg"><see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> pour lequel un ID de session est demandé.</param>
        <summary>Récupère un ID de session pour un message.</summary>
        <returns>Chaîne d'ID de session qui identifie de façon unique la session en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le même ID de session peut être retourné pour les objets dans la même application, mais cette méthode ne retourne jamais le même ID de session pour deux objets dans différentes applications à distance.  
  
 Pour plus d’informations sur l’identification des sessions et des ID de session, consultez ASP.Net [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir la chaîne d’ID de session pour la session active.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Message contenant un appel à la méthode en question.</param>
        <summary>Retourne une valeur Boolean indiquant si la méthode du message donné est surchargée.</summary>
        <returns><see langword="true" /> si la méthode appelée dans <paramref name="msg" /> est surchargée ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Objet à vérifier.</param>
        <summary>Retourne une valeur Boolean indiquant si l'objet spécifié par le proxy transparent donné est contenu dans un domaine d'application différent de celui de l'objet qui a appelé la méthode en cours.</summary>
        <returns><see langword="true" /> si l'objet est à l'extérieur du domaine d'application en cours ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les domaines d’application, consultez [domaines d’Application](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domaines d'application</related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Objet à vérifier.</param>
        <summary>Retourne une valeur Boolean indiquant si l'objet représenté par le proxy spécifié est contenu dans un contexte différent de celui de l'objet qui a appelé la méthode en cours.</summary>
        <returns><see langword="true" /> si l'objet est à l'extérieur du contexte en cours ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contexte est une séquence ordonnée de propriétés qui définissent un environnement pour les objets qui résident dans celui-ci. Les contextes sont créés pendant le processus d’activation pour les objets qui sont configurés pour exiger que certains services automatiques telles synchronisation transactions, l’activation juste-à-temps, sécurité et ainsi de suite. Plusieurs objets peuvent coexister dans un contexte.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Méthode en question.</param>
        <summary>Retourne une valeur Boolean indiquant si le client qui a appelé la méthode spécifiée dans le message donné attend que le serveur ait terminé de traiter la méthode avant de continuer l'exécution.</summary>
        <returns><see langword="true" /> si la méthode est unidirectionnelle ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand une méthode unidirectionnelle est appelée, le client n’attend pas le serveur termine le traitement du message. La méthode du client retourne à l’application sans connaissance de déterminant si le serveur traite correctement le message. Les méthodes sont marquées comme unidirectionnelle à l’aide de la <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.  
  
 Les méthodes unidirectionnelles ne peuvent pas avoir une valeur de retour ou les paramètres de sortie.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant immédiat n'a pas d'autorisation d'accès à l'infrastructure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code d’infrastructure. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Référence à l'objet à vérifier.</param>
        <summary>Retourne une valeur Boolean indiquant si l'objet spécifié est un proxy transparent ou un objet réel.</summary>
        <returns>Valeur Boolean indiquant si l'objet spécifié dans le paramètre <paramref name="proxy" /> est un proxy transparent ou un objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un client qui utilise un objet de tout type d’une limite de communication à distance utilise un proxy transparent pour l’objet. Le proxy transparent donne l’impression que l’objet réel réside dans l’espace du client. Pour cela, en transférant les appels effectués sur celui-ci vers l’objet réel à l’aide de l’infrastructure de communication à distance.  
  
 Le proxy transparent est lui-même hébergé par une instance d’une classe runtime managée de type <xref:System.Runtime.Remoting.Proxies.RealProxy>. Le <xref:System.Runtime.Remoting.Proxies.RealProxy> implémente une partie des fonctionnalités nécessaires pour transmettre les opérations à partir du proxy transparent. Un objet proxy hérite de la sémantique associée aux objets managés tels que le garbage collection, la prise en charge des méthodes et les membres et peut être étendu pour former de nouvelles classes. Le proxy a donc une double nature ; d’une part, il doit d’agir en tant qu’objet de la même classe que l’objet distant (proxy transparent) et sur l’autre, il est lui-même un objet managé.  
  
 Un objet proxy peut être utilisé sans tenir compte des sous-divisions de communication à distance dans un <xref:System.AppDomain>. Applications ne doivent pas faire la distinction entre les références de proxy et les références d’objet. Toutefois, les fournisseurs de services traitant de problèmes tels que l’activation, gestion de la durée de vie et les transactions doivent se ces distinctions.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> méthode pour déterminer si un objet est un proxy ou un objet réel. Pour l’exemple de code complet, consultez l’exemple pour la <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Constante définie en interne qui identifie l'étape dans un échange de communication à distance.</param>
        <summary>Enregistre l'étape dans un échange de communication à distance à un débogueur externe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un `"REMOTING_PERF"` symbole de prétraitement est appliqué à la méthode à l’aide de la <xref:System.Diagnostics.ConditionalAttribute> attribut.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit le <see cref="T:System.MarshalByRefObject" /> donné en instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" />, qui peut être sérialisée pour transmission entre domaines d'application et sur un réseau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Objet à convertir.</param>
        <summary>Accepte <see cref="T:System.MarshalByRefObject" />, puis inscrit celui-ci avec l'infrastructure de communication à distance avant de le convertir en instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" />.</summary>
        <returns>Instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" /> représentant l'objet spécifié dans le paramètre <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Runtime.Remoting.ObjRef> est une représentation sérialisable d’un objet utilisé pour transférer une référence d’objet sur une limite de domaine d’application. Création d’un <xref:System.Runtime.Remoting.ObjRef> pour un objet est appelé marshaling. Le <xref:System.Runtime.Remoting.ObjRef> peut être transféré via un canal dans un autre domaine d’application (éventuellement un autre processus ou ordinateur). Une fois dans l’autre domaine d’application, la <xref:System.Runtime.Remoting.ObjRef> doit être analysé pour créer un proxy pour l’objet, généralement connecté à l’objet réel. Cette opération est appelée unmarshaling.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contient des informations qui décrivent la <xref:System.Type> et de la classe de l’objet marshalé, un URI qui identifie de façon unique l’instance d’objet spécifique et la communication des informations sur l’accès à la sous-division de communication à distance où se trouve l’objet.  
  
 Lors du marshaling, le contexte du thread actuel est utilisé, pas le contexte qui était active lorsque l’objet a été créé. Si un URI n’a pas été explicitement défini le <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> (méthode), il est automatiquement généré par l’infrastructure d’identité de communication à distance.  
  
 Vous ne pouvez pas associer un URI avec un proxy pour l’une des deux raisons : l’URI a été généré sur le côté serveur pour l’objet qu’il représente, soit l’objet est bien connu, auquel cas l’URI est connu. Pour cette raison, si le `Obj` paramètre est un proxy, une exception sera levée. Pour les proxies personnalisés, cette restriction est assouplie, car le proxy transparent est traité en tant que l’objet serveur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Le paramètre <paramref name="Obj" /> est un objet proxy.</exception>
        <exception cref="T:System.Security.SecurityException">Au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation de configuration des types et des canaux de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domaines d'application</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Objet à convertir.</param>
        <param name="URI">URI spécifié avec lequel initialiser le nouveau <see cref="T:System.Runtime.Remoting.ObjRef" />. Peut être <see langword="null" />.</param>
        <summary>Convertit le <see cref="T:System.MarshalByRefObject" /> donné en instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" /> avec l'URI spécifié.</summary>
        <returns>Instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" /> représentant l'objet spécifié dans le paramètre <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Runtime.Remoting.ObjRef> est une représentation sérialisable d’un objet utilisé pour transférer une référence d’objet sur une limite de domaine d’application. Création d’un <xref:System.Runtime.Remoting.ObjRef> pour un objet est appelé marshaling. Le <xref:System.Runtime.Remoting.ObjRef> peut être transféré via un canal dans un autre domaine d’application (éventuellement un autre processus ou ordinateur). Une fois dans l’autre domaine d’application, la <xref:System.Runtime.Remoting.ObjRef> doit être analysé pour créer un proxy pour l’objet, généralement connecté à l’objet réel. Cette opération est appelée unmarshaling.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contient des informations qui décrivent la <xref:System.Type> et de la classe de l’objet marshalé, un URI qui identifie de façon unique l’instance d’objet spécifique et la communication des informations sur l’accès à la sous-division de communication à distance où se trouve l’objet.  
  
 Lors du marshaling, le contexte du thread actuel est utilisé, pas le contexte qui était active lorsque l’objet a été créé.  
  
 Vous ne pouvez pas associer un URI avec un proxy pour l’une des deux raisons : l’URI a été généré sur le côté serveur pour l’objet qu’il représente, soit l’objet est bien connu, auquel cas l’URI est connu. Pour cette raison, si le `Obj` paramètre est un proxy, une exception sera levée. Pour les proxies personnalisés, cette restriction est assouplie, car le proxy transparent est traité en tant que l’objet serveur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser la valeur actuelle <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> méthode à marshaler un objet spécifié.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> est un objet proxy et le paramètre <paramref name="URI" /> n'est pas <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation de configuration des types et des canaux de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domaines d'application</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Objet à convertir en <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">URI avec lequel l'objet spécifié dans le paramètre <paramref name="Obj" /> est marshalé. Peut être <see langword="null" />.</param>
        <param name="RequestedType"><see cref="T:System.Type" /><paramref name="Obj" /> sous lequel il est marshalé. Peut être <see langword="null" />.</param>
        <summary>Accepte un <see cref="T:System.MarshalByRefObject" /> et convertit celui-ci en instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" /> avec l'URI spécifié, et le <see cref="T:System.Type" /> fourni.</summary>
        <returns>Instance de la classe <see cref="T:System.Runtime.Remoting.ObjRef" /> représentant l'objet spécifié dans le paramètre <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Runtime.Remoting.ObjRef> est une représentation sérialisable d’un objet utilisé pour transférer une référence d’objet sur une limite de domaine d’application. Création d’un <xref:System.Runtime.Remoting.ObjRef> pour un objet est appelé marshaling. Le <xref:System.Runtime.Remoting.ObjRef> peut être transféré via un canal dans un autre domaine d’application (éventuellement un autre processus ou ordinateur). Une fois dans l’autre domaine d’application, la <xref:System.Runtime.Remoting.ObjRef> doit être analysé pour créer un proxy pour l’objet, généralement connecté à l’objet réel. Cette opération est appelée unmarshaling.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contient des informations qui décrivent la <xref:System.Type> et de la classe de l’objet marshalé, un URI qui identifie de façon unique l’instance d’objet spécifique et la communication des informations sur l’accès à la sous-division de communication à distance où se trouve l’objet.  
  
 Spécifié <xref:System.Type> est utilisé pour limiter l’étendue de la hiérarchie des types exposés par l’infrastructure de communication à distance. Par exemple, si l’objet A dérive de l’objet B, qui est dérivée de l’objet C, et <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> est appelée, le client peut effectuer un cast du proxy entre C et B, mais pas à A.  
  
 Lors du marshaling, le contexte du thread actuel est utilisé, pas le contexte qui était active lorsque l’objet a été créé.  
  
 Vous ne pouvez pas associer un URI avec un proxy pour l’une des deux raisons : l’URI a été généré sur le côté serveur pour l’objet qu’il représente, soit l’objet est bien connu, auquel cas l’URI est connu. Pour cette raison, si le `Obj` paramètre est un proxy, une exception sera levée. Pour les proxies personnalisés, cette restriction est assouplie, car le proxy transparent est traité en tant que l’objet serveur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> est un proxy d'un objet distant, et le paramètre <paramref name="ObjUri" /> n'est pas <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation de configuration des types et des canaux de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Domaines d'application</related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Objet pour lequel définir un URI.</param>
        <param name="uri">URI à assigner à l'objet spécifié.</param>
        <summary>Définit l'URI pour le prochain appel à la méthode <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’URI défini par la méthode actuelle est utilisé lors du marshaling de l’objet donné.  
  
 Après avoir marshalé, l’URI de l’objet spécifié est défini à la chaîne dans le `uri` paramètre ajouté sur le <xref:System.Guid> d’actuel <xref:System.AppDomain>.  
  
 Si l’application actuelle est à l’écoute sur un port HTTP, la chaîne spécifiée dans le `uri` paramètre et le `uri` chaîne ajoutée sur le <xref:System.Guid> d’actuel <xref:System.AppDomain> itinéraire vers l’objet spécifié. Pour exemple, si l’application est à l’écoute sur le port HTTP 9000, puis les deux http://localhost:9000/objectUri, et http://localhost:9000/\<appdomainguid>/objectUri itinéraire vers l’objet spécifié dans le `obj` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir l’URI qui sera utilisé par le <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> méthode lors du marshaling de l’objet spécifié.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="obj" /> n'est pas un objet local, a déjà été marshalé, ou bien la méthode en cours a déjà été appelée.</exception>
        <exception cref="T:System.Security.SecurityException">Au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation de configuration des types et des canaux de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit un <see cref="T:System.Runtime.Remoting.ObjRef" /> donné en objet proxy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef"><see cref="T:System.Runtime.Remoting.ObjRef" /> qui représente l'objet distant pour lequel un proxy est créé.</param>
        <summary>Accepte <see cref="T:System.Runtime.Remoting.ObjRef" />, dont il crée un objet proxy.</summary>
        <returns>Proxy pour l'objet représenté par le <see cref="T:System.Runtime.Remoting.ObjRef" /> donné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Runtime.Remoting.ObjRef> est une représentation sérialisable d’un objet utilisé pour transférer une référence d’objet sur une limite de domaine d’application. Création d’un <xref:System.Runtime.Remoting.ObjRef> pour un objet est appelé marshaling. Le <xref:System.Runtime.Remoting.ObjRef> peut être transféré via un canal dans un autre domaine d’application (éventuellement un autre processus ou ordinateur). Une fois dans l’autre domaine d’application, la <xref:System.Runtime.Remoting.ObjRef> doit être analysé pour créer un proxy pour l’objet, généralement connecté à l’objet réel. Cette opération est appelée unmarshaling. Pendant l’unmarshaling, le <xref:System.Runtime.Remoting.ObjRef> est analysé pour extraire les informations de méthode de l’objet distant et à la fois le proxy transparent et <xref:System.Runtime.Remoting.Proxies.RealProxy> objets sont créés. Le contenu de l’élément analysé <xref:System.Runtime.Remoting.ObjRef> est ajouté au proxy transparent avant que le proxy transparent est inscrit avec le common language runtime.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contient des informations qui décrivent la <xref:System.Type> et de la classe de l’objet marshalé, un URI qui identifie de façon unique l’instance d’objet spécifique et la communication des informations sur l’accès à la sous-division de communication à distance où se trouve l’objet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment démarshaler un objet.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'instance de <see cref="T:System.Runtime.Remoting.ObjRef" /> spécifiée dans le paramètre <paramref name="objectRef" /> n'est pas correctement formée.</exception>
        <exception cref="T:System.Security.SecurityException">Au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation de configuration des types et des canaux de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef"><see cref="T:System.Runtime.Remoting.ObjRef" /> qui représente l'objet distant pour lequel un proxy est créé.</param>
        <param name="fRefine"><see langword="true" /> pour restreindre le proxy au type sur le serveur ; sinon <see langword="false" />.</param>
        <summary>Accepte <see cref="T:System.Runtime.Remoting.ObjRef" />, dont il crée un proxy, en le restreignant au type sur le serveur.</summary>
        <returns>Proxy pour l'objet représenté par le <see cref="T:System.Runtime.Remoting.ObjRef" /> donné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Runtime.Remoting.ObjRef> est une représentation sérialisable d’un objet utilisé pour transférer une référence d’objet sur une limite de domaine d’application. Création d’un <xref:System.Runtime.Remoting.ObjRef> pour un objet est appelé marshaling. Le <xref:System.Runtime.Remoting.ObjRef> peut être transféré via un canal dans un autre domaine d’application (éventuellement un autre processus ou ordinateur). Une fois dans l’autre domaine d’application, la <xref:System.Runtime.Remoting.ObjRef> doit être analysé pour créer un proxy pour l’objet, généralement connecté à l’objet réel. Cette opération est appelée unmarshaling. Pendant l’unmarshaling, le <xref:System.Runtime.Remoting.ObjRef> est analysé pour extraire les informations de méthode de l’objet distant et à la fois le proxy transparent et <xref:System.Runtime.Remoting.Proxies.RealProxy> objets sont créés. Le contenu de l’élément analysé <xref:System.Runtime.Remoting.ObjRef> est ajouté au proxy transparent avant que le proxy transparent est inscrit avec le common language runtime.  
  
 Un <xref:System.Runtime.Remoting.ObjRef> contient des informations qui décrivent la <xref:System.Type> et de la classe de l’objet marshalé, un URI qui identifie de façon unique l’instance d’objet spécifique et la communication des informations sur l’accès à la sous-division de communication à distance où se trouve l’objet.  
  
 Lorsque vous créez, le proxy est de type <xref:System.MarshalByRefObject>. Lorsque vous effectuez un cast en détail différents types, l’infrastructure de communication à distance effectue le suivi de type le plus utilisé pour éviter le chargement du type inutilement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'instance de <see cref="T:System.Runtime.Remoting.ObjRef" /> spécifiée dans le paramètre <paramref name="objectRef" /> n'est pas correctement formée.</exception>
        <exception cref="T:System.Security.SecurityException">Au moins un des appelants à un niveau plus élevé dans la pile des appels n'a pas l'autorisation de configuration des types et des canaux de communication à distance.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la configuration de l’infrastructure de communication à distance. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>