<Type Name="Collection" FullName="Microsoft.VisualBasic.Collection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c543b4d3675346a6dbc3cb17e964f74762b1c01e" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48660001" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Collection : System.Collections.IList, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed Collection extends System.Object implements class System.Collections.ICollection, class System.Collections.IList, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Collection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Collection&#xA;Implements IDeserializationCallback, IList, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Collection sealed : System::Collections::IList, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Collection = class&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(Microsoft.VisualBasic.Collection/CollectionDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Une <see langword="Collection" /> Visual Basic est un jeu ordonné d’éléments qui peut être considéré collectivement comme une unité.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si possible, vous devez utiliser les collections génériques dans le <xref:System.Collections.Generic?displayProperty=nameWithType> espace de noms ou le <xref:System.Collections.Concurrent> espace de noms au lieu de Visual Basic `Collection`. Pour plus d’informations, consultez [Collections](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b).  
  
 Visual Basic `Collection` objet offre un moyen pratique pour faire référence à un groupe d’éléments connexes comme un objet unique. Les éléments, ou *éléments*, dans une collection doivent seulement être associée par le fait qu’elles existent dans la collection. Éléments d’une collection n’est pas ont de partager le même type de données.  
  
 Vous pouvez créer une collection de la même façon que vous créez d’autres objets, comme l’illustre l’exemple suivant.  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 Une fois que vous avez créé une collection, vous pouvez effectuer les opérations suivantes :  
  
-   Ajoutez un élément avec la <xref:Microsoft.VisualBasic.Collection.Add%2A> (méthode).  
  
-   Supprimer un élément avec la <xref:Microsoft.VisualBasic.Collection.Remove%2A> (méthode).  
  
-   Supprimer tous les éléments avec le <xref:Microsoft.VisualBasic.Collection.Clear%2A> (méthode).  
  
-   Rechercher le nombre d’éléments contenus dans la collection avec le <xref:Microsoft.VisualBasic.Collection.Count%2A> propriété.  
  
-   Vérifiez si un élément spécifique est présent avec la <xref:Microsoft.VisualBasic.Collection.Contains%2A> (méthode).  
  
-   Retourner un élément spécifique de la collection avec le <xref:Microsoft.VisualBasic.Collection.Item%2A> propriété.  
  
-   Effectuer une itération dans la collection entière avec le [For Each... L’instruction suivante](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md).  
  
    > [!NOTE]
    >  Bien que Visual Basic `Collection` objet possède des fonctionnalités identiques à la `Collection` de l’objet dans Visual Basic 6.0, les deux ne peut pas interagir dans un environnement COM.  
  
    > [!CAUTION]
    >  Itération dans Visual Basic `Collection` n’est pas une procédure thread-safe. Même si la collection est synchronisée, les autres threads peuvent toujours modifier la collection, à l’origine de l’énumérateur à lever une exception. Pour garantir la sécurité des threads pendant l’énumération, soit verrouiller la collection ou d’intercepter les exceptions résultant des modifications apportées par d’autres threads. Pour plus d’informations sur le verrouillage d’un élément de programmation, consultez [instruction SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md).  
  
   
  
## Examples  
 L’exemple suivant crée la `Collection` objet `names` et une boîte de dialogue avec laquelle un utilisateur peut ajouter des objets (noms) à la collection. Il affiche ensuite les noms dans la collection et enfin vide la collection sans effacer la `Collection` objet lui-même.  
  
 Pour voir comment cela fonctionne, choisissez la **ajouter une classe** commande à partir de la **projet** menu et déclarez une variable publique appelée `instanceName` au niveau du module de `nameClass` (type `Public instanceName`) pour contenir les noms de chaque instance. Conservez le nom par défaut `nameClass`. Copiez et collez le code suivant dans le **général** section d’un autre module, puis démarrez-le avec l’instruction `classNamer` dans une autre procédure. (Cet exemple fonctionne uniquement avec les applications hôtes qui prennent en charge de classes).  
  
 [!code-vb[VbVbalrCollectionObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Collection ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Collection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crée et retourne un objet <see cref="T:Microsoft.VisualBasic.Collection" /> Visual Basic.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La collection de Visual Basic retournée par ce constructeur est vide et n’a pas aucune capacité initiale allouée.  
  
 Collections de Visual Basic ne sont pas compatibles avec le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] collections disponibles dans le <xref:System.Collections?displayProperty=nameWithType>, <xref:System.Collections.Generic?displayProperty=nameWithType>, et <xref:System.Collections.Specialized?displayProperty=nameWithType> espaces de noms.  
  
   
  
## Examples  
 L’exemple suivant crée une nouvelle collection de Visual Basic et l’assigne à la variable `coll`:  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 Cela `Collection` objet est basé sur 1, ce qui signifie que les valeurs d’index de la plage d’éléments compris entre 1 et la valeur de la `Count` propriété. Les collections Visual Basic contiennent des éléments de type <xref:System.Object>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object Item, string Key = null, object Before = null, object After = null);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Add(object Item, string Key, object Before, object After) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Add(System.Object,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (Item As Object, Optional Key As String = null, Optional Before As Object = null, Optional After As Object = null)" />
      <MemberSignature Language="F#" Value="member this.Add : obj * string * obj * obj -&gt; unit" Usage="collection.Add (Item, Key, Before, After)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Before" Type="System.Object" />
        <Parameter Name="After" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Item">Obligatoire. Objet de tout type qui spécifie les erreurs à ajouter à la collection.</param>
        <param name="Key">Optionnel. Expression <see langword="String" /> unique qui spécifie une chaîne clé qui peut être utilisée au lieu d'un index de position pour accéder à ce nouvel élément dans la collection.</param>
        <param name="Before">Optionnel. Expression qui spécifie une position relative dans la collection. L’élément à ajouter est placé dans la collection avant l’élément identifié par l’argument <c>Before</c>. Si <c>Before</c> est une expression numérique, ce doit être un nombre entre 1 et la valeur de la propriété <see cref="P:Microsoft.VisualBasic.Collection.Count" /> de la collection. Si <c>Before</c> est une expression <see langword="String" />, il doit correspondre à la chaîne clé spécifiée au moment où l’élément auquel il est fait référence a été ajouté à la collection. Vous ne pouvez pas spécifier à la fois les arguments <c>Before</c> et <c>After</c>.</param>
        <param name="After">Optionnel. Expression qui spécifie une position relative dans la collection. L’élément à ajouter est placé dans la collection après l’élément identifié par l’argument <c>After</c>. Si <c>After</c> est une expression numérique, ce doit être un nombre entre 1 et la valeur de la propriété <see langword="Count" /> de la collection. Si <c>After</c> est une expression <see langword="String" />, il doit correspondre à la chaîne clé spécifiée au moment où l’élément auquel il est fait référence a été ajouté à la collection. Vous ne pouvez pas spécifier à la fois les arguments <c>Before</c> et <c>After</c>.</param>
        <summary>Ajoute un élément à un objet <see langword="Collection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Before` ou `After` argument doit faire référence à un élément existant de la collection ; sinon, une erreur se produit.  
  
 Si les deux le `Before` et `After` arguments sont omis, le nouvel objet est ajouté à la fin de la collection.  
  
 Une erreur se produit également si une certaine `Key` valeur correspond à la clé pour un élément existant de la collection.  
  
   
  
## Examples  
 L’exemple suivant utilise le `Add` méthode pour ajouter `child` objets : instances d’une classe appelée `child` contenant un `Public` propriété `name` — à une collection appelée `family`. Pour voir comment cela fonctionne, créez un <xref:System.Windows.Forms.Form> avec deux <xref:System.Windows.Forms.Button> contrôles et définir leur <xref:System.Windows.Forms.Control.Text%2A> propriétés à `Add` et `List`. Ajouter le `child` définition de classe et le `family` déclaration au code du formulaire. Modifier le `_Click` gestionnaires d’événements pour le **ajouter** et **liste** boutons comme indiqué. Le **ajouter** bouton, vous pouvez ajouter des enfants. Le **liste** bouton affiche les noms de tous les enfants.  
  
 [!code-vb[VbVbalrCollectionObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="collection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments d'un objet Visual Basic <see langword="Collection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Clear` méthode vide la collection et réinitialise sa <xref:Microsoft.VisualBasic.Collection.Count%2A> 0 à la propriété.  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool Contains(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (Key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ Key);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="collection.Contains Key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">Obligatoire. Une expression <see langword="String" /> qui spécifie la clé à rechercher dans les éléments de la collection.</param>
        <summary>Retourne une valeur <see langword="Boolean" /> indiquant si un objet Visual Basic <see langword="Collection" /> contient un élément avec une clé spécifique.</summary>
        <returns>Retourne une valeur <see langword="Boolean" /> indiquant si un objet Visual Basic <see langword="Collection" /> contient un élément avec une clé spécifique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Contains` Retourne `True` si la collection contient un élément avec une clé correspondant exactement `Key`. Sinon, `Contains` retourne `False`. Casse est ignorée lors de la correspondance des valeurs de clé.  
  
 Visual Basic `Collection` peut contenir des éléments qui ont des clés et autres éléments sans clés. Cela varie selon que l’appel à la <xref:Microsoft.VisualBasic.Collection.Add%2A> méthode fournit un argument pour le paramètre facultatif `Key` paramètre.  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#4)]  
  
 Si vous souhaitez rechercher dans la collection d’éléments à l’aide de leurs clés, pensez à fournir le `Key` argument chaque fois que vous appelez le `Add` (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="Microsoft.VisualBasic.Collection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne un <see langword="Integer" /> contenant le nombre d'éléments dans une collection. Lecture seule.</summary>
        <value>Retourne un <see langword="Integer" /> contenant le nombre d'éléments dans une collection. Lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `Count` propriété afin de déterminer le nombre d’éléments dans un `Collection` objet.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Count` propriété pour afficher le nombre d’éléments dans un <xref:Microsoft.VisualBasic.Collection> objet dans la variable `birthdays`.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#6)]  
  
 Le `Collection` objet est basé sur 1, ce qui signifie que les valeurs d’index de la plage d’éléments compris entre 1 et la valeur de la `Count` propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une référence à un objet d'énumérateur, qui est utilisée pour itérer au sein d'un objet <see cref="T:Microsoft.VisualBasic.Collection" />.</summary>
        <returns>Récupère une référence à un objet d'énumérateur, qui est utilisée pour itérer au sein d'un objet <see cref="T:Microsoft.VisualBasic.Collection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [For Each... L’instruction suivante](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) appelle `GetEnumerator` pour obtenir un objet énumérateur pour prendre en charge d’itération sur les éléments d’une collection. Normalement, vous utilisez un `For Each`... `Next` pour parcourir une collection ou un tableau, et vous n’avez pas besoin d’appeler `GetEnumerator` explicitement.  
  
 Si vous avez besoin de contrôle plus précis sur l’itération à la `For Each`... `Next` fournissent des instructions, vous pouvez utiliser la `GetEnumerator` méthode pour effectuer un parcours personnalisé. Voici certains cas dans lesquels vous devrez peut-être pour ce faire.  
  
-   Vous pouvez souhaiter retourner au début de la collection et redémarrer l’itération avant qu’elle est terminée.  
  
-   Vous souhaiterez peut-être ignorer un ou plusieurs éléments pour diverses raisons.  
  
-   Vous devrez peut-être modifier les éléments de la collection au milieu d’un parcours. Dans ce cas, vous devez obtenir un nouvel objet énumérateur, car le précédent est invalidé.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser `GetEnumerator` pour récupérer tous les éléments d’un `Collection` objet.  
  
 [!code-vb[VbVbalrCollectionObject#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#7)]  
  
 `GetEnumerator` construit et retourne un objet énumérateur, qui implémente le <xref:System.Collections.IEnumerator> interface de la <xref:System.Collections> espace de noms. L’objet énumérateur expose la <xref:System.Collections.IEnumerator.Current%2A> propriété et la <xref:System.Collections.IEnumerator.MoveNext%2A> et <xref:System.Collections.IEnumerator.Reset%2A> méthodes. Pour plus d’informations, consultez [For Each... L’instruction suivante](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[int Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[int] { System::Object ^ get(int Index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">(A) Expression numérique qui spécifie la position d'un élément de la collection. <c>Index</c> doit être un nombre compris entre 1 et la valeur de la propriété <see cref="P:Microsoft.VisualBasic.Collection.Count" /> de la collection. Ou (B) Une expression <see langword="Object" /> qui spécifie la position ou la chaîne clé d'un élément de la collection.</param>
        <summary>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</summary>
        <value>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Index` est de type `Object`, le `Item` propriété tente de le traiter comme un `String`, `Char`, `Char` tableau ou la valeur entière. Si `Item` Impossible de convertir `Index` à `String` ou `Integer`, elle lève une <xref:System.ArgumentException> exception.  
  
 Le `Item` propriété est la propriété par défaut pour une collection. Par conséquent, les lignes de code suivantes sont équivalentes.  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 L’exemple suivant utilise le `Item` propriété à récupérer une référence à un objet dans une collection. Il crée `birthdays` comme un `Collection` de l’objet, puis récupère l’objet représentant l’anniversaire de Bill, à l’aide de la clé `"Bill"` comme le `Index` argument.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 Notez que le premier appel spécifie explicitement le `Item` propriété, mais la seconde est pas le cas. Les deux appels fonctionnent, car le `Item` propriété est la propriété par défaut pour un `Collection` objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">(A) Expression numérique qui spécifie la position d'un élément de la collection. <c>Index</c> doit être un nombre compris entre 1 et la valeur de la propriété <see cref="P:Microsoft.VisualBasic.Collection.Count" /> de la collection. Ou (B) Une expression <see langword="Object" /> qui spécifie la position ou la chaîne clé d'un élément de la collection.</param>
        <summary>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</summary>
        <value>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Index` est de type `Object`, le `Item` propriété tente de le traiter comme un `String`, `Char`, `Char` tableau ou la valeur entière. Si `Item` Impossible de convertir `Index` à `String` ou `Integer`, elle lève une <xref:System.ArgumentException> exception.  
  
 Le `Item` propriété est la propriété par défaut pour une collection. Par conséquent, les lignes de code suivantes sont équivalentes.  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 L’exemple suivant utilise le `Item` propriété à récupérer une référence à un objet dans une collection. Il crée `birthdays` comme un `Collection` de l’objet, puis récupère l’objet représentant l’anniversaire de Bill, à l’aide de la clé `"Bill"` comme le `Index` argument.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 Notez que le premier appel spécifie explicitement le `Item` propriété, mais la seconde est pas le cas. Les deux appels fonctionnent, car le `Item` propriété est la propriété par défaut pour un `Collection` objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[string Key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ Key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">Expression <see langword="String" /> unique qui spécifie une chaîne clé qui peut être utilisée au lieu d'un index de position pour accéder à un élément de la collection. <c>Key</c> doit correspondre à l’argument <c>Key</c> spécifié lorsque l’élément a été ajouté à la collection.</param>
        <summary>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</summary>
        <value>Retourne un élément spécifique d'un objet <see langword="Collection" /> en fonction de sa position ou de sa clé. Lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Index` est de type `Object`, le `Item` propriété tente de le traiter comme un `String`, `Char`, `Char` tableau ou la valeur entière. Si `Item` Impossible de convertir `Index` à `String` ou `Integer`, elle lève une <xref:System.ArgumentException> exception.  
  
 Le `Item` propriété est la propriété par défaut pour une collection. Par conséquent, les lignes de code suivantes sont équivalentes.  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 L’exemple suivant utilise le `Item` propriété à récupérer une référence à un objet dans une collection. Il crée `birthdays` comme un `Collection` de l’objet, puis récupère l’objet représentant l’anniversaire de Bill, à l’aide de la clé `"Bill"` comme le `Index` argument.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 Notez que le premier appel spécifie explicitement le `Item` propriété, mais la seconde est pas le cas. Les deux appels fonctionnent, car le `Item` propriété est la propriété par défaut pour un `Collection` objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un élément d'un objet <see langword="Collection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(int32 Index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; unit" Usage="collection.Remove Index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Expression numérique qui spécifie la position d'un élément de la collection. <c>Index</c> doit être un nombre compris entre 1 et la valeur de la propriété <see cref="P:Microsoft.VisualBasic.Collection.Count" /> de la collection.</param>
        <summary>Supprime un élément d'un objet <see langword="Collection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque `Remove` supprime un élément d’une collection, il décrémente la collection <xref:Microsoft.VisualBasic.Collection.Count%2A> propriété d’une unité. Il décrémente également la `Index` valeur de chaque élément qui suivait l’élément supprimé dans la collection.  
  
 Si un élément a été ajouté à la collection sans un `Key`, vous devez utiliser son `Index` pour le supprimer.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Remove` méthode pour supprimer des objets à partir d’un <xref:Microsoft.VisualBasic.Collection> objet dans la variable `birthdays`.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 La suite des quatre appels à la `Add` (méthode), le `Count` propriété contient 4, élément `"Bill"` a la valeur d’index 1 et élément `"Pete"` a la valeur d’index 4.  
  
 Suivant le premier appel à `Remove`, `Count` est 3, élément `"Bill"` est supprimé et l’élément `"Pete"` a la valeur d’index 3.  
  
 Après le deuxième appel à `Remove`, `Count` est 2, élément `"Mike"` est supprimé et l’élément `"Pete"` a la valeur d’index 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Key As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ Key);" />
      <MemberSignature Language="F#" Value="member this.Remove : string -&gt; unit" Usage="collection.Remove Key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">Expression <see langword="String" /> unique qui spécifie une chaîne clé qui peut être utilisée au lieu d'un index de position pour accéder à un élément de la collection. <c>Key</c> doit correspondre à l’argument <c>Key</c> spécifié lorsque l’élément a été ajouté à la collection.</param>
        <summary>Supprime un élément d'un objet <see langword="Collection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque `Remove` supprime un élément d’une collection, il décrémente la collection <xref:Microsoft.VisualBasic.Collection.Count%2A> propriété d’une unité. Il décrémente également la `Index` valeur de chaque élément qui suivait l’élément supprimé dans la collection.  
  
 Si un élément a été ajouté à la collection sans un `Key`, vous devez utiliser son `Index` pour le supprimer.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Remove` méthode pour supprimer des objets à partir d’un <xref:Microsoft.VisualBasic.Collection> objet dans la variable `birthdays`.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 La suite des quatre appels à la `Add` (méthode), le `Count` propriété contient 4, élément `"Bill"` a la valeur d’index 1 et élément `"Pete"` a la valeur d’index 4.  
  
 Suivant le premier appel à `Remove`, `Count` est 3, élément `"Bill"` est supprimé et l’élément `"Pete"` a la valeur d’index 3.  
  
 Après le deuxième appel à `Remove`, `Count` est 2, élément `"Mike"` est supprimé et l’élément `"Pete"` a la valeur d’index 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo" ExplicitInterfaceMemberName="ICollectionCopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void ICollectionCopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionCopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void ICollectionCopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel correspondant à la destination des éléments copiés à partir de l'objet <see cref="T:Microsoft.VisualBasic.Collection" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="index">Index de base zéro dans un <c>tableau</c> auquel commencer la copie.</param>
        <summary>Copie les éléments de <see cref="T:Microsoft.VisualBasic.Collection" /> dans <see cref="T:System.Array" />, à partir d'un index particulier de <see cref="T:System.Array" />. Implémente l'interface <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:Microsoft.VisualBasic.Collection> objet.  
  
 Cette méthode est un O (`n`) opération, où `n` est obtenu à partir de la <xref:Microsoft.VisualBasic.Collection.System%23Collections%23ICollection%23Count>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> est multidimensionnel.  
  
- ou - 
Le nombre d'éléments de l'objet <see cref="T:Microsoft.VisualBasic.Collection" /> source est supérieur à la quantité d'espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.InvalidCastException">Le type de l'objet <see cref="T:Microsoft.VisualBasic.Collection" /> source ne peut pas être casté automatiquement en type de <paramref name="array" /> de destination.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count" ExplicitInterfaceMemberName="ICollectionCount">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ICollectionCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionCount" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionCount As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized" ExplicitInterfaceMemberName="ICollectionIsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ICollectionIsSynchronized" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionIsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionIsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot" ExplicitInterfaceMemberName="ICollectionSyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ICollectionSyncRoot" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionSyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionSyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator" ExplicitInterfaceMemberName="ICollectionGetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance class System.Collections.IEnumerator ICollectionGetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionGetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function ICollectionGetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ ICollectionGetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de la collection. Implémente l'interface <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 (Visual Basic, c#)  
  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. Le <xref:System.Collections.IEnumerator.Reset%2A> méthode Replace également l’énumérateur à cette position. À cette position, la <xref:System.Collections.IEnumerator.Current%2A> propriété n’est pas définie. Par conséquent, vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l'ajout, la modification ou la suppression d'éléments, l'énumérateur est définitivement invalidé et son comportement n'est pas défini.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération. Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add" ExplicitInterfaceMemberName="IListAdd">
      <MemberSignature Language="C#" Value="int IList.Add (object Item);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object Item) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListAdd(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (Item As Object) As Integer Implements IList.Add" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ Item) = System::Collections::IList::Add;" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="int IList.Add (object value);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (value As Object) As Integer Implements IList.Add" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ value) = System::Collections::IList::Add;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> à ajouter à l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <param name="Item">To be added.</param>
        <summary>Ajoute un élément à l'objet <see cref="T:Microsoft.VisualBasic.Collection" />. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <returns>Position à laquelle le nouvel élément est inséré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également utiliser le <xref:Microsoft.VisualBasic.Collection.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:Microsoft.VisualBasic.Collection> objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est en lecture seule.  
  
- ou - 
L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est de taille fixe.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Add(System.Object)" />
        <altmember cref="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear" ExplicitInterfaceMemberName="IListClear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListClear" />
      <MemberSignature Language="VB.NET" Value="Sub IListClear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListClear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de l'objet <see cref="T:Microsoft.VisualBasic.Collection" />. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime tous les éléments de la <xref:Microsoft.VisualBasic.Collection> objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> est en lecture seule.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.Hashtable.Clear" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains" ExplicitInterfaceMemberName="IListContains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance bool IListContains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListContains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListContains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool IListContains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> à trouver dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <summary>Détermine si l'objet <see cref="T:Microsoft.VisualBasic.Collection" /> contient une valeur spécifique. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <returns>Retourne <see langword="True" /> si le <see cref="T:System.Object" /> est trouvé dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />, sinon <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine si le <xref:Microsoft.VisualBasic.Collection> objet contient une valeur spécifique.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf" ExplicitInterfaceMemberName="IListIndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListIndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListIndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> à trouver dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <summary>Détermine l'index d'un élément spécifique dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <returns>Index de <paramref name="value" /> si celui-ci figure dans la collection, sinon -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’index d’un élément spécifique dans le <xref:Microsoft.VisualBasic.Collection> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.IndexOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert" ExplicitInterfaceMemberName="IListInsert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListInsert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListInsert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListInsert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListInsert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro auquel la <c>valeur</c> doit être insérée.</param>
        <param name="value">
          <see cref="T:System.Object" /> à insérer dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <summary>Insère un élément dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" /> au niveau de l'index spécifié. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `index` est égal au nombre d’éléments dans le <xref:Microsoft.VisualBasic.Collection> de l’objet, puis `value` est ajouté à la fin.  
  
 Dans des collections d’éléments contigus, telles que les listes, les éléments situés après le point d’insertion descendent afin de prendre en compte le nouvel élément. Si la collection est indexée, les index des éléments déplacés sont également mis à jour. Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> n'est pas un index valide dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</exception>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est en lecture seule.  
  
- ou - 
L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est de taille fixe.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> est une référence null dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize" ExplicitInterfaceMemberName="IListIsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsFixedSize" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly" ExplicitInterfaceMemberName="IListIsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item" ExplicitInterfaceMemberName="IListItem">
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int Index] { get; set; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".property instance object IListItem(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(Index As Integer) As Object Implements IList.IListItem" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int Index); void set(int Index, System::Object ^ value); };" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListItem" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int index] { get; set; }" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(index As Integer) As Object Implements IList.IListItem" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListItem" FrameworkAlternate="netframework-2.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove" ExplicitInterfaceMemberName="IListRemove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet <see cref="T:System.Object" /> à supprimer de l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <summary>Supprime la première occurrence d'un objet spécifique de l'objet <see cref="T:Microsoft.VisualBasic.Collection" />. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans des collections d’éléments contigus, telles que les listes, les éléments qui suivent l’élément supprimé remontent pour occuper l’espace libéré. Si la collection est indexée, les index des éléments déplacés sont également mis à jour. Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage. Si `value` est introuvable dans le <xref:Microsoft.VisualBasic.Collection> objet, le <xref:Microsoft.VisualBasic.Collection> reste inchangé et aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est en lecture seule.  
  
- ou - 
L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est de taille fixe.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt" ExplicitInterfaceMemberName="IListRemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à supprimer.</param>
        <summary>Supprime l'élément d'objet <see cref="T:Microsoft.VisualBasic.Collection" /> au niveau de l'index spécifié. Implémente l'interface <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans des collections d’éléments contigus, telles que les listes, les éléments qui suivent l’élément supprimé remontent pour occuper l’espace libéré. Si la collection est indexée, les index des éléments déplacés sont également mis à jour. Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> n'est pas un index valide dans l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</exception>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est en lecture seule.  
  
- ou - 
L'objet <see cref="T:Microsoft.VisualBasic.Collection" /> est de taille fixe.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization" ExplicitInterfaceMemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Objet qui a initié le rappel.</param>
        <summary>S'exécute une fois la totalité du graphique d'objets <see cref="T:Microsoft.VisualBasic.Collection" /> désérialisée. Implémente l'interface <see cref="T:System.Runtime.Serialization.IDeserializationCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée une fois la totalité <xref:Microsoft.VisualBasic.Collection> graphique d’objet a été désérialisé.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.IDeserializationCallback" />
        <altmember cref="M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData" ExplicitInterfaceMemberName="GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenant les informations nécessaires pour sérialiser <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <param name="context">Un objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenant la source et la destination du flux sérialisé associé à l'objet <see cref="T:Microsoft.VisualBasic.Collection" />.</param>
        <summary>Retourne les données nécessaires à la sérialisation de l'objet <see cref="T:Microsoft.VisualBasic.Collection" />. Implémente l'interface <see cref="T:System.Runtime.Serialization.ISerializable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne les données nécessaires pour sérialiser le <xref:Microsoft.VisualBasic.Collection> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>