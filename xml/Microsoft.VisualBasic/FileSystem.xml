<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="698d4c7779138119bfe452e95602b55a06711e5b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37712142" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce module prend en charge les mots clés du langage Visual Basic et les membres de bibliothèque Runtime qui accèdent aux fichiers et dossiers.  
  
   
  
## Examples  
 Cet exemple utilise le `GetAttr` fonction permettant de déterminer les attributs d’un fichier et un répertoire ou un dossier.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder. <c>Path</c> may include the drive. If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</param>
        <summary>Changes the current directory or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ChDir` fonction modifie le répertoire par défaut, mais pas le lecteur par défaut. Par exemple, si le lecteur par défaut est C, l’instruction suivante change le répertoire par défaut sur le lecteur D, mais C reste le lecteur par défaut :  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Vous pouvez rendre relatif des changements de répertoire est en tapant les deux points, comme suit :  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Le `ChDir` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et.  
  
   
  
## Examples  
 Cet exemple utilise le `ChDir` (fonction) pour modifier le répertoire ou dossier actif.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is empty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Changes the current drive.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ChDrive` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Cet exemple utilise le `ChDrive` (fonction) pour modifier le lecteur actif. La fonction lève une exception si le lecteur n’existe pas.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ChDrive` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Cet exemple utilise le `ChDrive` (fonction) pour modifier le lecteur actif. La fonction lève une exception si le lecteur n’existe pas.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `CurDir` fonction pour retourner le chemin d’accès actuel.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. <see langword="Char" /> expression that specifies an existing drive. If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</param>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `CurDir` fonction pour retourner le chemin d’accès actuel.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Dir` fonction prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.  
  
 `VbVolume` Retourne le nom de volume pour le lecteur au lieu d’un nom de fichier spécifique.  
  
 Vous devez fournir un `PathName` la première fois que vous appelez le `Dir` (fonction). Pour récupérer l’élément suivant, vous pouvez effectuer les appels suivants à la `Dir` fonction sans paramètres.  
  
> [!IMPORTANT]
>  Pour s’exécuter correctement, le `Dir` fonction requiert le <xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code. Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, et [autorisations d’accès de Code](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Le `Attributes` des valeurs d’énumération arguments sont les suivantes :  
  
|Value|Constante|Description|  
|-|-|-|  
|`Normal`|`vbnormal`|Par défaut. Spécifie les fichiers sans attributs.|  
|`ReadOnly`|`vbReadOnly`|Spécifie les fichiers en lecture seule et également des fichiers sans attributs.|  
|`Hidden`|`vbHidden`|Spécifie les fichiers masqués, ainsi que les fichiers sans attributs.|  
|`System`|`vbSystem`|Spécifie les fichiers système et également des fichiers sans attributs.|  
|`Volume`|`vbVolume`|Spécifie le nom de volume. Si aucun autre attribut est spécifié, `vbVolume` est ignoré.|  
|`Directory`|`vbDirectory`|Spécifie les répertoires ou des dossiers et également des fichiers sans attributs.|  
|`Archive`|`vbArchive`|Fichier a changé depuis la dernière sauvegarde.|  
|`Alias`|`vbAlias`|Fichier porte un nom différent.|  
  
> [!NOTE]
>  Ces énumérations sont spécifiées par le langage Visual Basic et peuvent être utilisées partout dans votre code au lieu des valeurs réelles.  
  
   
  
## Examples  
 Cet exemple utilise le `Dir` (fonction) pour vérifier si certains fichiers et répertoires existent.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</param>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Dir` fonction prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.  
  
 `VbVolume` Retourne le nom de volume pour le lecteur au lieu d’un nom de fichier spécifique.  
  
 Vous devez fournir un `PathName` la première fois que vous appelez le `Dir` (fonction). Pour récupérer l’élément suivant, vous pouvez effectuer les appels suivants à la `Dir` fonction sans paramètres.  
  
> [!IMPORTANT]
>  Pour s’exécuter correctement, le `Dir` fonction requiert le <xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code. Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, et [autorisations d’accès de Code](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Le `Attributes` des valeurs d’énumération arguments sont les suivantes :  
  
|Value|Constante|Description|  
|-|-|-|  
|`Normal`|`vbnormal`|Par défaut. Spécifie les fichiers sans attributs.|  
|`ReadOnly`|`vbReadOnly`|Spécifie les fichiers en lecture seule, en plus des fichiers sans attributs.|  
|`Hidden`|`vbHidden`|Spécifie les fichiers cachés, en plus des fichiers sans attributs.|  
|`System`|`vbSystem`|Spécifie les fichiers système, en plus des fichiers sans attributs.|  
|`Volume`|`vbVolume`|Spécifie le nom de volume. Si aucun autre attribut est spécifié, `vbVolume` est ignoré.|  
|`Directory`|`vbDirectory`|Spécifie les dossiers, en plus des fichiers sans attributs.|  
|`Archive`|`vbArchive`|Fichier a changé depuis la dernière sauvegarde.|  
|`Alias`|`vbAlias`|Fichier porte un nom différent.|  
  
> [!NOTE]
>  Ces énumérations sont spécifiées par le langage Visual Basic et peuvent être utilisées partout dans votre code à la place les valeurs réelles.  
  
   
  
## Examples  
 Cet exemple utilise le `Dir` (fonction) pour vérifier si certains fichiers et répertoires existent.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains any valid file number.</param>
        <summary>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</summary>
        <returns>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `EOF` afin d’éviter l’erreur générée en tentant d’obtenir des données au-delà de la fin d’un fichier.  
  
 Le `EOF` fonction renvoie `False` jusqu'à ce que la fin du fichier a été atteinte. Avec les fichiers ouverts pour `Random` ou `Binary` accès, `EOF` retourne `False` jusqu'à l’exécution de la dernière `FileGet` fonction ne peut pas lire un enregistrement entier.  
  
 Avec les fichiers ouverts pour `Binary` accéder, une tentative de lecture par le biais du fichier en utilisant le `Input` fonctionner jusqu'à ce que `EOF` retourne `True` génère une erreur. Utiliser le `LOF` et `Loc` fonctions au lieu de `EOF` lors de la lecture des fichiers binaires avec `Input`, ou utilisez `Get` lorsque vous utilisez le `EOF` (fonction). Avec les fichiers ouverts pour `Output`, `EOF` retourne toujours `True`.  
  
   
  
## Examples  
 Cet exemple utilise le `EOF` fonction pour détecter la fin d’un fichier. Cet exemple suppose que `Testfile` est un fichier texte qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. <see langword="Integer" />. Any valid file number.</param>
        <summary>Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</summary>
        <returns>The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette fonction retourne une énumération qui représente le mode de fichier pour les fichiers ouverts à l’aide de la `FileOpen` (fonction).  
  
   
  
## Examples  
 Cet exemple utilise le `FileAttr` fonction pour retourner le mode d’un fichier ouvert.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameter array of 0 or more channels to be closed.</param>
        <summary>Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function. <see langword="My" /> gives you better productivity and performance in file I/O operations. See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileClose` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [Comment : lire du texte à partir de fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[Comment : écrire du texte dans des fichiers à l’aide de StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), et [procédure pas à pas : manipulation de fichiers et répertoires Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Si vous omettez `FileNumbers`, tous les fichiers actifs ouvrent par le `FileOpen` (fonction) sont fermés.  
  
 Lorsque vous fermez les fichiers qui ont été ouverts pour `Output` ou `Append`, la mémoire tampon finale de sortie est écrite dans la mémoire tampon de système d’exploitation pour ce fichier. Tout espace associé fermé de mémoires tampons est publié le fichier.  
  
 Lorsque le `FileClose` fonction est exécutée, l’association d’un fichier avec son fichier numéro se termine.  
  
   
  
## Examples  
 Cet exemple utilise le `FileClose` (fonction) pour fermer un fichier ouvert pour `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Required. <see langword="String" /> expression that specifies the name of the file to be copied. <c>Source</c> may include the directory or folder, and drive, of the source file.</param>
        <param name="Destination">Required. <see langword="String" /> expression that specifies the destination file name. <c>Destination</c> may include the directory or folder, and drive, of the destination file.</param>
        <summary>Copies a file. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous essayez d’utiliser le `FileCopy` fonctionnent sur un fichier ouvert, une erreur se produit.  
  
 `FileCopy` requiert une confiance totale pour travailler sur le lecteur local.  
  
   
  
## Examples  
 Cet exemple utilise le `FileCopy` (fonction) pour copier un fichier vers un autre. Pour cet exemple, supposons que `SrcFile` est un fichier qui contient des données.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</exception>
        <exception cref="T:System.IO.IOException">File is already open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Date" /> value that indicates the date and time a file was written to. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> value that indicates the date and time a file was created or last modified.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `FileDateTime` fonction pour déterminer la date et l’heure d’un fichier a été créée ou modifiée. Le format de la date et l’heure affichée est basé sur les paramètres régionaux du système.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la`FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé. La taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction),`FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la`FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le démarrage de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileGetObject` fonction est utilisée au lieu de `FileGet` pour éviter toute ambiguïté au moment de la compilation si type `Object` est retourné au lieu d’un autre type, tel que `Integer`, `Long`, `Short`, et ainsi de suite.  
  
 Si vous avez l’intention d’écrire le `Variant` type, `FileGetObject` est requis. En cas de doute, si vous utilisez un objet pour le deuxième paramètre, il est toujours conseillé d’utiliser `FilePutObject` et `FileGetObject`.  
  
 `FileGetObject` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGetObject` sont généralement écrites avec `FilePutObject`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, `FileGetObject` lit l’enregistrement ou octet après le dernier `FileGetObject` ou `FilePutObject` (fonction) (ou vers lequel pointe le dernier `Seek` fonction).  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGetObject` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Car il est impossible de déterminer précisément la quantité de données de la marge intérieure, il est judicieux d’avoir la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Si la variable lue est une chaîne, par défaut `FileGetObject` lit un descripteur à deux octets contenant la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe et lors de la lecture dans un fichier, le descripteur de longueur n’est pas écrit. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, la longueur d’enregistrement spécifié par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : 2 + 8 * NumberOfDimensions.  
  
     Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque :  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Les octets 218 sont distribués comme suit : 18 octets pour le descripteur (2 + 8 * 2) et 100 octets pour les données (5 * 10 * 4).  
  
-   `FileGetObject` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePutObject`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : 2 + 8 * NumberOfDimensions. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire des éléments individuels, y compris les tableaux et leurs descripteurs. Le <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe peut être appliquée aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lorsqu’elle est écrite sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, tous les `Random` règles s’appliquent à ces exceptions près :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGetObject` lit toutes les variables à partir du disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGetObject` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
 `FileGetObject` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
   
  
## Examples  
 L’exemple suivant lit un enregistrement dans un fichier de test et il récupère ensuite.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the length of a file in bytes. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> value that specifies the length of a file in bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier spécifié est ouvert lorsque la `FileLen` fonction est appelée, la valeur retournée représente la taille du fichier au moment il a été ouvert.  
  
> [!NOTE]
>  Pour obtenir la longueur actuelle d’un fichier ouvert, utilisez la `LOF` (fonction).  
  
   
  
## Examples  
 Cet exemple utilise le `FileLen` fonction pour retourner la longueur d’un fichier en octets. Pour cet exemple, supposons que `TestFile` est un fichier qui contient des données.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number. Use the <see langword="FreeFile" /> function to obtain the next available file number.</param>
        <param name="FileName">Required. <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</param>
        <param name="Mode">Required. Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Optional. Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />. Defaults to <see langword="ReadWrite" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Optional. Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />. Defaults to <see langword="Lock Read Write" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.</param>
        <summary>Opens a file for input or output. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileOpen` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Vous devez ouvrir un fichier avant toute opération d’e/s peut être effectuée sur celui-ci. `FileOpen` alloue une mémoire tampon d’e/s au fichier et détermine le mode d’accès à utiliser avec la mémoire tampon.  
  
> [!IMPORTANT]
>  Lors de l’écriture dans un fichier, une application peut avoir créer un fichier, si le fichier auquel il tente d’écrire n’existe pas. Pour ce faire, il a besoin d’autorisation pour le répertoire dans lequel le fichier doit être créé. Toutefois, si le fichier spécifié par `FileName` n’existe pas, l’application doit `Write` autorisation uniquement au fichier lui-même. Où que possible, afin d’améliorer la sécurité, créer le fichier pendant le déploiement et d’accorder `Write` autorisation à ce fichier uniquement, et non pour l’ensemble du répertoire. Pour aider à améliorer la sécurité, d’écrire des données dans les annuaires d’utilisateurs au lieu du répertoire racine ou le répertoire Program Files.  
  
 Vous trouverez le canal à ouvrir à l’aide de la `FreeFile()` (fonction).  
  
> [!IMPORTANT]
>  Le `FileOpen` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération, qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple illustre différentes utilisations de la `FileOpen` fonction pour activer l’entrée et sortie vers un fichier.  
  
 Le code suivant ouvre le fichier `TestFile` dans `Input` mode.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Cet exemple ouvre le fichier dans `Binary` mode pour les opérations d’écriture uniquement.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 L’exemple suivant ouvre le fichier dans `Random` mode. Le fichier contient des enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Cet exemple de code ouvre le fichier dans `Output` mode ; toute opération qui peut lire ou écrire dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Cet exemple de code ouvre le fichier dans `Binary` mode pour la lecture ; les autres processus ne peut pas lire le fichier.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Record length is negative (and not equal to -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le`VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le`RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FilePutObject` fonction est utilisée au lieu de `FilePut` pour éviter toute ambiguïté au moment de la compilation si type `Object` est passée au lieu d’un autre type, tel que `Integer`, `Long`, `Short`, et ainsi de suite.  
  
 `FilePutObject` écrit et lit des descripteurs qui décrivent l’objet. Si vous avez l’intention d’écrire le `Variant` type, `FilePutObject` est requis. En cas de doute, si vous utilisez un objet pour le deuxième paramètre, nous vous recommandons de toujours utiliser `FilePutObject` et `FileGetObject`.  
  
 `FilePutObject` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePutObject` sont généralement lues à partir d’un fichier à l’aide de `FileGetObject`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, `FilePutObject` écrit l’enregistrement ou octet après le dernier `FileGetObject` ou `FilePutObject` (fonction) (ou l’enregistrement ou octet vers lequel pointe le dernier `Seek` fonction).  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePutObject` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePutObject`, vous devez faire de même avec `FileGetObject`, et vous devez également vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePutObject` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Car il est impossible de déterminer précisément la quantité de données de la marge intérieure, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception est levée.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePutObject` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePutObject` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePutObject` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, la longueur d’enregistrement spécifié par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, tous les le `Random` mode règles s’appliquent, à l’exception :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePutObject` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePutObject` fonction pour écrire une chaîne dans un fichier.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="RecordWidth">Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <c>RecordWidth</c> equals 0, there is no limit to the length of a line. The default value for <c>RecordWidth</c> is 0.</param>
        <summary>Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `FileWidth` fonction permettant de définir la largeur de ligne de sortie pour un fichier.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</summary>
        <returns>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `FreeFile` pour fournir un numéro de fichier qui n’est pas déjà utilisé.  
  
   
  
## Examples  
 Cet exemple utilise le `FreeFile` fonction pour retourner le nombre de fichiers disponible suivant. Cinq fichiers sont ouverts à l’intérieur de la boucle, et des exemples de données sont écrites dans chacun.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">More than 255 files are in use.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file, directory, or folder name. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer les attributs définis, utilisez la `And` opérateur pour effectuer une comparaison au niveau du bit de la valeur retournée par la `GetAttr` (fonction) et la valeur de l’attribut de fichier individuel. Si le résultat n’est pas égal à zéro, cet attribut est défini pour le fichier nommé. Par exemple, la valeur de retour de la commande suivante `And` expression est zéro si le `Archive` attribut n’est pas défini :  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Une valeur différente de zéro est retournée si le `Archive` attribut est défini.  
  
   
  
## Examples  
 Cet exemple utilise le `GetAttr` fonction permettant de déterminer les attributs d’un fichier et un répertoire ou un dossier.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte quelques lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte quelques lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, étant donné que la virgule est considérée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="CharCount">Required. Any valid numeric expression specifying the number of characters to read.</param>
        <summary>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `InputString` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec le `InputString` (fonction) est généralement écrites dans un fichier à l’aide de `Print` ou `FilePut`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
 Contrairement à la `Input` (fonction), le `InputString` fonction retourne tous les caractères lus. Cela inclut des virgules, retours-chariot imbriqués, sauts de ligne, entre guillemets et les espaces de début.  
  
 Avec les fichiers ouverts pour `Binary` accéder, une tentative de lecture du fichier à l’aide de la `InputString` jusqu'à `EOF` retourne `True` génère une erreur. Utiliser le `LOF` et `Loc` fonctions au lieu de `EOF` lorsque vous lisez des fichiers binaires à l’aide de `InputString`, ou utilisez `FileGet` lorsque vous utilisez le `EOF` (fonction).  
  
> [!NOTE]
>  Lors de la lecture à partir de fichiers, ne faites pas de prendre des décisions de sécurité sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
   
  
## Examples  
 Cet exemple utilise le `InputString` fonction permettant de lire un caractère à la fois à partir d’un fichier et l’imprimer à la `Output` fenêtre. Cet exemple suppose que `MyFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 or &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies one or more file names to be deleted. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Deletes files from a disk. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.  
  
 **Note de sécurité** afin d’exécuter, le `Kill` fonction requiert `Read` et `PathDiscovery` indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code. Pour plus d’informations, consultez <xref:System.Security.SecurityException> [autorisations d’accès de Code](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Cet exemple utilise le `Kill` (fonction) pour supprimer un fichier à partir d’un disque.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Target file(s) open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file(s) not found.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</summary>
        <returns>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `LineInput` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `LineInput` sont généralement écrites dans un fichier à l’aide de `Print`.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
 Le `LineInput` fonction lit à partir d’un fichier d’un caractère à la fois jusqu'à ce qu’il rencontre un retour chariot (`Chr(13)`) ou saut de ligne-retour chariot (`Chr(13) + Chr(10)`) séquence. Séquences retour chariot/ligne flux sont ignorées au lieu d’ajouté à la chaîne de caractères.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `LineInput` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `LineInput` (fonction) pour lire une ligne dans un fichier séquentiel et l’affecter à une variable. Cet exemple suppose que `TestFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">End of file reached.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid <see langword="Integer" /> file number.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</summary>
        <returns>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Loc` fonction est de base zéro ; son utilisation pour récupérer le premier octet dans un fichier retournera 0.  
  
 Le `Loc` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Ce qui suit décrit la valeur de retour pour chaque mode d’accès au fichier :  
  
|Mode|Valeur de retour|  
|-|-|  
|`Random`|Numéro du dernier enregistrement lu ou écrit dans le fichier.|  
|`Sequential`|Position d’octet actuelle dans le fichier divisé par 128. Toutefois, les informations retournées par `Loc` pour les fichiers à accès séquentiel n’est ni utilisé ni nécessaire.|  
|`Binary`|Position du dernier octet lu ou écrit.|  
  
   
  
## Examples  
 Cet exemple utilise le `Loc` fonction pour retourner la position de lecture/écriture actuelle dans un fichier ouvert. Cet exemple suppose que `MyFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `FileLen` fonction pour obtenir la longueur d’un fichier qui n’est pas ouvert.  
  
   
  
## Examples  
 Cet exemple utilise le `LOF` fonction permettant de déterminer la taille d’un fichier ouvert. Cet exemple suppose que `TestFile` est un fichier texte qui contient des exemples de données.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory to be created. The <c>Path</c> may include the drive. If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</param>
        <summary>Creates a new directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette fonction crée un nouveau répertoire.  
  
   
  
## Examples  
 Cet exemple utilise le `MkDir` fonction permettant de créer un répertoire. Si le lecteur n’est pas spécifié, le nouveau répertoire est créé sur le lecteur actif.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <exception cref="T:System.IO.IOException">Directory already exists.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Print` et `PrintLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` n’inclut pas de saut de ligne à la fin d’une ligne ; Toutefois, `PrintLine` inclut une saut de ligne.  
  
 Données écrites avec `Print` sont généralement lues à partir d’un fichier à l’aide de `LineInput` ou `Input`.  
  
 Si vous omettez `Output` pour `PrintLine`, une ligne vide est imprimée dans le fichier ; pour `Print`, rien n’est sortie. Plusieurs expressions séparées par une virgule seront alignées sur les limites des onglets, mais mélange de virgules et `TAB` peut entraîner des résultats incohérents.  
  
 Pour `Boolean` données, soit `True` ou `False` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, quel que soit les paramètres régionaux.  
  
 Données de date sont écrites dans le fichier à l’aide du format de date courte standard reconnu par votre système. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
 Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, si `Output` les données de liste sont `DBNull`, `Null` est écrit dans le fichier.  
  
 Pour `Error` données, la sortie s’affiche en tant que `Error errorcode`. Le `Error` mot clé n’est pas traduit, quel que soit les paramètres régionaux.  
  
 Toutes les données écrites dans le fichier à l’aide de `Print` respectent les conventions ; autrement dit, les données sont correctement mis en forme en utilisant le séparateur décimal approprié. Si l’utilisateur souhaite sortir des données pour une utilisation par plusieurs paramètres régionaux, `Write` doit être utilisé.  
  
 Écriture dans un fichier à l’aide de la `Print` ou `PrintLine` functions exige `Write` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Print` et `PrintLine` fonctions pour écrire des données dans un fichier.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Print` et `PrintLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` n’inclut pas de saut de ligne à la fin d’une ligne ; Toutefois,`PrintLine` inclut une saut de ligne.  
  
 Données écrites avec `Print` sont généralement lues à partir d’un fichier à l’aide de `LineInput` ou `Input`.  
  
 Si vous omettez `Output` pour `PrintLine`, une ligne vide est imprimée dans le fichier ; pour `Print`, rien n’est sortie. Plusieurs expressions séparées par une virgule seront alignées sur les limites des onglets, mais mélange de virgules et `TAB` peut entraîner des résultats incohérents.  
  
 Pour `Boolean` données, soit `True` ou `False` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, quel que soit les paramètres régionaux.  
  
 Données de date sont écrites dans le fichier en utilisant le format de date courte standard reconnu par le système. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
 Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, si `Output` les données de liste sont `DBNull`, `Null` est écrit dans le fichier.  
  
 Pour `Error` données, la sortie s’affiche en tant que `Error errorcode`. Le `Error` mot clé n’est pas traduit, quel que soit les paramètres régionaux.  
  
 Toutes les données écrites dans le fichier à l’aide de `Print` respectent les conventions ; autrement dit, les données sont correctement mis en forme en utilisant le séparateur décimal approprié. Si l’utilisateur souhaite sortir des données pour une utilisation par plusieurs paramètres régionaux, `Write` doit être utilisé.  
  
 Écriture dans un fichier à l’aide de la `Print` ou `PrintLine` functions exige `Write` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Print` et `PrintLine` fonctions pour écrire des données dans un fichier.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Required. <see langword="String" /> expression that specifies the existing file name and location. <c>OldPath</c> may include the directory, and drive, of the file.</param>
        <param name="NewPath">Required. <see langword="String" /> expression that specifies the new file name and location. <c>NewPath</c> may include directory and drive of the destination location. The file name specified by <c>NewPath</c> cannot already exist.</param>
        <summary>Renames a disk file or directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le`Rename` fonction renomme un fichier et les déplace vers un autre répertoire, si nécessaire. Le `Rename` fonction peut déplacer un fichier sur les disques, mais elle ne peut renommer un répertoire existant lorsque les deux `NewPath` et `OldPath` se trouvent sur le même lecteur. `Rename` Impossible de créer un nouveau fichier ou un répertoire.  
  
 À l’aide de la `Rename` fonction sur un fichier ouvert génère une erreur. Vous devez fermer un fichier ouvert avant de le renommer. `Rename` arguments ne peut pas inclure plusieurs caractères (*) et des caractères génériques ( ?) à caractère unique.  
  
> [!IMPORTANT]
>  Lorsque vous utilisez `Rename` pour copier un fichier à partir d’un emplacement non protégé vers un emplacement protégé, le fichier conserve les droits moins restreints. Vérifiez que vous n’introduisez pas un risque de sécurité possible.  
  
   
  
## Examples  
 Cet exemple utilise le `Rename` (fonction) pour renommer un fichier. Pour cet exemple, supposons que les répertoires qui sont déjà spécifiés existent.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Path is invalid.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">Cannot rename to different device.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes all disk files opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Reset` fonction ferme tous les fichiers actifs ouverts par le `FileOpen` de fonction et a la même fonction que `FileClose()` sans aucun paramètre.  
  
   
  
## Examples  
 Cet exemple utilise le `Reset` (fonction) pour fermer tous les fichiers ouverts et écrire le contenu de toutes les mémoires tampons de fichiers sur le disque. Notez l’utilisation de la `Object` variable `FileNumber` comme une chaîne et un nombre.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory or folder to be removed. <c>Path</c> can include the drive. If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</param>
        <summary>Removes an existing directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />. For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une erreur se produit si vous essayez d’utiliser `RmDir` sur un répertoire qui contient les fichiers. Utilisez le `Kill` (fonction) pour supprimer tous les fichiers avant d’essayer de supprimer un répertoire.  
  
   
  
## Examples  
 Cet exemple utilise le `RmDir` (fonction) pour supprimer un répertoire existant.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.IO.IOException">Target directory contains files.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Directory does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Retourne une valeur comprise entre 1 et 2 147 483 647 (équivalent à 2 ^ 31 – 1), inclus.  
  
 Ce qui suit décrit les valeurs de retour pour chaque mode d’accès au fichier :  
  
|Mode|Valeur de retour|  
|-|-|  
|`Random`|Numéro de l’enregistrement suivant lues ou écrites|  
|`Binary`, `Input`, `Output`, `Append`|Position d’octet à partir duquel l’opération suivante se produit. Le premier octet dans un fichier est à la position 1, le deuxième octet est à la position 2 et ainsi de suite.|  
  
   
  
## Examples  
 Cet exemple utilise le `Seek` fonction pour retourner la position actuelle du fichier. L’exemple part du principe `TestFile` est un fichier qui contient les enregistrements de la structure `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Pour les fichiers ouverts dans `Random` mode, `Seek` renvoie le numéro de l’enregistrement suivant.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` retourne la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Cet exemple utilise le `Seek` fonction pour définir la position de la prochaine opération de lecture ou d’écrire dans un fichier.  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` définit la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <param name="Position">Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Retourne une valeur comprise entre 1 et 2 147 483 647 (équivalent à 2 ^ 31 – 1), inclus.  
  
 Ce qui suit décrit les valeurs de retour pour chaque mode d’accès au fichier :  
  
|Mode|Valeur de retour|  
|-|-|  
|`Random`|Numéro de l’enregistrement suivant lues ou écrites|  
|`Binary`, `Input`, `Output`, `Append`|Position d’octet à partir duquel l’opération suivante se produit. Le premier octet dans un fichier est à la position 1, le deuxième octet est à la position 2 et ainsi de suite.|  
  
   
  
## Examples  
 Cet exemple utilise le `Seek` fonction pour retourner la position actuelle du fichier. L’exemple part du principe `TestFile` est un fichier qui contient les enregistrements de la structure `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Pour les fichiers ouverts dans `Random` mode, `Seek` renvoie le numéro de l’enregistrement suivant.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` retourne la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Cet exemple utilise le `Seek` fonction pour définir la position de la prochaine opération de lecture ou d’écrire dans un fichier.  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` définit la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> can include directory or folder, and drive.</param>
        <param name="Attributes">Required. Constant or numeric expression, whose sum specifies file attributes.</param>
        <summary>Sets attribute information for a file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une erreur d’exécution se produit si vous essayez de définir les attributs d’un fichier ouvert.  
  
 Le `Attributes` des valeurs d’énumération arguments sont les suivantes :  
  
|Value|Constante|Description|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (valeur par défaut).|  
|`ReadOnly`|`vbReadOnly`|Lecture seule.|  
|`Hidden`|`vbHidden`|Masqué.|  
|`System`|`vbSystem`|Fichier système.|  
|`Volume`|`vbVolume`|Nom de volume|  
|`Directory`|`vbDirectory`|Répertoire ou dossier.|  
|`Archive`|`vbArchive`|Fichier a changé depuis la dernière sauvegarde.|  
|`Alias`|`vbAlias`|Fichier porte un nom différent.|  
  
> [!NOTE]
>  Ces énumérations sont spécifiées par le langage Visual Basic. Les noms peuvent être utilisés n’importe où dans votre code au lieu des valeurs réelles.  
  
   
  
## Examples  
 Cet exemple utilise le `SetAttr` fonction permettant de définir les attributs d’un fichier.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> type is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Required. The number of spaces to insert before displaying or printing the next expression in a list.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Count` est inférieure à la largeur de ligne de sortie, la position suivante d’impression immédiatement suit le nombre d’espaces imprimés. Si`Count` est supérieure à la largeur de ligne de sortie, `SPC` calcule la prochaine position d’impression à l’aide de la formule :  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Par exemple, si la position d’impression actuelle est 24, la largeur de ligne de sortie est 80, et que vous spécifiez `SPC(90)`, l’impression suivante commence à la position 34 (position courante + le reste de 90/80). Si la différence entre la position d’impression actuelle et la largeur de ligne de sortie est inférieure à `Count` (ou `Count` `Mod` *largeur*), le `SPC` fonction passe au début de la ligne suivante et génère espaces égal à `Count` – (*largeur* – *currentprintposition*).  
  
> [!NOTE]
>  Assurez-vous que les colonnes sont suffisamment larges pour lettres larges.  
  
   
  
## Examples  
 Cet exemple utilise le `SPC` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la position d’impression en cours sur la ligne actuelle est supérieure à `Column`, `TAB` passe à la valeur de colonne égale à `Column` sur la ligne de sortie suivante. Si `Column` est inférieur à 1, `TAB` déplace la position d’impression à la colonne 1. Si `Column` est supérieure à la largeur de ligne de sortie `TAB` calcule la prochaine position d’impression à l’aide de la formule :  
  
 Largeur de colonne Mod  
  
 Par exemple, si *largeur* est 80 et que vous spécifiez `TAB(90)`, l’impression suivante commence à la colonne 10 (le reste de 90/80). Si `Column` est inférieure à la position actuelle, l’impression commence à la ligne suivante à la position d’impression calculée. Si la position calculée est supérieure à la position actuelle, l’impression commence à l’impression calculée position sur la même ligne.  
  
 La position d’impression à l’extrême gauche sur une ligne de sortie est toujours 1. Lorsque vous utilisez le `Print` ou `PrintLine` fonctions pour imprimer les fichiers, le plus à droite est la largeur actuelle du fichier de sortie, que vous pouvez définir à l’aide de la `FileWidth` (fonction).  
  
 Le `TAB` fonction peut également être utilisée avec le `WriteLine` (fonction). Il ne peut pas être utilisé avec <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Assurez-vous que les colonnes sont assez large pour contenir des lettres larges.  
  
   
  
## Examples  
 Cet exemple utilise le `TAB` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la position d’impression actuelle sur la ligne actuelle est supérieure à `Column`, `TAB` passe à la valeur de colonne égale à `Column` sur la ligne de sortie suivante. Si `Column` est inférieur à 1, `TAB` déplace la position d’impression à la colonne 1. Si `Column` est supérieure à la largeur de ligne de sortie, `TAB` calcule la prochaine position d’impression à l’aide de la formule :  
  
 Largeur de colonne Mod  
  
 Par exemple, si *largeur* est 80 et que vous spécifiez `TAB(90)`, l’impression suivante commence à la colonne 10 (le reste de 90/80). Si `Column` est inférieure à la position actuelle, l’impression commence à la ligne suivante à la position d’impression calculée. Si la position calculée est supérieure à la position actuelle, l’impression commence à l’impression calculée position sur la même ligne.  
  
 La position d’impression à l’extrême gauche sur une ligne de sortie est toujours 1. Lorsque vous utilisez le `Print` ou `PrintLine` fonctions pour imprimer les fichiers, le plus à droite est la largeur actuelle du fichier de sortie, que vous pouvez définir à l’aide de la `FileWidth` (fonction).  
  
 Le `TAB` fonction peut également être utilisée avec le `WriteLine` (fonction). Il ne peut pas être utilisé avec <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Assurez-vous que les colonnes sont assez large pour contenir des lettres larges.  
  
   
  
## Examples  
 Cet exemple utilise le `TAB` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Write` et `WriteLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Si vous omettez `Output`, une ligne vide est imprimée dans le fichier. Plusieurs expressions peuvent être séparées par une virgule.  
  
 Contrairement à la `Print` (fonction), le `Write` fonction insère des virgules entre les éléments et les chaînes entre guillemets car ils sont écrits dans le fichier. Il est inutile de placer de délimiteurs explicites dans la liste. Lorsque `Write` est utilisé pour écrire des données dans un fichier, numérique uniquement, `Boolean`, date, la valeur null, et `Error` formats de données sont pris en charge. Les hypothèses universelles suivantes sont suivies afin que les données peuvent toujours être lues et correctement interprétées à l’aide de `Input`, indépendamment des paramètres régionaux :  
  
-   Données numériques sont toujours écrit avec un point comme séparateur décimal.  
  
-   Pour `Boolean` données, soit `#TRUE#` ou `#FALSE#` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, indépendamment des paramètres régionaux.  
  
-   Données de date sont écrites dans le fichier en utilisant le format de date universel. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
-   Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, pour les données de type null, `#NULL#` est écrit.  
  
-   Pour `Error` données, la sortie s’affiche en tant que `#ERROR errorcode#`. Le `Error` mot clé n’est pas traduit, indépendamment des paramètres régionaux.  
  
 `WriteLine` Insère un caractère de saut de ligne (autrement dit, un retour chariot/ligne de flux, ou `Chr(13) + Chr(10)`), une fois qu’il a écrit le dernier caractère `Output` au fichier.  
  
 Vous pouvez incorporer des guillemets dans une chaîne à l’aide de guillemets doubles, ou « ». Par exemple :  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Retourne une chaîne avec la valeur de `Double quotation marks aren't "difficult" to handle`.  
  
 Écriture dans un fichier à l’aide de la `Write` ou `WriteLine` functions exige `Append` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Write` fonction pour écrire des données brutes dans un fichier séquentiel.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Write` et `WriteLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Si vous omettez `Output`, une ligne vide est imprimée dans le fichier. Plusieurs expressions peuvent être séparées par une virgule.  
  
 Contrairement à la `Print` (fonction), le `Write` fonction insère des virgules entre les éléments et les chaînes entre guillemets car ils sont écrits dans le fichier. Il est inutile de placer de délimiteurs explicites dans la liste. Lorsque `Write` est utilisé pour écrire des données dans un fichier, numérique uniquement, `Boolean`, date, la valeur null, et `Error` formats de données sont pris en charge. Les hypothèses universelles suivantes sont suivies afin que les données peuvent toujours être lues et correctement interprétées à l’aide de `Input`, indépendamment des paramètres régionaux :  
  
-   Données numériques sont toujours écrit avec un point comme séparateur décimal.  
  
-   Pour `Boolean` données, soit `#TRUE#` ou `#FALSE#` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, indépendamment des paramètres régionaux.  
  
-   Données de date sont écrites dans le fichier en utilisant le format de date universel. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
-   Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, pour les données de type null, `#NULL#` est écrit.  
  
-   Pour `Error` données, la sortie s’affiche en tant que `#ERROR errorcode#`. Le `Error` mot clé n’est pas traduit, indépendamment des paramètres régionaux.  
  
 `WriteLine` Insère un caractère de saut de ligne (autrement dit, un retour chariot/ligne de flux, ou `Chr(13) + Chr(10)`), une fois qu’il a écrit le dernier caractère `Output` au fichier.  
  
 Vous pouvez incorporer des guillemets dans une chaîne à l’aide de guillemets doubles, ou « ». Par exemple :  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Retourne une chaîne avec la valeur de `Double quotation marks aren't "difficult" to handle`.  
  
 Écriture dans un fichier à l’aide de la `Write` ou `WriteLine` functions exige `Append` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Write` fonction pour écrire des données brutes dans un fichier séquentiel.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>